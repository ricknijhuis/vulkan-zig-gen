// This file is generated from the Khronos Vulkan XML API registry by vulkan-zig.

const std = @import("std");
const builtin = @import("builtin");
const root = @import("root");
const vk = @This();
const Allocator = std.mem.Allocator;

pub const vulkan_call_conv: std.builtin.CallingConvention = if (builtin.os.tag == .windows and builtin.cpu.arch == .x86)
    .winapi
else if (builtin.abi == .android and (builtin.cpu.arch.isArm() or builtin.cpu.arch.isThumb()) and std.Target.arm.featureSetHas(builtin.cpu.features, .has_v7) and builtin.cpu.arch.ptrBitWidth() == 32)
    // On Android 32-bit ARM targets, Vulkan functions use the "hardfloat"
    // calling convention, i.e. float parameters are passed in registers. This
    // is true even if the rest of the application passes floats on the stack,
    // as it does by default when compiling for the armeabi-v7a NDK ABI.
    .arm_aapcs_vfp
else
    .c;
pub fn FlagsMixin(comptime FlagsType: type) type {
    return struct {
        pub const IntType = @typeInfo(FlagsType).@"struct".backing_integer.?;
        pub fn toInt(self: FlagsType) IntType {
            return @bitCast(self);
        }
        pub fn fromInt(flags: IntType) FlagsType {
            return @bitCast(flags);
        }
        pub fn merge(lhs: FlagsType, rhs: FlagsType) FlagsType {
            return fromInt(toInt(lhs) | toInt(rhs));
        }
        pub fn intersect(lhs: FlagsType, rhs: FlagsType) FlagsType {
            return fromInt(toInt(lhs) & toInt(rhs));
        }
        pub fn complement(self: FlagsType) FlagsType {
            return fromInt(~toInt(self));
        }
        pub fn subtract(lhs: FlagsType, rhs: FlagsType) FlagsType {
            return fromInt(toInt(lhs) & toInt(rhs.complement()));
        }
        pub fn contains(lhs: FlagsType, rhs: FlagsType) bool {
            return toInt(intersect(lhs, rhs)) == toInt(rhs);
        }
    };
}
fn FlagFormatMixin(comptime FlagsType: type) type {
    return struct {
        pub fn format(
            self: FlagsType,
            writer: anytype,
        ) !void {
            try writer.writeAll(@typeName(FlagsType) ++ "{");
            var first = true;
            @setEvalBranchQuota(100_000);
            inline for (comptime std.meta.fieldNames(FlagsType)) |name| {
                if (name[0] == '_') continue;
                if (@field(self, name)) {
                    if (first) {
                        try writer.writeAll(" ." ++ name);
                        first = false;
                    } else {
                        try writer.writeAll(", ." ++ name);
                    }
                }
            }
            if (!first) try writer.writeAll(" ");
            try writer.writeAll("}");
        }
    };
}
pub const Version = packed struct(u32) {
    patch: u12,
    minor: u10,
    major: u7,
    variant: u3,
};
pub fn makeApiVersion(variant: u3, major: u7, minor: u10, patch: u12) Version {
    return .{ .variant = variant, .major = major, .minor = minor, .patch = patch };
}
pub const ApiInfo = struct {
    name: [:0]const u8 = "custom",
    version: Version = makeApiVersion(0, 0, 0, 0),
};
pub const have_vulkan_video = false;
pub const MAX_PHYSICAL_DEVICE_NAME_SIZE = 256;
pub const UUID_SIZE = 16;
pub const LUID_SIZE = 8;
pub const MAX_EXTENSION_NAME_SIZE = 256;
pub const MAX_DESCRIPTION_SIZE = 256;
pub const MAX_MEMORY_TYPES = 32;
pub const MAX_MEMORY_HEAPS = 16;
pub const LOD_CLAMP_NONE = @as(f32, 1000.0);
pub const REMAINING_MIP_LEVELS = ~@as(u32, 0);
pub const REMAINING_ARRAY_LAYERS = ~@as(u32, 0);
pub const REMAINING_3D_SLICES_EXT = ~@as(u32, 0);
pub const WHOLE_SIZE = ~@as(u64, 0);
pub const ATTACHMENT_UNUSED = ~@as(u32, 0);
pub const TRUE = 1;
pub const FALSE = 0;
pub const QUEUE_FAMILY_IGNORED = ~@as(u32, 0);
pub const QUEUE_FAMILY_EXTERNAL = ~@as(u32, 1);
pub const QUEUE_FAMILY_FOREIGN_EXT = ~@as(u32, 2);
pub const SUBPASS_EXTERNAL = ~@as(u32, 0);
pub const MAX_DEVICE_GROUP_SIZE = 32;
pub const MAX_DRIVER_NAME_SIZE = 256;
pub const MAX_DRIVER_INFO_SIZE = 256;
pub const SHADER_UNUSED_KHR = ~@as(u32, 0);
pub const MAX_GLOBAL_PRIORITY_SIZE = 16;
pub const MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT = 32;
pub const MAX_PIPELINE_BINARY_KEY_SIZE_KHR = 32;
pub const MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR = 7;
pub const MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR = 3;
pub const SHADER_INDEX_UNUSED_AMDX = ~@as(u32, 0);
pub const PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV = ~@as(u32, 0);
pub const MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM = 128;
pub const VKSC_API_VARIANT = 1;
pub const API_VERSION_1_0 = makeApiVersion(0, 1, 0, 0);
pub const API_VERSION_1_1 = makeApiVersion(0, 1, 1, 0);
pub const API_VERSION_1_2 = makeApiVersion(0, 1, 2, 0);
pub const API_VERSION_1_3 = makeApiVersion(0, 1, 3, 0);
pub const API_VERSION_1_4 = makeApiVersion(0, 1, 4, 0);
pub const VKSC_API_VERSION_1_0 = makeApiVersion(VKSC_API_VARIANT, 1, 0, 0);
pub const HEADER_VERSION = 321;
pub const HEADER_VERSION_COMPLETE = makeApiVersion(0, 1, 4, HEADER_VERSION);
pub const Display = if (@hasDecl(root, "Display")) root.Display else opaque {};
pub const VisualID = if (@hasDecl(root, "VisualID")) root.VisualID else c_uint;
pub const Window = if (@hasDecl(root, "Window")) root.Window else c_ulong;
pub const RROutput = if (@hasDecl(root, "RROutput")) root.RROutput else c_ulong;
pub const wl_display = if (@hasDecl(root, "wl_display")) root.wl_display else opaque {};
pub const wl_surface = if (@hasDecl(root, "wl_surface")) root.wl_surface else opaque {};
pub const HINSTANCE = if (@hasDecl(root, "HINSTANCE")) root.HINSTANCE else std.os.windows.HINSTANCE;
pub const HWND = if (@hasDecl(root, "HWND")) root.HWND else std.os.windows.HWND;
pub const HMONITOR = if (@hasDecl(root, "HMONITOR")) root.HMONITOR else *opaque {};
pub const HANDLE = if (@hasDecl(root, "HANDLE")) root.HANDLE else std.os.windows.HANDLE;
pub const SECURITY_ATTRIBUTES = if (@hasDecl(root, "SECURITY_ATTRIBUTES")) root.SECURITY_ATTRIBUTES else std.os.windows.SECURITY_ATTRIBUTES;
pub const DWORD = if (@hasDecl(root, "DWORD")) root.DWORD else std.os.windows.DWORD;
pub const LPCWSTR = if (@hasDecl(root, "LPCWSTR")) root.LPCWSTR else std.os.windows.LPCWSTR;
pub const xcb_connection_t = if (@hasDecl(root, "xcb_connection_t")) root.xcb_connection_t else opaque {};
pub const xcb_visualid_t = if (@hasDecl(root, "xcb_visualid_t")) root.xcb_visualid_t else u32;
pub const xcb_window_t = if (@hasDecl(root, "xcb_window_t")) root.xcb_window_t else u32;
pub const IDirectFB = if (@hasDecl(root, "IDirectFB")) root.IDirectFB else opaque {};
pub const IDirectFBSurface = if (@hasDecl(root, "IDirectFBSurface")) root.IDirectFBSurface else opaque {};
pub const zx_handle_t = if (@hasDecl(root, "zx_handle_t")) root.zx_handle_t else u32;
pub const GgpStreamDescriptor = if (@hasDecl(root, "GgpStreamDescriptor")) root.GgpStreamDescriptor else *opaque {};
pub const GgpFrameToken = if (@hasDecl(root, "GgpFrameToken")) root.GgpFrameToken else *opaque {};
pub const _screen_context = if (@hasDecl(root, "_screen_context")) root._screen_context else opaque {};
pub const _screen_window = if (@hasDecl(root, "_screen_window")) root._screen_window else opaque {};
pub const _screen_buffer = if (@hasDecl(root, "_screen_buffer")) root._screen_buffer else opaque {};
pub const NvSciSyncAttrList = if (@hasDecl(root, "NvSciSyncAttrList")) root.NvSciSyncAttrList else *opaque {};
pub const NvSciSyncObj = if (@hasDecl(root, "NvSciSyncObj")) root.NvSciSyncObj else *opaque {};
pub const NvSciSyncFence = if (@hasDecl(root, "NvSciSyncFence")) root.NvSciSyncFence else *opaque {};
pub const NvSciBufAttrList = if (@hasDecl(root, "NvSciBufAttrList")) root.NvSciBufAttrList else *opaque {};
pub const NvSciBufObj = if (@hasDecl(root, "NvSciBufObj")) root.NvSciBufObj else *opaque {};
pub const ANativeWindow = if (@hasDecl(root, "ANativeWindow")) root.ANativeWindow else opaque {};
pub const AHardwareBuffer = if (@hasDecl(root, "AHardwareBuffer")) root.AHardwareBuffer else opaque {};
pub const CAMetalLayer = if (@hasDecl(root, "CAMetalLayer")) root.CAMetalLayer else opaque {};
pub const MTLDevice_id = if (@hasDecl(root, "MTLDevice_id")) root.MTLDevice_id else opaque {};
pub const MTLCommandQueue_id = if (@hasDecl(root, "MTLCommandQueue_id")) root.MTLCommandQueue_id else opaque {};
pub const MTLBuffer_id = if (@hasDecl(root, "MTLBuffer_id")) root.MTLBuffer_id else opaque {};
pub const MTLTexture_id = if (@hasDecl(root, "MTLTexture_id")) root.MTLTexture_id else opaque {};
pub const MTLSharedEvent_id = if (@hasDecl(root, "MTLSharedEvent_id")) root.MTLSharedEvent_id else opaque {};
pub const IOSurfaceRef = if (@hasDecl(root, "IOSurfaceRef")) root.IOSurfaceRef else opaque {};
pub const SampleMask = u32;
pub const Bool32 = enum(i32) {
    false,
    true,
    _,
};
pub const Flags = u32;
pub const Flags64 = u64;
pub const DeviceSize = u64;
pub const DeviceAddress = u64;
pub const OHNativeWindow = if (@hasDecl(root, "OHNativeWindow")) root.OHNativeWindow else opaque {};
pub const PipelineDynamicStateCreateFlags = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PipelineDynamicStateCreateFlags).toInt;
    pub const fromInt = FlagsMixin(PipelineDynamicStateCreateFlags).fromInt;
    pub const merge = FlagsMixin(PipelineDynamicStateCreateFlags).merge;
    pub const intersect = FlagsMixin(PipelineDynamicStateCreateFlags).intersect;
    pub const complement = FlagsMixin(PipelineDynamicStateCreateFlags).complement;
    pub const subtract = FlagsMixin(PipelineDynamicStateCreateFlags).subtract;
    pub const contains = FlagsMixin(PipelineDynamicStateCreateFlags).contains;
    pub const format = FlagFormatMixin(PipelineDynamicStateCreateFlags).format;
};
pub const PipelineMultisampleStateCreateFlags = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PipelineMultisampleStateCreateFlags).toInt;
    pub const fromInt = FlagsMixin(PipelineMultisampleStateCreateFlags).fromInt;
    pub const merge = FlagsMixin(PipelineMultisampleStateCreateFlags).merge;
    pub const intersect = FlagsMixin(PipelineMultisampleStateCreateFlags).intersect;
    pub const complement = FlagsMixin(PipelineMultisampleStateCreateFlags).complement;
    pub const subtract = FlagsMixin(PipelineMultisampleStateCreateFlags).subtract;
    pub const contains = FlagsMixin(PipelineMultisampleStateCreateFlags).contains;
    pub const format = FlagFormatMixin(PipelineMultisampleStateCreateFlags).format;
};
pub const PipelineRasterizationStateCreateFlags = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PipelineRasterizationStateCreateFlags).toInt;
    pub const fromInt = FlagsMixin(PipelineRasterizationStateCreateFlags).fromInt;
    pub const merge = FlagsMixin(PipelineRasterizationStateCreateFlags).merge;
    pub const intersect = FlagsMixin(PipelineRasterizationStateCreateFlags).intersect;
    pub const complement = FlagsMixin(PipelineRasterizationStateCreateFlags).complement;
    pub const subtract = FlagsMixin(PipelineRasterizationStateCreateFlags).subtract;
    pub const contains = FlagsMixin(PipelineRasterizationStateCreateFlags).contains;
    pub const format = FlagFormatMixin(PipelineRasterizationStateCreateFlags).format;
};
pub const PipelineViewportStateCreateFlags = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PipelineViewportStateCreateFlags).toInt;
    pub const fromInt = FlagsMixin(PipelineViewportStateCreateFlags).fromInt;
    pub const merge = FlagsMixin(PipelineViewportStateCreateFlags).merge;
    pub const intersect = FlagsMixin(PipelineViewportStateCreateFlags).intersect;
    pub const complement = FlagsMixin(PipelineViewportStateCreateFlags).complement;
    pub const subtract = FlagsMixin(PipelineViewportStateCreateFlags).subtract;
    pub const contains = FlagsMixin(PipelineViewportStateCreateFlags).contains;
    pub const format = FlagFormatMixin(PipelineViewportStateCreateFlags).format;
};
pub const PipelineTessellationStateCreateFlags = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PipelineTessellationStateCreateFlags).toInt;
    pub const fromInt = FlagsMixin(PipelineTessellationStateCreateFlags).fromInt;
    pub const merge = FlagsMixin(PipelineTessellationStateCreateFlags).merge;
    pub const intersect = FlagsMixin(PipelineTessellationStateCreateFlags).intersect;
    pub const complement = FlagsMixin(PipelineTessellationStateCreateFlags).complement;
    pub const subtract = FlagsMixin(PipelineTessellationStateCreateFlags).subtract;
    pub const contains = FlagsMixin(PipelineTessellationStateCreateFlags).contains;
    pub const format = FlagFormatMixin(PipelineTessellationStateCreateFlags).format;
};
pub const PipelineInputAssemblyStateCreateFlags = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PipelineInputAssemblyStateCreateFlags).toInt;
    pub const fromInt = FlagsMixin(PipelineInputAssemblyStateCreateFlags).fromInt;
    pub const merge = FlagsMixin(PipelineInputAssemblyStateCreateFlags).merge;
    pub const intersect = FlagsMixin(PipelineInputAssemblyStateCreateFlags).intersect;
    pub const complement = FlagsMixin(PipelineInputAssemblyStateCreateFlags).complement;
    pub const subtract = FlagsMixin(PipelineInputAssemblyStateCreateFlags).subtract;
    pub const contains = FlagsMixin(PipelineInputAssemblyStateCreateFlags).contains;
    pub const format = FlagFormatMixin(PipelineInputAssemblyStateCreateFlags).format;
};
pub const PipelineVertexInputStateCreateFlags = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PipelineVertexInputStateCreateFlags).toInt;
    pub const fromInt = FlagsMixin(PipelineVertexInputStateCreateFlags).fromInt;
    pub const merge = FlagsMixin(PipelineVertexInputStateCreateFlags).merge;
    pub const intersect = FlagsMixin(PipelineVertexInputStateCreateFlags).intersect;
    pub const complement = FlagsMixin(PipelineVertexInputStateCreateFlags).complement;
    pub const subtract = FlagsMixin(PipelineVertexInputStateCreateFlags).subtract;
    pub const contains = FlagsMixin(PipelineVertexInputStateCreateFlags).contains;
    pub const format = FlagFormatMixin(PipelineVertexInputStateCreateFlags).format;
};
pub const BufferViewCreateFlags = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(BufferViewCreateFlags).toInt;
    pub const fromInt = FlagsMixin(BufferViewCreateFlags).fromInt;
    pub const merge = FlagsMixin(BufferViewCreateFlags).merge;
    pub const intersect = FlagsMixin(BufferViewCreateFlags).intersect;
    pub const complement = FlagsMixin(BufferViewCreateFlags).complement;
    pub const subtract = FlagsMixin(BufferViewCreateFlags).subtract;
    pub const contains = FlagsMixin(BufferViewCreateFlags).contains;
    pub const format = FlagFormatMixin(BufferViewCreateFlags).format;
};
pub const DeviceCreateFlags = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(DeviceCreateFlags).toInt;
    pub const fromInt = FlagsMixin(DeviceCreateFlags).fromInt;
    pub const merge = FlagsMixin(DeviceCreateFlags).merge;
    pub const intersect = FlagsMixin(DeviceCreateFlags).intersect;
    pub const complement = FlagsMixin(DeviceCreateFlags).complement;
    pub const subtract = FlagsMixin(DeviceCreateFlags).subtract;
    pub const contains = FlagsMixin(DeviceCreateFlags).contains;
    pub const format = FlagFormatMixin(DeviceCreateFlags).format;
};
pub const SemaphoreCreateFlags = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(SemaphoreCreateFlags).toInt;
    pub const fromInt = FlagsMixin(SemaphoreCreateFlags).fromInt;
    pub const merge = FlagsMixin(SemaphoreCreateFlags).merge;
    pub const intersect = FlagsMixin(SemaphoreCreateFlags).intersect;
    pub const complement = FlagsMixin(SemaphoreCreateFlags).complement;
    pub const subtract = FlagsMixin(SemaphoreCreateFlags).subtract;
    pub const contains = FlagsMixin(SemaphoreCreateFlags).contains;
    pub const format = FlagFormatMixin(SemaphoreCreateFlags).format;
};
pub const ShaderModuleCreateFlags = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(ShaderModuleCreateFlags).toInt;
    pub const fromInt = FlagsMixin(ShaderModuleCreateFlags).fromInt;
    pub const merge = FlagsMixin(ShaderModuleCreateFlags).merge;
    pub const intersect = FlagsMixin(ShaderModuleCreateFlags).intersect;
    pub const complement = FlagsMixin(ShaderModuleCreateFlags).complement;
    pub const subtract = FlagsMixin(ShaderModuleCreateFlags).subtract;
    pub const contains = FlagsMixin(ShaderModuleCreateFlags).contains;
    pub const format = FlagFormatMixin(ShaderModuleCreateFlags).format;
};
pub const MemoryUnmapFlagsKHR = MemoryUnmapFlags;
pub const DescriptorPoolResetFlags = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(DescriptorPoolResetFlags).toInt;
    pub const fromInt = FlagsMixin(DescriptorPoolResetFlags).fromInt;
    pub const merge = FlagsMixin(DescriptorPoolResetFlags).merge;
    pub const intersect = FlagsMixin(DescriptorPoolResetFlags).intersect;
    pub const complement = FlagsMixin(DescriptorPoolResetFlags).complement;
    pub const subtract = FlagsMixin(DescriptorPoolResetFlags).subtract;
    pub const contains = FlagsMixin(DescriptorPoolResetFlags).contains;
    pub const format = FlagFormatMixin(DescriptorPoolResetFlags).format;
};
pub const GeometryFlagsNV = GeometryFlagsKHR;
pub const GeometryInstanceFlagsNV = GeometryInstanceFlagsKHR;
pub const BuildAccelerationStructureFlagsNV = BuildAccelerationStructureFlagsKHR;
pub const PrivateDataSlotCreateFlags = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PrivateDataSlotCreateFlags).toInt;
    pub const fromInt = FlagsMixin(PrivateDataSlotCreateFlags).fromInt;
    pub const merge = FlagsMixin(PrivateDataSlotCreateFlags).merge;
    pub const intersect = FlagsMixin(PrivateDataSlotCreateFlags).intersect;
    pub const complement = FlagsMixin(PrivateDataSlotCreateFlags).complement;
    pub const subtract = FlagsMixin(PrivateDataSlotCreateFlags).subtract;
    pub const contains = FlagsMixin(PrivateDataSlotCreateFlags).contains;
    pub const format = FlagFormatMixin(PrivateDataSlotCreateFlags).format;
};
pub const PrivateDataSlotCreateFlagsEXT = PrivateDataSlotCreateFlags;
pub const DescriptorUpdateTemplateCreateFlags = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(DescriptorUpdateTemplateCreateFlags).toInt;
    pub const fromInt = FlagsMixin(DescriptorUpdateTemplateCreateFlags).fromInt;
    pub const merge = FlagsMixin(DescriptorUpdateTemplateCreateFlags).merge;
    pub const intersect = FlagsMixin(DescriptorUpdateTemplateCreateFlags).intersect;
    pub const complement = FlagsMixin(DescriptorUpdateTemplateCreateFlags).complement;
    pub const subtract = FlagsMixin(DescriptorUpdateTemplateCreateFlags).subtract;
    pub const contains = FlagsMixin(DescriptorUpdateTemplateCreateFlags).contains;
    pub const format = FlagFormatMixin(DescriptorUpdateTemplateCreateFlags).format;
};
pub const DescriptorUpdateTemplateCreateFlagsKHR = DescriptorUpdateTemplateCreateFlags;
pub const PipelineCreationFeedbackFlagsEXT = PipelineCreationFeedbackFlags;
pub const SemaphoreWaitFlagsKHR = SemaphoreWaitFlags;
pub const AccessFlags2KHR = AccessFlags2;
pub const PipelineStageFlags2KHR = PipelineStageFlags2;
pub const AccelerationStructureMotionInfoFlagsNV = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(AccelerationStructureMotionInfoFlagsNV).toInt;
    pub const fromInt = FlagsMixin(AccelerationStructureMotionInfoFlagsNV).fromInt;
    pub const merge = FlagsMixin(AccelerationStructureMotionInfoFlagsNV).merge;
    pub const intersect = FlagsMixin(AccelerationStructureMotionInfoFlagsNV).intersect;
    pub const complement = FlagsMixin(AccelerationStructureMotionInfoFlagsNV).complement;
    pub const subtract = FlagsMixin(AccelerationStructureMotionInfoFlagsNV).subtract;
    pub const contains = FlagsMixin(AccelerationStructureMotionInfoFlagsNV).contains;
    pub const format = FlagFormatMixin(AccelerationStructureMotionInfoFlagsNV).format;
};
pub const AccelerationStructureMotionInstanceFlagsNV = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(AccelerationStructureMotionInstanceFlagsNV).toInt;
    pub const fromInt = FlagsMixin(AccelerationStructureMotionInstanceFlagsNV).fromInt;
    pub const merge = FlagsMixin(AccelerationStructureMotionInstanceFlagsNV).merge;
    pub const intersect = FlagsMixin(AccelerationStructureMotionInstanceFlagsNV).intersect;
    pub const complement = FlagsMixin(AccelerationStructureMotionInstanceFlagsNV).complement;
    pub const subtract = FlagsMixin(AccelerationStructureMotionInstanceFlagsNV).subtract;
    pub const contains = FlagsMixin(AccelerationStructureMotionInstanceFlagsNV).contains;
    pub const format = FlagFormatMixin(AccelerationStructureMotionInstanceFlagsNV).format;
};
pub const FormatFeatureFlags2KHR = FormatFeatureFlags2;
pub const RenderingFlagsKHR = RenderingFlags;
pub const DirectDriverLoadingFlagsLUNARG = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(DirectDriverLoadingFlagsLUNARG).toInt;
    pub const fromInt = FlagsMixin(DirectDriverLoadingFlagsLUNARG).fromInt;
    pub const merge = FlagsMixin(DirectDriverLoadingFlagsLUNARG).merge;
    pub const intersect = FlagsMixin(DirectDriverLoadingFlagsLUNARG).intersect;
    pub const complement = FlagsMixin(DirectDriverLoadingFlagsLUNARG).complement;
    pub const subtract = FlagsMixin(DirectDriverLoadingFlagsLUNARG).subtract;
    pub const contains = FlagsMixin(DirectDriverLoadingFlagsLUNARG).contains;
    pub const format = FlagFormatMixin(DirectDriverLoadingFlagsLUNARG).format;
};
pub const PipelineCreateFlags2KHR = PipelineCreateFlags2;
pub const BufferUsageFlags2KHR = BufferUsageFlags2;
pub const DisplayModeCreateFlagsKHR = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(DisplayModeCreateFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(DisplayModeCreateFlagsKHR).fromInt;
    pub const merge = FlagsMixin(DisplayModeCreateFlagsKHR).merge;
    pub const intersect = FlagsMixin(DisplayModeCreateFlagsKHR).intersect;
    pub const complement = FlagsMixin(DisplayModeCreateFlagsKHR).complement;
    pub const subtract = FlagsMixin(DisplayModeCreateFlagsKHR).subtract;
    pub const contains = FlagsMixin(DisplayModeCreateFlagsKHR).contains;
    pub const format = FlagFormatMixin(DisplayModeCreateFlagsKHR).format;
};
pub const DisplaySurfaceCreateFlagsKHR = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(DisplaySurfaceCreateFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(DisplaySurfaceCreateFlagsKHR).fromInt;
    pub const merge = FlagsMixin(DisplaySurfaceCreateFlagsKHR).merge;
    pub const intersect = FlagsMixin(DisplaySurfaceCreateFlagsKHR).intersect;
    pub const complement = FlagsMixin(DisplaySurfaceCreateFlagsKHR).complement;
    pub const subtract = FlagsMixin(DisplaySurfaceCreateFlagsKHR).subtract;
    pub const contains = FlagsMixin(DisplaySurfaceCreateFlagsKHR).contains;
    pub const format = FlagFormatMixin(DisplaySurfaceCreateFlagsKHR).format;
};
pub const AndroidSurfaceCreateFlagsKHR = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(AndroidSurfaceCreateFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(AndroidSurfaceCreateFlagsKHR).fromInt;
    pub const merge = FlagsMixin(AndroidSurfaceCreateFlagsKHR).merge;
    pub const intersect = FlagsMixin(AndroidSurfaceCreateFlagsKHR).intersect;
    pub const complement = FlagsMixin(AndroidSurfaceCreateFlagsKHR).complement;
    pub const subtract = FlagsMixin(AndroidSurfaceCreateFlagsKHR).subtract;
    pub const contains = FlagsMixin(AndroidSurfaceCreateFlagsKHR).contains;
    pub const format = FlagFormatMixin(AndroidSurfaceCreateFlagsKHR).format;
};
pub const ViSurfaceCreateFlagsNN = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(ViSurfaceCreateFlagsNN).toInt;
    pub const fromInt = FlagsMixin(ViSurfaceCreateFlagsNN).fromInt;
    pub const merge = FlagsMixin(ViSurfaceCreateFlagsNN).merge;
    pub const intersect = FlagsMixin(ViSurfaceCreateFlagsNN).intersect;
    pub const complement = FlagsMixin(ViSurfaceCreateFlagsNN).complement;
    pub const subtract = FlagsMixin(ViSurfaceCreateFlagsNN).subtract;
    pub const contains = FlagsMixin(ViSurfaceCreateFlagsNN).contains;
    pub const format = FlagFormatMixin(ViSurfaceCreateFlagsNN).format;
};
pub const WaylandSurfaceCreateFlagsKHR = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(WaylandSurfaceCreateFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(WaylandSurfaceCreateFlagsKHR).fromInt;
    pub const merge = FlagsMixin(WaylandSurfaceCreateFlagsKHR).merge;
    pub const intersect = FlagsMixin(WaylandSurfaceCreateFlagsKHR).intersect;
    pub const complement = FlagsMixin(WaylandSurfaceCreateFlagsKHR).complement;
    pub const subtract = FlagsMixin(WaylandSurfaceCreateFlagsKHR).subtract;
    pub const contains = FlagsMixin(WaylandSurfaceCreateFlagsKHR).contains;
    pub const format = FlagFormatMixin(WaylandSurfaceCreateFlagsKHR).format;
};
pub const Win32SurfaceCreateFlagsKHR = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(Win32SurfaceCreateFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(Win32SurfaceCreateFlagsKHR).fromInt;
    pub const merge = FlagsMixin(Win32SurfaceCreateFlagsKHR).merge;
    pub const intersect = FlagsMixin(Win32SurfaceCreateFlagsKHR).intersect;
    pub const complement = FlagsMixin(Win32SurfaceCreateFlagsKHR).complement;
    pub const subtract = FlagsMixin(Win32SurfaceCreateFlagsKHR).subtract;
    pub const contains = FlagsMixin(Win32SurfaceCreateFlagsKHR).contains;
    pub const format = FlagFormatMixin(Win32SurfaceCreateFlagsKHR).format;
};
pub const XlibSurfaceCreateFlagsKHR = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(XlibSurfaceCreateFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(XlibSurfaceCreateFlagsKHR).fromInt;
    pub const merge = FlagsMixin(XlibSurfaceCreateFlagsKHR).merge;
    pub const intersect = FlagsMixin(XlibSurfaceCreateFlagsKHR).intersect;
    pub const complement = FlagsMixin(XlibSurfaceCreateFlagsKHR).complement;
    pub const subtract = FlagsMixin(XlibSurfaceCreateFlagsKHR).subtract;
    pub const contains = FlagsMixin(XlibSurfaceCreateFlagsKHR).contains;
    pub const format = FlagFormatMixin(XlibSurfaceCreateFlagsKHR).format;
};
pub const XcbSurfaceCreateFlagsKHR = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(XcbSurfaceCreateFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(XcbSurfaceCreateFlagsKHR).fromInt;
    pub const merge = FlagsMixin(XcbSurfaceCreateFlagsKHR).merge;
    pub const intersect = FlagsMixin(XcbSurfaceCreateFlagsKHR).intersect;
    pub const complement = FlagsMixin(XcbSurfaceCreateFlagsKHR).complement;
    pub const subtract = FlagsMixin(XcbSurfaceCreateFlagsKHR).subtract;
    pub const contains = FlagsMixin(XcbSurfaceCreateFlagsKHR).contains;
    pub const format = FlagFormatMixin(XcbSurfaceCreateFlagsKHR).format;
};
pub const DirectFBSurfaceCreateFlagsEXT = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(DirectFBSurfaceCreateFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(DirectFBSurfaceCreateFlagsEXT).fromInt;
    pub const merge = FlagsMixin(DirectFBSurfaceCreateFlagsEXT).merge;
    pub const intersect = FlagsMixin(DirectFBSurfaceCreateFlagsEXT).intersect;
    pub const complement = FlagsMixin(DirectFBSurfaceCreateFlagsEXT).complement;
    pub const subtract = FlagsMixin(DirectFBSurfaceCreateFlagsEXT).subtract;
    pub const contains = FlagsMixin(DirectFBSurfaceCreateFlagsEXT).contains;
    pub const format = FlagFormatMixin(DirectFBSurfaceCreateFlagsEXT).format;
};
pub const IOSSurfaceCreateFlagsMVK = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(IOSSurfaceCreateFlagsMVK).toInt;
    pub const fromInt = FlagsMixin(IOSSurfaceCreateFlagsMVK).fromInt;
    pub const merge = FlagsMixin(IOSSurfaceCreateFlagsMVK).merge;
    pub const intersect = FlagsMixin(IOSSurfaceCreateFlagsMVK).intersect;
    pub const complement = FlagsMixin(IOSSurfaceCreateFlagsMVK).complement;
    pub const subtract = FlagsMixin(IOSSurfaceCreateFlagsMVK).subtract;
    pub const contains = FlagsMixin(IOSSurfaceCreateFlagsMVK).contains;
    pub const format = FlagFormatMixin(IOSSurfaceCreateFlagsMVK).format;
};
pub const MacOSSurfaceCreateFlagsMVK = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(MacOSSurfaceCreateFlagsMVK).toInt;
    pub const fromInt = FlagsMixin(MacOSSurfaceCreateFlagsMVK).fromInt;
    pub const merge = FlagsMixin(MacOSSurfaceCreateFlagsMVK).merge;
    pub const intersect = FlagsMixin(MacOSSurfaceCreateFlagsMVK).intersect;
    pub const complement = FlagsMixin(MacOSSurfaceCreateFlagsMVK).complement;
    pub const subtract = FlagsMixin(MacOSSurfaceCreateFlagsMVK).subtract;
    pub const contains = FlagsMixin(MacOSSurfaceCreateFlagsMVK).contains;
    pub const format = FlagFormatMixin(MacOSSurfaceCreateFlagsMVK).format;
};
pub const MetalSurfaceCreateFlagsEXT = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(MetalSurfaceCreateFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(MetalSurfaceCreateFlagsEXT).fromInt;
    pub const merge = FlagsMixin(MetalSurfaceCreateFlagsEXT).merge;
    pub const intersect = FlagsMixin(MetalSurfaceCreateFlagsEXT).intersect;
    pub const complement = FlagsMixin(MetalSurfaceCreateFlagsEXT).complement;
    pub const subtract = FlagsMixin(MetalSurfaceCreateFlagsEXT).subtract;
    pub const contains = FlagsMixin(MetalSurfaceCreateFlagsEXT).contains;
    pub const format = FlagFormatMixin(MetalSurfaceCreateFlagsEXT).format;
};
pub const ImagePipeSurfaceCreateFlagsFUCHSIA = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(ImagePipeSurfaceCreateFlagsFUCHSIA).toInt;
    pub const fromInt = FlagsMixin(ImagePipeSurfaceCreateFlagsFUCHSIA).fromInt;
    pub const merge = FlagsMixin(ImagePipeSurfaceCreateFlagsFUCHSIA).merge;
    pub const intersect = FlagsMixin(ImagePipeSurfaceCreateFlagsFUCHSIA).intersect;
    pub const complement = FlagsMixin(ImagePipeSurfaceCreateFlagsFUCHSIA).complement;
    pub const subtract = FlagsMixin(ImagePipeSurfaceCreateFlagsFUCHSIA).subtract;
    pub const contains = FlagsMixin(ImagePipeSurfaceCreateFlagsFUCHSIA).contains;
    pub const format = FlagFormatMixin(ImagePipeSurfaceCreateFlagsFUCHSIA).format;
};
pub const StreamDescriptorSurfaceCreateFlagsGGP = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(StreamDescriptorSurfaceCreateFlagsGGP).toInt;
    pub const fromInt = FlagsMixin(StreamDescriptorSurfaceCreateFlagsGGP).fromInt;
    pub const merge = FlagsMixin(StreamDescriptorSurfaceCreateFlagsGGP).merge;
    pub const intersect = FlagsMixin(StreamDescriptorSurfaceCreateFlagsGGP).intersect;
    pub const complement = FlagsMixin(StreamDescriptorSurfaceCreateFlagsGGP).complement;
    pub const subtract = FlagsMixin(StreamDescriptorSurfaceCreateFlagsGGP).subtract;
    pub const contains = FlagsMixin(StreamDescriptorSurfaceCreateFlagsGGP).contains;
    pub const format = FlagFormatMixin(StreamDescriptorSurfaceCreateFlagsGGP).format;
};
pub const HeadlessSurfaceCreateFlagsEXT = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(HeadlessSurfaceCreateFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(HeadlessSurfaceCreateFlagsEXT).fromInt;
    pub const merge = FlagsMixin(HeadlessSurfaceCreateFlagsEXT).merge;
    pub const intersect = FlagsMixin(HeadlessSurfaceCreateFlagsEXT).intersect;
    pub const complement = FlagsMixin(HeadlessSurfaceCreateFlagsEXT).complement;
    pub const subtract = FlagsMixin(HeadlessSurfaceCreateFlagsEXT).subtract;
    pub const contains = FlagsMixin(HeadlessSurfaceCreateFlagsEXT).contains;
    pub const format = FlagFormatMixin(HeadlessSurfaceCreateFlagsEXT).format;
};
pub const ScreenSurfaceCreateFlagsQNX = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(ScreenSurfaceCreateFlagsQNX).toInt;
    pub const fromInt = FlagsMixin(ScreenSurfaceCreateFlagsQNX).fromInt;
    pub const merge = FlagsMixin(ScreenSurfaceCreateFlagsQNX).merge;
    pub const intersect = FlagsMixin(ScreenSurfaceCreateFlagsQNX).intersect;
    pub const complement = FlagsMixin(ScreenSurfaceCreateFlagsQNX).complement;
    pub const subtract = FlagsMixin(ScreenSurfaceCreateFlagsQNX).subtract;
    pub const contains = FlagsMixin(ScreenSurfaceCreateFlagsQNX).contains;
    pub const format = FlagFormatMixin(ScreenSurfaceCreateFlagsQNX).format;
};
pub const PeerMemoryFeatureFlagsKHR = PeerMemoryFeatureFlags;
pub const MemoryAllocateFlagsKHR = MemoryAllocateFlags;
pub const CommandPoolTrimFlags = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(CommandPoolTrimFlags).toInt;
    pub const fromInt = FlagsMixin(CommandPoolTrimFlags).fromInt;
    pub const merge = FlagsMixin(CommandPoolTrimFlags).merge;
    pub const intersect = FlagsMixin(CommandPoolTrimFlags).intersect;
    pub const complement = FlagsMixin(CommandPoolTrimFlags).complement;
    pub const subtract = FlagsMixin(CommandPoolTrimFlags).subtract;
    pub const contains = FlagsMixin(CommandPoolTrimFlags).contains;
    pub const format = FlagFormatMixin(CommandPoolTrimFlags).format;
};
pub const CommandPoolTrimFlagsKHR = CommandPoolTrimFlags;
pub const ExternalMemoryHandleTypeFlagsKHR = ExternalMemoryHandleTypeFlags;
pub const ExternalMemoryFeatureFlagsKHR = ExternalMemoryFeatureFlags;
pub const ExternalSemaphoreHandleTypeFlagsKHR = ExternalSemaphoreHandleTypeFlags;
pub const ExternalSemaphoreFeatureFlagsKHR = ExternalSemaphoreFeatureFlags;
pub const SemaphoreImportFlagsKHR = SemaphoreImportFlags;
pub const ExternalFenceHandleTypeFlagsKHR = ExternalFenceHandleTypeFlags;
pub const ExternalFenceFeatureFlagsKHR = ExternalFenceFeatureFlags;
pub const FenceImportFlagsKHR = FenceImportFlags;
pub const PipelineViewportSwizzleStateCreateFlagsNV = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PipelineViewportSwizzleStateCreateFlagsNV).toInt;
    pub const fromInt = FlagsMixin(PipelineViewportSwizzleStateCreateFlagsNV).fromInt;
    pub const merge = FlagsMixin(PipelineViewportSwizzleStateCreateFlagsNV).merge;
    pub const intersect = FlagsMixin(PipelineViewportSwizzleStateCreateFlagsNV).intersect;
    pub const complement = FlagsMixin(PipelineViewportSwizzleStateCreateFlagsNV).complement;
    pub const subtract = FlagsMixin(PipelineViewportSwizzleStateCreateFlagsNV).subtract;
    pub const contains = FlagsMixin(PipelineViewportSwizzleStateCreateFlagsNV).contains;
    pub const format = FlagFormatMixin(PipelineViewportSwizzleStateCreateFlagsNV).format;
};
pub const PipelineDiscardRectangleStateCreateFlagsEXT = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PipelineDiscardRectangleStateCreateFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(PipelineDiscardRectangleStateCreateFlagsEXT).fromInt;
    pub const merge = FlagsMixin(PipelineDiscardRectangleStateCreateFlagsEXT).merge;
    pub const intersect = FlagsMixin(PipelineDiscardRectangleStateCreateFlagsEXT).intersect;
    pub const complement = FlagsMixin(PipelineDiscardRectangleStateCreateFlagsEXT).complement;
    pub const subtract = FlagsMixin(PipelineDiscardRectangleStateCreateFlagsEXT).subtract;
    pub const contains = FlagsMixin(PipelineDiscardRectangleStateCreateFlagsEXT).contains;
    pub const format = FlagFormatMixin(PipelineDiscardRectangleStateCreateFlagsEXT).format;
};
pub const PipelineCoverageToColorStateCreateFlagsNV = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PipelineCoverageToColorStateCreateFlagsNV).toInt;
    pub const fromInt = FlagsMixin(PipelineCoverageToColorStateCreateFlagsNV).fromInt;
    pub const merge = FlagsMixin(PipelineCoverageToColorStateCreateFlagsNV).merge;
    pub const intersect = FlagsMixin(PipelineCoverageToColorStateCreateFlagsNV).intersect;
    pub const complement = FlagsMixin(PipelineCoverageToColorStateCreateFlagsNV).complement;
    pub const subtract = FlagsMixin(PipelineCoverageToColorStateCreateFlagsNV).subtract;
    pub const contains = FlagsMixin(PipelineCoverageToColorStateCreateFlagsNV).contains;
    pub const format = FlagFormatMixin(PipelineCoverageToColorStateCreateFlagsNV).format;
};
pub const PipelineCoverageModulationStateCreateFlagsNV = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PipelineCoverageModulationStateCreateFlagsNV).toInt;
    pub const fromInt = FlagsMixin(PipelineCoverageModulationStateCreateFlagsNV).fromInt;
    pub const merge = FlagsMixin(PipelineCoverageModulationStateCreateFlagsNV).merge;
    pub const intersect = FlagsMixin(PipelineCoverageModulationStateCreateFlagsNV).intersect;
    pub const complement = FlagsMixin(PipelineCoverageModulationStateCreateFlagsNV).complement;
    pub const subtract = FlagsMixin(PipelineCoverageModulationStateCreateFlagsNV).subtract;
    pub const contains = FlagsMixin(PipelineCoverageModulationStateCreateFlagsNV).contains;
    pub const format = FlagFormatMixin(PipelineCoverageModulationStateCreateFlagsNV).format;
};
pub const PipelineCoverageReductionStateCreateFlagsNV = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PipelineCoverageReductionStateCreateFlagsNV).toInt;
    pub const fromInt = FlagsMixin(PipelineCoverageReductionStateCreateFlagsNV).fromInt;
    pub const merge = FlagsMixin(PipelineCoverageReductionStateCreateFlagsNV).merge;
    pub const intersect = FlagsMixin(PipelineCoverageReductionStateCreateFlagsNV).intersect;
    pub const complement = FlagsMixin(PipelineCoverageReductionStateCreateFlagsNV).complement;
    pub const subtract = FlagsMixin(PipelineCoverageReductionStateCreateFlagsNV).subtract;
    pub const contains = FlagsMixin(PipelineCoverageReductionStateCreateFlagsNV).contains;
    pub const format = FlagFormatMixin(PipelineCoverageReductionStateCreateFlagsNV).format;
};
pub const ValidationCacheCreateFlagsEXT = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(ValidationCacheCreateFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(ValidationCacheCreateFlagsEXT).fromInt;
    pub const merge = FlagsMixin(ValidationCacheCreateFlagsEXT).merge;
    pub const intersect = FlagsMixin(ValidationCacheCreateFlagsEXT).intersect;
    pub const complement = FlagsMixin(ValidationCacheCreateFlagsEXT).complement;
    pub const subtract = FlagsMixin(ValidationCacheCreateFlagsEXT).subtract;
    pub const contains = FlagsMixin(ValidationCacheCreateFlagsEXT).contains;
    pub const format = FlagFormatMixin(ValidationCacheCreateFlagsEXT).format;
};
pub const DebugUtilsMessengerCreateFlagsEXT = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(DebugUtilsMessengerCreateFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(DebugUtilsMessengerCreateFlagsEXT).fromInt;
    pub const merge = FlagsMixin(DebugUtilsMessengerCreateFlagsEXT).merge;
    pub const intersect = FlagsMixin(DebugUtilsMessengerCreateFlagsEXT).intersect;
    pub const complement = FlagsMixin(DebugUtilsMessengerCreateFlagsEXT).complement;
    pub const subtract = FlagsMixin(DebugUtilsMessengerCreateFlagsEXT).subtract;
    pub const contains = FlagsMixin(DebugUtilsMessengerCreateFlagsEXT).contains;
    pub const format = FlagFormatMixin(DebugUtilsMessengerCreateFlagsEXT).format;
};
pub const DebugUtilsMessengerCallbackDataFlagsEXT = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(DebugUtilsMessengerCallbackDataFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(DebugUtilsMessengerCallbackDataFlagsEXT).fromInt;
    pub const merge = FlagsMixin(DebugUtilsMessengerCallbackDataFlagsEXT).merge;
    pub const intersect = FlagsMixin(DebugUtilsMessengerCallbackDataFlagsEXT).intersect;
    pub const complement = FlagsMixin(DebugUtilsMessengerCallbackDataFlagsEXT).complement;
    pub const subtract = FlagsMixin(DebugUtilsMessengerCallbackDataFlagsEXT).subtract;
    pub const contains = FlagsMixin(DebugUtilsMessengerCallbackDataFlagsEXT).contains;
    pub const format = FlagFormatMixin(DebugUtilsMessengerCallbackDataFlagsEXT).format;
};
pub const DeviceMemoryReportFlagsEXT = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(DeviceMemoryReportFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(DeviceMemoryReportFlagsEXT).fromInt;
    pub const merge = FlagsMixin(DeviceMemoryReportFlagsEXT).merge;
    pub const intersect = FlagsMixin(DeviceMemoryReportFlagsEXT).intersect;
    pub const complement = FlagsMixin(DeviceMemoryReportFlagsEXT).complement;
    pub const subtract = FlagsMixin(DeviceMemoryReportFlagsEXT).subtract;
    pub const contains = FlagsMixin(DeviceMemoryReportFlagsEXT).contains;
    pub const format = FlagFormatMixin(DeviceMemoryReportFlagsEXT).format;
};
pub const PipelineRasterizationConservativeStateCreateFlagsEXT = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PipelineRasterizationConservativeStateCreateFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(PipelineRasterizationConservativeStateCreateFlagsEXT).fromInt;
    pub const merge = FlagsMixin(PipelineRasterizationConservativeStateCreateFlagsEXT).merge;
    pub const intersect = FlagsMixin(PipelineRasterizationConservativeStateCreateFlagsEXT).intersect;
    pub const complement = FlagsMixin(PipelineRasterizationConservativeStateCreateFlagsEXT).complement;
    pub const subtract = FlagsMixin(PipelineRasterizationConservativeStateCreateFlagsEXT).subtract;
    pub const contains = FlagsMixin(PipelineRasterizationConservativeStateCreateFlagsEXT).contains;
    pub const format = FlagFormatMixin(PipelineRasterizationConservativeStateCreateFlagsEXT).format;
};
pub const DescriptorBindingFlagsEXT = DescriptorBindingFlags;
pub const ResolveModeFlagsKHR = ResolveModeFlags;
pub const PipelineRasterizationStateStreamCreateFlagsEXT = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PipelineRasterizationStateStreamCreateFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(PipelineRasterizationStateStreamCreateFlagsEXT).fromInt;
    pub const merge = FlagsMixin(PipelineRasterizationStateStreamCreateFlagsEXT).merge;
    pub const intersect = FlagsMixin(PipelineRasterizationStateStreamCreateFlagsEXT).intersect;
    pub const complement = FlagsMixin(PipelineRasterizationStateStreamCreateFlagsEXT).complement;
    pub const subtract = FlagsMixin(PipelineRasterizationStateStreamCreateFlagsEXT).subtract;
    pub const contains = FlagsMixin(PipelineRasterizationStateStreamCreateFlagsEXT).contains;
    pub const format = FlagFormatMixin(PipelineRasterizationStateStreamCreateFlagsEXT).format;
};
pub const PipelineRasterizationDepthClipStateCreateFlagsEXT = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PipelineRasterizationDepthClipStateCreateFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(PipelineRasterizationDepthClipStateCreateFlagsEXT).fromInt;
    pub const merge = FlagsMixin(PipelineRasterizationDepthClipStateCreateFlagsEXT).merge;
    pub const intersect = FlagsMixin(PipelineRasterizationDepthClipStateCreateFlagsEXT).intersect;
    pub const complement = FlagsMixin(PipelineRasterizationDepthClipStateCreateFlagsEXT).complement;
    pub const subtract = FlagsMixin(PipelineRasterizationDepthClipStateCreateFlagsEXT).subtract;
    pub const contains = FlagsMixin(PipelineRasterizationDepthClipStateCreateFlagsEXT).contains;
    pub const format = FlagFormatMixin(PipelineRasterizationDepthClipStateCreateFlagsEXT).format;
};
pub const ToolPurposeFlagsEXT = ToolPurposeFlags;
pub const SubmitFlagsKHR = SubmitFlags;
pub const ImageFormatConstraintsFlagsFUCHSIA = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(ImageFormatConstraintsFlagsFUCHSIA).toInt;
    pub const fromInt = FlagsMixin(ImageFormatConstraintsFlagsFUCHSIA).fromInt;
    pub const merge = FlagsMixin(ImageFormatConstraintsFlagsFUCHSIA).merge;
    pub const intersect = FlagsMixin(ImageFormatConstraintsFlagsFUCHSIA).intersect;
    pub const complement = FlagsMixin(ImageFormatConstraintsFlagsFUCHSIA).complement;
    pub const subtract = FlagsMixin(ImageFormatConstraintsFlagsFUCHSIA).subtract;
    pub const contains = FlagsMixin(ImageFormatConstraintsFlagsFUCHSIA).contains;
    pub const format = FlagFormatMixin(ImageFormatConstraintsFlagsFUCHSIA).format;
};
pub const HostImageCopyFlagsEXT = HostImageCopyFlags;
pub const PresentScalingFlagsEXT = PresentScalingFlagsKHR;
pub const PresentGravityFlagsEXT = PresentGravityFlagsKHR;
pub const SurfaceCreateFlagsOHOS = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(SurfaceCreateFlagsOHOS).toInt;
    pub const fromInt = FlagsMixin(SurfaceCreateFlagsOHOS).fromInt;
    pub const merge = FlagsMixin(SurfaceCreateFlagsOHOS).merge;
    pub const intersect = FlagsMixin(SurfaceCreateFlagsOHOS).intersect;
    pub const complement = FlagsMixin(SurfaceCreateFlagsOHOS).complement;
    pub const subtract = FlagsMixin(SurfaceCreateFlagsOHOS).subtract;
    pub const contains = FlagsMixin(SurfaceCreateFlagsOHOS).contains;
    pub const format = FlagFormatMixin(SurfaceCreateFlagsOHOS).format;
};
pub const VideoBeginCodingFlagsKHR = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(VideoBeginCodingFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoBeginCodingFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoBeginCodingFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoBeginCodingFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoBeginCodingFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoBeginCodingFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoBeginCodingFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoBeginCodingFlagsKHR).format;
};
pub const VideoEndCodingFlagsKHR = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(VideoEndCodingFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEndCodingFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEndCodingFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEndCodingFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEndCodingFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEndCodingFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEndCodingFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEndCodingFlagsKHR).format;
};
pub const VideoDecodeFlagsKHR = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(VideoDecodeFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoDecodeFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoDecodeFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoDecodeFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoDecodeFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoDecodeFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoDecodeFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoDecodeFlagsKHR).format;
};
pub const VideoEncodeRateControlFlagsKHR = packed struct {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(VideoEncodeRateControlFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeRateControlFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeRateControlFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeRateControlFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeRateControlFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeRateControlFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeRateControlFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeRateControlFlagsKHR).format;
};
pub const Instance = enum(usize) { null_handle = 0, _ };
pub const PhysicalDevice = enum(usize) { null_handle = 0, _ };
pub const Device = enum(usize) { null_handle = 0, _ };
pub const Queue = enum(usize) { null_handle = 0, _ };
pub const CommandBuffer = enum(usize) { null_handle = 0, _ };
pub const DeviceMemory = enum(u64) { null_handle = 0, _ };
pub const CommandPool = enum(u64) { null_handle = 0, _ };
pub const Buffer = enum(u64) { null_handle = 0, _ };
pub const BufferView = enum(u64) { null_handle = 0, _ };
pub const Image = enum(u64) { null_handle = 0, _ };
pub const ImageView = enum(u64) { null_handle = 0, _ };
pub const ShaderModule = enum(u64) { null_handle = 0, _ };
pub const Pipeline = enum(u64) { null_handle = 0, _ };
pub const PipelineLayout = enum(u64) { null_handle = 0, _ };
pub const Sampler = enum(u64) { null_handle = 0, _ };
pub const DescriptorSet = enum(u64) { null_handle = 0, _ };
pub const DescriptorSetLayout = enum(u64) { null_handle = 0, _ };
pub const DescriptorPool = enum(u64) { null_handle = 0, _ };
pub const Fence = enum(u64) { null_handle = 0, _ };
pub const Semaphore = enum(u64) { null_handle = 0, _ };
pub const Event = enum(u64) { null_handle = 0, _ };
pub const QueryPool = enum(u64) { null_handle = 0, _ };
pub const Framebuffer = enum(u64) { null_handle = 0, _ };
pub const RenderPass = enum(u64) { null_handle = 0, _ };
pub const PipelineCache = enum(u64) { null_handle = 0, _ };
pub const PipelineBinaryKHR = enum(u64) { null_handle = 0, _ };
pub const IndirectCommandsLayoutNV = enum(u64) { null_handle = 0, _ };
pub const IndirectCommandsLayoutEXT = enum(u64) { null_handle = 0, _ };
pub const IndirectExecutionSetEXT = enum(u64) { null_handle = 0, _ };
pub const DescriptorUpdateTemplate = enum(u64) { null_handle = 0, _ };
pub const DescriptorUpdateTemplateKHR = DescriptorUpdateTemplate;
pub const SamplerYcbcrConversion = enum(u64) { null_handle = 0, _ };
pub const SamplerYcbcrConversionKHR = SamplerYcbcrConversion;
pub const ValidationCacheEXT = enum(u64) { null_handle = 0, _ };
pub const AccelerationStructureKHR = enum(u64) { null_handle = 0, _ };
pub const AccelerationStructureNV = enum(u64) { null_handle = 0, _ };
pub const PerformanceConfigurationINTEL = enum(u64) { null_handle = 0, _ };
pub const BufferCollectionFUCHSIA = enum(u64) { null_handle = 0, _ };
pub const DeferredOperationKHR = enum(u64) { null_handle = 0, _ };
pub const PrivateDataSlot = enum(u64) { null_handle = 0, _ };
pub const PrivateDataSlotEXT = PrivateDataSlot;
pub const CuModuleNVX = enum(u64) { null_handle = 0, _ };
pub const CuFunctionNVX = enum(u64) { null_handle = 0, _ };
pub const OpticalFlowSessionNV = enum(u64) { null_handle = 0, _ };
pub const MicromapEXT = enum(u64) { null_handle = 0, _ };
pub const ShaderEXT = enum(u64) { null_handle = 0, _ };
pub const TensorARM = enum(u64) { null_handle = 0, _ };
pub const TensorViewARM = enum(u64) { null_handle = 0, _ };
pub const DataGraphPipelineSessionARM = enum(u64) { null_handle = 0, _ };
pub const DisplayKHR = enum(u64) { null_handle = 0, _ };
pub const DisplayModeKHR = enum(u64) { null_handle = 0, _ };
pub const SurfaceKHR = enum(u64) { null_handle = 0, _ };
pub const SwapchainKHR = enum(u64) { null_handle = 0, _ };
pub const DebugReportCallbackEXT = enum(u64) { null_handle = 0, _ };
pub const DebugUtilsMessengerEXT = enum(u64) { null_handle = 0, _ };
pub const VideoSessionKHR = enum(u64) { null_handle = 0, _ };
pub const VideoSessionParametersKHR = enum(u64) { null_handle = 0, _ };
pub const SemaphoreSciSyncPoolNV = enum(u64) { null_handle = 0, _ };
pub const DescriptorUpdateTemplateTypeKHR = DescriptorUpdateTemplateType;
pub const PointClippingBehaviorKHR = PointClippingBehavior;
pub const QueueGlobalPriorityKHR = QueueGlobalPriority;
pub const QueueGlobalPriorityEXT = QueueGlobalPriority;
pub const TimeDomainEXT = TimeDomainKHR;
pub const SemaphoreTypeKHR = SemaphoreType;
pub const CopyAccelerationStructureModeNV = CopyAccelerationStructureModeKHR;
pub const AccelerationStructureTypeNV = AccelerationStructureTypeKHR;
pub const GeometryTypeNV = GeometryTypeKHR;
pub const RayTracingShaderGroupTypeNV = RayTracingShaderGroupTypeKHR;
pub const LineRasterizationModeKHR = LineRasterizationMode;
pub const LineRasterizationModeEXT = LineRasterizationMode;
pub const PipelineRobustnessBufferBehaviorEXT = PipelineRobustnessBufferBehavior;
pub const PipelineRobustnessImageBehaviorEXT = PipelineRobustnessImageBehavior;
pub const ScopeNV = ScopeKHR;
pub const ComponentTypeNV = ComponentTypeKHR;
pub const TessellationDomainOriginKHR = TessellationDomainOrigin;
pub const SamplerYcbcrModelConversionKHR = SamplerYcbcrModelConversion;
pub const SamplerYcbcrRangeKHR = SamplerYcbcrRange;
pub const ChromaLocationKHR = ChromaLocation;
pub const SamplerReductionModeEXT = SamplerReductionMode;
pub const ShaderFloatControlsIndependenceKHR = ShaderFloatControlsIndependence;
pub const DriverIdKHR = DriverId;
pub const PfnInternalAllocationNotification = ?*const fn (
    p_user_data: ?*anyopaque,
    size: usize,
    allocation_type: InternalAllocationType,
    allocation_scope: SystemAllocationScope,
) callconv(vulkan_call_conv) void;
pub const PfnInternalFreeNotification = ?*const fn (
    p_user_data: ?*anyopaque,
    size: usize,
    allocation_type: InternalAllocationType,
    allocation_scope: SystemAllocationScope,
) callconv(vulkan_call_conv) void;
pub const PfnReallocationFunction = ?*const fn (
    p_user_data: ?*anyopaque,
    p_original: ?*anyopaque,
    size: usize,
    alignment: usize,
    allocation_scope: SystemAllocationScope,
) callconv(vulkan_call_conv) ?*anyopaque;
pub const PfnAllocationFunction = ?*const fn (
    p_user_data: ?*anyopaque,
    size: usize,
    alignment: usize,
    allocation_scope: SystemAllocationScope,
) callconv(vulkan_call_conv) ?*anyopaque;
pub const PfnFreeFunction = ?*const fn (
    p_user_data: ?*anyopaque,
    p_memory: ?*anyopaque,
) callconv(vulkan_call_conv) void;
pub const PfnVoidFunction = ?*const fn () callconv(vulkan_call_conv) void;
pub const PfnDebugReportCallbackEXT = ?*const fn (
    flags: DebugReportFlagsEXT,
    object_type: DebugReportObjectTypeEXT,
    object: u64,
    location: usize,
    message_code: i32,
    p_layer_prefix: ?*const u8,
    p_message: ?*const u8,
    p_user_data: ?*anyopaque,
) callconv(vulkan_call_conv) Bool32;
pub const PfnDebugUtilsMessengerCallbackEXT = ?*const fn (
    message_severity: DebugUtilsMessageSeverityFlagsEXT,
    message_types: DebugUtilsMessageTypeFlagsEXT,
    p_callback_data: ?*const DebugUtilsMessengerCallbackDataEXT,
    p_user_data: ?*anyopaque,
) callconv(vulkan_call_conv) Bool32;
pub const PfnFaultCallbackFunction = ?*const fn (
    unrecorded_faults: Bool32,
    fault_count: u32,
    p_faults: ?*const FaultData,
) callconv(vulkan_call_conv) void;
pub const PfnDeviceMemoryReportCallbackEXT = ?*const fn (
    p_callback_data: ?*const DeviceMemoryReportCallbackDataEXT,
    p_user_data: ?*anyopaque,
) callconv(vulkan_call_conv) void;
pub const PfnGetInstanceProcAddrLUNARG = ?*const fn (
    instance: Instance,
    p_name: ?*const u8,
) callconv(vulkan_call_conv) PfnVoidFunction;
pub const BaseOutStructure = extern struct {
    s_type: StructureType,
    p_next: ?*BaseOutStructure = null,
};
pub const BaseInStructure = extern struct {
    s_type: StructureType,
    p_next: ?*const BaseInStructure = null,
};
pub const Offset2D = extern struct {
    x: i32,
    y: i32,
};
pub const Offset3D = extern struct {
    x: i32,
    y: i32,
    z: i32,
};
pub const Extent2D = extern struct {
    width: u32,
    height: u32,
};
pub const Extent3D = extern struct {
    width: u32,
    height: u32,
    depth: u32,
};
pub const Viewport = extern struct {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
    min_depth: f32,
    max_depth: f32,
};
pub const Rect2D = extern struct {
    offset: Offset2D,
    extent: Extent2D,
};
pub const ClearRect = extern struct {
    rect: Rect2D,
    base_array_layer: u32,
    layer_count: u32,
};
pub const ComponentMapping = extern struct {
    r: ComponentSwizzle,
    g: ComponentSwizzle,
    b: ComponentSwizzle,
    a: ComponentSwizzle,
};
pub const PhysicalDeviceProperties = extern struct {
    api_version: u32,
    driver_version: u32,
    vendor_id: u32,
    device_id: u32,
    device_type: PhysicalDeviceType,
    device_name: [MAX_PHYSICAL_DEVICE_NAME_SIZE]u8,
    pipeline_cache_uuid: [UUID_SIZE]u8,
    limits: PhysicalDeviceLimits,
    sparse_properties: PhysicalDeviceSparseProperties,
};
pub const ExtensionProperties = extern struct {
    extension_name: [MAX_EXTENSION_NAME_SIZE]u8,
    spec_version: u32,
};
pub const LayerProperties = extern struct {
    layer_name: [MAX_EXTENSION_NAME_SIZE]u8,
    spec_version: u32,
    implementation_version: u32,
    description: [MAX_DESCRIPTION_SIZE]u8,
};
pub const ApplicationInfo = extern struct {
    s_type: StructureType = .application_info,
    p_next: ?*const anyopaque = null,
    p_application_name: ?[*:0]const u8 = null,
    application_version: u32,
    p_engine_name: ?[*:0]const u8 = null,
    engine_version: u32,
    api_version: u32,
};
pub const AllocationCallbacks = extern struct {
    p_user_data: ?*anyopaque = null,
    pfn_allocation: PfnAllocationFunction,
    pfn_reallocation: PfnReallocationFunction,
    pfn_free: PfnFreeFunction,
    pfn_internal_allocation: PfnInternalAllocationNotification = null,
    pfn_internal_free: PfnInternalFreeNotification = null,
};
pub const DeviceQueueCreateInfo = extern struct {
    s_type: StructureType = .device_queue_create_info,
    p_next: ?*const anyopaque = null,
    flags: DeviceQueueCreateFlags = .{},
    queue_family_index: u32,
    queue_count: u32,
    p_queue_priorities: [*]const f32,
};
pub const DeviceCreateInfo = extern struct {
    s_type: StructureType = .device_create_info,
    p_next: ?*const anyopaque = null,
    flags: DeviceCreateFlags = .{},
    queue_create_info_count: u32 = 0,
    p_queue_create_infos: ?[*]const DeviceQueueCreateInfo = null,
    enabled_layer_count: u32 = 0,
    pp_enabled_layer_names: ?[*]const [*:0]const u8 = null,
    enabled_extension_count: u32 = 0,
    pp_enabled_extension_names: ?[*]const [*:0]const u8 = null,
    p_enabled_features: ?*const PhysicalDeviceFeatures = null,
};
pub const InstanceCreateInfo = extern struct {
    s_type: StructureType = .instance_create_info,
    p_next: ?*const anyopaque = null,
    flags: InstanceCreateFlags = .{},
    p_application_info: ?*const ApplicationInfo = null,
    enabled_layer_count: u32 = 0,
    pp_enabled_layer_names: ?[*]const [*:0]const u8 = null,
    enabled_extension_count: u32 = 0,
    pp_enabled_extension_names: ?[*]const [*:0]const u8 = null,
};
pub const QueueFamilyProperties = extern struct {
    queue_flags: QueueFlags = .{},
    queue_count: u32,
    timestamp_valid_bits: u32,
    min_image_transfer_granularity: Extent3D,
};
pub const PhysicalDeviceMemoryProperties = extern struct {
    memory_type_count: u32,
    memory_types: [MAX_MEMORY_TYPES]MemoryType,
    memory_heap_count: u32,
    memory_heaps: [MAX_MEMORY_HEAPS]MemoryHeap,
};
pub const MemoryAllocateInfo = extern struct {
    s_type: StructureType = .memory_allocate_info,
    p_next: ?*const anyopaque = null,
    allocation_size: DeviceSize,
    memory_type_index: u32,
};
pub const MemoryRequirements = extern struct {
    size: DeviceSize,
    alignment: DeviceSize,
    memory_type_bits: u32,
};
pub const SparseImageFormatProperties = extern struct {
    aspect_mask: ImageAspectFlags = .{},
    image_granularity: Extent3D,
    flags: SparseImageFormatFlags = .{},
};
pub const SparseImageMemoryRequirements = extern struct {
    format_properties: SparseImageFormatProperties,
    image_mip_tail_first_lod: u32,
    image_mip_tail_size: DeviceSize,
    image_mip_tail_offset: DeviceSize,
    image_mip_tail_stride: DeviceSize,
};
pub const MemoryType = extern struct {
    property_flags: MemoryPropertyFlags = .{},
    heap_index: u32,
};
pub const MemoryHeap = extern struct {
    size: DeviceSize,
    flags: MemoryHeapFlags = .{},
};
pub const MappedMemoryRange = extern struct {
    s_type: StructureType = .mapped_memory_range,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory,
    offset: DeviceSize,
    size: DeviceSize,
};
pub const FormatProperties = extern struct {
    linear_tiling_features: FormatFeatureFlags = .{},
    optimal_tiling_features: FormatFeatureFlags = .{},
    buffer_features: FormatFeatureFlags = .{},
};
pub const ImageFormatProperties = extern struct {
    max_extent: Extent3D,
    max_mip_levels: u32,
    max_array_layers: u32,
    sample_counts: SampleCountFlags = .{},
    max_resource_size: DeviceSize,
};
pub const DescriptorBufferInfo = extern struct {
    buffer: Buffer = .null_handle,
    offset: DeviceSize,
    range: DeviceSize,
};
pub const DescriptorImageInfo = extern struct {
    sampler: Sampler,
    image_view: ImageView,
    image_layout: ImageLayout,
};
pub const WriteDescriptorSet = extern struct {
    s_type: StructureType = .write_descriptor_set,
    p_next: ?*const anyopaque = null,
    dst_set: DescriptorSet,
    dst_binding: u32,
    dst_array_element: u32,
    descriptor_count: u32,
    descriptor_type: DescriptorType,
    p_image_info: [*]const DescriptorImageInfo,
    p_buffer_info: [*]const DescriptorBufferInfo,
    p_texel_buffer_view: [*]const BufferView,
};
pub const CopyDescriptorSet = extern struct {
    s_type: StructureType = .copy_descriptor_set,
    p_next: ?*const anyopaque = null,
    src_set: DescriptorSet,
    src_binding: u32,
    src_array_element: u32,
    dst_set: DescriptorSet,
    dst_binding: u32,
    dst_array_element: u32,
    descriptor_count: u32,
};
pub const BufferUsageFlags2CreateInfo = extern struct {
    s_type: StructureType = .buffer_usage_flags_2_create_info,
    p_next: ?*const anyopaque = null,
    usage: BufferUsageFlags2,
};
pub const BufferUsageFlags2CreateInfoKHR = BufferUsageFlags2CreateInfo;
pub const BufferCreateInfo = extern struct {
    s_type: StructureType = .buffer_create_info,
    p_next: ?*const anyopaque = null,
    flags: BufferCreateFlags = .{},
    size: DeviceSize,
    usage: BufferUsageFlags,
    sharing_mode: SharingMode,
    queue_family_index_count: u32 = 0,
    p_queue_family_indices: ?[*]const u32 = null,
};
pub const BufferViewCreateInfo = extern struct {
    s_type: StructureType = .buffer_view_create_info,
    p_next: ?*const anyopaque = null,
    flags: BufferViewCreateFlags = .{},
    buffer: Buffer,
    format: Format,
    offset: DeviceSize,
    range: DeviceSize,
};
pub const ImageSubresource = extern struct {
    aspect_mask: ImageAspectFlags,
    mip_level: u32,
    array_layer: u32,
};
pub const ImageSubresourceLayers = extern struct {
    aspect_mask: ImageAspectFlags,
    mip_level: u32,
    base_array_layer: u32,
    layer_count: u32,
};
pub const ImageSubresourceRange = extern struct {
    aspect_mask: ImageAspectFlags,
    base_mip_level: u32,
    level_count: u32,
    base_array_layer: u32,
    layer_count: u32,
};
pub const MemoryBarrier = extern struct {
    s_type: StructureType = .memory_barrier,
    p_next: ?*const anyopaque = null,
    src_access_mask: AccessFlags = .{},
    dst_access_mask: AccessFlags = .{},
};
pub const BufferMemoryBarrier = extern struct {
    s_type: StructureType = .buffer_memory_barrier,
    p_next: ?*const anyopaque = null,
    src_access_mask: AccessFlags,
    dst_access_mask: AccessFlags,
    src_queue_family_index: u32,
    dst_queue_family_index: u32,
    buffer: Buffer,
    offset: DeviceSize,
    size: DeviceSize,
};
pub const ImageMemoryBarrier = extern struct {
    s_type: StructureType = .image_memory_barrier,
    p_next: ?*const anyopaque = null,
    src_access_mask: AccessFlags,
    dst_access_mask: AccessFlags,
    old_layout: ImageLayout,
    new_layout: ImageLayout,
    src_queue_family_index: u32,
    dst_queue_family_index: u32,
    image: Image,
    subresource_range: ImageSubresourceRange,
};
pub const ImageCreateInfo = extern struct {
    s_type: StructureType = .image_create_info,
    p_next: ?*const anyopaque = null,
    flags: ImageCreateFlags = .{},
    image_type: ImageType,
    format: Format,
    extent: Extent3D,
    mip_levels: u32,
    array_layers: u32,
    samples: SampleCountFlags,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    sharing_mode: SharingMode,
    queue_family_index_count: u32 = 0,
    p_queue_family_indices: ?[*]const u32 = null,
    initial_layout: ImageLayout,
};
pub const SubresourceLayout = extern struct {
    offset: DeviceSize,
    size: DeviceSize,
    row_pitch: DeviceSize,
    array_pitch: DeviceSize,
    depth_pitch: DeviceSize,
};
pub const ImageViewCreateInfo = extern struct {
    s_type: StructureType = .image_view_create_info,
    p_next: ?*const anyopaque = null,
    flags: ImageViewCreateFlags = .{},
    image: Image,
    view_type: ImageViewType,
    format: Format,
    components: ComponentMapping,
    subresource_range: ImageSubresourceRange,
};
pub const BufferCopy = extern struct {
    src_offset: DeviceSize,
    dst_offset: DeviceSize,
    size: DeviceSize,
};
pub const SparseMemoryBind = extern struct {
    resource_offset: DeviceSize,
    size: DeviceSize,
    memory: DeviceMemory = .null_handle,
    memory_offset: DeviceSize,
    flags: SparseMemoryBindFlags = .{},
};
pub const SparseImageMemoryBind = extern struct {
    subresource: ImageSubresource,
    offset: Offset3D,
    extent: Extent3D,
    memory: DeviceMemory = .null_handle,
    memory_offset: DeviceSize,
    flags: SparseMemoryBindFlags = .{},
};
pub const SparseBufferMemoryBindInfo = extern struct {
    buffer: Buffer,
    bind_count: u32,
    p_binds: [*]const SparseMemoryBind,
};
pub const SparseImageOpaqueMemoryBindInfo = extern struct {
    image: Image,
    bind_count: u32,
    p_binds: [*]const SparseMemoryBind,
};
pub const SparseImageMemoryBindInfo = extern struct {
    image: Image,
    bind_count: u32,
    p_binds: [*]const SparseImageMemoryBind,
};
pub const BindSparseInfo = extern struct {
    s_type: StructureType = .bind_sparse_info,
    p_next: ?*const anyopaque = null,
    wait_semaphore_count: u32 = 0,
    p_wait_semaphores: ?[*]const Semaphore = null,
    buffer_bind_count: u32 = 0,
    p_buffer_binds: ?[*]const SparseBufferMemoryBindInfo = null,
    image_opaque_bind_count: u32 = 0,
    p_image_opaque_binds: ?[*]const SparseImageOpaqueMemoryBindInfo = null,
    image_bind_count: u32 = 0,
    p_image_binds: ?[*]const SparseImageMemoryBindInfo = null,
    signal_semaphore_count: u32 = 0,
    p_signal_semaphores: ?[*]const Semaphore = null,
};
pub const ImageCopy = extern struct {
    src_subresource: ImageSubresourceLayers,
    src_offset: Offset3D,
    dst_subresource: ImageSubresourceLayers,
    dst_offset: Offset3D,
    extent: Extent3D,
};
pub const ImageBlit = extern struct {
    src_subresource: ImageSubresourceLayers,
    src_offsets: [2]Offset3D,
    dst_subresource: ImageSubresourceLayers,
    dst_offsets: [2]Offset3D,
};
pub const BufferImageCopy = extern struct {
    buffer_offset: DeviceSize,
    buffer_row_length: u32,
    buffer_image_height: u32,
    image_subresource: ImageSubresourceLayers,
    image_offset: Offset3D,
    image_extent: Extent3D,
};
pub const CopyMemoryIndirectCommandNV = extern struct {
    src_address: DeviceAddress,
    dst_address: DeviceAddress,
    size: DeviceSize,
};
pub const CopyMemoryToImageIndirectCommandNV = extern struct {
    src_address: DeviceAddress,
    buffer_row_length: u32,
    buffer_image_height: u32,
    image_subresource: ImageSubresourceLayers,
    image_offset: Offset3D,
    image_extent: Extent3D,
};
pub const ImageResolve = extern struct {
    src_subresource: ImageSubresourceLayers,
    src_offset: Offset3D,
    dst_subresource: ImageSubresourceLayers,
    dst_offset: Offset3D,
    extent: Extent3D,
};
pub const ShaderModuleCreateInfo = extern struct {
    s_type: StructureType = .shader_module_create_info,
    p_next: ?*const anyopaque = null,
    flags: ShaderModuleCreateFlags = .{},
    code_size: usize,
    p_code: [*]const u32,
};
pub const DescriptorSetLayoutBinding = extern struct {
    binding: u32,
    descriptor_type: DescriptorType,
    descriptor_count: u32 = 0,
    stage_flags: ShaderStageFlags,
    p_immutable_samplers: ?[*]const Sampler = null,
};
pub const DescriptorSetLayoutCreateInfo = extern struct {
    s_type: StructureType = .descriptor_set_layout_create_info,
    p_next: ?*const anyopaque = null,
    flags: DescriptorSetLayoutCreateFlags = .{},
    binding_count: u32 = 0,
    p_bindings: ?[*]const DescriptorSetLayoutBinding = null,
};
pub const DescriptorPoolSize = extern struct {
    type: DescriptorType,
    descriptor_count: u32,
};
pub const DescriptorPoolCreateInfo = extern struct {
    s_type: StructureType = .descriptor_pool_create_info,
    p_next: ?*const anyopaque = null,
    flags: DescriptorPoolCreateFlags = .{},
    max_sets: u32,
    pool_size_count: u32 = 0,
    p_pool_sizes: ?[*]const DescriptorPoolSize = null,
};
pub const DescriptorSetAllocateInfo = extern struct {
    s_type: StructureType = .descriptor_set_allocate_info,
    p_next: ?*const anyopaque = null,
    descriptor_pool: DescriptorPool,
    descriptor_set_count: u32,
    p_set_layouts: [*]const DescriptorSetLayout,
};
pub const SpecializationMapEntry = extern struct {
    constant_id: u32,
    offset: u32,
    size: usize,
};
pub const SpecializationInfo = extern struct {
    map_entry_count: u32 = 0,
    p_map_entries: ?[*]const SpecializationMapEntry = null,
    data_size: usize = 0,
    p_data: ?*const anyopaque = null,
};
pub const PipelineShaderStageCreateInfo = extern struct {
    s_type: StructureType = .pipeline_shader_stage_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineShaderStageCreateFlags = .{},
    stage: ShaderStageFlags,
    module: ShaderModule = .null_handle,
    p_name: [*:0]const u8,
    p_specialization_info: ?*const SpecializationInfo = null,
};
pub const ComputePipelineCreateInfo = extern struct {
    s_type: StructureType = .compute_pipeline_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineCreateFlags = .{},
    stage: PipelineShaderStageCreateInfo,
    layout: PipelineLayout,
    base_pipeline_handle: Pipeline = .null_handle,
    base_pipeline_index: i32,
};
pub const ComputePipelineIndirectBufferInfoNV = extern struct {
    s_type: StructureType = .compute_pipeline_indirect_buffer_info_nv,
    p_next: ?*const anyopaque = null,
    device_address: DeviceAddress,
    size: DeviceSize,
    pipeline_device_address_capture_replay: DeviceAddress,
};
pub const PipelineCreateFlags2CreateInfo = extern struct {
    s_type: StructureType = .pipeline_create_flags_2_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineCreateFlags2,
};
pub const PipelineCreateFlags2CreateInfoKHR = PipelineCreateFlags2CreateInfo;
pub const VertexInputBindingDescription = extern struct {
    binding: u32,
    stride: u32,
    input_rate: VertexInputRate,
};
pub const VertexInputAttributeDescription = extern struct {
    location: u32,
    binding: u32,
    format: Format,
    offset: u32,
};
pub const PipelineVertexInputStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_vertex_input_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineVertexInputStateCreateFlags = .{},
    vertex_binding_description_count: u32 = 0,
    p_vertex_binding_descriptions: ?[*]const VertexInputBindingDescription = null,
    vertex_attribute_description_count: u32 = 0,
    p_vertex_attribute_descriptions: ?[*]const VertexInputAttributeDescription = null,
};
pub const PipelineInputAssemblyStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_input_assembly_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineInputAssemblyStateCreateFlags = .{},
    topology: PrimitiveTopology,
    primitive_restart_enable: Bool32,
};
pub const PipelineTessellationStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_tessellation_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineTessellationStateCreateFlags = .{},
    patch_control_points: u32,
};
pub const PipelineViewportStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_viewport_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineViewportStateCreateFlags = .{},
    viewport_count: u32 = 0,
    p_viewports: ?[*]const Viewport = null,
    scissor_count: u32 = 0,
    p_scissors: ?[*]const Rect2D = null,
};
pub const PipelineRasterizationStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_rasterization_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineRasterizationStateCreateFlags = .{},
    depth_clamp_enable: Bool32,
    rasterizer_discard_enable: Bool32,
    polygon_mode: PolygonMode,
    cull_mode: CullModeFlags = .{},
    front_face: FrontFace,
    depth_bias_enable: Bool32,
    depth_bias_constant_factor: f32,
    depth_bias_clamp: f32,
    depth_bias_slope_factor: f32,
    line_width: f32,
};
pub const PipelineMultisampleStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_multisample_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineMultisampleStateCreateFlags = .{},
    rasterization_samples: SampleCountFlags,
    sample_shading_enable: Bool32,
    min_sample_shading: f32,
    p_sample_mask: ?[*]const SampleMask = null,
    alpha_to_coverage_enable: Bool32,
    alpha_to_one_enable: Bool32,
};
pub const PipelineColorBlendAttachmentState = extern struct {
    blend_enable: Bool32,
    src_color_blend_factor: BlendFactor,
    dst_color_blend_factor: BlendFactor,
    color_blend_op: BlendOp,
    src_alpha_blend_factor: BlendFactor,
    dst_alpha_blend_factor: BlendFactor,
    alpha_blend_op: BlendOp,
    color_write_mask: ColorComponentFlags = .{},
};
pub const PipelineColorBlendStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_color_blend_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineColorBlendStateCreateFlags = .{},
    logic_op_enable: Bool32,
    logic_op: LogicOp,
    attachment_count: u32 = 0,
    p_attachments: ?[*]const PipelineColorBlendAttachmentState = null,
    blend_constants: [4]f32,
};
pub const PipelineDynamicStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_dynamic_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineDynamicStateCreateFlags = .{},
    dynamic_state_count: u32 = 0,
    p_dynamic_states: ?[*]const DynamicState = null,
};
pub const StencilOpState = extern struct {
    fail_op: StencilOp,
    pass_op: StencilOp,
    depth_fail_op: StencilOp,
    compare_op: CompareOp,
    compare_mask: u32,
    write_mask: u32,
    reference: u32,
};
pub const PipelineDepthStencilStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_depth_stencil_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineDepthStencilStateCreateFlags = .{},
    depth_test_enable: Bool32,
    depth_write_enable: Bool32,
    depth_compare_op: CompareOp,
    depth_bounds_test_enable: Bool32,
    stencil_test_enable: Bool32,
    front: StencilOpState,
    back: StencilOpState,
    min_depth_bounds: f32,
    max_depth_bounds: f32,
};
pub const GraphicsPipelineCreateInfo = extern struct {
    s_type: StructureType = .graphics_pipeline_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineCreateFlags = .{},
    stage_count: u32 = 0,
    p_stages: ?[*]const PipelineShaderStageCreateInfo = null,
    p_vertex_input_state: ?*const PipelineVertexInputStateCreateInfo = null,
    p_input_assembly_state: ?*const PipelineInputAssemblyStateCreateInfo = null,
    p_tessellation_state: ?*const PipelineTessellationStateCreateInfo = null,
    p_viewport_state: ?*const PipelineViewportStateCreateInfo = null,
    p_rasterization_state: ?*const PipelineRasterizationStateCreateInfo = null,
    p_multisample_state: ?*const PipelineMultisampleStateCreateInfo = null,
    p_depth_stencil_state: ?*const PipelineDepthStencilStateCreateInfo = null,
    p_color_blend_state: ?*const PipelineColorBlendStateCreateInfo = null,
    p_dynamic_state: ?*const PipelineDynamicStateCreateInfo = null,
    layout: PipelineLayout = .null_handle,
    render_pass: RenderPass = .null_handle,
    subpass: u32,
    base_pipeline_handle: Pipeline = .null_handle,
    base_pipeline_index: i32,
};
pub const PipelineCacheCreateInfo = extern struct {
    s_type: StructureType = .pipeline_cache_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineCacheCreateFlags = .{},
    initial_data_size: usize = 0,
    p_initial_data: ?*const anyopaque = null,
};
pub const PipelineCacheHeaderVersionOne = extern struct {
    header_size: u32,
    header_version: PipelineCacheHeaderVersion,
    vendor_id: u32,
    device_id: u32,
    pipeline_cache_uuid: [UUID_SIZE]u8,
};
pub const PipelineCacheStageValidationIndexEntry = extern struct {
    code_size: u64,
    code_offset: u64,
};
pub const PipelineCacheSafetyCriticalIndexEntry = extern struct {
    pipeline_identifier: [UUID_SIZE]u8,
    pipeline_memory_size: u64,
    json_size: u64,
    json_offset: u64,
    stage_index_count: u32,
    stage_index_stride: u32,
    stage_index_offset: u64,
};
pub const PipelineCacheHeaderVersionSafetyCriticalOne = extern struct {
    header_version_one: PipelineCacheHeaderVersionOne,
    validation_version: PipelineCacheValidationVersion,
    implementation_data: u32,
    pipeline_index_count: u32,
    pipeline_index_stride: u32,
    pipeline_index_offset: u64,
};
pub const PushConstantRange = extern struct {
    stage_flags: ShaderStageFlags,
    offset: u32,
    size: u32,
};
pub const PipelineBinaryCreateInfoKHR = extern struct {
    s_type: StructureType = .pipeline_binary_create_info_khr,
    p_next: ?*const anyopaque = null,
    p_keys_and_data_info: ?*const PipelineBinaryKeysAndDataKHR = null,
    pipeline: Pipeline = .null_handle,
    p_pipeline_create_info: ?*const PipelineCreateInfoKHR = null,
};
pub const PipelineBinaryHandlesInfoKHR = extern struct {
    s_type: StructureType = .pipeline_binary_handles_info_khr,
    p_next: ?*const anyopaque = null,
    pipeline_binary_count: u32,
    p_pipeline_binaries: ?[*]PipelineBinaryKHR = null,
};
pub const PipelineBinaryDataKHR = extern struct {
    data_size: usize,
    p_data: *anyopaque,
};
pub const PipelineBinaryKeysAndDataKHR = extern struct {
    binary_count: u32,
    p_pipeline_binary_keys: [*]const PipelineBinaryKeyKHR,
    p_pipeline_binary_data: [*]const PipelineBinaryDataKHR,
};
pub const PipelineBinaryKeyKHR = extern struct {
    s_type: StructureType = .pipeline_binary_key_khr,
    p_next: ?*anyopaque = null,
    key_size: u32,
    key: [MAX_PIPELINE_BINARY_KEY_SIZE_KHR]u8,
};
pub const PipelineBinaryInfoKHR = extern struct {
    s_type: StructureType = .pipeline_binary_info_khr,
    p_next: ?*const anyopaque = null,
    binary_count: u32 = 0,
    p_pipeline_binaries: ?[*]const PipelineBinaryKHR = null,
};
pub const ReleaseCapturedPipelineDataInfoKHR = extern struct {
    s_type: StructureType = .release_captured_pipeline_data_info_khr,
    p_next: ?*anyopaque = null,
    pipeline: Pipeline,
};
pub const PipelineBinaryDataInfoKHR = extern struct {
    s_type: StructureType = .pipeline_binary_data_info_khr,
    p_next: ?*anyopaque = null,
    pipeline_binary: PipelineBinaryKHR,
};
pub const PipelineCreateInfoKHR = extern struct {
    s_type: StructureType = .pipeline_create_info_khr,
    p_next: ?*anyopaque = null,
};
pub const PipelineLayoutCreateInfo = extern struct {
    s_type: StructureType = .pipeline_layout_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineLayoutCreateFlags = .{},
    set_layout_count: u32 = 0,
    p_set_layouts: ?[*]const DescriptorSetLayout = null,
    push_constant_range_count: u32 = 0,
    p_push_constant_ranges: ?[*]const PushConstantRange = null,
};
pub const SamplerCreateInfo = extern struct {
    s_type: StructureType = .sampler_create_info,
    p_next: ?*const anyopaque = null,
    flags: SamplerCreateFlags = .{},
    mag_filter: Filter,
    min_filter: Filter,
    mipmap_mode: SamplerMipmapMode,
    address_mode_u: SamplerAddressMode,
    address_mode_v: SamplerAddressMode,
    address_mode_w: SamplerAddressMode,
    mip_lod_bias: f32,
    anisotropy_enable: Bool32,
    max_anisotropy: f32,
    compare_enable: Bool32,
    compare_op: CompareOp,
    min_lod: f32,
    max_lod: f32,
    border_color: BorderColor,
    unnormalized_coordinates: Bool32,
};
pub const CommandPoolCreateInfo = extern struct {
    s_type: StructureType = .command_pool_create_info,
    p_next: ?*const anyopaque = null,
    flags: CommandPoolCreateFlags = .{},
    queue_family_index: u32,
};
pub const CommandBufferAllocateInfo = extern struct {
    s_type: StructureType = .command_buffer_allocate_info,
    p_next: ?*const anyopaque = null,
    command_pool: CommandPool,
    level: CommandBufferLevel,
    command_buffer_count: u32,
};
pub const CommandBufferInheritanceInfo = extern struct {
    s_type: StructureType = .command_buffer_inheritance_info,
    p_next: ?*const anyopaque = null,
    render_pass: RenderPass = .null_handle,
    subpass: u32,
    framebuffer: Framebuffer = .null_handle,
    occlusion_query_enable: Bool32,
    query_flags: QueryControlFlags = .{},
    pipeline_statistics: QueryPipelineStatisticFlags = .{},
};
pub const CommandBufferBeginInfo = extern struct {
    s_type: StructureType = .command_buffer_begin_info,
    p_next: ?*const anyopaque = null,
    flags: CommandBufferUsageFlags = .{},
    p_inheritance_info: ?*const CommandBufferInheritanceInfo = null,
};
pub const RenderPassBeginInfo = extern struct {
    s_type: StructureType = .render_pass_begin_info,
    p_next: ?*const anyopaque = null,
    render_pass: RenderPass,
    framebuffer: Framebuffer,
    render_area: Rect2D,
    clear_value_count: u32 = 0,
    p_clear_values: ?[*]const ClearValue = null,
};
pub const ClearColorValue = extern union {
    float_32: [4]f32,
    int_32: [4]i32,
    uint_32: [4]u32,
};
pub const ClearDepthStencilValue = extern struct {
    depth: f32,
    stencil: u32,
};
pub const ClearValue = extern union {
    color: ClearColorValue,
    depth_stencil: ClearDepthStencilValue,
};
pub const ClearAttachment = extern struct {
    aspect_mask: ImageAspectFlags,
    color_attachment: u32,
    clear_value: ClearValue,
};
pub const AttachmentDescription = extern struct {
    flags: AttachmentDescriptionFlags = .{},
    format: Format,
    samples: SampleCountFlags,
    load_op: AttachmentLoadOp,
    store_op: AttachmentStoreOp,
    stencil_load_op: AttachmentLoadOp,
    stencil_store_op: AttachmentStoreOp,
    initial_layout: ImageLayout,
    final_layout: ImageLayout,
};
pub const AttachmentReference = extern struct {
    attachment: u32,
    layout: ImageLayout,
};
pub const SubpassDescription = extern struct {
    flags: SubpassDescriptionFlags = .{},
    pipeline_bind_point: PipelineBindPoint,
    input_attachment_count: u32 = 0,
    p_input_attachments: ?[*]const AttachmentReference = null,
    color_attachment_count: u32 = 0,
    p_color_attachments: ?[*]const AttachmentReference = null,
    p_resolve_attachments: ?[*]const AttachmentReference = null,
    p_depth_stencil_attachment: ?*const AttachmentReference = null,
    preserve_attachment_count: u32 = 0,
    p_preserve_attachments: ?[*]const u32 = null,
};
pub const SubpassDependency = extern struct {
    src_subpass: u32,
    dst_subpass: u32,
    src_stage_mask: PipelineStageFlags = .{},
    dst_stage_mask: PipelineStageFlags = .{},
    src_access_mask: AccessFlags = .{},
    dst_access_mask: AccessFlags = .{},
    dependency_flags: DependencyFlags = .{},
};
pub const RenderPassCreateInfo = extern struct {
    s_type: StructureType = .render_pass_create_info,
    p_next: ?*const anyopaque = null,
    flags: RenderPassCreateFlags = .{},
    attachment_count: u32 = 0,
    p_attachments: ?[*]const AttachmentDescription = null,
    subpass_count: u32,
    p_subpasses: [*]const SubpassDescription,
    dependency_count: u32 = 0,
    p_dependencies: ?[*]const SubpassDependency = null,
};
pub const EventCreateInfo = extern struct {
    s_type: StructureType = .event_create_info,
    p_next: ?*const anyopaque = null,
    flags: EventCreateFlags = .{},
};
pub const FenceCreateInfo = extern struct {
    s_type: StructureType = .fence_create_info,
    p_next: ?*const anyopaque = null,
    flags: FenceCreateFlags = .{},
};
pub const PhysicalDeviceFeatures = extern struct {
    robust_buffer_access: Bool32 = .false,
    full_draw_index_uint_32: Bool32 = .false,
    image_cube_array: Bool32 = .false,
    independent_blend: Bool32 = .false,
    geometry_shader: Bool32 = .false,
    tessellation_shader: Bool32 = .false,
    sample_rate_shading: Bool32 = .false,
    dual_src_blend: Bool32 = .false,
    logic_op: Bool32 = .false,
    multi_draw_indirect: Bool32 = .false,
    draw_indirect_first_instance: Bool32 = .false,
    depth_clamp: Bool32 = .false,
    depth_bias_clamp: Bool32 = .false,
    fill_mode_non_solid: Bool32 = .false,
    depth_bounds: Bool32 = .false,
    wide_lines: Bool32 = .false,
    large_points: Bool32 = .false,
    alpha_to_one: Bool32 = .false,
    multi_viewport: Bool32 = .false,
    sampler_anisotropy: Bool32 = .false,
    texture_compression_etc2: Bool32 = .false,
    texture_compression_astc_ldr: Bool32 = .false,
    texture_compression_bc: Bool32 = .false,
    occlusion_query_precise: Bool32 = .false,
    pipeline_statistics_query: Bool32 = .false,
    vertex_pipeline_stores_and_atomics: Bool32 = .false,
    fragment_stores_and_atomics: Bool32 = .false,
    shader_tessellation_and_geometry_point_size: Bool32 = .false,
    shader_image_gather_extended: Bool32 = .false,
    shader_storage_image_extended_formats: Bool32 = .false,
    shader_storage_image_multisample: Bool32 = .false,
    shader_storage_image_read_without_format: Bool32 = .false,
    shader_storage_image_write_without_format: Bool32 = .false,
    shader_uniform_buffer_array_dynamic_indexing: Bool32 = .false,
    shader_sampled_image_array_dynamic_indexing: Bool32 = .false,
    shader_storage_buffer_array_dynamic_indexing: Bool32 = .false,
    shader_storage_image_array_dynamic_indexing: Bool32 = .false,
    shader_clip_distance: Bool32 = .false,
    shader_cull_distance: Bool32 = .false,
    shader_float_64: Bool32 = .false,
    shader_int_64: Bool32 = .false,
    shader_int_16: Bool32 = .false,
    shader_resource_residency: Bool32 = .false,
    shader_resource_min_lod: Bool32 = .false,
    sparse_binding: Bool32 = .false,
    sparse_residency_buffer: Bool32 = .false,
    sparse_residency_image_2d: Bool32 = .false,
    sparse_residency_image_3d: Bool32 = .false,
    sparse_residency_2_samples: Bool32 = .false,
    sparse_residency_4_samples: Bool32 = .false,
    sparse_residency_8_samples: Bool32 = .false,
    sparse_residency_16_samples: Bool32 = .false,
    sparse_residency_aliased: Bool32 = .false,
    variable_multisample_rate: Bool32 = .false,
    inherited_queries: Bool32 = .false,
};
pub const PhysicalDeviceSparseProperties = extern struct {
    residency_standard_2d_block_shape: Bool32,
    residency_standard_2d_multisample_block_shape: Bool32,
    residency_standard_3d_block_shape: Bool32,
    residency_aligned_mip_size: Bool32,
    residency_non_resident_strict: Bool32,
};
pub const PhysicalDeviceLimits = extern struct {
    max_image_dimension_1d: u32,
    max_image_dimension_2d: u32,
    max_image_dimension_3d: u32,
    max_image_dimension_cube: u32,
    max_image_array_layers: u32,
    max_texel_buffer_elements: u32,
    max_uniform_buffer_range: u32,
    max_storage_buffer_range: u32,
    max_push_constants_size: u32,
    max_memory_allocation_count: u32,
    max_sampler_allocation_count: u32,
    buffer_image_granularity: DeviceSize,
    sparse_address_space_size: DeviceSize,
    max_bound_descriptor_sets: u32,
    max_per_stage_descriptor_samplers: u32,
    max_per_stage_descriptor_uniform_buffers: u32,
    max_per_stage_descriptor_storage_buffers: u32,
    max_per_stage_descriptor_sampled_images: u32,
    max_per_stage_descriptor_storage_images: u32,
    max_per_stage_descriptor_input_attachments: u32,
    max_per_stage_resources: u32,
    max_descriptor_set_samplers: u32,
    max_descriptor_set_uniform_buffers: u32,
    max_descriptor_set_uniform_buffers_dynamic: u32,
    max_descriptor_set_storage_buffers: u32,
    max_descriptor_set_storage_buffers_dynamic: u32,
    max_descriptor_set_sampled_images: u32,
    max_descriptor_set_storage_images: u32,
    max_descriptor_set_input_attachments: u32,
    max_vertex_input_attributes: u32,
    max_vertex_input_bindings: u32,
    max_vertex_input_attribute_offset: u32,
    max_vertex_input_binding_stride: u32,
    max_vertex_output_components: u32,
    max_tessellation_generation_level: u32,
    max_tessellation_patch_size: u32,
    max_tessellation_control_per_vertex_input_components: u32,
    max_tessellation_control_per_vertex_output_components: u32,
    max_tessellation_control_per_patch_output_components: u32,
    max_tessellation_control_total_output_components: u32,
    max_tessellation_evaluation_input_components: u32,
    max_tessellation_evaluation_output_components: u32,
    max_geometry_shader_invocations: u32,
    max_geometry_input_components: u32,
    max_geometry_output_components: u32,
    max_geometry_output_vertices: u32,
    max_geometry_total_output_components: u32,
    max_fragment_input_components: u32,
    max_fragment_output_attachments: u32,
    max_fragment_dual_src_attachments: u32,
    max_fragment_combined_output_resources: u32,
    max_compute_shared_memory_size: u32,
    max_compute_work_group_count: [3]u32,
    max_compute_work_group_invocations: u32,
    max_compute_work_group_size: [3]u32,
    sub_pixel_precision_bits: u32,
    sub_texel_precision_bits: u32,
    mipmap_precision_bits: u32,
    max_draw_indexed_index_value: u32,
    max_draw_indirect_count: u32,
    max_sampler_lod_bias: f32,
    max_sampler_anisotropy: f32,
    max_viewports: u32,
    max_viewport_dimensions: [2]u32,
    viewport_bounds_range: [2]f32,
    viewport_sub_pixel_bits: u32,
    min_memory_map_alignment: usize,
    min_texel_buffer_offset_alignment: DeviceSize,
    min_uniform_buffer_offset_alignment: DeviceSize,
    min_storage_buffer_offset_alignment: DeviceSize,
    min_texel_offset: i32,
    max_texel_offset: u32,
    min_texel_gather_offset: i32,
    max_texel_gather_offset: u32,
    min_interpolation_offset: f32,
    max_interpolation_offset: f32,
    sub_pixel_interpolation_offset_bits: u32,
    max_framebuffer_width: u32,
    max_framebuffer_height: u32,
    max_framebuffer_layers: u32,
    framebuffer_color_sample_counts: SampleCountFlags = .{},
    framebuffer_depth_sample_counts: SampleCountFlags = .{},
    framebuffer_stencil_sample_counts: SampleCountFlags = .{},
    framebuffer_no_attachments_sample_counts: SampleCountFlags = .{},
    max_color_attachments: u32,
    sampled_image_color_sample_counts: SampleCountFlags = .{},
    sampled_image_integer_sample_counts: SampleCountFlags = .{},
    sampled_image_depth_sample_counts: SampleCountFlags = .{},
    sampled_image_stencil_sample_counts: SampleCountFlags = .{},
    storage_image_sample_counts: SampleCountFlags = .{},
    max_sample_mask_words: u32,
    timestamp_compute_and_graphics: Bool32,
    timestamp_period: f32,
    max_clip_distances: u32,
    max_cull_distances: u32,
    max_combined_clip_and_cull_distances: u32,
    discrete_queue_priorities: u32,
    point_size_range: [2]f32,
    line_width_range: [2]f32,
    point_size_granularity: f32,
    line_width_granularity: f32,
    strict_lines: Bool32,
    standard_sample_locations: Bool32,
    optimal_buffer_copy_offset_alignment: DeviceSize,
    optimal_buffer_copy_row_pitch_alignment: DeviceSize,
    non_coherent_atom_size: DeviceSize,
};
pub const SemaphoreCreateInfo = extern struct {
    s_type: StructureType = .semaphore_create_info,
    p_next: ?*const anyopaque = null,
    flags: SemaphoreCreateFlags = .{},
};
pub const QueryPoolCreateInfo = extern struct {
    s_type: StructureType = .query_pool_create_info,
    p_next: ?*const anyopaque = null,
    flags: QueryPoolCreateFlags = .{},
    query_type: QueryType,
    query_count: u32,
    pipeline_statistics: QueryPipelineStatisticFlags = .{},
};
pub const FramebufferCreateInfo = extern struct {
    s_type: StructureType = .framebuffer_create_info,
    p_next: ?*const anyopaque = null,
    flags: FramebufferCreateFlags = .{},
    render_pass: RenderPass,
    attachment_count: u32 = 0,
    p_attachments: ?[*]const ImageView = null,
    width: u32,
    height: u32,
    layers: u32,
};
pub const DrawIndirectCommand = extern struct {
    vertex_count: u32,
    instance_count: u32,
    first_vertex: u32,
    first_instance: u32,
};
pub const DrawIndexedIndirectCommand = extern struct {
    index_count: u32,
    instance_count: u32,
    first_index: u32,
    vertex_offset: i32,
    first_instance: u32,
};
pub const DispatchIndirectCommand = extern struct {
    x: u32,
    y: u32,
    z: u32,
};
pub const MultiDrawInfoEXT = extern struct {
    first_vertex: u32,
    vertex_count: u32,
};
pub const MultiDrawIndexedInfoEXT = extern struct {
    first_index: u32,
    index_count: u32,
    vertex_offset: i32,
};
pub const SubmitInfo = extern struct {
    s_type: StructureType = .submit_info,
    p_next: ?*const anyopaque = null,
    wait_semaphore_count: u32 = 0,
    p_wait_semaphores: ?[*]const Semaphore = null,
    p_wait_dst_stage_mask: ?[*]const PipelineStageFlags = null,
    command_buffer_count: u32 = 0,
    p_command_buffers: ?[*]const CommandBuffer = null,
    signal_semaphore_count: u32 = 0,
    p_signal_semaphores: ?[*]const Semaphore = null,
};
pub const DisplayPropertiesKHR = extern struct {
    display: DisplayKHR,
    display_name: [*:0]const u8,
    physical_dimensions: Extent2D,
    physical_resolution: Extent2D,
    supported_transforms: SurfaceTransformFlagsKHR = .{},
    plane_reorder_possible: Bool32,
    persistent_content: Bool32,
};
pub const DisplayPlanePropertiesKHR = extern struct {
    current_display: DisplayKHR,
    current_stack_index: u32,
};
pub const DisplayModeParametersKHR = extern struct {
    visible_region: Extent2D,
    refresh_rate: u32,
};
pub const DisplayModePropertiesKHR = extern struct {
    display_mode: DisplayModeKHR,
    parameters: DisplayModeParametersKHR,
};
pub const DisplayModeCreateInfoKHR = extern struct {
    s_type: StructureType = .display_mode_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: DisplayModeCreateFlagsKHR = .{},
    parameters: DisplayModeParametersKHR,
};
pub const DisplayPlaneCapabilitiesKHR = extern struct {
    supported_alpha: DisplayPlaneAlphaFlagsKHR = .{},
    min_src_position: Offset2D,
    max_src_position: Offset2D,
    min_src_extent: Extent2D,
    max_src_extent: Extent2D,
    min_dst_position: Offset2D,
    max_dst_position: Offset2D,
    min_dst_extent: Extent2D,
    max_dst_extent: Extent2D,
};
pub const DisplaySurfaceCreateInfoKHR = extern struct {
    s_type: StructureType = .display_surface_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: DisplaySurfaceCreateFlagsKHR = .{},
    display_mode: DisplayModeKHR,
    plane_index: u32,
    plane_stack_index: u32,
    transform: SurfaceTransformFlagsKHR,
    global_alpha: f32,
    alpha_mode: DisplayPlaneAlphaFlagsKHR,
    image_extent: Extent2D,
};
pub const DisplaySurfaceStereoCreateInfoNV = extern struct {
    s_type: StructureType = .display_surface_stereo_create_info_nv,
    p_next: ?*const anyopaque = null,
    stereo_type: DisplaySurfaceStereoTypeNV,
};
pub const DisplayPresentInfoKHR = extern struct {
    s_type: StructureType = .display_present_info_khr,
    p_next: ?*const anyopaque = null,
    src_rect: Rect2D,
    dst_rect: Rect2D,
    persistent: Bool32,
};
pub const SurfaceCapabilitiesKHR = extern struct {
    min_image_count: u32,
    max_image_count: u32,
    current_extent: Extent2D,
    min_image_extent: Extent2D,
    max_image_extent: Extent2D,
    max_image_array_layers: u32,
    supported_transforms: SurfaceTransformFlagsKHR,
    current_transform: SurfaceTransformFlagsKHR,
    supported_composite_alpha: CompositeAlphaFlagsKHR,
    supported_usage_flags: ImageUsageFlags,
};
pub const AndroidSurfaceCreateInfoKHR = extern struct {
    s_type: StructureType = .android_surface_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: AndroidSurfaceCreateFlagsKHR = .{},
    window: *ANativeWindow,
};
pub const ViSurfaceCreateInfoNN = extern struct {
    s_type: StructureType = .vi_surface_create_info_nn,
    p_next: ?*const anyopaque = null,
    flags: ViSurfaceCreateFlagsNN = .{},
    window: *anyopaque,
};
pub const WaylandSurfaceCreateInfoKHR = extern struct {
    s_type: StructureType = .wayland_surface_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: WaylandSurfaceCreateFlagsKHR = .{},
    display: *wl_display,
    surface: *wl_surface,
};
pub const Win32SurfaceCreateInfoKHR = extern struct {
    s_type: StructureType = .win32_surface_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: Win32SurfaceCreateFlagsKHR = .{},
    hinstance: HINSTANCE,
    hwnd: HWND,
};
pub const XlibSurfaceCreateInfoKHR = extern struct {
    s_type: StructureType = .xlib_surface_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: XlibSurfaceCreateFlagsKHR = .{},
    dpy: *Display,
    window: Window,
};
pub const XcbSurfaceCreateInfoKHR = extern struct {
    s_type: StructureType = .xcb_surface_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: XcbSurfaceCreateFlagsKHR = .{},
    connection: *xcb_connection_t,
    window: xcb_window_t,
};
pub const DirectFBSurfaceCreateInfoEXT = extern struct {
    s_type: StructureType = .directfb_surface_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: DirectFBSurfaceCreateFlagsEXT = .{},
    dfb: *IDirectFB,
    surface: *IDirectFBSurface,
};
pub const ImagePipeSurfaceCreateInfoFUCHSIA = extern struct {
    s_type: StructureType = .imagepipe_surface_create_info_fuchsia,
    p_next: ?*const anyopaque = null,
    flags: ImagePipeSurfaceCreateFlagsFUCHSIA = .{},
    image_pipe_handle: zx_handle_t,
};
pub const StreamDescriptorSurfaceCreateInfoGGP = extern struct {
    s_type: StructureType = .stream_descriptor_surface_create_info_ggp,
    p_next: ?*const anyopaque = null,
    flags: StreamDescriptorSurfaceCreateFlagsGGP = .{},
    stream_descriptor: GgpStreamDescriptor,
};
pub const ScreenSurfaceCreateInfoQNX = extern struct {
    s_type: StructureType = .screen_surface_create_info_qnx,
    p_next: ?*const anyopaque = null,
    flags: ScreenSurfaceCreateFlagsQNX = .{},
    context: *_screen_context,
    window: *_screen_window,
};
pub const SurfaceFormatKHR = extern struct {
    format: Format,
    color_space: ColorSpaceKHR,
};
pub const SwapchainCreateInfoKHR = extern struct {
    s_type: StructureType = .swapchain_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: SwapchainCreateFlagsKHR = .{},
    surface: SurfaceKHR,
    min_image_count: u32,
    image_format: Format,
    image_color_space: ColorSpaceKHR,
    image_extent: Extent2D,
    image_array_layers: u32,
    image_usage: ImageUsageFlags,
    image_sharing_mode: SharingMode,
    queue_family_index_count: u32 = 0,
    p_queue_family_indices: ?[*]const u32 = null,
    pre_transform: SurfaceTransformFlagsKHR,
    composite_alpha: CompositeAlphaFlagsKHR,
    present_mode: PresentModeKHR,
    clipped: Bool32,
    old_swapchain: SwapchainKHR = .null_handle,
};
pub const PresentInfoKHR = extern struct {
    s_type: StructureType = .present_info_khr,
    p_next: ?*const anyopaque = null,
    wait_semaphore_count: u32 = 0,
    p_wait_semaphores: ?[*]const Semaphore = null,
    swapchain_count: u32,
    p_swapchains: [*]const SwapchainKHR,
    p_image_indices: [*]const u32,
    p_results: ?[*]Result = null,
};
pub const DebugReportCallbackCreateInfoEXT = extern struct {
    s_type: StructureType = .debug_report_callback_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: DebugReportFlagsEXT = .{},
    pfn_callback: PfnDebugReportCallbackEXT,
    p_user_data: ?*anyopaque = null,
};
pub const ValidationFlagsEXT = extern struct {
    s_type: StructureType = .validation_flags_ext,
    p_next: ?*const anyopaque = null,
    disabled_validation_check_count: u32,
    p_disabled_validation_checks: [*]const ValidationCheckEXT,
};
pub const ValidationFeaturesEXT = extern struct {
    s_type: StructureType = .validation_features_ext,
    p_next: ?*const anyopaque = null,
    enabled_validation_feature_count: u32 = 0,
    p_enabled_validation_features: ?[*]const ValidationFeatureEnableEXT = null,
    disabled_validation_feature_count: u32 = 0,
    p_disabled_validation_features: ?[*]const ValidationFeatureDisableEXT = null,
};
pub const LayerSettingsCreateInfoEXT = extern struct {
    s_type: StructureType = .layer_settings_create_info_ext,
    p_next: ?*const anyopaque = null,
    setting_count: u32 = 0,
    p_settings: ?[*]const LayerSettingEXT = null,
};
pub const LayerSettingEXT = extern struct {
    p_layer_name: [*:0]const u8,
    p_setting_name: [*:0]const u8,
    type: LayerSettingTypeEXT,
    value_count: u32 = 0,
    p_values: ?*const anyopaque = null,
};
pub const ApplicationParametersEXT = extern struct {
    s_type: StructureType = .application_parameters_ext,
    p_next: ?*const anyopaque = null,
    vendor_id: u32,
    device_id: u32 = 0,
    key: u32,
    value: u64,
};
pub const PipelineRasterizationStateRasterizationOrderAMD = extern struct {
    s_type: StructureType = .pipeline_rasterization_state_rasterization_order_amd,
    p_next: ?*const anyopaque = null,
    rasterization_order: RasterizationOrderAMD,
};
pub const DebugMarkerObjectNameInfoEXT = extern struct {
    s_type: StructureType = .debug_marker_object_name_info_ext,
    p_next: ?*const anyopaque = null,
    object_type: DebugReportObjectTypeEXT,
    object: u64,
    p_object_name: [*:0]const u8,
};
pub const DebugMarkerObjectTagInfoEXT = extern struct {
    s_type: StructureType = .debug_marker_object_tag_info_ext,
    p_next: ?*const anyopaque = null,
    object_type: DebugReportObjectTypeEXT,
    object: u64,
    tag_name: u64,
    tag_size: usize,
    p_tag: *const anyopaque,
};
pub const DebugMarkerMarkerInfoEXT = extern struct {
    s_type: StructureType = .debug_marker_marker_info_ext,
    p_next: ?*const anyopaque = null,
    p_marker_name: [*:0]const u8,
    color: [4]f32,
};
pub const DedicatedAllocationImageCreateInfoNV = extern struct {
    s_type: StructureType = .dedicated_allocation_image_create_info_nv,
    p_next: ?*const anyopaque = null,
    dedicated_allocation: Bool32,
};
pub const DedicatedAllocationBufferCreateInfoNV = extern struct {
    s_type: StructureType = .dedicated_allocation_buffer_create_info_nv,
    p_next: ?*const anyopaque = null,
    dedicated_allocation: Bool32,
};
pub const DedicatedAllocationMemoryAllocateInfoNV = extern struct {
    s_type: StructureType = .dedicated_allocation_memory_allocate_info_nv,
    p_next: ?*const anyopaque = null,
    image: Image = .null_handle,
    buffer: Buffer = .null_handle,
};
pub const ExternalImageFormatPropertiesNV = extern struct {
    image_format_properties: ImageFormatProperties,
    external_memory_features: ExternalMemoryFeatureFlagsNV = .{},
    export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsNV = .{},
    compatible_handle_types: ExternalMemoryHandleTypeFlagsNV = .{},
};
pub const ExternalMemoryImageCreateInfoNV = extern struct {
    s_type: StructureType = .external_memory_image_create_info_nv,
    p_next: ?*const anyopaque = null,
    handle_types: ExternalMemoryHandleTypeFlagsNV = .{},
};
pub const ExportMemoryAllocateInfoNV = extern struct {
    s_type: StructureType = .export_memory_allocate_info_nv,
    p_next: ?*const anyopaque = null,
    handle_types: ExternalMemoryHandleTypeFlagsNV = .{},
};
pub const ImportMemoryWin32HandleInfoNV = extern struct {
    s_type: StructureType = .import_memory_win32_handle_info_nv,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalMemoryHandleTypeFlagsNV = .{},
    handle: HANDLE,
};
pub const ExportMemoryWin32HandleInfoNV = extern struct {
    s_type: StructureType = .export_memory_win32_handle_info_nv,
    p_next: ?*const anyopaque = null,
    p_attributes: ?*const SECURITY_ATTRIBUTES = null,
    dw_access: DWORD,
};
pub const ExportMemorySciBufInfoNV = extern struct {
    s_type: StructureType = .export_memory_sci_buf_info_nv,
    p_next: ?*const anyopaque = null,
    p_attributes: NvSciBufAttrList,
};
pub const ImportMemorySciBufInfoNV = extern struct {
    s_type: StructureType = .import_memory_sci_buf_info_nv,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalMemoryHandleTypeFlags,
    handle: NvSciBufObj,
};
pub const MemoryGetSciBufInfoNV = extern struct {
    s_type: StructureType = .memory_get_sci_buf_info_nv,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory,
    handle_type: ExternalMemoryHandleTypeFlags,
};
pub const MemorySciBufPropertiesNV = extern struct {
    s_type: StructureType = .memory_sci_buf_properties_nv,
    p_next: ?*const anyopaque = null,
    memory_type_bits: u32,
};
pub const PhysicalDeviceExternalMemorySciBufFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_external_memory_sci_buf_features_nv,
    p_next: ?*anyopaque = null,
    sci_buf_import: Bool32 = .false,
    sci_buf_export: Bool32 = .false,
};
pub const PhysicalDeviceExternalSciBufFeaturesNV = PhysicalDeviceExternalMemorySciBufFeaturesNV;
pub const Win32KeyedMutexAcquireReleaseInfoNV = extern struct {
    s_type: StructureType = .win32_keyed_mutex_acquire_release_info_nv,
    p_next: ?*const anyopaque = null,
    acquire_count: u32 = 0,
    p_acquire_syncs: ?[*]const DeviceMemory = null,
    p_acquire_keys: ?[*]const u64 = null,
    p_acquire_timeout_milliseconds: ?[*]const u32 = null,
    release_count: u32 = 0,
    p_release_syncs: ?[*]const DeviceMemory = null,
    p_release_keys: ?[*]const u64 = null,
};
pub const PhysicalDeviceDeviceGeneratedCommandsFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_device_generated_commands_features_nv,
    p_next: ?*anyopaque = null,
    device_generated_commands: Bool32 = .false,
};
pub const PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_device_generated_commands_compute_features_nv,
    p_next: ?*anyopaque = null,
    device_generated_compute: Bool32 = .false,
    device_generated_compute_pipelines: Bool32 = .false,
    device_generated_compute_capture_replay: Bool32 = .false,
};
pub const DevicePrivateDataCreateInfo = extern struct {
    s_type: StructureType = .device_private_data_create_info,
    p_next: ?*const anyopaque = null,
    private_data_slot_request_count: u32,
};
pub const DevicePrivateDataCreateInfoEXT = DevicePrivateDataCreateInfo;
pub const PrivateDataSlotCreateInfo = extern struct {
    s_type: StructureType = .private_data_slot_create_info,
    p_next: ?*const anyopaque = null,
    flags: PrivateDataSlotCreateFlags,
};
pub const PrivateDataSlotCreateInfoEXT = PrivateDataSlotCreateInfo;
pub const PhysicalDevicePrivateDataFeatures = extern struct {
    s_type: StructureType = .physical_device_private_data_features,
    p_next: ?*anyopaque = null,
    private_data: Bool32 = .false,
};
pub const PhysicalDevicePrivateDataFeaturesEXT = PhysicalDevicePrivateDataFeatures;
pub const PhysicalDeviceDeviceGeneratedCommandsPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_device_generated_commands_properties_nv,
    p_next: ?*anyopaque = null,
    max_graphics_shader_group_count: u32,
    max_indirect_sequence_count: u32,
    max_indirect_commands_token_count: u32,
    max_indirect_commands_stream_count: u32,
    max_indirect_commands_token_offset: u32,
    max_indirect_commands_stream_stride: u32,
    min_sequences_count_buffer_offset_alignment: u32,
    min_sequences_index_buffer_offset_alignment: u32,
    min_indirect_commands_buffer_offset_alignment: u32,
};
pub const PhysicalDeviceClusterAccelerationStructureFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_cluster_acceleration_structure_features_nv,
    p_next: ?*anyopaque = null,
    cluster_acceleration_structure: Bool32 = .false,
};
pub const PhysicalDeviceClusterAccelerationStructurePropertiesNV = extern struct {
    s_type: StructureType = .physical_device_cluster_acceleration_structure_properties_nv,
    p_next: ?*anyopaque = null,
    max_vertices_per_cluster: u32,
    max_triangles_per_cluster: u32,
    cluster_scratch_byte_alignment: u32,
    cluster_byte_alignment: u32,
    cluster_template_byte_alignment: u32,
    cluster_bottom_level_byte_alignment: u32,
    cluster_template_bounds_byte_alignment: u32,
    max_cluster_geometry_index: u32,
};
pub const StridedDeviceAddressNV = extern struct {
    start_address: DeviceAddress,
    stride_in_bytes: DeviceSize,
};
pub const RayTracingPipelineClusterAccelerationStructureCreateInfoNV = extern struct {
    s_type: StructureType = .ray_tracing_pipeline_cluster_acceleration_structure_create_info_nv,
    p_next: ?*anyopaque = null,
    allow_cluster_acceleration_structure: Bool32,
};
pub const ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV = packed struct(u32) {
    geometry_index: u24,
    reserved: u5 = 0,
    geometry_flags: u3,
};
pub const ClusterAccelerationStructureMoveObjectsInfoNV = extern struct {
    src_acceleration_structure: DeviceAddress,
};
pub const ClusterAccelerationStructureBuildClustersBottomLevelInfoNV = extern struct {
    cluster_references_count: u32,
    cluster_references_stride: u32,
    cluster_references: DeviceAddress,
};
pub const ClusterAccelerationStructureGetTemplateIndicesInfoNV = extern struct {
    cluster_template_address: DeviceAddress,
};
pub const ClusterAccelerationStructureBuildTriangleClusterInfoNV = extern struct {
    cluster_id: u32,
    cluster_flags: ClusterAccelerationStructureClusterFlagsNV,
    cluster_data: packed struct(u32) {
        triangle_count: u9,
        vertex_count: u9,
        position_truncate_bit_count: u6,
        index_type: u4,
        opacity_micromap_index_type: u4,
    },
    base_geometry_index_and_geometry_flags: ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV,
    index_buffer_stride: u16,
    vertex_buffer_stride: u16,
    geometry_index_and_flags_buffer_stride: u16,
    opacity_micromap_index_buffer_stride: u16,
    index_buffer: DeviceAddress,
    vertex_buffer: DeviceAddress,
    geometry_index_and_flags_buffer: DeviceAddress,
    opacity_micromap_array: DeviceAddress,
    opacity_micromap_index_buffer: DeviceAddress,
};
pub const ClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV = extern struct {
    cluster_id: u32,
    cluster_flags: ClusterAccelerationStructureClusterFlagsNV,
    cluster_data: packed struct(u32) {
        triangle_count: u9,
        vertex_count: u9,
        position_truncate_bit_count: u6,
        index_type: u4,
        opacity_micromap_index_type: u4,
    },
    base_geometry_index_and_geometry_flags: ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV,
    index_buffer_stride: u16,
    vertex_buffer_stride: u16,
    geometry_index_and_flags_buffer_stride: u16,
    opacity_micromap_index_buffer_stride: u16,
    index_buffer: DeviceAddress,
    vertex_buffer: DeviceAddress,
    geometry_index_and_flags_buffer: DeviceAddress,
    opacity_micromap_array: DeviceAddress,
    opacity_micromap_index_buffer: DeviceAddress,
    instantiation_bounding_box_limit: DeviceAddress,
};
pub const ClusterAccelerationStructureInstantiateClusterInfoNV = extern struct {
    cluster_id_offset: u32,
    geometry_index_offset: packed struct(u32) {
        offset: u24,
        reserved: u8 = 0,
    },
    cluster_template_address: DeviceAddress,
    vertex_buffer: StridedDeviceAddressNV,
};
pub const ClusterAccelerationStructureClustersBottomLevelInputNV = extern struct {
    s_type: StructureType = .cluster_acceleration_structure_clusters_bottom_level_input_nv,
    p_next: ?*anyopaque = null,
    max_total_cluster_count: u32,
    max_cluster_count_per_acceleration_structure: u32,
};
pub const ClusterAccelerationStructureTriangleClusterInputNV = extern struct {
    s_type: StructureType = .cluster_acceleration_structure_triangle_cluster_input_nv,
    p_next: ?*anyopaque = null,
    vertex_format: Format,
    max_geometry_index_value: u32,
    max_cluster_unique_geometry_count: u32,
    max_cluster_triangle_count: u32,
    max_cluster_vertex_count: u32,
    max_total_triangle_count: u32,
    max_total_vertex_count: u32,
    min_position_truncate_bit_count: u32,
};
pub const ClusterAccelerationStructureMoveObjectsInputNV = extern struct {
    s_type: StructureType = .cluster_acceleration_structure_move_objects_input_nv,
    p_next: ?*anyopaque = null,
    type: ClusterAccelerationStructureTypeNV,
    no_move_overlap: Bool32,
    max_moved_bytes: DeviceSize,
};
pub const ClusterAccelerationStructureOpInputNV = extern union {
    p_clusters_bottom_level: *ClusterAccelerationStructureClustersBottomLevelInputNV,
    p_triangle_clusters: *ClusterAccelerationStructureTriangleClusterInputNV,
    p_move_objects: *ClusterAccelerationStructureMoveObjectsInputNV,
};
pub const ClusterAccelerationStructureInputInfoNV = extern struct {
    s_type: StructureType = .cluster_acceleration_structure_input_info_nv,
    p_next: ?*anyopaque = null,
    max_acceleration_structure_count: u32,
    flags: BuildAccelerationStructureFlagsKHR = .{},
    op_type: ClusterAccelerationStructureOpTypeNV,
    op_mode: ClusterAccelerationStructureOpModeNV,
    op_input: ClusterAccelerationStructureOpInputNV,
};
pub const ClusterAccelerationStructureCommandsInfoNV = extern struct {
    s_type: StructureType = .cluster_acceleration_structure_commands_info_nv,
    p_next: ?*anyopaque = null,
    input: ClusterAccelerationStructureInputInfoNV,
    dst_implicit_data: DeviceAddress,
    scratch_data: DeviceAddress,
    dst_addresses_array: StridedDeviceAddressRegionKHR,
    dst_sizes_array: StridedDeviceAddressRegionKHR,
    src_infos_array: StridedDeviceAddressRegionKHR,
    src_infos_count: DeviceAddress,
    address_resolution_flags: ClusterAccelerationStructureAddressResolutionFlagsNV = .{},
};
pub const PhysicalDeviceMultiDrawPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_multi_draw_properties_ext,
    p_next: ?*anyopaque = null,
    max_multi_draw_count: u32,
};
pub const GraphicsShaderGroupCreateInfoNV = extern struct {
    s_type: StructureType = .graphics_shader_group_create_info_nv,
    p_next: ?*const anyopaque = null,
    stage_count: u32,
    p_stages: [*]const PipelineShaderStageCreateInfo,
    p_vertex_input_state: ?*const PipelineVertexInputStateCreateInfo = null,
    p_tessellation_state: ?*const PipelineTessellationStateCreateInfo = null,
};
pub const GraphicsPipelineShaderGroupsCreateInfoNV = extern struct {
    s_type: StructureType = .graphics_pipeline_shader_groups_create_info_nv,
    p_next: ?*const anyopaque = null,
    group_count: u32 = 0,
    p_groups: ?[*]const GraphicsShaderGroupCreateInfoNV = null,
    pipeline_count: u32 = 0,
    p_pipelines: ?[*]const Pipeline = null,
};
pub const BindShaderGroupIndirectCommandNV = extern struct {
    group_index: u32,
};
pub const BindIndexBufferIndirectCommandNV = extern struct {
    buffer_address: DeviceAddress,
    size: u32,
    index_type: IndexType,
};
pub const BindVertexBufferIndirectCommandNV = extern struct {
    buffer_address: DeviceAddress,
    size: u32,
    stride: u32,
};
pub const SetStateFlagsIndirectCommandNV = extern struct {
    data: u32,
};
pub const IndirectCommandsStreamNV = extern struct {
    buffer: Buffer,
    offset: DeviceSize,
};
pub const IndirectCommandsLayoutTokenNV = extern struct {
    s_type: StructureType = .indirect_commands_layout_token_nv,
    p_next: ?*const anyopaque = null,
    token_type: IndirectCommandsTokenTypeNV,
    stream: u32,
    offset: u32,
    vertex_binding_unit: u32,
    vertex_dynamic_stride: Bool32,
    pushconstant_pipeline_layout: PipelineLayout = .null_handle,
    pushconstant_shader_stage_flags: ShaderStageFlags = .{},
    pushconstant_offset: u32,
    pushconstant_size: u32,
    indirect_state_flags: IndirectStateFlagsNV = .{},
    index_type_count: u32 = 0,
    p_index_types: ?[*]const IndexType = null,
    p_index_type_values: ?[*]const u32 = null,
};
pub const IndirectCommandsLayoutCreateInfoNV = extern struct {
    s_type: StructureType = .indirect_commands_layout_create_info_nv,
    p_next: ?*const anyopaque = null,
    flags: IndirectCommandsLayoutUsageFlagsNV = .{},
    pipeline_bind_point: PipelineBindPoint,
    token_count: u32,
    p_tokens: [*]const IndirectCommandsLayoutTokenNV,
    stream_count: u32,
    p_stream_strides: [*]const u32,
};
pub const GeneratedCommandsInfoNV = extern struct {
    s_type: StructureType = .generated_commands_info_nv,
    p_next: ?*const anyopaque = null,
    pipeline_bind_point: PipelineBindPoint,
    pipeline: Pipeline = .null_handle,
    indirect_commands_layout: IndirectCommandsLayoutNV,
    stream_count: u32,
    p_streams: [*]const IndirectCommandsStreamNV,
    sequences_count: u32,
    preprocess_buffer: Buffer,
    preprocess_offset: DeviceSize,
    preprocess_size: DeviceSize,
    sequences_count_buffer: Buffer = .null_handle,
    sequences_count_offset: DeviceSize,
    sequences_index_buffer: Buffer = .null_handle,
    sequences_index_offset: DeviceSize,
};
pub const GeneratedCommandsMemoryRequirementsInfoNV = extern struct {
    s_type: StructureType = .generated_commands_memory_requirements_info_nv,
    p_next: ?*const anyopaque = null,
    pipeline_bind_point: PipelineBindPoint,
    pipeline: Pipeline = .null_handle,
    indirect_commands_layout: IndirectCommandsLayoutNV,
    max_sequences_count: u32,
};
pub const PipelineIndirectDeviceAddressInfoNV = extern struct {
    s_type: StructureType = .pipeline_indirect_device_address_info_nv,
    p_next: ?*const anyopaque = null,
    pipeline_bind_point: PipelineBindPoint,
    pipeline: Pipeline,
};
pub const BindPipelineIndirectCommandNV = extern struct {
    pipeline_address: DeviceAddress,
};
pub const PhysicalDeviceFeatures2 = extern struct {
    s_type: StructureType = .physical_device_features_2,
    p_next: ?*anyopaque = null,
    features: PhysicalDeviceFeatures,
};
pub const PhysicalDeviceFeatures2KHR = PhysicalDeviceFeatures2;
pub const PhysicalDeviceProperties2 = extern struct {
    s_type: StructureType = .physical_device_properties_2,
    p_next: ?*anyopaque = null,
    properties: PhysicalDeviceProperties,
};
pub const PhysicalDeviceProperties2KHR = PhysicalDeviceProperties2;
pub const FormatProperties2 = extern struct {
    s_type: StructureType = .format_properties_2,
    p_next: ?*anyopaque = null,
    format_properties: FormatProperties,
};
pub const FormatProperties2KHR = FormatProperties2;
pub const ImageFormatProperties2 = extern struct {
    s_type: StructureType = .image_format_properties_2,
    p_next: ?*anyopaque = null,
    image_format_properties: ImageFormatProperties,
};
pub const ImageFormatProperties2KHR = ImageFormatProperties2;
pub const PhysicalDeviceImageFormatInfo2 = extern struct {
    s_type: StructureType = .physical_device_image_format_info_2,
    p_next: ?*const anyopaque = null,
    format: Format,
    type: ImageType,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    flags: ImageCreateFlags = .{},
};
pub const PhysicalDeviceImageFormatInfo2KHR = PhysicalDeviceImageFormatInfo2;
pub const QueueFamilyProperties2 = extern struct {
    s_type: StructureType = .queue_family_properties_2,
    p_next: ?*anyopaque = null,
    queue_family_properties: QueueFamilyProperties,
};
pub const QueueFamilyProperties2KHR = QueueFamilyProperties2;
pub const PhysicalDeviceMemoryProperties2 = extern struct {
    s_type: StructureType = .physical_device_memory_properties_2,
    p_next: ?*anyopaque = null,
    memory_properties: PhysicalDeviceMemoryProperties,
};
pub const PhysicalDeviceMemoryProperties2KHR = PhysicalDeviceMemoryProperties2;
pub const SparseImageFormatProperties2 = extern struct {
    s_type: StructureType = .sparse_image_format_properties_2,
    p_next: ?*anyopaque = null,
    properties: SparseImageFormatProperties,
};
pub const SparseImageFormatProperties2KHR = SparseImageFormatProperties2;
pub const PhysicalDeviceSparseImageFormatInfo2 = extern struct {
    s_type: StructureType = .physical_device_sparse_image_format_info_2,
    p_next: ?*const anyopaque = null,
    format: Format,
    type: ImageType,
    samples: SampleCountFlags,
    usage: ImageUsageFlags,
    tiling: ImageTiling,
};
pub const PhysicalDeviceSparseImageFormatInfo2KHR = PhysicalDeviceSparseImageFormatInfo2;
pub const PhysicalDevicePushDescriptorProperties = extern struct {
    s_type: StructureType = .physical_device_push_descriptor_properties,
    p_next: ?*anyopaque = null,
    max_push_descriptors: u32,
};
pub const PhysicalDevicePushDescriptorPropertiesKHR = PhysicalDevicePushDescriptorProperties;
pub const ConformanceVersion = extern struct {
    major: u8,
    minor: u8,
    subminor: u8,
    patch: u8,
};
pub const ConformanceVersionKHR = ConformanceVersion;
pub const PhysicalDeviceDriverProperties = extern struct {
    s_type: StructureType = .physical_device_driver_properties,
    p_next: ?*anyopaque = null,
    driver_id: DriverId,
    driver_name: [MAX_DRIVER_NAME_SIZE]u8,
    driver_info: [MAX_DRIVER_INFO_SIZE]u8,
    conformance_version: ConformanceVersion,
};
pub const PhysicalDeviceDriverPropertiesKHR = PhysicalDeviceDriverProperties;
pub const PresentRegionsKHR = extern struct {
    s_type: StructureType = .present_regions_khr,
    p_next: ?*const anyopaque = null,
    swapchain_count: u32,
    p_regions: ?[*]const PresentRegionKHR = null,
};
pub const PresentRegionKHR = extern struct {
    rectangle_count: u32 = 0,
    p_rectangles: ?[*]const RectLayerKHR = null,
};
pub const RectLayerKHR = extern struct {
    offset: Offset2D,
    extent: Extent2D,
    layer: u32,
};
pub const PhysicalDeviceVariablePointersFeatures = extern struct {
    s_type: StructureType = .physical_device_variable_pointers_features,
    p_next: ?*anyopaque = null,
    variable_pointers_storage_buffer: Bool32 = .false,
    variable_pointers: Bool32 = .false,
};
pub const PhysicalDeviceVariablePointersFeaturesKHR = PhysicalDeviceVariablePointersFeatures;
pub const PhysicalDeviceVariablePointerFeaturesKHR = PhysicalDeviceVariablePointersFeatures;
pub const PhysicalDeviceVariablePointerFeatures = PhysicalDeviceVariablePointersFeatures;
pub const ExternalMemoryProperties = extern struct {
    external_memory_features: ExternalMemoryFeatureFlags,
    export_from_imported_handle_types: ExternalMemoryHandleTypeFlags = .{},
    compatible_handle_types: ExternalMemoryHandleTypeFlags,
};
pub const ExternalMemoryPropertiesKHR = ExternalMemoryProperties;
pub const PhysicalDeviceExternalImageFormatInfo = extern struct {
    s_type: StructureType = .physical_device_external_image_format_info,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalMemoryHandleTypeFlags,
};
pub const PhysicalDeviceExternalImageFormatInfoKHR = PhysicalDeviceExternalImageFormatInfo;
pub const ExternalImageFormatProperties = extern struct {
    s_type: StructureType = .external_image_format_properties,
    p_next: ?*anyopaque = null,
    external_memory_properties: ExternalMemoryProperties,
};
pub const ExternalImageFormatPropertiesKHR = ExternalImageFormatProperties;
pub const PhysicalDeviceExternalBufferInfo = extern struct {
    s_type: StructureType = .physical_device_external_buffer_info,
    p_next: ?*const anyopaque = null,
    flags: BufferCreateFlags = .{},
    usage: BufferUsageFlags = .{},
    handle_type: ExternalMemoryHandleTypeFlags,
};
pub const PhysicalDeviceExternalBufferInfoKHR = PhysicalDeviceExternalBufferInfo;
pub const ExternalBufferProperties = extern struct {
    s_type: StructureType = .external_buffer_properties,
    p_next: ?*anyopaque = null,
    external_memory_properties: ExternalMemoryProperties,
};
pub const ExternalBufferPropertiesKHR = ExternalBufferProperties;
pub const PhysicalDeviceIDProperties = extern struct {
    s_type: StructureType = .physical_device_id_properties,
    p_next: ?*anyopaque = null,
    device_uuid: [UUID_SIZE]u8,
    driver_uuid: [UUID_SIZE]u8,
    device_luid: [LUID_SIZE]u8,
    device_node_mask: u32,
    device_luid_valid: Bool32,
};
pub const PhysicalDeviceIDPropertiesKHR = PhysicalDeviceIDProperties;
pub const ExternalMemoryImageCreateInfo = extern struct {
    s_type: StructureType = .external_memory_image_create_info,
    p_next: ?*const anyopaque = null,
    handle_types: ExternalMemoryHandleTypeFlags = .{},
};
pub const ExternalMemoryImageCreateInfoKHR = ExternalMemoryImageCreateInfo;
pub const ExternalMemoryBufferCreateInfo = extern struct {
    s_type: StructureType = .external_memory_buffer_create_info,
    p_next: ?*const anyopaque = null,
    handle_types: ExternalMemoryHandleTypeFlags = .{},
};
pub const ExternalMemoryBufferCreateInfoKHR = ExternalMemoryBufferCreateInfo;
pub const ExportMemoryAllocateInfo = extern struct {
    s_type: StructureType = .export_memory_allocate_info,
    p_next: ?*const anyopaque = null,
    handle_types: ExternalMemoryHandleTypeFlags = .{},
};
pub const ExportMemoryAllocateInfoKHR = ExportMemoryAllocateInfo;
pub const ImportMemoryWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .import_memory_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalMemoryHandleTypeFlags,
    handle: HANDLE,
    name: LPCWSTR,
};
pub const ExportMemoryWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .export_memory_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    p_attributes: ?*const SECURITY_ATTRIBUTES = null,
    dw_access: DWORD,
    name: LPCWSTR,
};
pub const ImportMemoryZirconHandleInfoFUCHSIA = extern struct {
    s_type: StructureType = .import_memory_zircon_handle_info_fuchsia,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalMemoryHandleTypeFlags,
    handle: zx_handle_t,
};
pub const MemoryZirconHandlePropertiesFUCHSIA = extern struct {
    s_type: StructureType = .memory_zircon_handle_properties_fuchsia,
    p_next: ?*anyopaque = null,
    memory_type_bits: u32,
};
pub const MemoryGetZirconHandleInfoFUCHSIA = extern struct {
    s_type: StructureType = .memory_get_zircon_handle_info_fuchsia,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory,
    handle_type: ExternalMemoryHandleTypeFlags,
};
pub const MemoryWin32HandlePropertiesKHR = extern struct {
    s_type: StructureType = .memory_win32_handle_properties_khr,
    p_next: ?*anyopaque = null,
    memory_type_bits: u32,
};
pub const MemoryGetWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .memory_get_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory,
    handle_type: ExternalMemoryHandleTypeFlags,
};
pub const ImportMemoryFdInfoKHR = extern struct {
    s_type: StructureType = .import_memory_fd_info_khr,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalMemoryHandleTypeFlags,
    fd: c_int,
};
pub const MemoryFdPropertiesKHR = extern struct {
    s_type: StructureType = .memory_fd_properties_khr,
    p_next: ?*anyopaque = null,
    memory_type_bits: u32,
};
pub const MemoryGetFdInfoKHR = extern struct {
    s_type: StructureType = .memory_get_fd_info_khr,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory,
    handle_type: ExternalMemoryHandleTypeFlags,
};
pub const Win32KeyedMutexAcquireReleaseInfoKHR = extern struct {
    s_type: StructureType = .win32_keyed_mutex_acquire_release_info_khr,
    p_next: ?*const anyopaque = null,
    acquire_count: u32 = 0,
    p_acquire_syncs: ?[*]const DeviceMemory = null,
    p_acquire_keys: ?[*]const u64 = null,
    p_acquire_timeouts: ?[*]const u32 = null,
    release_count: u32 = 0,
    p_release_syncs: ?[*]const DeviceMemory = null,
    p_release_keys: ?[*]const u64 = null,
};
pub const ImportMemoryMetalHandleInfoEXT = extern struct {
    s_type: StructureType = .import_memory_metal_handle_info_ext,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalMemoryHandleTypeFlags,
    handle: ?*anyopaque = null,
};
pub const MemoryMetalHandlePropertiesEXT = extern struct {
    s_type: StructureType = .memory_metal_handle_properties_ext,
    p_next: ?*anyopaque = null,
    memory_type_bits: u32,
};
pub const MemoryGetMetalHandleInfoEXT = extern struct {
    s_type: StructureType = .memory_get_metal_handle_info_ext,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory,
    handle_type: ExternalMemoryHandleTypeFlags,
};
pub const PhysicalDeviceExternalSemaphoreInfo = extern struct {
    s_type: StructureType = .physical_device_external_semaphore_info,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalSemaphoreHandleTypeFlags,
};
pub const PhysicalDeviceExternalSemaphoreInfoKHR = PhysicalDeviceExternalSemaphoreInfo;
pub const ExternalSemaphoreProperties = extern struct {
    s_type: StructureType = .external_semaphore_properties,
    p_next: ?*anyopaque = null,
    export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlags,
    compatible_handle_types: ExternalSemaphoreHandleTypeFlags,
    external_semaphore_features: ExternalSemaphoreFeatureFlags = .{},
};
pub const ExternalSemaphorePropertiesKHR = ExternalSemaphoreProperties;
pub const ExportSemaphoreCreateInfo = extern struct {
    s_type: StructureType = .export_semaphore_create_info,
    p_next: ?*const anyopaque = null,
    handle_types: ExternalSemaphoreHandleTypeFlags = .{},
};
pub const ExportSemaphoreCreateInfoKHR = ExportSemaphoreCreateInfo;
pub const ImportSemaphoreWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .import_semaphore_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore,
    flags: SemaphoreImportFlags = .{},
    handle_type: ExternalSemaphoreHandleTypeFlags,
    handle: HANDLE,
    name: LPCWSTR,
};
pub const ExportSemaphoreWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .export_semaphore_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    p_attributes: ?*const SECURITY_ATTRIBUTES = null,
    dw_access: DWORD,
    name: LPCWSTR,
};
pub const D3D12FenceSubmitInfoKHR = extern struct {
    s_type: StructureType = .d3d12_fence_submit_info_khr,
    p_next: ?*const anyopaque = null,
    wait_semaphore_values_count: u32 = 0,
    p_wait_semaphore_values: ?[*]const u64 = null,
    signal_semaphore_values_count: u32 = 0,
    p_signal_semaphore_values: ?[*]const u64 = null,
};
pub const SemaphoreGetWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .semaphore_get_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore,
    handle_type: ExternalSemaphoreHandleTypeFlags,
};
pub const ImportSemaphoreFdInfoKHR = extern struct {
    s_type: StructureType = .import_semaphore_fd_info_khr,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore,
    flags: SemaphoreImportFlags = .{},
    handle_type: ExternalSemaphoreHandleTypeFlags,
    fd: c_int,
};
pub const SemaphoreGetFdInfoKHR = extern struct {
    s_type: StructureType = .semaphore_get_fd_info_khr,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore,
    handle_type: ExternalSemaphoreHandleTypeFlags,
};
pub const ImportSemaphoreZirconHandleInfoFUCHSIA = extern struct {
    s_type: StructureType = .import_semaphore_zircon_handle_info_fuchsia,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore,
    flags: SemaphoreImportFlags = .{},
    handle_type: ExternalSemaphoreHandleTypeFlags,
    zircon_handle: zx_handle_t,
};
pub const SemaphoreGetZirconHandleInfoFUCHSIA = extern struct {
    s_type: StructureType = .semaphore_get_zircon_handle_info_fuchsia,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore,
    handle_type: ExternalSemaphoreHandleTypeFlags,
};
pub const PhysicalDeviceExternalFenceInfo = extern struct {
    s_type: StructureType = .physical_device_external_fence_info,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalFenceHandleTypeFlags,
};
pub const PhysicalDeviceExternalFenceInfoKHR = PhysicalDeviceExternalFenceInfo;
pub const ExternalFenceProperties = extern struct {
    s_type: StructureType = .external_fence_properties,
    p_next: ?*anyopaque = null,
    export_from_imported_handle_types: ExternalFenceHandleTypeFlags,
    compatible_handle_types: ExternalFenceHandleTypeFlags,
    external_fence_features: ExternalFenceFeatureFlags = .{},
};
pub const ExternalFencePropertiesKHR = ExternalFenceProperties;
pub const ExportFenceCreateInfo = extern struct {
    s_type: StructureType = .export_fence_create_info,
    p_next: ?*const anyopaque = null,
    handle_types: ExternalFenceHandleTypeFlags = .{},
};
pub const ExportFenceCreateInfoKHR = ExportFenceCreateInfo;
pub const ImportFenceWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .import_fence_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    fence: Fence,
    flags: FenceImportFlags = .{},
    handle_type: ExternalFenceHandleTypeFlags,
    handle: HANDLE,
    name: LPCWSTR,
};
pub const ExportFenceWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .export_fence_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    p_attributes: ?*const SECURITY_ATTRIBUTES = null,
    dw_access: DWORD,
    name: LPCWSTR,
};
pub const FenceGetWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .fence_get_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    fence: Fence,
    handle_type: ExternalFenceHandleTypeFlags,
};
pub const ImportFenceFdInfoKHR = extern struct {
    s_type: StructureType = .import_fence_fd_info_khr,
    p_next: ?*const anyopaque = null,
    fence: Fence,
    flags: FenceImportFlags = .{},
    handle_type: ExternalFenceHandleTypeFlags,
    fd: c_int,
};
pub const FenceGetFdInfoKHR = extern struct {
    s_type: StructureType = .fence_get_fd_info_khr,
    p_next: ?*const anyopaque = null,
    fence: Fence,
    handle_type: ExternalFenceHandleTypeFlags,
};
pub const ExportFenceSciSyncInfoNV = extern struct {
    s_type: StructureType = .export_fence_sci_sync_info_nv,
    p_next: ?*const anyopaque = null,
    p_attributes: NvSciSyncAttrList,
};
pub const ImportFenceSciSyncInfoNV = extern struct {
    s_type: StructureType = .import_fence_sci_sync_info_nv,
    p_next: ?*const anyopaque = null,
    fence: Fence,
    handle_type: ExternalFenceHandleTypeFlags,
    handle: *anyopaque,
};
pub const FenceGetSciSyncInfoNV = extern struct {
    s_type: StructureType = .fence_get_sci_sync_info_nv,
    p_next: ?*const anyopaque = null,
    fence: Fence,
    handle_type: ExternalFenceHandleTypeFlags,
};
pub const ExportSemaphoreSciSyncInfoNV = extern struct {
    s_type: StructureType = .export_semaphore_sci_sync_info_nv,
    p_next: ?*const anyopaque = null,
    p_attributes: NvSciSyncAttrList,
};
pub const ImportSemaphoreSciSyncInfoNV = extern struct {
    s_type: StructureType = .import_semaphore_sci_sync_info_nv,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore,
    handle_type: ExternalSemaphoreHandleTypeFlags,
    handle: *anyopaque,
};
pub const SemaphoreGetSciSyncInfoNV = extern struct {
    s_type: StructureType = .semaphore_get_sci_sync_info_nv,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore,
    handle_type: ExternalSemaphoreHandleTypeFlags,
};
pub const SciSyncAttributesInfoNV = extern struct {
    s_type: StructureType = .sci_sync_attributes_info_nv,
    p_next: ?*const anyopaque = null,
    client_type: SciSyncClientTypeNV,
    primitive_type: SciSyncPrimitiveTypeNV,
};
pub const PhysicalDeviceExternalSciSyncFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_external_sci_sync_features_nv,
    p_next: ?*anyopaque = null,
    sci_sync_fence: Bool32 = .false,
    sci_sync_semaphore: Bool32 = .false,
    sci_sync_import: Bool32 = .false,
    sci_sync_export: Bool32 = .false,
};
pub const PhysicalDeviceExternalSciSync2FeaturesNV = extern struct {
    s_type: StructureType = .physical_device_external_sci_sync_2_features_nv,
    p_next: ?*anyopaque = null,
    sci_sync_fence: Bool32 = .false,
    sci_sync_semaphore_2: Bool32 = .false,
    sci_sync_import: Bool32 = .false,
    sci_sync_export: Bool32 = .false,
};
pub const SemaphoreSciSyncPoolCreateInfoNV = extern struct {
    s_type: StructureType = .semaphore_sci_sync_pool_create_info_nv,
    p_next: ?*const anyopaque = null,
    handle: NvSciSyncObj,
};
pub const SemaphoreSciSyncCreateInfoNV = extern struct {
    s_type: StructureType = .semaphore_sci_sync_create_info_nv,
    p_next: ?*const anyopaque = null,
    semaphore_pool: SemaphoreSciSyncPoolNV,
    p_fence: *const NvSciSyncFence,
};
pub const DeviceSemaphoreSciSyncPoolReservationCreateInfoNV = extern struct {
    s_type: StructureType,
    p_next: ?*const anyopaque = null,
    semaphore_sci_sync_pool_request_count: u32,
};
pub const PhysicalDeviceMultiviewFeatures = extern struct {
    s_type: StructureType = .physical_device_multiview_features,
    p_next: ?*anyopaque = null,
    multiview: Bool32 = .false,
    multiview_geometry_shader: Bool32 = .false,
    multiview_tessellation_shader: Bool32 = .false,
};
pub const PhysicalDeviceMultiviewFeaturesKHR = PhysicalDeviceMultiviewFeatures;
pub const PhysicalDeviceMultiviewProperties = extern struct {
    s_type: StructureType = .physical_device_multiview_properties,
    p_next: ?*anyopaque = null,
    max_multiview_view_count: u32,
    max_multiview_instance_index: u32,
};
pub const PhysicalDeviceMultiviewPropertiesKHR = PhysicalDeviceMultiviewProperties;
pub const RenderPassMultiviewCreateInfo = extern struct {
    s_type: StructureType = .render_pass_multiview_create_info,
    p_next: ?*const anyopaque = null,
    subpass_count: u32 = 0,
    p_view_masks: ?[*]const u32 = null,
    dependency_count: u32 = 0,
    p_view_offsets: ?[*]const i32 = null,
    correlation_mask_count: u32 = 0,
    p_correlation_masks: ?[*]const u32 = null,
};
pub const RenderPassMultiviewCreateInfoKHR = RenderPassMultiviewCreateInfo;
pub const SurfaceCapabilities2EXT = extern struct {
    s_type: StructureType = .surface_capabilities_2_ext,
    p_next: ?*anyopaque = null,
    min_image_count: u32,
    max_image_count: u32,
    current_extent: Extent2D,
    min_image_extent: Extent2D,
    max_image_extent: Extent2D,
    max_image_array_layers: u32,
    supported_transforms: SurfaceTransformFlagsKHR,
    current_transform: SurfaceTransformFlagsKHR,
    supported_composite_alpha: CompositeAlphaFlagsKHR,
    supported_usage_flags: ImageUsageFlags,
    supported_surface_counters: SurfaceCounterFlagsEXT = .{},
};
pub const DisplayPowerInfoEXT = extern struct {
    s_type: StructureType = .display_power_info_ext,
    p_next: ?*const anyopaque = null,
    power_state: DisplayPowerStateEXT,
};
pub const DeviceEventInfoEXT = extern struct {
    s_type: StructureType = .device_event_info_ext,
    p_next: ?*const anyopaque = null,
    device_event: DeviceEventTypeEXT,
};
pub const DisplayEventInfoEXT = extern struct {
    s_type: StructureType = .display_event_info_ext,
    p_next: ?*const anyopaque = null,
    display_event: DisplayEventTypeEXT,
};
pub const SwapchainCounterCreateInfoEXT = extern struct {
    s_type: StructureType = .swapchain_counter_create_info_ext,
    p_next: ?*const anyopaque = null,
    surface_counters: SurfaceCounterFlagsEXT = .{},
};
pub const PhysicalDeviceGroupProperties = extern struct {
    s_type: StructureType = .physical_device_group_properties,
    p_next: ?*anyopaque = null,
    physical_device_count: u32,
    physical_devices: [MAX_DEVICE_GROUP_SIZE]PhysicalDevice,
    subset_allocation: Bool32,
};
pub const PhysicalDeviceGroupPropertiesKHR = PhysicalDeviceGroupProperties;
pub const MemoryAllocateFlagsInfo = extern struct {
    s_type: StructureType = .memory_allocate_flags_info,
    p_next: ?*const anyopaque = null,
    flags: MemoryAllocateFlags = .{},
    device_mask: u32,
};
pub const MemoryAllocateFlagsInfoKHR = MemoryAllocateFlagsInfo;
pub const BindBufferMemoryInfo = extern struct {
    s_type: StructureType = .bind_buffer_memory_info,
    p_next: ?*const anyopaque = null,
    buffer: Buffer,
    memory: DeviceMemory,
    memory_offset: DeviceSize,
};
pub const BindBufferMemoryInfoKHR = BindBufferMemoryInfo;
pub const BindBufferMemoryDeviceGroupInfo = extern struct {
    s_type: StructureType = .bind_buffer_memory_device_group_info,
    p_next: ?*const anyopaque = null,
    device_index_count: u32 = 0,
    p_device_indices: ?[*]const u32 = null,
};
pub const BindBufferMemoryDeviceGroupInfoKHR = BindBufferMemoryDeviceGroupInfo;
pub const BindImageMemoryInfo = extern struct {
    s_type: StructureType = .bind_image_memory_info,
    p_next: ?*const anyopaque = null,
    image: Image,
    memory: DeviceMemory,
    memory_offset: DeviceSize,
};
pub const BindImageMemoryInfoKHR = BindImageMemoryInfo;
pub const BindImageMemoryDeviceGroupInfo = extern struct {
    s_type: StructureType = .bind_image_memory_device_group_info,
    p_next: ?*const anyopaque = null,
    device_index_count: u32 = 0,
    p_device_indices: ?[*]const u32 = null,
    split_instance_bind_region_count: u32 = 0,
    p_split_instance_bind_regions: ?[*]const Rect2D = null,
};
pub const BindImageMemoryDeviceGroupInfoKHR = BindImageMemoryDeviceGroupInfo;
pub const DeviceGroupRenderPassBeginInfo = extern struct {
    s_type: StructureType = .device_group_render_pass_begin_info,
    p_next: ?*const anyopaque = null,
    device_mask: u32,
    device_render_area_count: u32 = 0,
    p_device_render_areas: ?[*]const Rect2D = null,
};
pub const DeviceGroupRenderPassBeginInfoKHR = DeviceGroupRenderPassBeginInfo;
pub const DeviceGroupCommandBufferBeginInfo = extern struct {
    s_type: StructureType = .device_group_command_buffer_begin_info,
    p_next: ?*const anyopaque = null,
    device_mask: u32,
};
pub const DeviceGroupCommandBufferBeginInfoKHR = DeviceGroupCommandBufferBeginInfo;
pub const DeviceGroupSubmitInfo = extern struct {
    s_type: StructureType = .device_group_submit_info,
    p_next: ?*const anyopaque = null,
    wait_semaphore_count: u32 = 0,
    p_wait_semaphore_device_indices: ?[*]const u32 = null,
    command_buffer_count: u32 = 0,
    p_command_buffer_device_masks: ?[*]const u32 = null,
    signal_semaphore_count: u32 = 0,
    p_signal_semaphore_device_indices: ?[*]const u32 = null,
};
pub const DeviceGroupSubmitInfoKHR = DeviceGroupSubmitInfo;
pub const DeviceGroupBindSparseInfo = extern struct {
    s_type: StructureType = .device_group_bind_sparse_info,
    p_next: ?*const anyopaque = null,
    resource_device_index: u32,
    memory_device_index: u32,
};
pub const DeviceGroupBindSparseInfoKHR = DeviceGroupBindSparseInfo;
pub const DeviceGroupPresentCapabilitiesKHR = extern struct {
    s_type: StructureType = .device_group_present_capabilities_khr,
    p_next: ?*anyopaque = null,
    present_mask: [MAX_DEVICE_GROUP_SIZE]u32,
    modes: DeviceGroupPresentModeFlagsKHR,
};
pub const ImageSwapchainCreateInfoKHR = extern struct {
    s_type: StructureType = .image_swapchain_create_info_khr,
    p_next: ?*const anyopaque = null,
    swapchain: SwapchainKHR = .null_handle,
};
pub const BindImageMemorySwapchainInfoKHR = extern struct {
    s_type: StructureType = .bind_image_memory_swapchain_info_khr,
    p_next: ?*const anyopaque = null,
    swapchain: SwapchainKHR,
    image_index: u32,
};
pub const AcquireNextImageInfoKHR = extern struct {
    s_type: StructureType = .acquire_next_image_info_khr,
    p_next: ?*const anyopaque = null,
    swapchain: SwapchainKHR,
    timeout: u64,
    semaphore: Semaphore = .null_handle,
    fence: Fence = .null_handle,
    device_mask: u32,
};
pub const DeviceGroupPresentInfoKHR = extern struct {
    s_type: StructureType = .device_group_present_info_khr,
    p_next: ?*const anyopaque = null,
    swapchain_count: u32 = 0,
    p_device_masks: ?[*]const u32 = null,
    mode: DeviceGroupPresentModeFlagsKHR,
};
pub const DeviceGroupDeviceCreateInfo = extern struct {
    s_type: StructureType = .device_group_device_create_info,
    p_next: ?*const anyopaque = null,
    physical_device_count: u32 = 0,
    p_physical_devices: ?[*]const PhysicalDevice = null,
};
pub const DeviceGroupDeviceCreateInfoKHR = DeviceGroupDeviceCreateInfo;
pub const DeviceGroupSwapchainCreateInfoKHR = extern struct {
    s_type: StructureType = .device_group_swapchain_create_info_khr,
    p_next: ?*const anyopaque = null,
    modes: DeviceGroupPresentModeFlagsKHR,
};
pub const DescriptorUpdateTemplateEntry = extern struct {
    dst_binding: u32,
    dst_array_element: u32,
    descriptor_count: u32,
    descriptor_type: DescriptorType,
    offset: usize,
    stride: usize,
};
pub const DescriptorUpdateTemplateEntryKHR = DescriptorUpdateTemplateEntry;
pub const DescriptorUpdateTemplateCreateInfo = extern struct {
    s_type: StructureType = .descriptor_update_template_create_info,
    p_next: ?*const anyopaque = null,
    flags: DescriptorUpdateTemplateCreateFlags = .{},
    descriptor_update_entry_count: u32,
    p_descriptor_update_entries: [*]const DescriptorUpdateTemplateEntry,
    template_type: DescriptorUpdateTemplateType,
    descriptor_set_layout: DescriptorSetLayout,
    pipeline_bind_point: PipelineBindPoint,
    pipeline_layout: PipelineLayout,
    set: u32,
};
pub const DescriptorUpdateTemplateCreateInfoKHR = DescriptorUpdateTemplateCreateInfo;
pub const XYColorEXT = extern struct {
    x: f32,
    y: f32,
};
pub const PhysicalDevicePresentIdFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_present_id_features_khr,
    p_next: ?*anyopaque = null,
    present_id: Bool32 = .false,
};
pub const PresentIdKHR = extern struct {
    s_type: StructureType = .present_id_khr,
    p_next: ?*const anyopaque = null,
    swapchain_count: u32,
    p_present_ids: ?[*]const u64 = null,
};
pub const PhysicalDevicePresentId2FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_present_id_2_features_khr,
    p_next: ?*anyopaque = null,
    present_id_2: Bool32 = .false,
};
pub const PresentId2KHR = extern struct {
    s_type: StructureType = .present_id_2_khr,
    p_next: ?*const anyopaque = null,
    swapchain_count: u32,
    p_present_ids: ?[*]const u64 = null,
};
pub const PresentWait2InfoKHR = extern struct {
    s_type: StructureType = .present_wait_2_info_khr,
    p_next: ?*const anyopaque = null,
    present_id: u64,
    timeout: u64,
};
pub const PhysicalDevicePresentWaitFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_present_wait_features_khr,
    p_next: ?*anyopaque = null,
    present_wait: Bool32 = .false,
};
pub const PhysicalDevicePresentWait2FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_present_wait_2_features_khr,
    p_next: ?*anyopaque = null,
    present_wait_2: Bool32 = .false,
};
pub const HdrMetadataEXT = extern struct {
    s_type: StructureType = .hdr_metadata_ext,
    p_next: ?*const anyopaque = null,
    display_primary_red: XYColorEXT,
    display_primary_green: XYColorEXT,
    display_primary_blue: XYColorEXT,
    white_point: XYColorEXT,
    max_luminance: f32,
    min_luminance: f32,
    max_content_light_level: f32,
    max_frame_average_light_level: f32,
};
pub const HdrVividDynamicMetadataHUAWEI = extern struct {
    s_type: StructureType = .hdr_vivid_dynamic_metadata_huawei,
    p_next: ?*const anyopaque = null,
    dynamic_metadata_size: usize,
    p_dynamic_metadata: *const anyopaque,
};
pub const DisplayNativeHdrSurfaceCapabilitiesAMD = extern struct {
    s_type: StructureType = .display_native_hdr_surface_capabilities_amd,
    p_next: ?*anyopaque = null,
    local_dimming_support: Bool32,
};
pub const SwapchainDisplayNativeHdrCreateInfoAMD = extern struct {
    s_type: StructureType = .swapchain_display_native_hdr_create_info_amd,
    p_next: ?*const anyopaque = null,
    local_dimming_enable: Bool32,
};
pub const RefreshCycleDurationGOOGLE = extern struct {
    refresh_duration: u64,
};
pub const PastPresentationTimingGOOGLE = extern struct {
    present_id: u32,
    desired_present_time: u64,
    actual_present_time: u64,
    earliest_present_time: u64,
    present_margin: u64,
};
pub const PresentTimesInfoGOOGLE = extern struct {
    s_type: StructureType = .present_times_info_google,
    p_next: ?*const anyopaque = null,
    swapchain_count: u32,
    p_times: ?[*]const PresentTimeGOOGLE = null,
};
pub const PresentTimeGOOGLE = extern struct {
    present_id: u32,
    desired_present_time: u64,
};
pub const IOSSurfaceCreateInfoMVK = extern struct {
    s_type: StructureType = .ios_surface_create_info_mvk,
    p_next: ?*const anyopaque = null,
    flags: IOSSurfaceCreateFlagsMVK = .{},
    p_view: *const anyopaque,
};
pub const MacOSSurfaceCreateInfoMVK = extern struct {
    s_type: StructureType = .macos_surface_create_info_mvk,
    p_next: ?*const anyopaque = null,
    flags: MacOSSurfaceCreateFlagsMVK = .{},
    p_view: *const anyopaque,
};
pub const MetalSurfaceCreateInfoEXT = extern struct {
    s_type: StructureType = .metal_surface_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: MetalSurfaceCreateFlagsEXT = .{},
    p_layer: *const CAMetalLayer,
};
pub const ViewportWScalingNV = extern struct {
    xcoeff: f32,
    ycoeff: f32,
};
pub const PipelineViewportWScalingStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_viewport_w_scaling_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    viewport_w_scaling_enable: Bool32,
    viewport_count: u32,
    p_viewport_w_scalings: ?[*]const ViewportWScalingNV = null,
};
pub const ViewportSwizzleNV = extern struct {
    x: ViewportCoordinateSwizzleNV,
    y: ViewportCoordinateSwizzleNV,
    z: ViewportCoordinateSwizzleNV,
    w: ViewportCoordinateSwizzleNV,
};
pub const PipelineViewportSwizzleStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_viewport_swizzle_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    flags: PipelineViewportSwizzleStateCreateFlagsNV = .{},
    viewport_count: u32,
    p_viewport_swizzles: [*]const ViewportSwizzleNV,
};
pub const PhysicalDeviceDiscardRectanglePropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_discard_rectangle_properties_ext,
    p_next: ?*anyopaque = null,
    max_discard_rectangles: u32,
};
pub const PipelineDiscardRectangleStateCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_discard_rectangle_state_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: PipelineDiscardRectangleStateCreateFlagsEXT = .{},
    discard_rectangle_mode: DiscardRectangleModeEXT,
    discard_rectangle_count: u32 = 0,
    p_discard_rectangles: ?[*]const Rect2D = null,
};
pub const PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = extern struct {
    s_type: StructureType = .physical_device_multiview_per_view_attributes_properties_nvx,
    p_next: ?*anyopaque = null,
    per_view_position_all_components: Bool32,
};
pub const InputAttachmentAspectReference = extern struct {
    subpass: u32,
    input_attachment_index: u32,
    aspect_mask: ImageAspectFlags,
};
pub const InputAttachmentAspectReferenceKHR = InputAttachmentAspectReference;
pub const RenderPassInputAttachmentAspectCreateInfo = extern struct {
    s_type: StructureType = .render_pass_input_attachment_aspect_create_info,
    p_next: ?*const anyopaque = null,
    aspect_reference_count: u32,
    p_aspect_references: [*]const InputAttachmentAspectReference,
};
pub const RenderPassInputAttachmentAspectCreateInfoKHR = RenderPassInputAttachmentAspectCreateInfo;
pub const PhysicalDeviceSurfaceInfo2KHR = extern struct {
    s_type: StructureType = .physical_device_surface_info_2_khr,
    p_next: ?*const anyopaque = null,
    surface: SurfaceKHR = .null_handle,
};
pub const SurfaceCapabilities2KHR = extern struct {
    s_type: StructureType = .surface_capabilities_2_khr,
    p_next: ?*anyopaque = null,
    surface_capabilities: SurfaceCapabilitiesKHR,
};
pub const SurfaceFormat2KHR = extern struct {
    s_type: StructureType = .surface_format_2_khr,
    p_next: ?*anyopaque = null,
    surface_format: SurfaceFormatKHR,
};
pub const DisplayProperties2KHR = extern struct {
    s_type: StructureType = .display_properties_2_khr,
    p_next: ?*anyopaque = null,
    display_properties: DisplayPropertiesKHR,
};
pub const DisplayPlaneProperties2KHR = extern struct {
    s_type: StructureType = .display_plane_properties_2_khr,
    p_next: ?*anyopaque = null,
    display_plane_properties: DisplayPlanePropertiesKHR,
};
pub const DisplayModeProperties2KHR = extern struct {
    s_type: StructureType = .display_mode_properties_2_khr,
    p_next: ?*anyopaque = null,
    display_mode_properties: DisplayModePropertiesKHR,
};
pub const DisplayModeStereoPropertiesNV = extern struct {
    s_type: StructureType = .display_mode_stereo_properties_nv,
    p_next: ?*const anyopaque = null,
    hdmi_3d_supported: Bool32,
};
pub const DisplayPlaneInfo2KHR = extern struct {
    s_type: StructureType = .display_plane_info_2_khr,
    p_next: ?*const anyopaque = null,
    mode: DisplayModeKHR,
    plane_index: u32,
};
pub const DisplayPlaneCapabilities2KHR = extern struct {
    s_type: StructureType = .display_plane_capabilities_2_khr,
    p_next: ?*anyopaque = null,
    capabilities: DisplayPlaneCapabilitiesKHR,
};
pub const SharedPresentSurfaceCapabilitiesKHR = extern struct {
    s_type: StructureType = .shared_present_surface_capabilities_khr,
    p_next: ?*anyopaque = null,
    shared_present_supported_usage_flags: ImageUsageFlags = .{},
};
pub const PhysicalDevice16BitStorageFeatures = extern struct {
    s_type: StructureType = .physical_device_16bit_storage_features,
    p_next: ?*anyopaque = null,
    storage_buffer_16_bit_access: Bool32 = .false,
    uniform_and_storage_buffer_16_bit_access: Bool32 = .false,
    storage_push_constant_16: Bool32 = .false,
    storage_input_output_16: Bool32 = .false,
};
pub const PhysicalDevice16BitStorageFeaturesKHR = PhysicalDevice16BitStorageFeatures;
pub const PhysicalDeviceSubgroupProperties = extern struct {
    s_type: StructureType = .physical_device_subgroup_properties,
    p_next: ?*anyopaque = null,
    subgroup_size: u32,
    supported_stages: ShaderStageFlags,
    supported_operations: SubgroupFeatureFlags,
    quad_operations_in_all_stages: Bool32,
};
pub const PhysicalDeviceShaderSubgroupExtendedTypesFeatures = extern struct {
    s_type: StructureType = .physical_device_shader_subgroup_extended_types_features,
    p_next: ?*anyopaque = null,
    shader_subgroup_extended_types: Bool32 = .false,
};
pub const PhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = PhysicalDeviceShaderSubgroupExtendedTypesFeatures;
pub const BufferMemoryRequirementsInfo2 = extern struct {
    s_type: StructureType = .buffer_memory_requirements_info_2,
    p_next: ?*const anyopaque = null,
    buffer: Buffer,
};
pub const BufferMemoryRequirementsInfo2KHR = BufferMemoryRequirementsInfo2;
pub const DeviceBufferMemoryRequirements = extern struct {
    s_type: StructureType = .device_buffer_memory_requirements,
    p_next: ?*const anyopaque = null,
    p_create_info: *const BufferCreateInfo,
};
pub const DeviceBufferMemoryRequirementsKHR = DeviceBufferMemoryRequirements;
pub const ImageMemoryRequirementsInfo2 = extern struct {
    s_type: StructureType = .image_memory_requirements_info_2,
    p_next: ?*const anyopaque = null,
    image: Image,
};
pub const ImageMemoryRequirementsInfo2KHR = ImageMemoryRequirementsInfo2;
pub const ImageSparseMemoryRequirementsInfo2 = extern struct {
    s_type: StructureType = .image_sparse_memory_requirements_info_2,
    p_next: ?*const anyopaque = null,
    image: Image,
};
pub const ImageSparseMemoryRequirementsInfo2KHR = ImageSparseMemoryRequirementsInfo2;
pub const DeviceImageMemoryRequirements = extern struct {
    s_type: StructureType = .device_image_memory_requirements,
    p_next: ?*const anyopaque = null,
    p_create_info: *const ImageCreateInfo,
    plane_aspect: ImageAspectFlags,
};
pub const DeviceImageMemoryRequirementsKHR = DeviceImageMemoryRequirements;
pub const MemoryRequirements2 = extern struct {
    s_type: StructureType = .memory_requirements_2,
    p_next: ?*anyopaque = null,
    memory_requirements: MemoryRequirements,
};
pub const MemoryRequirements2KHR = MemoryRequirements2;
pub const SparseImageMemoryRequirements2 = extern struct {
    s_type: StructureType = .sparse_image_memory_requirements_2,
    p_next: ?*anyopaque = null,
    memory_requirements: SparseImageMemoryRequirements,
};
pub const SparseImageMemoryRequirements2KHR = SparseImageMemoryRequirements2;
pub const PhysicalDevicePointClippingProperties = extern struct {
    s_type: StructureType = .physical_device_point_clipping_properties,
    p_next: ?*anyopaque = null,
    point_clipping_behavior: PointClippingBehavior,
};
pub const PhysicalDevicePointClippingPropertiesKHR = PhysicalDevicePointClippingProperties;
pub const MemoryDedicatedRequirements = extern struct {
    s_type: StructureType = .memory_dedicated_requirements,
    p_next: ?*anyopaque = null,
    prefers_dedicated_allocation: Bool32,
    requires_dedicated_allocation: Bool32,
};
pub const MemoryDedicatedRequirementsKHR = MemoryDedicatedRequirements;
pub const MemoryDedicatedAllocateInfo = extern struct {
    s_type: StructureType = .memory_dedicated_allocate_info,
    p_next: ?*const anyopaque = null,
    image: Image = .null_handle,
    buffer: Buffer = .null_handle,
};
pub const MemoryDedicatedAllocateInfoKHR = MemoryDedicatedAllocateInfo;
pub const ImageViewUsageCreateInfo = extern struct {
    s_type: StructureType = .image_view_usage_create_info,
    p_next: ?*const anyopaque = null,
    usage: ImageUsageFlags,
};
pub const ImageViewSlicedCreateInfoEXT = extern struct {
    s_type: StructureType = .image_view_sliced_create_info_ext,
    p_next: ?*const anyopaque = null,
    slice_offset: u32,
    slice_count: u32,
};
pub const ImageViewUsageCreateInfoKHR = ImageViewUsageCreateInfo;
pub const PipelineTessellationDomainOriginStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_tessellation_domain_origin_state_create_info,
    p_next: ?*const anyopaque = null,
    domain_origin: TessellationDomainOrigin,
};
pub const PipelineTessellationDomainOriginStateCreateInfoKHR = PipelineTessellationDomainOriginStateCreateInfo;
pub const SamplerYcbcrConversionInfo = extern struct {
    s_type: StructureType = .sampler_ycbcr_conversion_info,
    p_next: ?*const anyopaque = null,
    conversion: SamplerYcbcrConversion,
};
pub const SamplerYcbcrConversionInfoKHR = SamplerYcbcrConversionInfo;
pub const SamplerYcbcrConversionCreateInfo = extern struct {
    s_type: StructureType = .sampler_ycbcr_conversion_create_info,
    p_next: ?*const anyopaque = null,
    format: Format,
    ycbcr_model: SamplerYcbcrModelConversion,
    ycbcr_range: SamplerYcbcrRange,
    components: ComponentMapping,
    x_chroma_offset: ChromaLocation,
    y_chroma_offset: ChromaLocation,
    chroma_filter: Filter,
    force_explicit_reconstruction: Bool32,
};
pub const SamplerYcbcrConversionCreateInfoKHR = SamplerYcbcrConversionCreateInfo;
pub const BindImagePlaneMemoryInfo = extern struct {
    s_type: StructureType = .bind_image_plane_memory_info,
    p_next: ?*const anyopaque = null,
    plane_aspect: ImageAspectFlags,
};
pub const BindImagePlaneMemoryInfoKHR = BindImagePlaneMemoryInfo;
pub const ImagePlaneMemoryRequirementsInfo = extern struct {
    s_type: StructureType = .image_plane_memory_requirements_info,
    p_next: ?*const anyopaque = null,
    plane_aspect: ImageAspectFlags,
};
pub const ImagePlaneMemoryRequirementsInfoKHR = ImagePlaneMemoryRequirementsInfo;
pub const PhysicalDeviceSamplerYcbcrConversionFeatures = extern struct {
    s_type: StructureType = .physical_device_sampler_ycbcr_conversion_features,
    p_next: ?*anyopaque = null,
    sampler_ycbcr_conversion: Bool32 = .false,
};
pub const PhysicalDeviceSamplerYcbcrConversionFeaturesKHR = PhysicalDeviceSamplerYcbcrConversionFeatures;
pub const SamplerYcbcrConversionImageFormatProperties = extern struct {
    s_type: StructureType = .sampler_ycbcr_conversion_image_format_properties,
    p_next: ?*anyopaque = null,
    combined_image_sampler_descriptor_count: u32,
};
pub const SamplerYcbcrConversionImageFormatPropertiesKHR = SamplerYcbcrConversionImageFormatProperties;
pub const TextureLODGatherFormatPropertiesAMD = extern struct {
    s_type: StructureType = .texture_lod_gather_format_properties_amd,
    p_next: ?*anyopaque = null,
    supports_texture_gather_lod_bias_amd: Bool32,
};
pub const ConditionalRenderingBeginInfoEXT = extern struct {
    s_type: StructureType = .conditional_rendering_begin_info_ext,
    p_next: ?*const anyopaque = null,
    buffer: Buffer,
    offset: DeviceSize,
    flags: ConditionalRenderingFlagsEXT = .{},
};
pub const ProtectedSubmitInfo = extern struct {
    s_type: StructureType = .protected_submit_info,
    p_next: ?*const anyopaque = null,
    protected_submit: Bool32,
};
pub const PhysicalDeviceProtectedMemoryFeatures = extern struct {
    s_type: StructureType = .physical_device_protected_memory_features,
    p_next: ?*anyopaque = null,
    protected_memory: Bool32 = .false,
};
pub const PhysicalDeviceProtectedMemoryProperties = extern struct {
    s_type: StructureType = .physical_device_protected_memory_properties,
    p_next: ?*anyopaque = null,
    protected_no_fault: Bool32,
};
pub const DeviceQueueInfo2 = extern struct {
    s_type: StructureType = .device_queue_info_2,
    p_next: ?*const anyopaque = null,
    flags: DeviceQueueCreateFlags = .{},
    queue_family_index: u32,
    queue_index: u32,
};
pub const PipelineCoverageToColorStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_coverage_to_color_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    flags: PipelineCoverageToColorStateCreateFlagsNV = .{},
    coverage_to_color_enable: Bool32,
    coverage_to_color_location: u32 = 0,
};
pub const PhysicalDeviceSamplerFilterMinmaxProperties = extern struct {
    s_type: StructureType = .physical_device_sampler_filter_minmax_properties,
    p_next: ?*anyopaque = null,
    filter_minmax_single_component_formats: Bool32,
    filter_minmax_image_component_mapping: Bool32,
};
pub const PhysicalDeviceSamplerFilterMinmaxPropertiesEXT = PhysicalDeviceSamplerFilterMinmaxProperties;
pub const SampleLocationEXT = extern struct {
    x: f32,
    y: f32,
};
pub const SampleLocationsInfoEXT = extern struct {
    s_type: StructureType = .sample_locations_info_ext,
    p_next: ?*const anyopaque = null,
    sample_locations_per_pixel: SampleCountFlags,
    sample_location_grid_size: Extent2D,
    sample_locations_count: u32 = 0,
    p_sample_locations: ?[*]const SampleLocationEXT = null,
};
pub const AttachmentSampleLocationsEXT = extern struct {
    attachment_index: u32,
    sample_locations_info: SampleLocationsInfoEXT,
};
pub const SubpassSampleLocationsEXT = extern struct {
    subpass_index: u32,
    sample_locations_info: SampleLocationsInfoEXT,
};
pub const RenderPassSampleLocationsBeginInfoEXT = extern struct {
    s_type: StructureType = .render_pass_sample_locations_begin_info_ext,
    p_next: ?*const anyopaque = null,
    attachment_initial_sample_locations_count: u32 = 0,
    p_attachment_initial_sample_locations: ?[*]const AttachmentSampleLocationsEXT = null,
    post_subpass_sample_locations_count: u32 = 0,
    p_post_subpass_sample_locations: ?[*]const SubpassSampleLocationsEXT = null,
};
pub const PipelineSampleLocationsStateCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_sample_locations_state_create_info_ext,
    p_next: ?*const anyopaque = null,
    sample_locations_enable: Bool32,
    sample_locations_info: SampleLocationsInfoEXT,
};
pub const PhysicalDeviceSampleLocationsPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_sample_locations_properties_ext,
    p_next: ?*anyopaque = null,
    sample_location_sample_counts: SampleCountFlags,
    max_sample_location_grid_size: Extent2D,
    sample_location_coordinate_range: [2]f32,
    sample_location_sub_pixel_bits: u32,
    variable_sample_locations: Bool32,
};
pub const MultisamplePropertiesEXT = extern struct {
    s_type: StructureType = .multisample_properties_ext,
    p_next: ?*anyopaque = null,
    max_sample_location_grid_size: Extent2D,
};
pub const SamplerReductionModeCreateInfo = extern struct {
    s_type: StructureType = .sampler_reduction_mode_create_info,
    p_next: ?*const anyopaque = null,
    reduction_mode: SamplerReductionMode,
};
pub const SamplerReductionModeCreateInfoEXT = SamplerReductionModeCreateInfo;
pub const PhysicalDeviceBlendOperationAdvancedFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_blend_operation_advanced_features_ext,
    p_next: ?*anyopaque = null,
    advanced_blend_coherent_operations: Bool32 = .false,
};
pub const PhysicalDeviceMultiDrawFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_multi_draw_features_ext,
    p_next: ?*anyopaque = null,
    multi_draw: Bool32 = .false,
};
pub const PhysicalDeviceBlendOperationAdvancedPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_blend_operation_advanced_properties_ext,
    p_next: ?*anyopaque = null,
    advanced_blend_max_color_attachments: u32,
    advanced_blend_independent_blend: Bool32,
    advanced_blend_non_premultiplied_src_color: Bool32,
    advanced_blend_non_premultiplied_dst_color: Bool32,
    advanced_blend_correlated_overlap: Bool32,
    advanced_blend_all_operations: Bool32,
};
pub const PipelineColorBlendAdvancedStateCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_color_blend_advanced_state_create_info_ext,
    p_next: ?*const anyopaque = null,
    src_premultiplied: Bool32,
    dst_premultiplied: Bool32,
    blend_overlap: BlendOverlapEXT,
};
pub const PhysicalDeviceInlineUniformBlockFeatures = extern struct {
    s_type: StructureType = .physical_device_inline_uniform_block_features,
    p_next: ?*anyopaque = null,
    inline_uniform_block: Bool32 = .false,
    descriptor_binding_inline_uniform_block_update_after_bind: Bool32 = .false,
};
pub const PhysicalDeviceInlineUniformBlockFeaturesEXT = PhysicalDeviceInlineUniformBlockFeatures;
pub const PhysicalDeviceInlineUniformBlockProperties = extern struct {
    s_type: StructureType = .physical_device_inline_uniform_block_properties,
    p_next: ?*anyopaque = null,
    max_inline_uniform_block_size: u32,
    max_per_stage_descriptor_inline_uniform_blocks: u32,
    max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    max_descriptor_set_inline_uniform_blocks: u32,
    max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
};
pub const PhysicalDeviceInlineUniformBlockPropertiesEXT = PhysicalDeviceInlineUniformBlockProperties;
pub const WriteDescriptorSetInlineUniformBlock = extern struct {
    s_type: StructureType = .write_descriptor_set_inline_uniform_block,
    p_next: ?*const anyopaque = null,
    data_size: u32,
    p_data: *const anyopaque,
};
pub const WriteDescriptorSetInlineUniformBlockEXT = WriteDescriptorSetInlineUniformBlock;
pub const DescriptorPoolInlineUniformBlockCreateInfo = extern struct {
    s_type: StructureType = .descriptor_pool_inline_uniform_block_create_info,
    p_next: ?*const anyopaque = null,
    max_inline_uniform_block_bindings: u32,
};
pub const DescriptorPoolInlineUniformBlockCreateInfoEXT = DescriptorPoolInlineUniformBlockCreateInfo;
pub const PipelineCoverageModulationStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_coverage_modulation_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    flags: PipelineCoverageModulationStateCreateFlagsNV = .{},
    coverage_modulation_mode: CoverageModulationModeNV,
    coverage_modulation_table_enable: Bool32,
    coverage_modulation_table_count: u32 = 0,
    p_coverage_modulation_table: ?[*]const f32 = null,
};
pub const ImageFormatListCreateInfo = extern struct {
    s_type: StructureType = .image_format_list_create_info,
    p_next: ?*const anyopaque = null,
    view_format_count: u32 = 0,
    p_view_formats: ?[*]const Format = null,
};
pub const ImageFormatListCreateInfoKHR = ImageFormatListCreateInfo;
pub const ValidationCacheCreateInfoEXT = extern struct {
    s_type: StructureType = .validation_cache_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: ValidationCacheCreateFlagsEXT = .{},
    initial_data_size: usize = 0,
    p_initial_data: ?*const anyopaque = null,
};
pub const ShaderModuleValidationCacheCreateInfoEXT = extern struct {
    s_type: StructureType = .shader_module_validation_cache_create_info_ext,
    p_next: ?*const anyopaque = null,
    validation_cache: ValidationCacheEXT,
};
pub const PhysicalDeviceMaintenance3Properties = extern struct {
    s_type: StructureType = .physical_device_maintenance_3_properties,
    p_next: ?*anyopaque = null,
    max_per_set_descriptors: u32,
    max_memory_allocation_size: DeviceSize,
};
pub const PhysicalDeviceMaintenance3PropertiesKHR = PhysicalDeviceMaintenance3Properties;
pub const PhysicalDeviceMaintenance4Features = extern struct {
    s_type: StructureType = .physical_device_maintenance_4_features,
    p_next: ?*anyopaque = null,
    maintenance_4: Bool32 = .false,
};
pub const PhysicalDeviceMaintenance4FeaturesKHR = PhysicalDeviceMaintenance4Features;
pub const PhysicalDeviceMaintenance4Properties = extern struct {
    s_type: StructureType = .physical_device_maintenance_4_properties,
    p_next: ?*anyopaque = null,
    max_buffer_size: DeviceSize,
};
pub const PhysicalDeviceMaintenance4PropertiesKHR = PhysicalDeviceMaintenance4Properties;
pub const PhysicalDeviceMaintenance5Features = extern struct {
    s_type: StructureType = .physical_device_maintenance_5_features,
    p_next: ?*anyopaque = null,
    maintenance_5: Bool32 = .false,
};
pub const PhysicalDeviceMaintenance5FeaturesKHR = PhysicalDeviceMaintenance5Features;
pub const PhysicalDeviceMaintenance5Properties = extern struct {
    s_type: StructureType = .physical_device_maintenance_5_properties,
    p_next: ?*anyopaque = null,
    early_fragment_multisample_coverage_after_sample_counting: Bool32,
    early_fragment_sample_mask_test_before_sample_counting: Bool32,
    depth_stencil_swizzle_one_support: Bool32,
    polygon_mode_point_size: Bool32,
    non_strict_single_pixel_wide_lines_use_parallelogram: Bool32,
    non_strict_wide_lines_use_parallelogram: Bool32,
};
pub const PhysicalDeviceMaintenance5PropertiesKHR = PhysicalDeviceMaintenance5Properties;
pub const PhysicalDeviceMaintenance6Features = extern struct {
    s_type: StructureType = .physical_device_maintenance_6_features,
    p_next: ?*anyopaque = null,
    maintenance_6: Bool32 = .false,
};
pub const PhysicalDeviceMaintenance6FeaturesKHR = PhysicalDeviceMaintenance6Features;
pub const PhysicalDeviceMaintenance6Properties = extern struct {
    s_type: StructureType = .physical_device_maintenance_6_properties,
    p_next: ?*anyopaque = null,
    block_texel_view_compatible_multiple_layers: Bool32,
    max_combined_image_sampler_descriptor_count: u32,
    fragment_shading_rate_clamp_combiner_inputs: Bool32,
};
pub const PhysicalDeviceMaintenance6PropertiesKHR = PhysicalDeviceMaintenance6Properties;
pub const PhysicalDeviceMaintenance7FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_maintenance_7_features_khr,
    p_next: ?*anyopaque = null,
    maintenance_7: Bool32 = .false,
};
pub const PhysicalDeviceMaintenance7PropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_maintenance_7_properties_khr,
    p_next: ?*anyopaque = null,
    robust_fragment_shading_rate_attachment_access: Bool32,
    separate_depth_stencil_attachment_access: Bool32,
    max_descriptor_set_total_uniform_buffers_dynamic: u32,
    max_descriptor_set_total_storage_buffers_dynamic: u32,
    max_descriptor_set_total_buffers_dynamic: u32,
    max_descriptor_set_update_after_bind_total_uniform_buffers_dynamic: u32,
    max_descriptor_set_update_after_bind_total_storage_buffers_dynamic: u32,
    max_descriptor_set_update_after_bind_total_buffers_dynamic: u32,
};
pub const PhysicalDeviceLayeredApiPropertiesListKHR = extern struct {
    s_type: StructureType = .physical_device_layered_api_properties_list_khr,
    p_next: ?*anyopaque = null,
    layered_api_count: u32 = 0,
    p_layered_apis: ?[*]PhysicalDeviceLayeredApiPropertiesKHR = null,
};
pub const PhysicalDeviceLayeredApiPropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_layered_api_properties_khr,
    p_next: ?*anyopaque = null,
    vendor_id: u32,
    device_id: u32,
    layered_api: PhysicalDeviceLayeredApiKHR,
    device_name: [MAX_PHYSICAL_DEVICE_NAME_SIZE]u8,
};
pub const PhysicalDeviceLayeredApiVulkanPropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_layered_api_vulkan_properties_khr,
    p_next: ?*anyopaque = null,
    properties: PhysicalDeviceProperties2,
};
pub const PhysicalDeviceMaintenance8FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_maintenance_8_features_khr,
    p_next: ?*anyopaque = null,
    maintenance_8: Bool32 = .false,
};
pub const PhysicalDeviceMaintenance9FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_maintenance_9_features_khr,
    p_next: ?*anyopaque = null,
    maintenance_9: Bool32 = .false,
};
pub const PhysicalDeviceMaintenance9PropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_maintenance_9_properties_khr,
    p_next: ?*anyopaque = null,
    image_2d_view_of_3d_sparse: Bool32,
    default_vertex_attribute_value: DefaultVertexAttributeValueKHR,
};
pub const QueueFamilyOwnershipTransferPropertiesKHR = extern struct {
    s_type: StructureType = .queue_family_ownership_transfer_properties_khr,
    p_next: ?*anyopaque = null,
    optimal_image_transfer_to_queue_families: u32,
};
pub const RenderingAreaInfo = extern struct {
    s_type: StructureType = .rendering_area_info,
    p_next: ?*const anyopaque = null,
    view_mask: u32,
    color_attachment_count: u32 = 0,
    p_color_attachment_formats: ?[*]const Format = null,
    depth_attachment_format: Format,
    stencil_attachment_format: Format,
};
pub const RenderingAreaInfoKHR = RenderingAreaInfo;
pub const DescriptorSetLayoutSupport = extern struct {
    s_type: StructureType = .descriptor_set_layout_support,
    p_next: ?*anyopaque = null,
    supported: Bool32,
};
pub const DescriptorSetLayoutSupportKHR = DescriptorSetLayoutSupport;
pub const PhysicalDeviceShaderDrawParametersFeatures = extern struct {
    s_type: StructureType = .physical_device_shader_draw_parameters_features,
    p_next: ?*anyopaque = null,
    shader_draw_parameters: Bool32 = .false,
};
pub const PhysicalDeviceShaderDrawParameterFeatures = PhysicalDeviceShaderDrawParametersFeatures;
pub const PhysicalDeviceShaderFloat16Int8Features = extern struct {
    s_type: StructureType = .physical_device_shader_float16_int8_features,
    p_next: ?*anyopaque = null,
    shader_float_16: Bool32 = .false,
    shader_int_8: Bool32 = .false,
};
pub const PhysicalDeviceShaderFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;
pub const PhysicalDeviceFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;
pub const PhysicalDeviceFloatControlsProperties = extern struct {
    s_type: StructureType = .physical_device_float_controls_properties,
    p_next: ?*anyopaque = null,
    denorm_behavior_independence: ShaderFloatControlsIndependence,
    rounding_mode_independence: ShaderFloatControlsIndependence,
    shader_signed_zero_inf_nan_preserve_float_16: Bool32,
    shader_signed_zero_inf_nan_preserve_float_32: Bool32,
    shader_signed_zero_inf_nan_preserve_float_64: Bool32,
    shader_denorm_preserve_float_16: Bool32,
    shader_denorm_preserve_float_32: Bool32,
    shader_denorm_preserve_float_64: Bool32,
    shader_denorm_flush_to_zero_float_16: Bool32,
    shader_denorm_flush_to_zero_float_32: Bool32,
    shader_denorm_flush_to_zero_float_64: Bool32,
    shader_rounding_mode_rte_float_16: Bool32,
    shader_rounding_mode_rte_float_32: Bool32,
    shader_rounding_mode_rte_float_64: Bool32,
    shader_rounding_mode_rtz_float_16: Bool32,
    shader_rounding_mode_rtz_float_32: Bool32,
    shader_rounding_mode_rtz_float_64: Bool32,
};
pub const PhysicalDeviceFloatControlsPropertiesKHR = PhysicalDeviceFloatControlsProperties;
pub const PhysicalDeviceHostQueryResetFeatures = extern struct {
    s_type: StructureType = .physical_device_host_query_reset_features,
    p_next: ?*anyopaque = null,
    host_query_reset: Bool32 = .false,
};
pub const PhysicalDeviceHostQueryResetFeaturesEXT = PhysicalDeviceHostQueryResetFeatures;
pub const NativeBufferUsage2ANDROID = extern struct {
    consumer: u64,
    producer: u64,
};
pub const NativeBufferANDROID = extern struct {
    s_type: StructureType,
    p_next: ?*const anyopaque = null,
    handle: *const anyopaque,
    stride: c_int,
    format: c_int,
    usage: c_int,
    usage_2: NativeBufferUsage2ANDROID,
};
pub const SwapchainImageCreateInfoANDROID = extern struct {
    s_type: StructureType,
    p_next: ?*const anyopaque = null,
    usage: SwapchainImageUsageFlagsANDROID,
};
pub const PhysicalDevicePresentationPropertiesANDROID = extern struct {
    s_type: StructureType,
    p_next: ?*const anyopaque = null,
    shared_image: Bool32,
};
pub const ShaderResourceUsageAMD = extern struct {
    num_used_vgprs: u32,
    num_used_sgprs: u32,
    lds_size_per_local_work_group: u32,
    lds_usage_size_in_bytes: usize,
    scratch_mem_usage_in_bytes: usize,
};
pub const ShaderStatisticsInfoAMD = extern struct {
    shader_stage_mask: ShaderStageFlags,
    resource_usage: ShaderResourceUsageAMD,
    num_physical_vgprs: u32,
    num_physical_sgprs: u32,
    num_available_vgprs: u32,
    num_available_sgprs: u32,
    compute_work_group_size: [3]u32,
};
pub const DeviceQueueGlobalPriorityCreateInfo = extern struct {
    s_type: StructureType = .device_queue_global_priority_create_info,
    p_next: ?*const anyopaque = null,
    global_priority: QueueGlobalPriority,
};
pub const DeviceQueueGlobalPriorityCreateInfoKHR = DeviceQueueGlobalPriorityCreateInfo;
pub const DeviceQueueGlobalPriorityCreateInfoEXT = DeviceQueueGlobalPriorityCreateInfo;
pub const PhysicalDeviceGlobalPriorityQueryFeatures = extern struct {
    s_type: StructureType = .physical_device_global_priority_query_features,
    p_next: ?*anyopaque = null,
    global_priority_query: Bool32 = .false,
};
pub const PhysicalDeviceGlobalPriorityQueryFeaturesKHR = PhysicalDeviceGlobalPriorityQueryFeatures;
pub const PhysicalDeviceGlobalPriorityQueryFeaturesEXT = PhysicalDeviceGlobalPriorityQueryFeatures;
pub const QueueFamilyGlobalPriorityProperties = extern struct {
    s_type: StructureType = .queue_family_global_priority_properties,
    p_next: ?*anyopaque = null,
    priority_count: u32,
    priorities: [MAX_GLOBAL_PRIORITY_SIZE]QueueGlobalPriority,
};
pub const QueueFamilyGlobalPriorityPropertiesKHR = QueueFamilyGlobalPriorityProperties;
pub const QueueFamilyGlobalPriorityPropertiesEXT = QueueFamilyGlobalPriorityProperties;
pub const DebugUtilsObjectNameInfoEXT = extern struct {
    s_type: StructureType = .debug_utils_object_name_info_ext,
    p_next: ?*const anyopaque = null,
    object_type: ObjectType,
    object_handle: u64,
    p_object_name: ?[*:0]const u8 = null,
};
pub const DebugUtilsObjectTagInfoEXT = extern struct {
    s_type: StructureType = .debug_utils_object_tag_info_ext,
    p_next: ?*const anyopaque = null,
    object_type: ObjectType,
    object_handle: u64,
    tag_name: u64,
    tag_size: usize,
    p_tag: *const anyopaque,
};
pub const DebugUtilsLabelEXT = extern struct {
    s_type: StructureType = .debug_utils_label_ext,
    p_next: ?*const anyopaque = null,
    p_label_name: [*:0]const u8,
    color: [4]f32,
};
pub const DebugUtilsMessengerCreateInfoEXT = extern struct {
    s_type: StructureType = .debug_utils_messenger_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: DebugUtilsMessengerCreateFlagsEXT = .{},
    message_severity: DebugUtilsMessageSeverityFlagsEXT,
    message_type: DebugUtilsMessageTypeFlagsEXT,
    pfn_user_callback: PfnDebugUtilsMessengerCallbackEXT,
    p_user_data: ?*anyopaque = null,
};
pub const DebugUtilsMessengerCallbackDataEXT = extern struct {
    s_type: StructureType = .debug_utils_messenger_callback_data_ext,
    p_next: ?*const anyopaque = null,
    flags: DebugUtilsMessengerCallbackDataFlagsEXT = .{},
    p_message_id_name: ?[*:0]const u8 = null,
    message_id_number: i32,
    p_message: ?[*:0]const u8 = null,
    queue_label_count: u32 = 0,
    p_queue_labels: ?[*]const DebugUtilsLabelEXT = null,
    cmd_buf_label_count: u32 = 0,
    p_cmd_buf_labels: ?[*]const DebugUtilsLabelEXT = null,
    object_count: u32 = 0,
    p_objects: ?[*]const DebugUtilsObjectNameInfoEXT = null,
};
pub const PhysicalDeviceDeviceMemoryReportFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_device_memory_report_features_ext,
    p_next: ?*anyopaque = null,
    device_memory_report: Bool32 = .false,
};
pub const DeviceDeviceMemoryReportCreateInfoEXT = extern struct {
    s_type: StructureType = .device_device_memory_report_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: DeviceMemoryReportFlagsEXT,
    pfn_user_callback: PfnDeviceMemoryReportCallbackEXT,
    p_user_data: *anyopaque,
};
pub const DeviceMemoryReportCallbackDataEXT = extern struct {
    s_type: StructureType = .device_memory_report_callback_data_ext,
    p_next: ?*anyopaque = null,
    flags: DeviceMemoryReportFlagsEXT,
    type: DeviceMemoryReportEventTypeEXT,
    memory_object_id: u64,
    size: DeviceSize,
    object_type: ObjectType,
    object_handle: u64,
    heap_index: u32,
};
pub const ImportMemoryHostPointerInfoEXT = extern struct {
    s_type: StructureType = .import_memory_host_pointer_info_ext,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalMemoryHandleTypeFlags,
    p_host_pointer: *anyopaque,
};
pub const MemoryHostPointerPropertiesEXT = extern struct {
    s_type: StructureType = .memory_host_pointer_properties_ext,
    p_next: ?*anyopaque = null,
    memory_type_bits: u32,
};
pub const PhysicalDeviceExternalMemoryHostPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_external_memory_host_properties_ext,
    p_next: ?*anyopaque = null,
    min_imported_host_pointer_alignment: DeviceSize,
};
pub const PhysicalDeviceConservativeRasterizationPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_conservative_rasterization_properties_ext,
    p_next: ?*anyopaque = null,
    primitive_overestimation_size: f32,
    max_extra_primitive_overestimation_size: f32,
    extra_primitive_overestimation_size_granularity: f32,
    primitive_underestimation: Bool32,
    conservative_point_and_line_rasterization: Bool32,
    degenerate_triangles_rasterized: Bool32,
    degenerate_lines_rasterized: Bool32,
    fully_covered_fragment_shader_input_variable: Bool32,
    conservative_rasterization_post_depth_coverage: Bool32,
};
pub const CalibratedTimestampInfoKHR = extern struct {
    s_type: StructureType = .calibrated_timestamp_info_khr,
    p_next: ?*const anyopaque = null,
    time_domain: TimeDomainKHR,
};
pub const CalibratedTimestampInfoEXT = CalibratedTimestampInfoKHR;
pub const PhysicalDeviceShaderCorePropertiesAMD = extern struct {
    s_type: StructureType = .physical_device_shader_core_properties_amd,
    p_next: ?*anyopaque = null,
    shader_engine_count: u32,
    shader_arrays_per_engine_count: u32,
    compute_units_per_shader_array: u32,
    simd_per_compute_unit: u32,
    wavefronts_per_simd: u32,
    wavefront_size: u32,
    sgprs_per_simd: u32,
    min_sgpr_allocation: u32,
    max_sgpr_allocation: u32,
    sgpr_allocation_granularity: u32,
    vgprs_per_simd: u32,
    min_vgpr_allocation: u32,
    max_vgpr_allocation: u32,
    vgpr_allocation_granularity: u32,
};
pub const PhysicalDeviceShaderCoreProperties2AMD = extern struct {
    s_type: StructureType = .physical_device_shader_core_properties_2_amd,
    p_next: ?*anyopaque = null,
    shader_core_features: ShaderCorePropertiesFlagsAMD,
    active_compute_unit_count: u32,
};
pub const PipelineRasterizationConservativeStateCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_rasterization_conservative_state_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: PipelineRasterizationConservativeStateCreateFlagsEXT = .{},
    conservative_rasterization_mode: ConservativeRasterizationModeEXT,
    extra_primitive_overestimation_size: f32,
};
pub const PhysicalDeviceDescriptorIndexingFeatures = extern struct {
    s_type: StructureType = .physical_device_descriptor_indexing_features,
    p_next: ?*anyopaque = null,
    shader_input_attachment_array_dynamic_indexing: Bool32 = .false,
    shader_uniform_texel_buffer_array_dynamic_indexing: Bool32 = .false,
    shader_storage_texel_buffer_array_dynamic_indexing: Bool32 = .false,
    shader_uniform_buffer_array_non_uniform_indexing: Bool32 = .false,
    shader_sampled_image_array_non_uniform_indexing: Bool32 = .false,
    shader_storage_buffer_array_non_uniform_indexing: Bool32 = .false,
    shader_storage_image_array_non_uniform_indexing: Bool32 = .false,
    shader_input_attachment_array_non_uniform_indexing: Bool32 = .false,
    shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32 = .false,
    shader_storage_texel_buffer_array_non_uniform_indexing: Bool32 = .false,
    descriptor_binding_uniform_buffer_update_after_bind: Bool32 = .false,
    descriptor_binding_sampled_image_update_after_bind: Bool32 = .false,
    descriptor_binding_storage_image_update_after_bind: Bool32 = .false,
    descriptor_binding_storage_buffer_update_after_bind: Bool32 = .false,
    descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32 = .false,
    descriptor_binding_storage_texel_buffer_update_after_bind: Bool32 = .false,
    descriptor_binding_update_unused_while_pending: Bool32 = .false,
    descriptor_binding_partially_bound: Bool32 = .false,
    descriptor_binding_variable_descriptor_count: Bool32 = .false,
    runtime_descriptor_array: Bool32 = .false,
};
pub const PhysicalDeviceDescriptorIndexingFeaturesEXT = PhysicalDeviceDescriptorIndexingFeatures;
pub const PhysicalDeviceDescriptorIndexingProperties = extern struct {
    s_type: StructureType = .physical_device_descriptor_indexing_properties,
    p_next: ?*anyopaque = null,
    max_update_after_bind_descriptors_in_all_pools: u32,
    shader_uniform_buffer_array_non_uniform_indexing_native: Bool32,
    shader_sampled_image_array_non_uniform_indexing_native: Bool32,
    shader_storage_buffer_array_non_uniform_indexing_native: Bool32,
    shader_storage_image_array_non_uniform_indexing_native: Bool32,
    shader_input_attachment_array_non_uniform_indexing_native: Bool32,
    robust_buffer_access_update_after_bind: Bool32,
    quad_divergent_implicit_lod: Bool32,
    max_per_stage_descriptor_update_after_bind_samplers: u32,
    max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
    max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
    max_per_stage_descriptor_update_after_bind_sampled_images: u32,
    max_per_stage_descriptor_update_after_bind_storage_images: u32,
    max_per_stage_descriptor_update_after_bind_input_attachments: u32,
    max_per_stage_update_after_bind_resources: u32,
    max_descriptor_set_update_after_bind_samplers: u32,
    max_descriptor_set_update_after_bind_uniform_buffers: u32,
    max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
    max_descriptor_set_update_after_bind_storage_buffers: u32,
    max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
    max_descriptor_set_update_after_bind_sampled_images: u32,
    max_descriptor_set_update_after_bind_storage_images: u32,
    max_descriptor_set_update_after_bind_input_attachments: u32,
};
pub const PhysicalDeviceDescriptorIndexingPropertiesEXT = PhysicalDeviceDescriptorIndexingProperties;
pub const DescriptorSetLayoutBindingFlagsCreateInfo = extern struct {
    s_type: StructureType = .descriptor_set_layout_binding_flags_create_info,
    p_next: ?*const anyopaque = null,
    binding_count: u32 = 0,
    p_binding_flags: ?[*]const DescriptorBindingFlags = null,
};
pub const DescriptorSetLayoutBindingFlagsCreateInfoEXT = DescriptorSetLayoutBindingFlagsCreateInfo;
pub const DescriptorSetVariableDescriptorCountAllocateInfo = extern struct {
    s_type: StructureType = .descriptor_set_variable_descriptor_count_allocate_info,
    p_next: ?*const anyopaque = null,
    descriptor_set_count: u32 = 0,
    p_descriptor_counts: ?[*]const u32 = null,
};
pub const DescriptorSetVariableDescriptorCountAllocateInfoEXT = DescriptorSetVariableDescriptorCountAllocateInfo;
pub const DescriptorSetVariableDescriptorCountLayoutSupport = extern struct {
    s_type: StructureType = .descriptor_set_variable_descriptor_count_layout_support,
    p_next: ?*anyopaque = null,
    max_variable_descriptor_count: u32,
};
pub const DescriptorSetVariableDescriptorCountLayoutSupportEXT = DescriptorSetVariableDescriptorCountLayoutSupport;
pub const AttachmentDescription2 = extern struct {
    s_type: StructureType = .attachment_description_2,
    p_next: ?*const anyopaque = null,
    flags: AttachmentDescriptionFlags = .{},
    format: Format,
    samples: SampleCountFlags,
    load_op: AttachmentLoadOp,
    store_op: AttachmentStoreOp,
    stencil_load_op: AttachmentLoadOp,
    stencil_store_op: AttachmentStoreOp,
    initial_layout: ImageLayout,
    final_layout: ImageLayout,
};
pub const AttachmentDescription2KHR = AttachmentDescription2;
pub const AttachmentReference2 = extern struct {
    s_type: StructureType = .attachment_reference_2,
    p_next: ?*const anyopaque = null,
    attachment: u32,
    layout: ImageLayout,
    aspect_mask: ImageAspectFlags,
};
pub const AttachmentReference2KHR = AttachmentReference2;
pub const SubpassDescription2 = extern struct {
    s_type: StructureType = .subpass_description_2,
    p_next: ?*const anyopaque = null,
    flags: SubpassDescriptionFlags = .{},
    pipeline_bind_point: PipelineBindPoint,
    view_mask: u32,
    input_attachment_count: u32 = 0,
    p_input_attachments: ?[*]const AttachmentReference2 = null,
    color_attachment_count: u32 = 0,
    p_color_attachments: ?[*]const AttachmentReference2 = null,
    p_resolve_attachments: ?[*]const AttachmentReference2 = null,
    p_depth_stencil_attachment: ?*const AttachmentReference2 = null,
    preserve_attachment_count: u32 = 0,
    p_preserve_attachments: ?[*]const u32 = null,
};
pub const SubpassDescription2KHR = SubpassDescription2;
pub const SubpassDependency2 = extern struct {
    s_type: StructureType = .subpass_dependency_2,
    p_next: ?*const anyopaque = null,
    src_subpass: u32,
    dst_subpass: u32,
    src_stage_mask: PipelineStageFlags = .{},
    dst_stage_mask: PipelineStageFlags = .{},
    src_access_mask: AccessFlags = .{},
    dst_access_mask: AccessFlags = .{},
    dependency_flags: DependencyFlags = .{},
    view_offset: i32,
};
pub const SubpassDependency2KHR = SubpassDependency2;
pub const RenderPassCreateInfo2 = extern struct {
    s_type: StructureType = .render_pass_create_info_2,
    p_next: ?*const anyopaque = null,
    flags: RenderPassCreateFlags = .{},
    attachment_count: u32 = 0,
    p_attachments: ?[*]const AttachmentDescription2 = null,
    subpass_count: u32,
    p_subpasses: [*]const SubpassDescription2,
    dependency_count: u32 = 0,
    p_dependencies: ?[*]const SubpassDependency2 = null,
    correlated_view_mask_count: u32 = 0,
    p_correlated_view_masks: ?[*]const u32 = null,
};
pub const RenderPassCreateInfo2KHR = RenderPassCreateInfo2;
pub const SubpassBeginInfo = extern struct {
    s_type: StructureType = .subpass_begin_info,
    p_next: ?*const anyopaque = null,
    contents: SubpassContents,
};
pub const SubpassBeginInfoKHR = SubpassBeginInfo;
pub const SubpassEndInfo = extern struct {
    s_type: StructureType = .subpass_end_info,
    p_next: ?*const anyopaque = null,
};
pub const SubpassEndInfoKHR = SubpassEndInfo;
pub const PhysicalDeviceTimelineSemaphoreFeatures = extern struct {
    s_type: StructureType = .physical_device_timeline_semaphore_features,
    p_next: ?*anyopaque = null,
    timeline_semaphore: Bool32 = .false,
};
pub const PhysicalDeviceTimelineSemaphoreFeaturesKHR = PhysicalDeviceTimelineSemaphoreFeatures;
pub const PhysicalDeviceTimelineSemaphoreProperties = extern struct {
    s_type: StructureType = .physical_device_timeline_semaphore_properties,
    p_next: ?*anyopaque = null,
    max_timeline_semaphore_value_difference: u64,
};
pub const PhysicalDeviceTimelineSemaphorePropertiesKHR = PhysicalDeviceTimelineSemaphoreProperties;
pub const SemaphoreTypeCreateInfo = extern struct {
    s_type: StructureType = .semaphore_type_create_info,
    p_next: ?*const anyopaque = null,
    semaphore_type: SemaphoreType,
    initial_value: u64,
};
pub const SemaphoreTypeCreateInfoKHR = SemaphoreTypeCreateInfo;
pub const TimelineSemaphoreSubmitInfo = extern struct {
    s_type: StructureType = .timeline_semaphore_submit_info,
    p_next: ?*const anyopaque = null,
    wait_semaphore_value_count: u32 = 0,
    p_wait_semaphore_values: ?[*]const u64 = null,
    signal_semaphore_value_count: u32 = 0,
    p_signal_semaphore_values: ?[*]const u64 = null,
};
pub const TimelineSemaphoreSubmitInfoKHR = TimelineSemaphoreSubmitInfo;
pub const SemaphoreWaitInfo = extern struct {
    s_type: StructureType = .semaphore_wait_info,
    p_next: ?*const anyopaque = null,
    flags: SemaphoreWaitFlags = .{},
    semaphore_count: u32,
    p_semaphores: [*]const Semaphore,
    p_values: [*]const u64,
};
pub const SemaphoreWaitInfoKHR = SemaphoreWaitInfo;
pub const SemaphoreSignalInfo = extern struct {
    s_type: StructureType = .semaphore_signal_info,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore,
    value: u64,
};
pub const SemaphoreSignalInfoKHR = SemaphoreSignalInfo;
pub const VertexInputBindingDivisorDescription = extern struct {
    binding: u32,
    divisor: u32,
};
pub const VertexInputBindingDivisorDescriptionKHR = VertexInputBindingDivisorDescription;
pub const VertexInputBindingDivisorDescriptionEXT = VertexInputBindingDivisorDescription;
pub const PipelineVertexInputDivisorStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_vertex_input_divisor_state_create_info,
    p_next: ?*const anyopaque = null,
    vertex_binding_divisor_count: u32,
    p_vertex_binding_divisors: [*]const VertexInputBindingDivisorDescription,
};
pub const PipelineVertexInputDivisorStateCreateInfoKHR = PipelineVertexInputDivisorStateCreateInfo;
pub const PipelineVertexInputDivisorStateCreateInfoEXT = PipelineVertexInputDivisorStateCreateInfo;
pub const PhysicalDeviceVertexAttributeDivisorPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_vertex_attribute_divisor_properties_ext,
    p_next: ?*anyopaque = null,
    max_vertex_attrib_divisor: u32,
};
pub const PhysicalDeviceVertexAttributeDivisorProperties = extern struct {
    s_type: StructureType = .physical_device_vertex_attribute_divisor_properties,
    p_next: ?*anyopaque = null,
    max_vertex_attrib_divisor: u32,
    supports_non_zero_first_instance: Bool32,
};
pub const PhysicalDeviceVertexAttributeDivisorPropertiesKHR = PhysicalDeviceVertexAttributeDivisorProperties;
pub const PhysicalDevicePCIBusInfoPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_pci_bus_info_properties_ext,
    p_next: ?*anyopaque = null,
    pci_domain: u32,
    pci_bus: u32,
    pci_device: u32,
    pci_function: u32,
};
pub const ImportAndroidHardwareBufferInfoANDROID = extern struct {
    s_type: StructureType = .import_android_hardware_buffer_info_android,
    p_next: ?*const anyopaque = null,
    buffer: *AHardwareBuffer,
};
pub const AndroidHardwareBufferUsageANDROID = extern struct {
    s_type: StructureType = .android_hardware_buffer_usage_android,
    p_next: ?*anyopaque = null,
    android_hardware_buffer_usage: u64,
};
pub const AndroidHardwareBufferPropertiesANDROID = extern struct {
    s_type: StructureType = .android_hardware_buffer_properties_android,
    p_next: ?*anyopaque = null,
    allocation_size: DeviceSize,
    memory_type_bits: u32,
};
pub const MemoryGetAndroidHardwareBufferInfoANDROID = extern struct {
    s_type: StructureType = .memory_get_android_hardware_buffer_info_android,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory,
};
pub const AndroidHardwareBufferFormatPropertiesANDROID = extern struct {
    s_type: StructureType = .android_hardware_buffer_format_properties_android,
    p_next: ?*anyopaque = null,
    format: Format,
    external_format: u64,
    format_features: FormatFeatureFlags,
    sampler_ycbcr_conversion_components: ComponentMapping,
    suggested_ycbcr_model: SamplerYcbcrModelConversion,
    suggested_ycbcr_range: SamplerYcbcrRange,
    suggested_x_chroma_offset: ChromaLocation,
    suggested_y_chroma_offset: ChromaLocation,
};
pub const CommandBufferInheritanceConditionalRenderingInfoEXT = extern struct {
    s_type: StructureType = .command_buffer_inheritance_conditional_rendering_info_ext,
    p_next: ?*const anyopaque = null,
    conditional_rendering_enable: Bool32,
};
pub const ExternalFormatANDROID = extern struct {
    s_type: StructureType = .external_format_android,
    p_next: ?*anyopaque = null,
    external_format: u64,
};
pub const PhysicalDevice8BitStorageFeatures = extern struct {
    s_type: StructureType = .physical_device_8bit_storage_features,
    p_next: ?*anyopaque = null,
    storage_buffer_8_bit_access: Bool32 = .false,
    uniform_and_storage_buffer_8_bit_access: Bool32 = .false,
    storage_push_constant_8: Bool32 = .false,
};
pub const PhysicalDevice8BitStorageFeaturesKHR = PhysicalDevice8BitStorageFeatures;
pub const PhysicalDeviceConditionalRenderingFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_conditional_rendering_features_ext,
    p_next: ?*anyopaque = null,
    conditional_rendering: Bool32 = .false,
    inherited_conditional_rendering: Bool32 = .false,
};
pub const PhysicalDeviceVulkanMemoryModelFeatures = extern struct {
    s_type: StructureType = .physical_device_vulkan_memory_model_features,
    p_next: ?*anyopaque = null,
    vulkan_memory_model: Bool32 = .false,
    vulkan_memory_model_device_scope: Bool32 = .false,
    vulkan_memory_model_availability_visibility_chains: Bool32 = .false,
};
pub const PhysicalDeviceVulkanMemoryModelFeaturesKHR = PhysicalDeviceVulkanMemoryModelFeatures;
pub const PhysicalDeviceShaderAtomicInt64Features = extern struct {
    s_type: StructureType = .physical_device_shader_atomic_int64_features,
    p_next: ?*anyopaque = null,
    shader_buffer_int_64_atomics: Bool32 = .false,
    shader_shared_int_64_atomics: Bool32 = .false,
};
pub const PhysicalDeviceShaderAtomicInt64FeaturesKHR = PhysicalDeviceShaderAtomicInt64Features;
pub const PhysicalDeviceShaderAtomicFloatFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_atomic_float_features_ext,
    p_next: ?*anyopaque = null,
    shader_buffer_float_32_atomics: Bool32 = .false,
    shader_buffer_float_32_atomic_add: Bool32 = .false,
    shader_buffer_float_64_atomics: Bool32 = .false,
    shader_buffer_float_64_atomic_add: Bool32 = .false,
    shader_shared_float_32_atomics: Bool32 = .false,
    shader_shared_float_32_atomic_add: Bool32 = .false,
    shader_shared_float_64_atomics: Bool32 = .false,
    shader_shared_float_64_atomic_add: Bool32 = .false,
    shader_image_float_32_atomics: Bool32 = .false,
    shader_image_float_32_atomic_add: Bool32 = .false,
    sparse_image_float_32_atomics: Bool32 = .false,
    sparse_image_float_32_atomic_add: Bool32 = .false,
};
pub const PhysicalDeviceShaderAtomicFloat2FeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_atomic_float_2_features_ext,
    p_next: ?*anyopaque = null,
    shader_buffer_float_16_atomics: Bool32 = .false,
    shader_buffer_float_16_atomic_add: Bool32 = .false,
    shader_buffer_float_16_atomic_min_max: Bool32 = .false,
    shader_buffer_float_32_atomic_min_max: Bool32 = .false,
    shader_buffer_float_64_atomic_min_max: Bool32 = .false,
    shader_shared_float_16_atomics: Bool32 = .false,
    shader_shared_float_16_atomic_add: Bool32 = .false,
    shader_shared_float_16_atomic_min_max: Bool32 = .false,
    shader_shared_float_32_atomic_min_max: Bool32 = .false,
    shader_shared_float_64_atomic_min_max: Bool32 = .false,
    shader_image_float_32_atomic_min_max: Bool32 = .false,
    sparse_image_float_32_atomic_min_max: Bool32 = .false,
};
pub const PhysicalDeviceVertexAttributeDivisorFeatures = extern struct {
    s_type: StructureType = .physical_device_vertex_attribute_divisor_features,
    p_next: ?*anyopaque = null,
    vertex_attribute_instance_rate_divisor: Bool32 = .false,
    vertex_attribute_instance_rate_zero_divisor: Bool32 = .false,
};
pub const PhysicalDeviceVertexAttributeDivisorFeaturesKHR = PhysicalDeviceVertexAttributeDivisorFeatures;
pub const PhysicalDeviceVertexAttributeDivisorFeaturesEXT = PhysicalDeviceVertexAttributeDivisorFeatures;
pub const QueueFamilyCheckpointPropertiesNV = extern struct {
    s_type: StructureType = .queue_family_checkpoint_properties_nv,
    p_next: ?*anyopaque = null,
    checkpoint_execution_stage_mask: PipelineStageFlags,
};
pub const CheckpointDataNV = extern struct {
    s_type: StructureType = .checkpoint_data_nv,
    p_next: ?*anyopaque = null,
    stage: PipelineStageFlags,
    p_checkpoint_marker: *anyopaque,
};
pub const PhysicalDeviceDepthStencilResolveProperties = extern struct {
    s_type: StructureType = .physical_device_depth_stencil_resolve_properties,
    p_next: ?*anyopaque = null,
    supported_depth_resolve_modes: ResolveModeFlags,
    supported_stencil_resolve_modes: ResolveModeFlags,
    independent_resolve_none: Bool32,
    independent_resolve: Bool32,
};
pub const PhysicalDeviceDepthStencilResolvePropertiesKHR = PhysicalDeviceDepthStencilResolveProperties;
pub const SubpassDescriptionDepthStencilResolve = extern struct {
    s_type: StructureType = .subpass_description_depth_stencil_resolve,
    p_next: ?*const anyopaque = null,
    depth_resolve_mode: ResolveModeFlags,
    stencil_resolve_mode: ResolveModeFlags,
    p_depth_stencil_resolve_attachment: ?*const AttachmentReference2 = null,
};
pub const SubpassDescriptionDepthStencilResolveKHR = SubpassDescriptionDepthStencilResolve;
pub const ImageViewASTCDecodeModeEXT = extern struct {
    s_type: StructureType = .image_view_astc_decode_mode_ext,
    p_next: ?*const anyopaque = null,
    decode_mode: Format,
};
pub const PhysicalDeviceASTCDecodeFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_astc_decode_features_ext,
    p_next: ?*anyopaque = null,
    decode_mode_shared_exponent: Bool32 = .false,
};
pub const PhysicalDeviceTransformFeedbackFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_transform_feedback_features_ext,
    p_next: ?*anyopaque = null,
    transform_feedback: Bool32 = .false,
    geometry_streams: Bool32 = .false,
};
pub const PhysicalDeviceTransformFeedbackPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_transform_feedback_properties_ext,
    p_next: ?*anyopaque = null,
    max_transform_feedback_streams: u32,
    max_transform_feedback_buffers: u32,
    max_transform_feedback_buffer_size: DeviceSize,
    max_transform_feedback_stream_data_size: u32,
    max_transform_feedback_buffer_data_size: u32,
    max_transform_feedback_buffer_data_stride: u32,
    transform_feedback_queries: Bool32,
    transform_feedback_streams_lines_triangles: Bool32,
    transform_feedback_rasterization_stream_select: Bool32,
    transform_feedback_draw: Bool32,
};
pub const PipelineRasterizationStateStreamCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_rasterization_state_stream_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: PipelineRasterizationStateStreamCreateFlagsEXT = .{},
    rasterization_stream: u32,
};
pub const PhysicalDeviceRepresentativeFragmentTestFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_representative_fragment_test_features_nv,
    p_next: ?*anyopaque = null,
    representative_fragment_test: Bool32 = .false,
};
pub const PipelineRepresentativeFragmentTestStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_representative_fragment_test_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    representative_fragment_test_enable: Bool32,
};
pub const PhysicalDeviceExclusiveScissorFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_exclusive_scissor_features_nv,
    p_next: ?*anyopaque = null,
    exclusive_scissor: Bool32 = .false,
};
pub const PipelineViewportExclusiveScissorStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_viewport_exclusive_scissor_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    exclusive_scissor_count: u32 = 0,
    p_exclusive_scissors: ?[*]const Rect2D = null,
};
pub const PhysicalDeviceCornerSampledImageFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_corner_sampled_image_features_nv,
    p_next: ?*anyopaque = null,
    corner_sampled_image: Bool32 = .false,
};
pub const PhysicalDeviceComputeShaderDerivativesFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_compute_shader_derivatives_features_khr,
    p_next: ?*anyopaque = null,
    compute_derivative_group_quads: Bool32 = .false,
    compute_derivative_group_linear: Bool32 = .false,
};
pub const PhysicalDeviceComputeShaderDerivativesFeaturesNV = PhysicalDeviceComputeShaderDerivativesFeaturesKHR;
pub const PhysicalDeviceComputeShaderDerivativesPropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_compute_shader_derivatives_properties_khr,
    p_next: ?*anyopaque = null,
    mesh_and_task_shader_derivatives: Bool32,
};
pub const PhysicalDeviceFragmentShaderBarycentricFeaturesNV = PhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
pub const PhysicalDeviceShaderImageFootprintFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_shader_image_footprint_features_nv,
    p_next: ?*anyopaque = null,
    image_footprint: Bool32 = .false,
};
pub const PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_dedicated_allocation_image_aliasing_features_nv,
    p_next: ?*anyopaque = null,
    dedicated_allocation_image_aliasing: Bool32 = .false,
};
pub const PhysicalDeviceCopyMemoryIndirectFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_copy_memory_indirect_features_nv,
    p_next: ?*anyopaque = null,
    indirect_copy: Bool32 = .false,
};
pub const PhysicalDeviceCopyMemoryIndirectPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_copy_memory_indirect_properties_nv,
    p_next: ?*anyopaque = null,
    supported_queues: QueueFlags,
};
pub const PhysicalDeviceMemoryDecompressionFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_memory_decompression_features_nv,
    p_next: ?*anyopaque = null,
    memory_decompression: Bool32 = .false,
};
pub const PhysicalDeviceMemoryDecompressionPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_memory_decompression_properties_nv,
    p_next: ?*anyopaque = null,
    decompression_methods: MemoryDecompressionMethodFlagsNV,
    max_decompression_indirect_count: u64,
};
pub const ShadingRatePaletteNV = extern struct {
    shading_rate_palette_entry_count: u32,
    p_shading_rate_palette_entries: [*]const ShadingRatePaletteEntryNV,
};
pub const PipelineViewportShadingRateImageStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_viewport_shading_rate_image_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    shading_rate_image_enable: Bool32,
    viewport_count: u32 = 0,
    p_shading_rate_palettes: ?[*]const ShadingRatePaletteNV = null,
};
pub const PhysicalDeviceShadingRateImageFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_shading_rate_image_features_nv,
    p_next: ?*anyopaque = null,
    shading_rate_image: Bool32 = .false,
    shading_rate_coarse_sample_order: Bool32 = .false,
};
pub const PhysicalDeviceShadingRateImagePropertiesNV = extern struct {
    s_type: StructureType = .physical_device_shading_rate_image_properties_nv,
    p_next: ?*anyopaque = null,
    shading_rate_texel_size: Extent2D,
    shading_rate_palette_size: u32,
    shading_rate_max_coarse_samples: u32,
};
pub const PhysicalDeviceInvocationMaskFeaturesHUAWEI = extern struct {
    s_type: StructureType = .physical_device_invocation_mask_features_huawei,
    p_next: ?*anyopaque = null,
    invocation_mask: Bool32 = .false,
};
pub const CoarseSampleLocationNV = extern struct {
    pixel_x: u32,
    pixel_y: u32,
    sample: u32,
};
pub const CoarseSampleOrderCustomNV = extern struct {
    shading_rate: ShadingRatePaletteEntryNV,
    sample_count: u32,
    sample_location_count: u32,
    p_sample_locations: [*]const CoarseSampleLocationNV,
};
pub const PipelineViewportCoarseSampleOrderStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_viewport_coarse_sample_order_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    sample_order_type: CoarseSampleOrderTypeNV,
    custom_sample_order_count: u32 = 0,
    p_custom_sample_orders: ?[*]const CoarseSampleOrderCustomNV = null,
};
pub const PhysicalDeviceMeshShaderFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_mesh_shader_features_nv,
    p_next: ?*anyopaque = null,
    task_shader: Bool32 = .false,
    mesh_shader: Bool32 = .false,
};
pub const PhysicalDeviceMeshShaderPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_mesh_shader_properties_nv,
    p_next: ?*anyopaque = null,
    max_draw_mesh_tasks_count: u32,
    max_task_work_group_invocations: u32,
    max_task_work_group_size: [3]u32,
    max_task_total_memory_size: u32,
    max_task_output_count: u32,
    max_mesh_work_group_invocations: u32,
    max_mesh_work_group_size: [3]u32,
    max_mesh_total_memory_size: u32,
    max_mesh_output_vertices: u32,
    max_mesh_output_primitives: u32,
    max_mesh_multiview_view_count: u32,
    mesh_output_per_vertex_granularity: u32,
    mesh_output_per_primitive_granularity: u32,
};
pub const DrawMeshTasksIndirectCommandNV = extern struct {
    task_count: u32,
    first_task: u32,
};
pub const PhysicalDeviceMeshShaderFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_mesh_shader_features_ext,
    p_next: ?*anyopaque = null,
    task_shader: Bool32 = .false,
    mesh_shader: Bool32 = .false,
    multiview_mesh_shader: Bool32 = .false,
    primitive_fragment_shading_rate_mesh_shader: Bool32 = .false,
    mesh_shader_queries: Bool32 = .false,
};
pub const PhysicalDeviceMeshShaderPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_mesh_shader_properties_ext,
    p_next: ?*anyopaque = null,
    max_task_work_group_total_count: u32,
    max_task_work_group_count: [3]u32,
    max_task_work_group_invocations: u32,
    max_task_work_group_size: [3]u32,
    max_task_payload_size: u32,
    max_task_shared_memory_size: u32,
    max_task_payload_and_shared_memory_size: u32,
    max_mesh_work_group_total_count: u32,
    max_mesh_work_group_count: [3]u32,
    max_mesh_work_group_invocations: u32,
    max_mesh_work_group_size: [3]u32,
    max_mesh_shared_memory_size: u32,
    max_mesh_payload_and_shared_memory_size: u32,
    max_mesh_output_memory_size: u32,
    max_mesh_payload_and_output_memory_size: u32,
    max_mesh_output_components: u32,
    max_mesh_output_vertices: u32,
    max_mesh_output_primitives: u32,
    max_mesh_output_layers: u32,
    max_mesh_multiview_view_count: u32,
    mesh_output_per_vertex_granularity: u32,
    mesh_output_per_primitive_granularity: u32,
    max_preferred_task_work_group_invocations: u32,
    max_preferred_mesh_work_group_invocations: u32,
    prefers_local_invocation_vertex_output: Bool32,
    prefers_local_invocation_primitive_output: Bool32,
    prefers_compact_vertex_output: Bool32,
    prefers_compact_primitive_output: Bool32,
};
pub const DrawMeshTasksIndirectCommandEXT = extern struct {
    group_count_x: u32,
    group_count_y: u32,
    group_count_z: u32,
};
pub const RayTracingShaderGroupCreateInfoNV = extern struct {
    s_type: StructureType = .ray_tracing_shader_group_create_info_nv,
    p_next: ?*const anyopaque = null,
    type: RayTracingShaderGroupTypeKHR,
    general_shader: u32,
    closest_hit_shader: u32,
    any_hit_shader: u32,
    intersection_shader: u32,
};
pub const RayTracingShaderGroupCreateInfoKHR = extern struct {
    s_type: StructureType = .ray_tracing_shader_group_create_info_khr,
    p_next: ?*const anyopaque = null,
    type: RayTracingShaderGroupTypeKHR,
    general_shader: u32,
    closest_hit_shader: u32,
    any_hit_shader: u32,
    intersection_shader: u32,
    p_shader_group_capture_replay_handle: ?*const anyopaque = null,
};
pub const RayTracingPipelineCreateInfoNV = extern struct {
    s_type: StructureType = .ray_tracing_pipeline_create_info_nv,
    p_next: ?*const anyopaque = null,
    flags: PipelineCreateFlags = .{},
    stage_count: u32,
    p_stages: [*]const PipelineShaderStageCreateInfo,
    group_count: u32,
    p_groups: [*]const RayTracingShaderGroupCreateInfoNV,
    max_recursion_depth: u32,
    layout: PipelineLayout,
    base_pipeline_handle: Pipeline = .null_handle,
    base_pipeline_index: i32,
};
pub const RayTracingPipelineCreateInfoKHR = extern struct {
    s_type: StructureType = .ray_tracing_pipeline_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: PipelineCreateFlags = .{},
    stage_count: u32 = 0,
    p_stages: ?[*]const PipelineShaderStageCreateInfo = null,
    group_count: u32 = 0,
    p_groups: ?[*]const RayTracingShaderGroupCreateInfoKHR = null,
    max_pipeline_ray_recursion_depth: u32,
    p_library_info: ?*const PipelineLibraryCreateInfoKHR = null,
    p_library_interface: ?*const RayTracingPipelineInterfaceCreateInfoKHR = null,
    p_dynamic_state: ?*const PipelineDynamicStateCreateInfo = null,
    layout: PipelineLayout,
    base_pipeline_handle: Pipeline = .null_handle,
    base_pipeline_index: i32,
};
pub const GeometryTrianglesNV = extern struct {
    s_type: StructureType = .geometry_triangles_nv,
    p_next: ?*const anyopaque = null,
    vertex_data: Buffer = .null_handle,
    vertex_offset: DeviceSize,
    vertex_count: u32,
    vertex_stride: DeviceSize,
    vertex_format: Format,
    index_data: Buffer = .null_handle,
    index_offset: DeviceSize,
    index_count: u32,
    index_type: IndexType,
    transform_data: Buffer = .null_handle,
    transform_offset: DeviceSize,
};
pub const GeometryAABBNV = extern struct {
    s_type: StructureType = .geometry_aabb_nv,
    p_next: ?*const anyopaque = null,
    aabb_data: Buffer = .null_handle,
    num_aab_bs: u32,
    stride: u32,
    offset: DeviceSize,
};
pub const GeometryDataNV = extern struct {
    triangles: GeometryTrianglesNV,
    aabbs: GeometryAABBNV,
};
pub const GeometryNV = extern struct {
    s_type: StructureType = .geometry_nv,
    p_next: ?*const anyopaque = null,
    geometry_type: GeometryTypeKHR,
    geometry: GeometryDataNV,
    flags: GeometryFlagsKHR = .{},
};
pub const AccelerationStructureInfoNV = extern struct {
    s_type: StructureType = .acceleration_structure_info_nv,
    p_next: ?*const anyopaque = null,
    type: AccelerationStructureTypeNV,
    flags: BuildAccelerationStructureFlagsNV = .{},
    instance_count: u32 = 0,
    geometry_count: u32 = 0,
    p_geometries: ?[*]const GeometryNV = null,
};
pub const AccelerationStructureCreateInfoNV = extern struct {
    s_type: StructureType = .acceleration_structure_create_info_nv,
    p_next: ?*const anyopaque = null,
    compacted_size: DeviceSize,
    info: AccelerationStructureInfoNV,
};
pub const BindAccelerationStructureMemoryInfoNV = extern struct {
    s_type: StructureType = .bind_acceleration_structure_memory_info_nv,
    p_next: ?*const anyopaque = null,
    acceleration_structure: AccelerationStructureNV,
    memory: DeviceMemory,
    memory_offset: DeviceSize,
    device_index_count: u32 = 0,
    p_device_indices: ?[*]const u32 = null,
};
pub const WriteDescriptorSetAccelerationStructureKHR = extern struct {
    s_type: StructureType = .write_descriptor_set_acceleration_structure_khr,
    p_next: ?*const anyopaque = null,
    acceleration_structure_count: u32,
    p_acceleration_structures: [*]const AccelerationStructureKHR,
};
pub const WriteDescriptorSetAccelerationStructureNV = extern struct {
    s_type: StructureType = .write_descriptor_set_acceleration_structure_nv,
    p_next: ?*const anyopaque = null,
    acceleration_structure_count: u32,
    p_acceleration_structures: [*]const AccelerationStructureNV,
};
pub const AccelerationStructureMemoryRequirementsInfoNV = extern struct {
    s_type: StructureType = .acceleration_structure_memory_requirements_info_nv,
    p_next: ?*const anyopaque = null,
    type: AccelerationStructureMemoryRequirementsTypeNV,
    acceleration_structure: AccelerationStructureNV,
};
pub const PhysicalDeviceAccelerationStructureFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_acceleration_structure_features_khr,
    p_next: ?*anyopaque = null,
    acceleration_structure: Bool32 = .false,
    acceleration_structure_capture_replay: Bool32 = .false,
    acceleration_structure_indirect_build: Bool32 = .false,
    acceleration_structure_host_commands: Bool32 = .false,
    descriptor_binding_acceleration_structure_update_after_bind: Bool32 = .false,
};
pub const PhysicalDeviceRayTracingPipelineFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_pipeline_features_khr,
    p_next: ?*anyopaque = null,
    ray_tracing_pipeline: Bool32 = .false,
    ray_tracing_pipeline_shader_group_handle_capture_replay: Bool32 = .false,
    ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: Bool32 = .false,
    ray_tracing_pipeline_trace_rays_indirect: Bool32 = .false,
    ray_traversal_primitive_culling: Bool32 = .false,
};
pub const PhysicalDeviceRayQueryFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_ray_query_features_khr,
    p_next: ?*anyopaque = null,
    ray_query: Bool32 = .false,
};
pub const PhysicalDeviceAccelerationStructurePropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_acceleration_structure_properties_khr,
    p_next: ?*anyopaque = null,
    max_geometry_count: u64,
    max_instance_count: u64,
    max_primitive_count: u64,
    max_per_stage_descriptor_acceleration_structures: u32,
    max_per_stage_descriptor_update_after_bind_acceleration_structures: u32,
    max_descriptor_set_acceleration_structures: u32,
    max_descriptor_set_update_after_bind_acceleration_structures: u32,
    min_acceleration_structure_scratch_offset_alignment: u32,
};
pub const PhysicalDeviceRayTracingPipelinePropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_pipeline_properties_khr,
    p_next: ?*anyopaque = null,
    shader_group_handle_size: u32,
    max_ray_recursion_depth: u32,
    max_shader_group_stride: u32,
    shader_group_base_alignment: u32,
    shader_group_handle_capture_replay_size: u32,
    max_ray_dispatch_invocation_count: u32,
    shader_group_handle_alignment: u32,
    max_ray_hit_attribute_size: u32,
};
pub const PhysicalDeviceRayTracingPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_properties_nv,
    p_next: ?*anyopaque = null,
    shader_group_handle_size: u32,
    max_recursion_depth: u32,
    max_shader_group_stride: u32,
    shader_group_base_alignment: u32,
    max_geometry_count: u64,
    max_instance_count: u64,
    max_triangle_count: u64,
    max_descriptor_set_acceleration_structures: u32,
};
pub const StridedDeviceAddressRegionKHR = extern struct {
    device_address: DeviceAddress = 0,
    stride: DeviceSize,
    size: DeviceSize,
};
pub const TraceRaysIndirectCommandKHR = extern struct {
    width: u32,
    height: u32,
    depth: u32,
};
pub const TraceRaysIndirectCommand2KHR = extern struct {
    raygen_shader_record_address: DeviceAddress,
    raygen_shader_record_size: DeviceSize,
    miss_shader_binding_table_address: DeviceAddress,
    miss_shader_binding_table_size: DeviceSize,
    miss_shader_binding_table_stride: DeviceSize,
    hit_shader_binding_table_address: DeviceAddress,
    hit_shader_binding_table_size: DeviceSize,
    hit_shader_binding_table_stride: DeviceSize,
    callable_shader_binding_table_address: DeviceAddress,
    callable_shader_binding_table_size: DeviceSize,
    callable_shader_binding_table_stride: DeviceSize,
    width: u32,
    height: u32,
    depth: u32,
};
pub const PhysicalDeviceRayTracingMaintenance1FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_maintenance_1_features_khr,
    p_next: ?*anyopaque = null,
    ray_tracing_maintenance_1: Bool32 = .false,
    ray_tracing_pipeline_trace_rays_indirect_2: Bool32 = .false,
};
pub const DrmFormatModifierPropertiesListEXT = extern struct {
    s_type: StructureType = .drm_format_modifier_properties_list_ext,
    p_next: ?*anyopaque = null,
    drm_format_modifier_count: u32 = 0,
    p_drm_format_modifier_properties: ?[*]DrmFormatModifierPropertiesEXT = null,
};
pub const DrmFormatModifierPropertiesEXT = extern struct {
    drm_format_modifier: u64,
    drm_format_modifier_plane_count: u32,
    drm_format_modifier_tiling_features: FormatFeatureFlags,
};
pub const PhysicalDeviceImageDrmFormatModifierInfoEXT = extern struct {
    s_type: StructureType = .physical_device_image_drm_format_modifier_info_ext,
    p_next: ?*const anyopaque = null,
    drm_format_modifier: u64,
    sharing_mode: SharingMode,
    queue_family_index_count: u32 = 0,
    p_queue_family_indices: ?[*]const u32 = null,
};
pub const ImageDrmFormatModifierListCreateInfoEXT = extern struct {
    s_type: StructureType = .image_drm_format_modifier_list_create_info_ext,
    p_next: ?*const anyopaque = null,
    drm_format_modifier_count: u32,
    p_drm_format_modifiers: [*]const u64,
};
pub const ImageDrmFormatModifierExplicitCreateInfoEXT = extern struct {
    s_type: StructureType = .image_drm_format_modifier_explicit_create_info_ext,
    p_next: ?*const anyopaque = null,
    drm_format_modifier: u64,
    drm_format_modifier_plane_count: u32,
    p_plane_layouts: [*]const SubresourceLayout,
};
pub const ImageDrmFormatModifierPropertiesEXT = extern struct {
    s_type: StructureType = .image_drm_format_modifier_properties_ext,
    p_next: ?*anyopaque = null,
    drm_format_modifier: u64,
};
pub const ImageStencilUsageCreateInfo = extern struct {
    s_type: StructureType = .image_stencil_usage_create_info,
    p_next: ?*const anyopaque = null,
    stencil_usage: ImageUsageFlags,
};
pub const ImageStencilUsageCreateInfoEXT = ImageStencilUsageCreateInfo;
pub const DeviceMemoryOverallocationCreateInfoAMD = extern struct {
    s_type: StructureType = .device_memory_overallocation_create_info_amd,
    p_next: ?*const anyopaque = null,
    overallocation_behavior: MemoryOverallocationBehaviorAMD,
};
pub const PhysicalDeviceFragmentDensityMapFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_fragment_density_map_features_ext,
    p_next: ?*anyopaque = null,
    fragment_density_map: Bool32 = .false,
    fragment_density_map_dynamic: Bool32 = .false,
    fragment_density_map_non_subsampled_images: Bool32 = .false,
};
pub const PhysicalDeviceFragmentDensityMap2FeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_fragment_density_map_2_features_ext,
    p_next: ?*anyopaque = null,
    fragment_density_map_deferred: Bool32 = .false,
};
pub const PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_fragment_density_map_offset_features_ext,
    p_next: ?*anyopaque = null,
    fragment_density_map_offset: Bool32 = .false,
};
pub const PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM = PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT;
pub const PhysicalDeviceFragmentDensityMapPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_fragment_density_map_properties_ext,
    p_next: ?*anyopaque = null,
    min_fragment_density_texel_size: Extent2D,
    max_fragment_density_texel_size: Extent2D,
    fragment_density_invocations: Bool32,
};
pub const PhysicalDeviceFragmentDensityMap2PropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_fragment_density_map_2_properties_ext,
    p_next: ?*anyopaque = null,
    subsampled_loads: Bool32,
    subsampled_coarse_reconstruction_early_access: Bool32,
    max_subsampled_array_layers: u32,
    max_descriptor_set_subsampled_samplers: u32,
};
pub const PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_fragment_density_map_offset_properties_ext,
    p_next: ?*anyopaque = null,
    fragment_density_offset_granularity: Extent2D,
};
pub const PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM = PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT;
pub const RenderPassFragmentDensityMapCreateInfoEXT = extern struct {
    s_type: StructureType = .render_pass_fragment_density_map_create_info_ext,
    p_next: ?*const anyopaque = null,
    fragment_density_map_attachment: AttachmentReference,
};
pub const RenderPassFragmentDensityMapOffsetEndInfoEXT = extern struct {
    s_type: StructureType = .render_pass_fragment_density_map_offset_end_info_ext,
    p_next: ?*const anyopaque = null,
    fragment_density_offset_count: u32 = 0,
    p_fragment_density_offsets: ?[*]const Offset2D = null,
};
pub const SubpassFragmentDensityMapOffsetEndInfoQCOM = RenderPassFragmentDensityMapOffsetEndInfoEXT;
pub const PhysicalDeviceScalarBlockLayoutFeatures = extern struct {
    s_type: StructureType = .physical_device_scalar_block_layout_features,
    p_next: ?*anyopaque = null,
    scalar_block_layout: Bool32 = .false,
};
pub const PhysicalDeviceScalarBlockLayoutFeaturesEXT = PhysicalDeviceScalarBlockLayoutFeatures;
pub const SurfaceProtectedCapabilitiesKHR = extern struct {
    s_type: StructureType = .surface_protected_capabilities_khr,
    p_next: ?*const anyopaque = null,
    supports_protected: Bool32,
};
pub const PhysicalDeviceUniformBufferStandardLayoutFeatures = extern struct {
    s_type: StructureType = .physical_device_uniform_buffer_standard_layout_features,
    p_next: ?*anyopaque = null,
    uniform_buffer_standard_layout: Bool32 = .false,
};
pub const PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = PhysicalDeviceUniformBufferStandardLayoutFeatures;
pub const PhysicalDeviceDepthClipEnableFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_depth_clip_enable_features_ext,
    p_next: ?*anyopaque = null,
    depth_clip_enable: Bool32 = .false,
};
pub const PipelineRasterizationDepthClipStateCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_rasterization_depth_clip_state_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: PipelineRasterizationDepthClipStateCreateFlagsEXT = .{},
    depth_clip_enable: Bool32,
};
pub const PhysicalDeviceMemoryBudgetPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_memory_budget_properties_ext,
    p_next: ?*anyopaque = null,
    heap_budget: [MAX_MEMORY_HEAPS]DeviceSize,
    heap_usage: [MAX_MEMORY_HEAPS]DeviceSize,
};
pub const PhysicalDeviceMemoryPriorityFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_memory_priority_features_ext,
    p_next: ?*anyopaque = null,
    memory_priority: Bool32 = .false,
};
pub const MemoryPriorityAllocateInfoEXT = extern struct {
    s_type: StructureType = .memory_priority_allocate_info_ext,
    p_next: ?*const anyopaque = null,
    priority: f32,
};
pub const PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_pageable_device_local_memory_features_ext,
    p_next: ?*anyopaque = null,
    pageable_device_local_memory: Bool32 = .false,
};
pub const PhysicalDeviceBufferDeviceAddressFeatures = extern struct {
    s_type: StructureType = .physical_device_buffer_device_address_features,
    p_next: ?*anyopaque = null,
    buffer_device_address: Bool32 = .false,
    buffer_device_address_capture_replay: Bool32 = .false,
    buffer_device_address_multi_device: Bool32 = .false,
};
pub const PhysicalDeviceBufferDeviceAddressFeaturesKHR = PhysicalDeviceBufferDeviceAddressFeatures;
pub const PhysicalDeviceBufferDeviceAddressFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_buffer_device_address_features_ext,
    p_next: ?*anyopaque = null,
    buffer_device_address: Bool32 = .false,
    buffer_device_address_capture_replay: Bool32 = .false,
    buffer_device_address_multi_device: Bool32 = .false,
};
pub const PhysicalDeviceBufferAddressFeaturesEXT = PhysicalDeviceBufferDeviceAddressFeaturesEXT;
pub const BufferDeviceAddressInfo = extern struct {
    s_type: StructureType = .buffer_device_address_info,
    p_next: ?*const anyopaque = null,
    buffer: Buffer,
};
pub const BufferDeviceAddressInfoKHR = BufferDeviceAddressInfo;
pub const BufferDeviceAddressInfoEXT = BufferDeviceAddressInfo;
pub const BufferOpaqueCaptureAddressCreateInfo = extern struct {
    s_type: StructureType = .buffer_opaque_capture_address_create_info,
    p_next: ?*const anyopaque = null,
    opaque_capture_address: u64,
};
pub const BufferOpaqueCaptureAddressCreateInfoKHR = BufferOpaqueCaptureAddressCreateInfo;
pub const BufferDeviceAddressCreateInfoEXT = extern struct {
    s_type: StructureType = .buffer_device_address_create_info_ext,
    p_next: ?*const anyopaque = null,
    device_address: DeviceAddress,
};
pub const PhysicalDeviceImageViewImageFormatInfoEXT = extern struct {
    s_type: StructureType = .physical_device_image_view_image_format_info_ext,
    p_next: ?*anyopaque = null,
    image_view_type: ImageViewType,
};
pub const FilterCubicImageViewImageFormatPropertiesEXT = extern struct {
    s_type: StructureType = .filter_cubic_image_view_image_format_properties_ext,
    p_next: ?*anyopaque = null,
    filter_cubic: Bool32,
    filter_cubic_minmax: Bool32,
};
pub const PhysicalDeviceImagelessFramebufferFeatures = extern struct {
    s_type: StructureType = .physical_device_imageless_framebuffer_features,
    p_next: ?*anyopaque = null,
    imageless_framebuffer: Bool32 = .false,
};
pub const PhysicalDeviceImagelessFramebufferFeaturesKHR = PhysicalDeviceImagelessFramebufferFeatures;
pub const FramebufferAttachmentsCreateInfo = extern struct {
    s_type: StructureType = .framebuffer_attachments_create_info,
    p_next: ?*const anyopaque = null,
    attachment_image_info_count: u32 = 0,
    p_attachment_image_infos: ?[*]const FramebufferAttachmentImageInfo = null,
};
pub const FramebufferAttachmentsCreateInfoKHR = FramebufferAttachmentsCreateInfo;
pub const FramebufferAttachmentImageInfo = extern struct {
    s_type: StructureType = .framebuffer_attachment_image_info,
    p_next: ?*const anyopaque = null,
    flags: ImageCreateFlags = .{},
    usage: ImageUsageFlags,
    width: u32,
    height: u32,
    layer_count: u32,
    view_format_count: u32 = 0,
    p_view_formats: ?[*]const Format = null,
};
pub const FramebufferAttachmentImageInfoKHR = FramebufferAttachmentImageInfo;
pub const RenderPassAttachmentBeginInfo = extern struct {
    s_type: StructureType = .render_pass_attachment_begin_info,
    p_next: ?*const anyopaque = null,
    attachment_count: u32 = 0,
    p_attachments: ?[*]const ImageView = null,
};
pub const RenderPassAttachmentBeginInfoKHR = RenderPassAttachmentBeginInfo;
pub const PhysicalDeviceTextureCompressionASTCHDRFeatures = extern struct {
    s_type: StructureType = .physical_device_texture_compression_astc_hdr_features,
    p_next: ?*anyopaque = null,
    texture_compression_astc_hdr: Bool32 = .false,
};
pub const PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = PhysicalDeviceTextureCompressionASTCHDRFeatures;
pub const PhysicalDeviceCooperativeMatrixFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_cooperative_matrix_features_nv,
    p_next: ?*anyopaque = null,
    cooperative_matrix: Bool32 = .false,
    cooperative_matrix_robust_buffer_access: Bool32 = .false,
};
pub const PhysicalDeviceCooperativeMatrixPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_cooperative_matrix_properties_nv,
    p_next: ?*anyopaque = null,
    cooperative_matrix_supported_stages: ShaderStageFlags,
};
pub const CooperativeMatrixPropertiesNV = extern struct {
    s_type: StructureType = .cooperative_matrix_properties_nv,
    p_next: ?*anyopaque = null,
    m_size: u32,
    n_size: u32,
    k_size: u32,
    a_type: ComponentTypeNV,
    b_type: ComponentTypeNV,
    c_type: ComponentTypeNV,
    d_type: ComponentTypeNV,
    scope: ScopeNV,
};
pub const PhysicalDeviceYcbcrImageArraysFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_ycbcr_image_arrays_features_ext,
    p_next: ?*anyopaque = null,
    ycbcr_image_arrays: Bool32 = .false,
};
pub const ImageViewHandleInfoNVX = extern struct {
    s_type: StructureType = .image_view_handle_info_nvx,
    p_next: ?*const anyopaque = null,
    image_view: ImageView,
    descriptor_type: DescriptorType,
    sampler: Sampler = .null_handle,
};
pub const ImageViewAddressPropertiesNVX = extern struct {
    s_type: StructureType = .image_view_address_properties_nvx,
    p_next: ?*anyopaque = null,
    device_address: DeviceAddress,
    size: DeviceSize,
};
pub const PresentFrameTokenGGP = extern struct {
    s_type: StructureType = .present_frame_token_ggp,
    p_next: ?*const anyopaque = null,
    frame_token: GgpFrameToken,
};
pub const PipelineCreationFeedback = extern struct {
    flags: PipelineCreationFeedbackFlags,
    duration: u64,
};
pub const PipelineCreationFeedbackEXT = PipelineCreationFeedback;
pub const PipelineCreationFeedbackCreateInfo = extern struct {
    s_type: StructureType = .pipeline_creation_feedback_create_info,
    p_next: ?*const anyopaque = null,
    p_pipeline_creation_feedback: *PipelineCreationFeedback,
    pipeline_stage_creation_feedback_count: u32 = 0,
    p_pipeline_stage_creation_feedbacks: ?[*]PipelineCreationFeedback = null,
};
pub const PipelineCreationFeedbackCreateInfoEXT = PipelineCreationFeedbackCreateInfo;
pub const SurfaceFullScreenExclusiveInfoEXT = extern struct {
    s_type: StructureType = .surface_full_screen_exclusive_info_ext,
    p_next: ?*anyopaque = null,
    full_screen_exclusive: FullScreenExclusiveEXT,
};
pub const SurfaceFullScreenExclusiveWin32InfoEXT = extern struct {
    s_type: StructureType = .surface_full_screen_exclusive_win32_info_ext,
    p_next: ?*const anyopaque = null,
    hmonitor: HMONITOR,
};
pub const SurfaceCapabilitiesFullScreenExclusiveEXT = extern struct {
    s_type: StructureType = .surface_capabilities_full_screen_exclusive_ext,
    p_next: ?*anyopaque = null,
    full_screen_exclusive_supported: Bool32,
};
pub const PhysicalDevicePresentBarrierFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_present_barrier_features_nv,
    p_next: ?*anyopaque = null,
    present_barrier: Bool32 = .false,
};
pub const SurfaceCapabilitiesPresentBarrierNV = extern struct {
    s_type: StructureType = .surface_capabilities_present_barrier_nv,
    p_next: ?*anyopaque = null,
    present_barrier_supported: Bool32,
};
pub const SwapchainPresentBarrierCreateInfoNV = extern struct {
    s_type: StructureType = .swapchain_present_barrier_create_info_nv,
    p_next: ?*anyopaque = null,
    present_barrier_enable: Bool32,
};
pub const PhysicalDevicePerformanceQueryFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_performance_query_features_khr,
    p_next: ?*anyopaque = null,
    performance_counter_query_pools: Bool32 = .false,
    performance_counter_multiple_query_pools: Bool32 = .false,
};
pub const PhysicalDevicePerformanceQueryPropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_performance_query_properties_khr,
    p_next: ?*anyopaque = null,
    allow_command_buffer_query_copies: Bool32,
};
pub const PerformanceCounterKHR = extern struct {
    s_type: StructureType = .performance_counter_khr,
    p_next: ?*anyopaque = null,
    unit: PerformanceCounterUnitKHR,
    scope: PerformanceCounterScopeKHR,
    storage: PerformanceCounterStorageKHR,
    uuid: [UUID_SIZE]u8,
};
pub const PerformanceCounterDescriptionKHR = extern struct {
    s_type: StructureType = .performance_counter_description_khr,
    p_next: ?*anyopaque = null,
    flags: PerformanceCounterDescriptionFlagsKHR = .{},
    name: [MAX_DESCRIPTION_SIZE]u8,
    category: [MAX_DESCRIPTION_SIZE]u8,
    description: [MAX_DESCRIPTION_SIZE]u8,
};
pub const QueryPoolPerformanceCreateInfoKHR = extern struct {
    s_type: StructureType = .query_pool_performance_create_info_khr,
    p_next: ?*const anyopaque = null,
    queue_family_index: u32,
    counter_index_count: u32,
    p_counter_indices: [*]const u32,
};
pub const PerformanceCounterResultKHR = extern union {
    int_32: i32,
    int_64: i64,
    uint_32: u32,
    uint_64: u64,
    float_32: f32,
    float_64: f64,
};
pub const AcquireProfilingLockInfoKHR = extern struct {
    s_type: StructureType = .acquire_profiling_lock_info_khr,
    p_next: ?*const anyopaque = null,
    flags: AcquireProfilingLockFlagsKHR = .{},
    timeout: u64,
};
pub const PerformanceQuerySubmitInfoKHR = extern struct {
    s_type: StructureType = .performance_query_submit_info_khr,
    p_next: ?*const anyopaque = null,
    counter_pass_index: u32,
};
pub const PerformanceQueryReservationInfoKHR = extern struct {
    s_type: StructureType,
    p_next: ?*const anyopaque = null,
    max_performance_queries_per_pool: u32,
};
pub const HeadlessSurfaceCreateInfoEXT = extern struct {
    s_type: StructureType = .headless_surface_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: HeadlessSurfaceCreateFlagsEXT = .{},
};
pub const PhysicalDeviceCoverageReductionModeFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_coverage_reduction_mode_features_nv,
    p_next: ?*anyopaque = null,
    coverage_reduction_mode: Bool32 = .false,
};
pub const PipelineCoverageReductionStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_coverage_reduction_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    flags: PipelineCoverageReductionStateCreateFlagsNV = .{},
    coverage_reduction_mode: CoverageReductionModeNV,
};
pub const FramebufferMixedSamplesCombinationNV = extern struct {
    s_type: StructureType = .framebuffer_mixed_samples_combination_nv,
    p_next: ?*anyopaque = null,
    coverage_reduction_mode: CoverageReductionModeNV,
    rasterization_samples: SampleCountFlags,
    depth_stencil_samples: SampleCountFlags,
    color_samples: SampleCountFlags,
};
pub const PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = extern struct {
    s_type: StructureType = .physical_device_shader_integer_functions_2_features_intel,
    p_next: ?*anyopaque = null,
    shader_integer_functions_2: Bool32 = .false,
};
pub const PerformanceValueDataINTEL = extern union {
    value_32: u32,
    value_64: u64,
    value_float: f32,
    value_bool: Bool32,
    value_string: [*:0]const u8,
};
pub const PerformanceValueINTEL = extern struct {
    type: PerformanceValueTypeINTEL,
    data: PerformanceValueDataINTEL,
};
pub const InitializePerformanceApiInfoINTEL = extern struct {
    s_type: StructureType = .initialize_performance_api_info_intel,
    p_next: ?*const anyopaque = null,
    p_user_data: ?*anyopaque = null,
};
pub const QueryPoolPerformanceQueryCreateInfoINTEL = extern struct {
    s_type: StructureType = .query_pool_performance_query_create_info_intel,
    p_next: ?*const anyopaque = null,
    performance_counters_sampling: QueryPoolSamplingModeINTEL,
};
pub const QueryPoolCreateInfoINTEL = QueryPoolPerformanceQueryCreateInfoINTEL;
pub const PerformanceMarkerInfoINTEL = extern struct {
    s_type: StructureType = .performance_marker_info_intel,
    p_next: ?*const anyopaque = null,
    marker: u64,
};
pub const PerformanceStreamMarkerInfoINTEL = extern struct {
    s_type: StructureType = .performance_stream_marker_info_intel,
    p_next: ?*const anyopaque = null,
    marker: u32,
};
pub const PerformanceOverrideInfoINTEL = extern struct {
    s_type: StructureType = .performance_override_info_intel,
    p_next: ?*const anyopaque = null,
    type: PerformanceOverrideTypeINTEL,
    enable: Bool32,
    parameter: u64,
};
pub const PerformanceConfigurationAcquireInfoINTEL = extern struct {
    s_type: StructureType = .performance_configuration_acquire_info_intel,
    p_next: ?*const anyopaque = null,
    type: PerformanceConfigurationTypeINTEL,
};
pub const PhysicalDeviceShaderClockFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_shader_clock_features_khr,
    p_next: ?*anyopaque = null,
    shader_subgroup_clock: Bool32 = .false,
    shader_device_clock: Bool32 = .false,
};
pub const PhysicalDeviceIndexTypeUint8Features = extern struct {
    s_type: StructureType = .physical_device_index_type_uint8_features,
    p_next: ?*anyopaque = null,
    index_type_uint_8: Bool32 = .false,
};
pub const PhysicalDeviceIndexTypeUint8FeaturesKHR = PhysicalDeviceIndexTypeUint8Features;
pub const PhysicalDeviceIndexTypeUint8FeaturesEXT = PhysicalDeviceIndexTypeUint8Features;
pub const PhysicalDeviceShaderSMBuiltinsPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_shader_sm_builtins_properties_nv,
    p_next: ?*anyopaque = null,
    shader_sm_count: u32,
    shader_warps_per_sm: u32,
};
pub const PhysicalDeviceShaderSMBuiltinsFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_shader_sm_builtins_features_nv,
    p_next: ?*anyopaque = null,
    shader_sm_builtins: Bool32 = .false,
};
pub const PhysicalDeviceFragmentShaderInterlockFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_fragment_shader_interlock_features_ext,
    p_next: ?*anyopaque = null,
    fragment_shader_sample_interlock: Bool32 = .false,
    fragment_shader_pixel_interlock: Bool32 = .false,
    fragment_shader_shading_rate_interlock: Bool32 = .false,
};
pub const PhysicalDeviceSeparateDepthStencilLayoutsFeatures = extern struct {
    s_type: StructureType = .physical_device_separate_depth_stencil_layouts_features,
    p_next: ?*anyopaque = null,
    separate_depth_stencil_layouts: Bool32 = .false,
};
pub const PhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
pub const AttachmentReferenceStencilLayout = extern struct {
    s_type: StructureType = .attachment_reference_stencil_layout,
    p_next: ?*anyopaque = null,
    stencil_layout: ImageLayout,
};
pub const PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_primitive_topology_list_restart_features_ext,
    p_next: ?*anyopaque = null,
    primitive_topology_list_restart: Bool32 = .false,
    primitive_topology_patch_list_restart: Bool32 = .false,
};
pub const AttachmentReferenceStencilLayoutKHR = AttachmentReferenceStencilLayout;
pub const AttachmentDescriptionStencilLayout = extern struct {
    s_type: StructureType = .attachment_description_stencil_layout,
    p_next: ?*anyopaque = null,
    stencil_initial_layout: ImageLayout,
    stencil_final_layout: ImageLayout,
};
pub const AttachmentDescriptionStencilLayoutKHR = AttachmentDescriptionStencilLayout;
pub const PhysicalDevicePipelineExecutablePropertiesFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_pipeline_executable_properties_features_khr,
    p_next: ?*anyopaque = null,
    pipeline_executable_info: Bool32 = .false,
};
pub const PipelineInfoKHR = extern struct {
    s_type: StructureType = .pipeline_info_khr,
    p_next: ?*const anyopaque = null,
    pipeline: Pipeline,
};
pub const PipelineInfoEXT = PipelineInfoKHR;
pub const PipelineExecutablePropertiesKHR = extern struct {
    s_type: StructureType = .pipeline_executable_properties_khr,
    p_next: ?*anyopaque = null,
    stages: ShaderStageFlags,
    name: [MAX_DESCRIPTION_SIZE]u8,
    description: [MAX_DESCRIPTION_SIZE]u8,
    subgroup_size: u32,
};
pub const PipelineExecutableInfoKHR = extern struct {
    s_type: StructureType = .pipeline_executable_info_khr,
    p_next: ?*const anyopaque = null,
    pipeline: Pipeline,
    executable_index: u32,
};
pub const PipelineExecutableStatisticValueKHR = extern union {
    b_32: Bool32,
    i_64: i64,
    u_64: u64,
    f_64: f64,
};
pub const PipelineExecutableStatisticKHR = extern struct {
    s_type: StructureType = .pipeline_executable_statistic_khr,
    p_next: ?*anyopaque = null,
    name: [MAX_DESCRIPTION_SIZE]u8,
    description: [MAX_DESCRIPTION_SIZE]u8,
    format: PipelineExecutableStatisticFormatKHR,
    value: PipelineExecutableStatisticValueKHR,
};
pub const PipelineExecutableInternalRepresentationKHR = extern struct {
    s_type: StructureType = .pipeline_executable_internal_representation_khr,
    p_next: ?*anyopaque = null,
    name: [MAX_DESCRIPTION_SIZE]u8,
    description: [MAX_DESCRIPTION_SIZE]u8,
    is_text: Bool32,
    data_size: usize,
    p_data: ?*anyopaque = null,
};
pub const PhysicalDeviceShaderDemoteToHelperInvocationFeatures = extern struct {
    s_type: StructureType = .physical_device_shader_demote_to_helper_invocation_features,
    p_next: ?*anyopaque = null,
    shader_demote_to_helper_invocation: Bool32 = .false,
};
pub const PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = PhysicalDeviceShaderDemoteToHelperInvocationFeatures;
pub const PhysicalDeviceTexelBufferAlignmentFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_texel_buffer_alignment_features_ext,
    p_next: ?*anyopaque = null,
    texel_buffer_alignment: Bool32 = .false,
};
pub const PhysicalDeviceTexelBufferAlignmentProperties = extern struct {
    s_type: StructureType = .physical_device_texel_buffer_alignment_properties,
    p_next: ?*anyopaque = null,
    storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    storage_texel_buffer_offset_single_texel_alignment: Bool32,
    uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    uniform_texel_buffer_offset_single_texel_alignment: Bool32,
};
pub const PhysicalDeviceTexelBufferAlignmentPropertiesEXT = PhysicalDeviceTexelBufferAlignmentProperties;
pub const PhysicalDeviceSubgroupSizeControlFeatures = extern struct {
    s_type: StructureType = .physical_device_subgroup_size_control_features,
    p_next: ?*anyopaque = null,
    subgroup_size_control: Bool32 = .false,
    compute_full_subgroups: Bool32 = .false,
};
pub const PhysicalDeviceSubgroupSizeControlFeaturesEXT = PhysicalDeviceSubgroupSizeControlFeatures;
pub const PhysicalDeviceSubgroupSizeControlProperties = extern struct {
    s_type: StructureType = .physical_device_subgroup_size_control_properties,
    p_next: ?*anyopaque = null,
    min_subgroup_size: u32,
    max_subgroup_size: u32,
    max_compute_workgroup_subgroups: u32,
    required_subgroup_size_stages: ShaderStageFlags,
};
pub const PhysicalDeviceSubgroupSizeControlPropertiesEXT = PhysicalDeviceSubgroupSizeControlProperties;
pub const PipelineShaderStageRequiredSubgroupSizeCreateInfo = extern struct {
    s_type: StructureType = .pipeline_shader_stage_required_subgroup_size_create_info,
    p_next: ?*anyopaque = null,
    required_subgroup_size: u32,
};
pub const PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = PipelineShaderStageRequiredSubgroupSizeCreateInfo;
pub const ShaderRequiredSubgroupSizeCreateInfoEXT = PipelineShaderStageRequiredSubgroupSizeCreateInfo;
pub const SubpassShadingPipelineCreateInfoHUAWEI = extern struct {
    s_type: StructureType = .subpass_shading_pipeline_create_info_huawei,
    p_next: ?*anyopaque = null,
    render_pass: RenderPass,
    subpass: u32,
};
pub const PhysicalDeviceSubpassShadingPropertiesHUAWEI = extern struct {
    s_type: StructureType = .physical_device_subpass_shading_properties_huawei,
    p_next: ?*anyopaque = null,
    max_subpass_shading_workgroup_size_aspect_ratio: u32,
};
pub const PhysicalDeviceClusterCullingShaderPropertiesHUAWEI = extern struct {
    s_type: StructureType = .physical_device_cluster_culling_shader_properties_huawei,
    p_next: ?*anyopaque = null,
    max_work_group_count: [3]u32,
    max_work_group_size: [3]u32,
    max_output_cluster_count: u32,
    indirect_buffer_offset_alignment: DeviceSize,
};
pub const MemoryOpaqueCaptureAddressAllocateInfo = extern struct {
    s_type: StructureType = .memory_opaque_capture_address_allocate_info,
    p_next: ?*const anyopaque = null,
    opaque_capture_address: u64,
};
pub const MemoryOpaqueCaptureAddressAllocateInfoKHR = MemoryOpaqueCaptureAddressAllocateInfo;
pub const DeviceMemoryOpaqueCaptureAddressInfo = extern struct {
    s_type: StructureType = .device_memory_opaque_capture_address_info,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory,
};
pub const DeviceMemoryOpaqueCaptureAddressInfoKHR = DeviceMemoryOpaqueCaptureAddressInfo;
pub const PhysicalDeviceLineRasterizationFeatures = extern struct {
    s_type: StructureType = .physical_device_line_rasterization_features,
    p_next: ?*anyopaque = null,
    rectangular_lines: Bool32 = .false,
    bresenham_lines: Bool32 = .false,
    smooth_lines: Bool32 = .false,
    stippled_rectangular_lines: Bool32 = .false,
    stippled_bresenham_lines: Bool32 = .false,
    stippled_smooth_lines: Bool32 = .false,
};
pub const PhysicalDeviceLineRasterizationFeaturesKHR = PhysicalDeviceLineRasterizationFeatures;
pub const PhysicalDeviceLineRasterizationFeaturesEXT = PhysicalDeviceLineRasterizationFeatures;
pub const PhysicalDeviceLineRasterizationProperties = extern struct {
    s_type: StructureType = .physical_device_line_rasterization_properties,
    p_next: ?*anyopaque = null,
    line_sub_pixel_precision_bits: u32,
};
pub const PhysicalDeviceLineRasterizationPropertiesKHR = PhysicalDeviceLineRasterizationProperties;
pub const PhysicalDeviceLineRasterizationPropertiesEXT = PhysicalDeviceLineRasterizationProperties;
pub const PipelineRasterizationLineStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_rasterization_line_state_create_info,
    p_next: ?*const anyopaque = null,
    line_rasterization_mode: LineRasterizationMode,
    stippled_line_enable: Bool32,
    line_stipple_factor: u32,
    line_stipple_pattern: u16,
};
pub const PipelineRasterizationLineStateCreateInfoKHR = PipelineRasterizationLineStateCreateInfo;
pub const PipelineRasterizationLineStateCreateInfoEXT = PipelineRasterizationLineStateCreateInfo;
pub const PhysicalDevicePipelineCreationCacheControlFeatures = extern struct {
    s_type: StructureType = .physical_device_pipeline_creation_cache_control_features,
    p_next: ?*anyopaque = null,
    pipeline_creation_cache_control: Bool32 = .false,
};
pub const PhysicalDevicePipelineCreationCacheControlFeaturesEXT = PhysicalDevicePipelineCreationCacheControlFeatures;
pub const PhysicalDeviceVulkan11Features = extern struct {
    s_type: StructureType = .physical_device_vulkan_1_1_features,
    p_next: ?*anyopaque = null,
    storage_buffer_16_bit_access: Bool32 = .false,
    uniform_and_storage_buffer_16_bit_access: Bool32 = .false,
    storage_push_constant_16: Bool32 = .false,
    storage_input_output_16: Bool32 = .false,
    multiview: Bool32 = .false,
    multiview_geometry_shader: Bool32 = .false,
    multiview_tessellation_shader: Bool32 = .false,
    variable_pointers_storage_buffer: Bool32 = .false,
    variable_pointers: Bool32 = .false,
    protected_memory: Bool32 = .false,
    sampler_ycbcr_conversion: Bool32 = .false,
    shader_draw_parameters: Bool32 = .false,
};
pub const PhysicalDeviceVulkan11Properties = extern struct {
    s_type: StructureType = .physical_device_vulkan_1_1_properties,
    p_next: ?*anyopaque = null,
    device_uuid: [UUID_SIZE]u8,
    driver_uuid: [UUID_SIZE]u8,
    device_luid: [LUID_SIZE]u8,
    device_node_mask: u32,
    device_luid_valid: Bool32,
    subgroup_size: u32,
    subgroup_supported_stages: ShaderStageFlags,
    subgroup_supported_operations: SubgroupFeatureFlags,
    subgroup_quad_operations_in_all_stages: Bool32,
    point_clipping_behavior: PointClippingBehavior,
    max_multiview_view_count: u32,
    max_multiview_instance_index: u32,
    protected_no_fault: Bool32,
    max_per_set_descriptors: u32,
    max_memory_allocation_size: DeviceSize,
};
pub const PhysicalDeviceVulkan12Features = extern struct {
    s_type: StructureType = .physical_device_vulkan_1_2_features,
    p_next: ?*anyopaque = null,
    sampler_mirror_clamp_to_edge: Bool32 = .false,
    draw_indirect_count: Bool32 = .false,
    storage_buffer_8_bit_access: Bool32 = .false,
    uniform_and_storage_buffer_8_bit_access: Bool32 = .false,
    storage_push_constant_8: Bool32 = .false,
    shader_buffer_int_64_atomics: Bool32 = .false,
    shader_shared_int_64_atomics: Bool32 = .false,
    shader_float_16: Bool32 = .false,
    shader_int_8: Bool32 = .false,
    descriptor_indexing: Bool32 = .false,
    shader_input_attachment_array_dynamic_indexing: Bool32 = .false,
    shader_uniform_texel_buffer_array_dynamic_indexing: Bool32 = .false,
    shader_storage_texel_buffer_array_dynamic_indexing: Bool32 = .false,
    shader_uniform_buffer_array_non_uniform_indexing: Bool32 = .false,
    shader_sampled_image_array_non_uniform_indexing: Bool32 = .false,
    shader_storage_buffer_array_non_uniform_indexing: Bool32 = .false,
    shader_storage_image_array_non_uniform_indexing: Bool32 = .false,
    shader_input_attachment_array_non_uniform_indexing: Bool32 = .false,
    shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32 = .false,
    shader_storage_texel_buffer_array_non_uniform_indexing: Bool32 = .false,
    descriptor_binding_uniform_buffer_update_after_bind: Bool32 = .false,
    descriptor_binding_sampled_image_update_after_bind: Bool32 = .false,
    descriptor_binding_storage_image_update_after_bind: Bool32 = .false,
    descriptor_binding_storage_buffer_update_after_bind: Bool32 = .false,
    descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32 = .false,
    descriptor_binding_storage_texel_buffer_update_after_bind: Bool32 = .false,
    descriptor_binding_update_unused_while_pending: Bool32 = .false,
    descriptor_binding_partially_bound: Bool32 = .false,
    descriptor_binding_variable_descriptor_count: Bool32 = .false,
    runtime_descriptor_array: Bool32 = .false,
    sampler_filter_minmax: Bool32 = .false,
    scalar_block_layout: Bool32 = .false,
    imageless_framebuffer: Bool32 = .false,
    uniform_buffer_standard_layout: Bool32 = .false,
    shader_subgroup_extended_types: Bool32 = .false,
    separate_depth_stencil_layouts: Bool32 = .false,
    host_query_reset: Bool32 = .false,
    timeline_semaphore: Bool32 = .false,
    buffer_device_address: Bool32 = .false,
    buffer_device_address_capture_replay: Bool32 = .false,
    buffer_device_address_multi_device: Bool32 = .false,
    vulkan_memory_model: Bool32 = .false,
    vulkan_memory_model_device_scope: Bool32 = .false,
    vulkan_memory_model_availability_visibility_chains: Bool32 = .false,
    shader_output_viewport_index: Bool32 = .false,
    shader_output_layer: Bool32 = .false,
    subgroup_broadcast_dynamic_id: Bool32 = .false,
};
pub const PhysicalDeviceVulkan12Properties = extern struct {
    s_type: StructureType = .physical_device_vulkan_1_2_properties,
    p_next: ?*anyopaque = null,
    driver_id: DriverId,
    driver_name: [MAX_DRIVER_NAME_SIZE]u8,
    driver_info: [MAX_DRIVER_INFO_SIZE]u8,
    conformance_version: ConformanceVersion,
    denorm_behavior_independence: ShaderFloatControlsIndependence,
    rounding_mode_independence: ShaderFloatControlsIndependence,
    shader_signed_zero_inf_nan_preserve_float_16: Bool32,
    shader_signed_zero_inf_nan_preserve_float_32: Bool32,
    shader_signed_zero_inf_nan_preserve_float_64: Bool32,
    shader_denorm_preserve_float_16: Bool32,
    shader_denorm_preserve_float_32: Bool32,
    shader_denorm_preserve_float_64: Bool32,
    shader_denorm_flush_to_zero_float_16: Bool32,
    shader_denorm_flush_to_zero_float_32: Bool32,
    shader_denorm_flush_to_zero_float_64: Bool32,
    shader_rounding_mode_rte_float_16: Bool32,
    shader_rounding_mode_rte_float_32: Bool32,
    shader_rounding_mode_rte_float_64: Bool32,
    shader_rounding_mode_rtz_float_16: Bool32,
    shader_rounding_mode_rtz_float_32: Bool32,
    shader_rounding_mode_rtz_float_64: Bool32,
    max_update_after_bind_descriptors_in_all_pools: u32,
    shader_uniform_buffer_array_non_uniform_indexing_native: Bool32,
    shader_sampled_image_array_non_uniform_indexing_native: Bool32,
    shader_storage_buffer_array_non_uniform_indexing_native: Bool32,
    shader_storage_image_array_non_uniform_indexing_native: Bool32,
    shader_input_attachment_array_non_uniform_indexing_native: Bool32,
    robust_buffer_access_update_after_bind: Bool32,
    quad_divergent_implicit_lod: Bool32,
    max_per_stage_descriptor_update_after_bind_samplers: u32,
    max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
    max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
    max_per_stage_descriptor_update_after_bind_sampled_images: u32,
    max_per_stage_descriptor_update_after_bind_storage_images: u32,
    max_per_stage_descriptor_update_after_bind_input_attachments: u32,
    max_per_stage_update_after_bind_resources: u32,
    max_descriptor_set_update_after_bind_samplers: u32,
    max_descriptor_set_update_after_bind_uniform_buffers: u32,
    max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
    max_descriptor_set_update_after_bind_storage_buffers: u32,
    max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
    max_descriptor_set_update_after_bind_sampled_images: u32,
    max_descriptor_set_update_after_bind_storage_images: u32,
    max_descriptor_set_update_after_bind_input_attachments: u32,
    supported_depth_resolve_modes: ResolveModeFlags,
    supported_stencil_resolve_modes: ResolveModeFlags,
    independent_resolve_none: Bool32,
    independent_resolve: Bool32,
    filter_minmax_single_component_formats: Bool32,
    filter_minmax_image_component_mapping: Bool32,
    max_timeline_semaphore_value_difference: u64,
    framebuffer_integer_color_sample_counts: SampleCountFlags = .{},
};
pub const PhysicalDeviceVulkan13Features = extern struct {
    s_type: StructureType = .physical_device_vulkan_1_3_features,
    p_next: ?*anyopaque = null,
    robust_image_access: Bool32 = .false,
    inline_uniform_block: Bool32 = .false,
    descriptor_binding_inline_uniform_block_update_after_bind: Bool32 = .false,
    pipeline_creation_cache_control: Bool32 = .false,
    private_data: Bool32 = .false,
    shader_demote_to_helper_invocation: Bool32 = .false,
    shader_terminate_invocation: Bool32 = .false,
    subgroup_size_control: Bool32 = .false,
    compute_full_subgroups: Bool32 = .false,
    synchronization_2: Bool32 = .false,
    texture_compression_astc_hdr: Bool32 = .false,
    shader_zero_initialize_workgroup_memory: Bool32 = .false,
    dynamic_rendering: Bool32 = .false,
    shader_integer_dot_product: Bool32 = .false,
    maintenance_4: Bool32 = .false,
};
pub const PhysicalDeviceVulkan13Properties = extern struct {
    s_type: StructureType = .physical_device_vulkan_1_3_properties,
    p_next: ?*anyopaque = null,
    min_subgroup_size: u32,
    max_subgroup_size: u32,
    max_compute_workgroup_subgroups: u32,
    required_subgroup_size_stages: ShaderStageFlags,
    max_inline_uniform_block_size: u32,
    max_per_stage_descriptor_inline_uniform_blocks: u32,
    max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    max_descriptor_set_inline_uniform_blocks: u32,
    max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
    max_inline_uniform_total_size: u32,
    integer_dot_product_8_bit_unsigned_accelerated: Bool32,
    integer_dot_product_8_bit_signed_accelerated: Bool32,
    integer_dot_product_8_bit_mixed_signedness_accelerated: Bool32,
    integer_dot_product_4x_8_bit_packed_unsigned_accelerated: Bool32,
    integer_dot_product_4x_8_bit_packed_signed_accelerated: Bool32,
    integer_dot_product_4x_8_bit_packed_mixed_signedness_accelerated: Bool32,
    integer_dot_product_16_bit_unsigned_accelerated: Bool32,
    integer_dot_product_16_bit_signed_accelerated: Bool32,
    integer_dot_product_16_bit_mixed_signedness_accelerated: Bool32,
    integer_dot_product_32_bit_unsigned_accelerated: Bool32,
    integer_dot_product_32_bit_signed_accelerated: Bool32,
    integer_dot_product_32_bit_mixed_signedness_accelerated: Bool32,
    integer_dot_product_64_bit_unsigned_accelerated: Bool32,
    integer_dot_product_64_bit_signed_accelerated: Bool32,
    integer_dot_product_64_bit_mixed_signedness_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_8_bit_unsigned_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_8_bit_signed_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_8_bit_mixed_signedness_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_4x_8_bit_packed_unsigned_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_4x_8_bit_packed_signed_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_4x_8_bit_packed_mixed_signedness_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_16_bit_unsigned_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_16_bit_signed_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_16_bit_mixed_signedness_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_32_bit_unsigned_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_32_bit_signed_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_32_bit_mixed_signedness_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_64_bit_unsigned_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_64_bit_signed_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_64_bit_mixed_signedness_accelerated: Bool32,
    storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    storage_texel_buffer_offset_single_texel_alignment: Bool32,
    uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    uniform_texel_buffer_offset_single_texel_alignment: Bool32,
    max_buffer_size: DeviceSize,
};
pub const PhysicalDeviceVulkan14Features = extern struct {
    s_type: StructureType = .physical_device_vulkan_1_4_features,
    p_next: ?*anyopaque = null,
    global_priority_query: Bool32 = .false,
    shader_subgroup_rotate: Bool32 = .false,
    shader_subgroup_rotate_clustered: Bool32 = .false,
    shader_float_controls_2: Bool32 = .false,
    shader_expect_assume: Bool32 = .false,
    rectangular_lines: Bool32 = .false,
    bresenham_lines: Bool32 = .false,
    smooth_lines: Bool32 = .false,
    stippled_rectangular_lines: Bool32 = .false,
    stippled_bresenham_lines: Bool32 = .false,
    stippled_smooth_lines: Bool32 = .false,
    vertex_attribute_instance_rate_divisor: Bool32 = .false,
    vertex_attribute_instance_rate_zero_divisor: Bool32 = .false,
    index_type_uint_8: Bool32 = .false,
    dynamic_rendering_local_read: Bool32 = .false,
    maintenance_5: Bool32 = .false,
    maintenance_6: Bool32 = .false,
    pipeline_protected_access: Bool32 = .false,
    pipeline_robustness: Bool32 = .false,
    host_image_copy: Bool32 = .false,
    push_descriptor: Bool32 = .false,
};
pub const PhysicalDeviceVulkan14Properties = extern struct {
    s_type: StructureType = .physical_device_vulkan_1_4_properties,
    p_next: ?*anyopaque = null,
    line_sub_pixel_precision_bits: u32,
    max_vertex_attrib_divisor: u32,
    supports_non_zero_first_instance: Bool32,
    max_push_descriptors: u32,
    dynamic_rendering_local_read_depth_stencil_attachments: Bool32,
    dynamic_rendering_local_read_multisampled_attachments: Bool32,
    early_fragment_multisample_coverage_after_sample_counting: Bool32,
    early_fragment_sample_mask_test_before_sample_counting: Bool32,
    depth_stencil_swizzle_one_support: Bool32,
    polygon_mode_point_size: Bool32,
    non_strict_single_pixel_wide_lines_use_parallelogram: Bool32,
    non_strict_wide_lines_use_parallelogram: Bool32,
    block_texel_view_compatible_multiple_layers: Bool32,
    max_combined_image_sampler_descriptor_count: u32,
    fragment_shading_rate_clamp_combiner_inputs: Bool32,
    default_robustness_storage_buffers: PipelineRobustnessBufferBehavior,
    default_robustness_uniform_buffers: PipelineRobustnessBufferBehavior,
    default_robustness_vertex_inputs: PipelineRobustnessBufferBehavior,
    default_robustness_images: PipelineRobustnessImageBehavior,
    copy_src_layout_count: u32 = 0,
    p_copy_src_layouts: ?[*]ImageLayout = null,
    copy_dst_layout_count: u32 = 0,
    p_copy_dst_layouts: ?[*]ImageLayout = null,
    optimal_tiling_layout_uuid: [UUID_SIZE]u8,
    identical_memory_type_requirements: Bool32,
};
pub const PipelineCompilerControlCreateInfoAMD = extern struct {
    s_type: StructureType = .pipeline_compiler_control_create_info_amd,
    p_next: ?*const anyopaque = null,
    compiler_control_flags: PipelineCompilerControlFlagsAMD = .{},
};
pub const PhysicalDeviceCoherentMemoryFeaturesAMD = extern struct {
    s_type: StructureType = .physical_device_coherent_memory_features_amd,
    p_next: ?*anyopaque = null,
    device_coherent_memory: Bool32 = .false,
};
pub const FaultData = extern struct {
    s_type: StructureType,
    p_next: ?*anyopaque = null,
    fault_level: FaultLevel,
    fault_type: FaultType,
};
pub const FaultCallbackInfo = extern struct {
    s_type: StructureType,
    p_next: ?*const anyopaque = null,
    fault_count: u32 = 0,
    p_faults: ?[*]FaultData = null,
    pfn_fault_callback: PfnFaultCallbackFunction,
};
pub const PhysicalDeviceToolProperties = extern struct {
    s_type: StructureType = .physical_device_tool_properties,
    p_next: ?*anyopaque = null,
    name: [MAX_EXTENSION_NAME_SIZE]u8,
    version: [MAX_EXTENSION_NAME_SIZE]u8,
    purposes: ToolPurposeFlags,
    description: [MAX_DESCRIPTION_SIZE]u8,
    layer: [MAX_EXTENSION_NAME_SIZE]u8,
};
pub const PhysicalDeviceToolPropertiesEXT = PhysicalDeviceToolProperties;
pub const SamplerCustomBorderColorCreateInfoEXT = extern struct {
    s_type: StructureType = .sampler_custom_border_color_create_info_ext,
    p_next: ?*const anyopaque = null,
    custom_border_color: ClearColorValue,
    format: Format,
};
pub const PhysicalDeviceCustomBorderColorPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_custom_border_color_properties_ext,
    p_next: ?*anyopaque = null,
    max_custom_border_color_samplers: u32,
};
pub const PhysicalDeviceCustomBorderColorFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_custom_border_color_features_ext,
    p_next: ?*anyopaque = null,
    custom_border_colors: Bool32 = .false,
    custom_border_color_without_format: Bool32 = .false,
};
pub const SamplerBorderColorComponentMappingCreateInfoEXT = extern struct {
    s_type: StructureType = .sampler_border_color_component_mapping_create_info_ext,
    p_next: ?*const anyopaque = null,
    components: ComponentMapping,
    srgb: Bool32,
};
pub const PhysicalDeviceBorderColorSwizzleFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_border_color_swizzle_features_ext,
    p_next: ?*anyopaque = null,
    border_color_swizzle: Bool32 = .false,
    border_color_swizzle_from_image: Bool32 = .false,
};
pub const DeviceOrHostAddressKHR = extern union {
    device_address: DeviceAddress,
    host_address: *anyopaque,
};
pub const DeviceOrHostAddressConstKHR = extern union {
    device_address: DeviceAddress,
    host_address: *const anyopaque,
};
pub const DeviceOrHostAddressConstAMDX = extern union {
    device_address: DeviceAddress,
    host_address: *const anyopaque,
};
pub const AccelerationStructureGeometryTrianglesDataKHR = extern struct {
    s_type: StructureType = .acceleration_structure_geometry_triangles_data_khr,
    p_next: ?*const anyopaque = null,
    vertex_format: Format,
    vertex_data: DeviceOrHostAddressConstKHR,
    vertex_stride: DeviceSize,
    max_vertex: u32,
    index_type: IndexType,
    index_data: DeviceOrHostAddressConstKHR,
    transform_data: DeviceOrHostAddressConstKHR,
};
pub const AccelerationStructureGeometryAabbsDataKHR = extern struct {
    s_type: StructureType = .acceleration_structure_geometry_aabbs_data_khr,
    p_next: ?*const anyopaque = null,
    data: DeviceOrHostAddressConstKHR,
    stride: DeviceSize,
};
pub const AccelerationStructureGeometryInstancesDataKHR = extern struct {
    s_type: StructureType = .acceleration_structure_geometry_instances_data_khr,
    p_next: ?*const anyopaque = null,
    array_of_pointers: Bool32,
    data: DeviceOrHostAddressConstKHR,
};
pub const AccelerationStructureGeometryLinearSweptSpheresDataNV = extern struct {
    s_type: StructureType = .acceleration_structure_geometry_linear_swept_spheres_data_nv,
    p_next: ?*const anyopaque = null,
    vertex_format: Format,
    vertex_data: DeviceOrHostAddressConstKHR,
    vertex_stride: DeviceSize,
    radius_format: Format,
    radius_data: DeviceOrHostAddressConstKHR,
    radius_stride: DeviceSize,
    index_type: IndexType,
    index_data: DeviceOrHostAddressConstKHR,
    index_stride: DeviceSize,
    indexing_mode: RayTracingLssIndexingModeNV,
    end_caps_mode: RayTracingLssPrimitiveEndCapsModeNV,
};
pub const AccelerationStructureGeometrySpheresDataNV = extern struct {
    s_type: StructureType = .acceleration_structure_geometry_spheres_data_nv,
    p_next: ?*const anyopaque = null,
    vertex_format: Format,
    vertex_data: DeviceOrHostAddressConstKHR,
    vertex_stride: DeviceSize,
    radius_format: Format,
    radius_data: DeviceOrHostAddressConstKHR,
    radius_stride: DeviceSize,
    index_type: IndexType,
    index_data: DeviceOrHostAddressConstKHR,
    index_stride: DeviceSize,
};
pub const AccelerationStructureGeometryDataKHR = extern union {
    triangles: AccelerationStructureGeometryTrianglesDataKHR,
    aabbs: AccelerationStructureGeometryAabbsDataKHR,
    instances: AccelerationStructureGeometryInstancesDataKHR,
};
pub const AccelerationStructureGeometryKHR = extern struct {
    s_type: StructureType = .acceleration_structure_geometry_khr,
    p_next: ?*const anyopaque = null,
    geometry_type: GeometryTypeKHR,
    geometry: AccelerationStructureGeometryDataKHR,
    flags: GeometryFlagsKHR = .{},
};
pub const AccelerationStructureBuildGeometryInfoKHR = extern struct {
    s_type: StructureType = .acceleration_structure_build_geometry_info_khr,
    p_next: ?*const anyopaque = null,
    type: AccelerationStructureTypeKHR,
    flags: BuildAccelerationStructureFlagsKHR = .{},
    mode: BuildAccelerationStructureModeKHR,
    src_acceleration_structure: AccelerationStructureKHR = .null_handle,
    dst_acceleration_structure: AccelerationStructureKHR = .null_handle,
    geometry_count: u32 = 0,
    p_geometries: ?[*]const AccelerationStructureGeometryKHR = null,
    pp_geometries: ?[*]const [*]const AccelerationStructureGeometryKHR = null,
    scratch_data: DeviceOrHostAddressKHR,
};
pub const AccelerationStructureBuildRangeInfoKHR = extern struct {
    primitive_count: u32,
    primitive_offset: u32,
    first_vertex: u32,
    transform_offset: u32,
};
pub const AccelerationStructureCreateInfoKHR = extern struct {
    s_type: StructureType = .acceleration_structure_create_info_khr,
    p_next: ?*const anyopaque = null,
    create_flags: AccelerationStructureCreateFlagsKHR = .{},
    buffer: Buffer,
    offset: DeviceSize,
    size: DeviceSize,
    type: AccelerationStructureTypeKHR,
    device_address: DeviceAddress = 0,
};
pub const AabbPositionsKHR = extern struct {
    min_x: f32,
    min_y: f32,
    min_z: f32,
    max_x: f32,
    max_y: f32,
    max_z: f32,
};
pub const AabbPositionsNV = AabbPositionsKHR;
pub const TransformMatrixKHR = extern struct {
    matrix: [3][4]f32,
};
pub const TransformMatrixNV = TransformMatrixKHR;
pub const AccelerationStructureInstanceKHR = extern struct {
    transform: TransformMatrixKHR,
    instance_custom_index_and_mask: packed struct(u32) {
        instance_custom_index: u24,
        mask: u8,
    },
    instance_shader_binding_table_record_offset_and_flags: packed struct(u32) {
        instance_shader_binding_table_record_offset: u24,
        flags: u8, // GeometryInstanceFlagsKHR
    },
    acceleration_structure_reference: u64,
};
pub const AccelerationStructureInstanceNV = extern struct {
    transform: TransformMatrixNV,
    instance_custom_index_and_mask: packed struct(u32) {
        instance_custom_index: u24,
        mask: u8,
    },
    instance_shader_binding_table_record_offset_and_flags: packed struct(u32) {
        instance_shader_binding_table_record_offset: u24,
        flags: u8, // GeometryInstanceFlagsKHR
    },
    acceleration_structure_reference: u64,
};
pub const AccelerationStructureDeviceAddressInfoKHR = extern struct {
    s_type: StructureType = .acceleration_structure_device_address_info_khr,
    p_next: ?*const anyopaque = null,
    acceleration_structure: AccelerationStructureKHR,
};
pub const AccelerationStructureVersionInfoKHR = extern struct {
    s_type: StructureType = .acceleration_structure_version_info_khr,
    p_next: ?*const anyopaque = null,
    p_version_data: [*]const u8,
};
pub const CopyAccelerationStructureInfoKHR = extern struct {
    s_type: StructureType = .copy_acceleration_structure_info_khr,
    p_next: ?*const anyopaque = null,
    src: AccelerationStructureKHR,
    dst: AccelerationStructureKHR,
    mode: CopyAccelerationStructureModeKHR,
};
pub const CopyAccelerationStructureToMemoryInfoKHR = extern struct {
    s_type: StructureType = .copy_acceleration_structure_to_memory_info_khr,
    p_next: ?*const anyopaque = null,
    src: AccelerationStructureKHR,
    dst: DeviceOrHostAddressKHR,
    mode: CopyAccelerationStructureModeKHR,
};
pub const CopyMemoryToAccelerationStructureInfoKHR = extern struct {
    s_type: StructureType = .copy_memory_to_acceleration_structure_info_khr,
    p_next: ?*const anyopaque = null,
    src: DeviceOrHostAddressConstKHR,
    dst: AccelerationStructureKHR,
    mode: CopyAccelerationStructureModeKHR,
};
pub const RayTracingPipelineInterfaceCreateInfoKHR = extern struct {
    s_type: StructureType = .ray_tracing_pipeline_interface_create_info_khr,
    p_next: ?*const anyopaque = null,
    max_pipeline_ray_payload_size: u32,
    max_pipeline_ray_hit_attribute_size: u32,
};
pub const PipelineLibraryCreateInfoKHR = extern struct {
    s_type: StructureType = .pipeline_library_create_info_khr,
    p_next: ?*const anyopaque = null,
    library_count: u32 = 0,
    p_libraries: ?[*]const Pipeline = null,
};
pub const RefreshObjectKHR = extern struct {
    object_type: ObjectType,
    object_handle: u64,
    flags: RefreshObjectFlagsKHR = .{},
};
pub const RefreshObjectListKHR = extern struct {
    s_type: StructureType = .refresh_object_list_khr,
    p_next: ?*const anyopaque = null,
    object_count: u32,
    p_objects: [*]const RefreshObjectKHR,
};
pub const PhysicalDeviceExtendedDynamicStateFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_extended_dynamic_state_features_ext,
    p_next: ?*anyopaque = null,
    extended_dynamic_state: Bool32 = .false,
};
pub const PhysicalDeviceExtendedDynamicState2FeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_extended_dynamic_state_2_features_ext,
    p_next: ?*anyopaque = null,
    extended_dynamic_state_2: Bool32 = .false,
    extended_dynamic_state_2_logic_op: Bool32 = .false,
    extended_dynamic_state_2_patch_control_points: Bool32 = .false,
};
pub const PhysicalDeviceExtendedDynamicState3FeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_extended_dynamic_state_3_features_ext,
    p_next: ?*anyopaque = null,
    extended_dynamic_state_3_tessellation_domain_origin: Bool32 = .false,
    extended_dynamic_state_3_depth_clamp_enable: Bool32 = .false,
    extended_dynamic_state_3_polygon_mode: Bool32 = .false,
    extended_dynamic_state_3_rasterization_samples: Bool32 = .false,
    extended_dynamic_state_3_sample_mask: Bool32 = .false,
    extended_dynamic_state_3_alpha_to_coverage_enable: Bool32 = .false,
    extended_dynamic_state_3_alpha_to_one_enable: Bool32 = .false,
    extended_dynamic_state_3_logic_op_enable: Bool32 = .false,
    extended_dynamic_state_3_color_blend_enable: Bool32 = .false,
    extended_dynamic_state_3_color_blend_equation: Bool32 = .false,
    extended_dynamic_state_3_color_write_mask: Bool32 = .false,
    extended_dynamic_state_3_rasterization_stream: Bool32 = .false,
    extended_dynamic_state_3_conservative_rasterization_mode: Bool32 = .false,
    extended_dynamic_state_3_extra_primitive_overestimation_size: Bool32 = .false,
    extended_dynamic_state_3_depth_clip_enable: Bool32 = .false,
    extended_dynamic_state_3_sample_locations_enable: Bool32 = .false,
    extended_dynamic_state_3_color_blend_advanced: Bool32 = .false,
    extended_dynamic_state_3_provoking_vertex_mode: Bool32 = .false,
    extended_dynamic_state_3_line_rasterization_mode: Bool32 = .false,
    extended_dynamic_state_3_line_stipple_enable: Bool32 = .false,
    extended_dynamic_state_3_depth_clip_negative_one_to_one: Bool32 = .false,
    extended_dynamic_state_3_viewport_w_scaling_enable: Bool32 = .false,
    extended_dynamic_state_3_viewport_swizzle: Bool32 = .false,
    extended_dynamic_state_3_coverage_to_color_enable: Bool32 = .false,
    extended_dynamic_state_3_coverage_to_color_location: Bool32 = .false,
    extended_dynamic_state_3_coverage_modulation_mode: Bool32 = .false,
    extended_dynamic_state_3_coverage_modulation_table_enable: Bool32 = .false,
    extended_dynamic_state_3_coverage_modulation_table: Bool32 = .false,
    extended_dynamic_state_3_coverage_reduction_mode: Bool32 = .false,
    extended_dynamic_state_3_representative_fragment_test_enable: Bool32 = .false,
    extended_dynamic_state_3_shading_rate_image_enable: Bool32 = .false,
};
pub const PhysicalDeviceExtendedDynamicState3PropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_extended_dynamic_state_3_properties_ext,
    p_next: ?*anyopaque = null,
    dynamic_primitive_topology_unrestricted: Bool32,
};
pub const ColorBlendEquationEXT = extern struct {
    src_color_blend_factor: BlendFactor,
    dst_color_blend_factor: BlendFactor,
    color_blend_op: BlendOp,
    src_alpha_blend_factor: BlendFactor,
    dst_alpha_blend_factor: BlendFactor,
    alpha_blend_op: BlendOp,
};
pub const ColorBlendAdvancedEXT = extern struct {
    advanced_blend_op: BlendOp,
    src_premultiplied: Bool32,
    dst_premultiplied: Bool32,
    blend_overlap: BlendOverlapEXT,
    clamp_results: Bool32,
};
pub const RenderPassTransformBeginInfoQCOM = extern struct {
    s_type: StructureType = .render_pass_transform_begin_info_qcom,
    p_next: ?*const anyopaque = null,
    transform: SurfaceTransformFlagsKHR,
};
pub const CopyCommandTransformInfoQCOM = extern struct {
    s_type: StructureType = .copy_command_transform_info_qcom,
    p_next: ?*const anyopaque = null,
    transform: SurfaceTransformFlagsKHR,
};
pub const CommandBufferInheritanceRenderPassTransformInfoQCOM = extern struct {
    s_type: StructureType = .command_buffer_inheritance_render_pass_transform_info_qcom,
    p_next: ?*const anyopaque = null,
    transform: SurfaceTransformFlagsKHR,
    render_area: Rect2D,
};
pub const PhysicalDevicePartitionedAccelerationStructureFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_partitioned_acceleration_structure_features_nv,
    p_next: ?*anyopaque = null,
    partitioned_acceleration_structure: Bool32 = .false,
};
pub const PhysicalDevicePartitionedAccelerationStructurePropertiesNV = extern struct {
    s_type: StructureType = .physical_device_partitioned_acceleration_structure_properties_nv,
    p_next: ?*anyopaque = null,
    max_partition_count: u32,
};
pub const BuildPartitionedAccelerationStructureIndirectCommandNV = extern struct {
    op_type: PartitionedAccelerationStructureOpTypeNV,
    arg_count: u32,
    arg_data: StridedDeviceAddressNV,
};
pub const PartitionedAccelerationStructureFlagsNV = extern struct {
    s_type: StructureType = .partitioned_acceleration_structure_flags_nv,
    p_next: ?*anyopaque = null,
    enable_partition_translation: Bool32,
};
pub const PartitionedAccelerationStructureWriteInstanceDataNV = extern struct {
    transform: TransformMatrixKHR,
    explicit_aabb: [6]f32,
    instance_id: u32,
    instance_mask: u32,
    instance_contribution_to_hit_group_index: u32,
    instance_flags: PartitionedAccelerationStructureInstanceFlagsNV = .{},
    instance_index: u32,
    partition_index: u32,
    acceleration_structure: DeviceAddress,
};
pub const PartitionedAccelerationStructureUpdateInstanceDataNV = extern struct {
    instance_index: u32,
    instance_contribution_to_hit_group_index: u32,
    acceleration_structure: DeviceAddress,
};
pub const PartitionedAccelerationStructureWritePartitionTranslationDataNV = extern struct {
    partition_index: u32,
    partition_translation: [3]f32,
};
pub const WriteDescriptorSetPartitionedAccelerationStructureNV = extern struct {
    s_type: StructureType = .write_descriptor_set_partitioned_acceleration_structure_nv,
    p_next: ?*anyopaque = null,
    acceleration_structure_count: u32,
    p_acceleration_structures: [*]const DeviceAddress,
};
pub const PartitionedAccelerationStructureInstancesInputNV = extern struct {
    s_type: StructureType = .partitioned_acceleration_structure_instances_input_nv,
    p_next: ?*anyopaque = null,
    flags: BuildAccelerationStructureFlagsKHR = .{},
    instance_count: u32,
    max_instance_per_partition_count: u32,
    partition_count: u32,
    max_instance_in_global_partition_count: u32,
};
pub const BuildPartitionedAccelerationStructureInfoNV = extern struct {
    s_type: StructureType = .build_partitioned_acceleration_structure_info_nv,
    p_next: ?*anyopaque = null,
    input: PartitionedAccelerationStructureInstancesInputNV,
    src_acceleration_structure_data: DeviceAddress,
    dst_acceleration_structure_data: DeviceAddress,
    scratch_data: DeviceAddress,
    src_infos: DeviceAddress,
    src_infos_count: DeviceAddress,
};
pub const PhysicalDeviceDiagnosticsConfigFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_diagnostics_config_features_nv,
    p_next: ?*anyopaque = null,
    diagnostics_config: Bool32 = .false,
};
pub const DeviceDiagnosticsConfigCreateInfoNV = extern struct {
    s_type: StructureType = .device_diagnostics_config_create_info_nv,
    p_next: ?*const anyopaque = null,
    flags: DeviceDiagnosticsConfigFlagsNV = .{},
};
pub const PipelineOfflineCreateInfo = extern struct {
    s_type: StructureType,
    p_next: ?*const anyopaque = null,
    pipeline_identifier: [UUID_SIZE]u8,
    match_control: PipelineMatchControl,
    pool_entry_size: DeviceSize,
};
pub const PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = extern struct {
    s_type: StructureType = .physical_device_zero_initialize_workgroup_memory_features,
    p_next: ?*anyopaque = null,
    shader_zero_initialize_workgroup_memory: Bool32 = .false,
};
pub const PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
pub const PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_shader_subgroup_uniform_control_flow_features_khr,
    p_next: ?*anyopaque = null,
    shader_subgroup_uniform_control_flow: Bool32 = .false,
};
pub const PhysicalDeviceRobustness2FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_robustness_2_features_khr,
    p_next: ?*anyopaque = null,
    robust_buffer_access_2: Bool32 = .false,
    robust_image_access_2: Bool32 = .false,
    null_descriptor: Bool32 = .false,
};
pub const PhysicalDeviceRobustness2FeaturesEXT = PhysicalDeviceRobustness2FeaturesKHR;
pub const PhysicalDeviceRobustness2PropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_robustness_2_properties_khr,
    p_next: ?*anyopaque = null,
    robust_storage_buffer_access_size_alignment: DeviceSize,
    robust_uniform_buffer_access_size_alignment: DeviceSize,
};
pub const PhysicalDeviceRobustness2PropertiesEXT = PhysicalDeviceRobustness2PropertiesKHR;
pub const PhysicalDeviceImageRobustnessFeatures = extern struct {
    s_type: StructureType = .physical_device_image_robustness_features,
    p_next: ?*anyopaque = null,
    robust_image_access: Bool32 = .false,
};
pub const PhysicalDeviceImageRobustnessFeaturesEXT = PhysicalDeviceImageRobustnessFeatures;
pub const PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_workgroup_memory_explicit_layout_features_khr,
    p_next: ?*anyopaque = null,
    workgroup_memory_explicit_layout: Bool32 = .false,
    workgroup_memory_explicit_layout_scalar_block_layout: Bool32 = .false,
    workgroup_memory_explicit_layout_8_bit_access: Bool32 = .false,
    workgroup_memory_explicit_layout_16_bit_access: Bool32 = .false,
};
pub const PhysicalDevicePortabilitySubsetFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_portability_subset_features_khr,
    p_next: ?*anyopaque = null,
    constant_alpha_color_blend_factors: Bool32 = .false,
    events: Bool32 = .false,
    image_view_format_reinterpretation: Bool32 = .false,
    image_view_format_swizzle: Bool32 = .false,
    image_view_2d_on_3d_image: Bool32 = .false,
    multisample_array_image: Bool32 = .false,
    mutable_comparison_samplers: Bool32 = .false,
    point_polygons: Bool32 = .false,
    sampler_mip_lod_bias: Bool32 = .false,
    separate_stencil_mask_ref: Bool32 = .false,
    shader_sample_rate_interpolation_functions: Bool32 = .false,
    tessellation_isolines: Bool32 = .false,
    tessellation_point_mode: Bool32 = .false,
    triangle_fans: Bool32 = .false,
    vertex_attribute_access_beyond_stride: Bool32 = .false,
};
pub const PhysicalDevicePortabilitySubsetPropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_portability_subset_properties_khr,
    p_next: ?*anyopaque = null,
    min_vertex_input_binding_stride_alignment: u32,
};
pub const PhysicalDevice4444FormatsFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_4444_formats_features_ext,
    p_next: ?*anyopaque = null,
    format_a4r4g4b4: Bool32 = .false,
    format_a4b4g4r4: Bool32 = .false,
};
pub const PhysicalDeviceSubpassShadingFeaturesHUAWEI = extern struct {
    s_type: StructureType = .physical_device_subpass_shading_features_huawei,
    p_next: ?*anyopaque = null,
    subpass_shading: Bool32 = .false,
};
pub const PhysicalDeviceClusterCullingShaderFeaturesHUAWEI = extern struct {
    s_type: StructureType = .physical_device_cluster_culling_shader_features_huawei,
    p_next: ?*anyopaque = null,
    clusterculling_shader: Bool32 = .false,
    multiview_cluster_culling_shader: Bool32 = .false,
};
pub const PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI = extern struct {
    s_type: StructureType = .physical_device_cluster_culling_shader_vrs_features_huawei,
    p_next: ?*anyopaque = null,
    cluster_shading_rate: Bool32,
};
pub const BufferCopy2 = extern struct {
    s_type: StructureType = .buffer_copy_2,
    p_next: ?*const anyopaque = null,
    src_offset: DeviceSize,
    dst_offset: DeviceSize,
    size: DeviceSize,
};
pub const BufferCopy2KHR = BufferCopy2;
pub const ImageCopy2 = extern struct {
    s_type: StructureType = .image_copy_2,
    p_next: ?*const anyopaque = null,
    src_subresource: ImageSubresourceLayers,
    src_offset: Offset3D,
    dst_subresource: ImageSubresourceLayers,
    dst_offset: Offset3D,
    extent: Extent3D,
};
pub const ImageCopy2KHR = ImageCopy2;
pub const ImageBlit2 = extern struct {
    s_type: StructureType = .image_blit_2,
    p_next: ?*const anyopaque = null,
    src_subresource: ImageSubresourceLayers,
    src_offsets: [2]Offset3D,
    dst_subresource: ImageSubresourceLayers,
    dst_offsets: [2]Offset3D,
};
pub const ImageBlit2KHR = ImageBlit2;
pub const BufferImageCopy2 = extern struct {
    s_type: StructureType = .buffer_image_copy_2,
    p_next: ?*const anyopaque = null,
    buffer_offset: DeviceSize,
    buffer_row_length: u32,
    buffer_image_height: u32,
    image_subresource: ImageSubresourceLayers,
    image_offset: Offset3D,
    image_extent: Extent3D,
};
pub const BufferImageCopy2KHR = BufferImageCopy2;
pub const ImageResolve2 = extern struct {
    s_type: StructureType = .image_resolve_2,
    p_next: ?*const anyopaque = null,
    src_subresource: ImageSubresourceLayers,
    src_offset: Offset3D,
    dst_subresource: ImageSubresourceLayers,
    dst_offset: Offset3D,
    extent: Extent3D,
};
pub const ImageResolve2KHR = ImageResolve2;
pub const CopyBufferInfo2 = extern struct {
    s_type: StructureType = .copy_buffer_info_2,
    p_next: ?*const anyopaque = null,
    src_buffer: Buffer,
    dst_buffer: Buffer,
    region_count: u32,
    p_regions: [*]const BufferCopy2,
};
pub const CopyBufferInfo2KHR = CopyBufferInfo2;
pub const CopyImageInfo2 = extern struct {
    s_type: StructureType = .copy_image_info_2,
    p_next: ?*const anyopaque = null,
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: [*]const ImageCopy2,
};
pub const CopyImageInfo2KHR = CopyImageInfo2;
pub const BlitImageInfo2 = extern struct {
    s_type: StructureType = .blit_image_info_2,
    p_next: ?*const anyopaque = null,
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: [*]const ImageBlit2,
    filter: Filter,
};
pub const BlitImageInfo2KHR = BlitImageInfo2;
pub const CopyBufferToImageInfo2 = extern struct {
    s_type: StructureType = .copy_buffer_to_image_info_2,
    p_next: ?*const anyopaque = null,
    src_buffer: Buffer,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: [*]const BufferImageCopy2,
};
pub const CopyBufferToImageInfo2KHR = CopyBufferToImageInfo2;
pub const CopyImageToBufferInfo2 = extern struct {
    s_type: StructureType = .copy_image_to_buffer_info_2,
    p_next: ?*const anyopaque = null,
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_buffer: Buffer,
    region_count: u32,
    p_regions: [*]const BufferImageCopy2,
};
pub const CopyImageToBufferInfo2KHR = CopyImageToBufferInfo2;
pub const ResolveImageInfo2 = extern struct {
    s_type: StructureType = .resolve_image_info_2,
    p_next: ?*const anyopaque = null,
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: [*]const ImageResolve2,
};
pub const ResolveImageInfo2KHR = ResolveImageInfo2;
pub const PhysicalDeviceShaderImageAtomicInt64FeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_image_atomic_int64_features_ext,
    p_next: ?*anyopaque = null,
    shader_image_int_64_atomics: Bool32 = .false,
    sparse_image_int_64_atomics: Bool32 = .false,
};
pub const FragmentShadingRateAttachmentInfoKHR = extern struct {
    s_type: StructureType = .fragment_shading_rate_attachment_info_khr,
    p_next: ?*const anyopaque = null,
    p_fragment_shading_rate_attachment: ?*const AttachmentReference2 = null,
    shading_rate_attachment_texel_size: Extent2D,
};
pub const PipelineFragmentShadingRateStateCreateInfoKHR = extern struct {
    s_type: StructureType = .pipeline_fragment_shading_rate_state_create_info_khr,
    p_next: ?*const anyopaque = null,
    fragment_size: Extent2D,
    combiner_ops: [2]FragmentShadingRateCombinerOpKHR,
};
pub const PhysicalDeviceFragmentShadingRateFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_fragment_shading_rate_features_khr,
    p_next: ?*anyopaque = null,
    pipeline_fragment_shading_rate: Bool32 = .false,
    primitive_fragment_shading_rate: Bool32 = .false,
    attachment_fragment_shading_rate: Bool32 = .false,
};
pub const PhysicalDeviceFragmentShadingRatePropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_fragment_shading_rate_properties_khr,
    p_next: ?*anyopaque = null,
    min_fragment_shading_rate_attachment_texel_size: Extent2D,
    max_fragment_shading_rate_attachment_texel_size: Extent2D,
    max_fragment_shading_rate_attachment_texel_size_aspect_ratio: u32,
    primitive_fragment_shading_rate_with_multiple_viewports: Bool32,
    layered_shading_rate_attachments: Bool32,
    fragment_shading_rate_non_trivial_combiner_ops: Bool32,
    max_fragment_size: Extent2D,
    max_fragment_size_aspect_ratio: u32,
    max_fragment_shading_rate_coverage_samples: u32,
    max_fragment_shading_rate_rasterization_samples: SampleCountFlags,
    fragment_shading_rate_with_shader_depth_stencil_writes: Bool32,
    fragment_shading_rate_with_sample_mask: Bool32,
    fragment_shading_rate_with_shader_sample_mask: Bool32,
    fragment_shading_rate_with_conservative_rasterization: Bool32,
    fragment_shading_rate_with_fragment_shader_interlock: Bool32,
    fragment_shading_rate_with_custom_sample_locations: Bool32,
    fragment_shading_rate_strict_multiply_combiner: Bool32,
};
pub const PhysicalDeviceFragmentShadingRateKHR = extern struct {
    s_type: StructureType = .physical_device_fragment_shading_rate_khr,
    p_next: ?*anyopaque = null,
    sample_counts: SampleCountFlags,
    fragment_size: Extent2D,
};
pub const PhysicalDeviceShaderTerminateInvocationFeatures = extern struct {
    s_type: StructureType = .physical_device_shader_terminate_invocation_features,
    p_next: ?*anyopaque = null,
    shader_terminate_invocation: Bool32 = .false,
};
pub const PhysicalDeviceShaderTerminateInvocationFeaturesKHR = PhysicalDeviceShaderTerminateInvocationFeatures;
pub const PhysicalDeviceFragmentShadingRateEnumsFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_fragment_shading_rate_enums_features_nv,
    p_next: ?*anyopaque = null,
    fragment_shading_rate_enums: Bool32 = .false,
    supersample_fragment_shading_rates: Bool32 = .false,
    no_invocation_fragment_shading_rates: Bool32 = .false,
};
pub const PhysicalDeviceFragmentShadingRateEnumsPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_fragment_shading_rate_enums_properties_nv,
    p_next: ?*anyopaque = null,
    max_fragment_shading_rate_invocation_count: SampleCountFlags,
};
pub const PipelineFragmentShadingRateEnumStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_fragment_shading_rate_enum_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    shading_rate_type: FragmentShadingRateTypeNV,
    shading_rate: FragmentShadingRateNV,
    combiner_ops: [2]FragmentShadingRateCombinerOpKHR,
};
pub const AccelerationStructureBuildSizesInfoKHR = extern struct {
    s_type: StructureType = .acceleration_structure_build_sizes_info_khr,
    p_next: ?*const anyopaque = null,
    acceleration_structure_size: DeviceSize,
    update_scratch_size: DeviceSize,
    build_scratch_size: DeviceSize,
};
pub const PhysicalDeviceImage2DViewOf3DFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_image_2d_view_of_3d_features_ext,
    p_next: ?*anyopaque = null,
    image_2d_view_of_3d: Bool32 = .false,
    sampler_2d_view_of_3d: Bool32 = .false,
};
pub const PhysicalDeviceImageSlicedViewOf3DFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_image_sliced_view_of_3d_features_ext,
    p_next: ?*anyopaque = null,
    image_sliced_view_of_3d: Bool32 = .false,
};
pub const PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_attachment_feedback_loop_dynamic_state_features_ext,
    p_next: ?*anyopaque = null,
    attachment_feedback_loop_dynamic_state: Bool32 = .false,
};
pub const PhysicalDeviceLegacyVertexAttributesFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_legacy_vertex_attributes_features_ext,
    p_next: ?*anyopaque = null,
    legacy_vertex_attributes: Bool32 = .false,
};
pub const PhysicalDeviceLegacyVertexAttributesPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_legacy_vertex_attributes_properties_ext,
    p_next: ?*anyopaque = null,
    native_unaligned_performance: Bool32,
};
pub const PhysicalDeviceMutableDescriptorTypeFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_mutable_descriptor_type_features_ext,
    p_next: ?*anyopaque = null,
    mutable_descriptor_type: Bool32 = .false,
};
pub const PhysicalDeviceMutableDescriptorTypeFeaturesVALVE = PhysicalDeviceMutableDescriptorTypeFeaturesEXT;
pub const MutableDescriptorTypeListEXT = extern struct {
    descriptor_type_count: u32 = 0,
    p_descriptor_types: ?[*]const DescriptorType = null,
};
pub const MutableDescriptorTypeListVALVE = MutableDescriptorTypeListEXT;
pub const MutableDescriptorTypeCreateInfoEXT = extern struct {
    s_type: StructureType = .mutable_descriptor_type_create_info_ext,
    p_next: ?*const anyopaque = null,
    mutable_descriptor_type_list_count: u32 = 0,
    p_mutable_descriptor_type_lists: ?[*]const MutableDescriptorTypeListEXT = null,
};
pub const MutableDescriptorTypeCreateInfoVALVE = MutableDescriptorTypeCreateInfoEXT;
pub const PhysicalDeviceDepthClipControlFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_depth_clip_control_features_ext,
    p_next: ?*anyopaque = null,
    depth_clip_control: Bool32 = .false,
};
pub const PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_zero_initialize_device_memory_features_ext,
    p_next: ?*anyopaque = null,
    zero_initialize_device_memory: Bool32 = .false,
};
pub const PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_device_generated_commands_features_ext,
    p_next: ?*anyopaque = null,
    device_generated_commands: Bool32 = .false,
    dynamic_generated_pipeline_layout: Bool32 = .false,
};
pub const PhysicalDeviceDeviceGeneratedCommandsPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_device_generated_commands_properties_ext,
    p_next: ?*anyopaque = null,
    max_indirect_pipeline_count: u32,
    max_indirect_shader_object_count: u32,
    max_indirect_sequence_count: u32,
    max_indirect_commands_token_count: u32,
    max_indirect_commands_token_offset: u32,
    max_indirect_commands_indirect_stride: u32,
    supported_indirect_commands_input_modes: IndirectCommandsInputModeFlagsEXT,
    supported_indirect_commands_shader_stages: ShaderStageFlags,
    supported_indirect_commands_shader_stages_pipeline_binding: ShaderStageFlags,
    supported_indirect_commands_shader_stages_shader_binding: ShaderStageFlags,
    device_generated_commands_transform_feedback: Bool32,
    device_generated_commands_multi_draw_indirect_count: Bool32,
};
pub const GeneratedCommandsPipelineInfoEXT = extern struct {
    s_type: StructureType = .generated_commands_pipeline_info_ext,
    p_next: ?*anyopaque = null,
    pipeline: Pipeline,
};
pub const GeneratedCommandsShaderInfoEXT = extern struct {
    s_type: StructureType = .generated_commands_shader_info_ext,
    p_next: ?*anyopaque = null,
    shader_count: u32,
    p_shaders: [*]const ShaderEXT,
};
pub const GeneratedCommandsMemoryRequirementsInfoEXT = extern struct {
    s_type: StructureType = .generated_commands_memory_requirements_info_ext,
    p_next: ?*const anyopaque = null,
    indirect_execution_set: IndirectExecutionSetEXT = .null_handle,
    indirect_commands_layout: IndirectCommandsLayoutEXT,
    max_sequence_count: u32,
    max_draw_count: u32,
};
pub const IndirectExecutionSetPipelineInfoEXT = extern struct {
    s_type: StructureType = .indirect_execution_set_pipeline_info_ext,
    p_next: ?*const anyopaque = null,
    initial_pipeline: Pipeline,
    max_pipeline_count: u32,
};
pub const IndirectExecutionSetShaderLayoutInfoEXT = extern struct {
    s_type: StructureType = .indirect_execution_set_shader_layout_info_ext,
    p_next: ?*const anyopaque = null,
    set_layout_count: u32 = 0,
    p_set_layouts: ?[*]const DescriptorSetLayout = null,
};
pub const IndirectExecutionSetShaderInfoEXT = extern struct {
    s_type: StructureType = .indirect_execution_set_shader_info_ext,
    p_next: ?*const anyopaque = null,
    shader_count: u32,
    p_initial_shaders: [*]const ShaderEXT,
    p_set_layout_infos: ?[*]const IndirectExecutionSetShaderLayoutInfoEXT = null,
    max_shader_count: u32,
    push_constant_range_count: u32 = 0,
    p_push_constant_ranges: ?[*]const PushConstantRange = null,
};
pub const IndirectExecutionSetInfoEXT = extern union {
    p_pipeline_info: *const IndirectExecutionSetPipelineInfoEXT,
    p_shader_info: *const IndirectExecutionSetShaderInfoEXT,
};
pub const IndirectExecutionSetCreateInfoEXT = extern struct {
    s_type: StructureType = .indirect_execution_set_create_info_ext,
    p_next: ?*const anyopaque = null,
    type: IndirectExecutionSetInfoTypeEXT,
    info: IndirectExecutionSetInfoEXT,
};
pub const GeneratedCommandsInfoEXT = extern struct {
    s_type: StructureType = .generated_commands_info_ext,
    p_next: ?*const anyopaque = null,
    shader_stages: ShaderStageFlags,
    indirect_execution_set: IndirectExecutionSetEXT = .null_handle,
    indirect_commands_layout: IndirectCommandsLayoutEXT,
    indirect_address: DeviceAddress,
    indirect_address_size: DeviceSize,
    preprocess_address: DeviceAddress = 0,
    preprocess_size: DeviceSize,
    max_sequence_count: u32,
    sequence_count_address: DeviceAddress = 0,
    max_draw_count: u32,
};
pub const WriteIndirectExecutionSetPipelineEXT = extern struct {
    s_type: StructureType = .write_indirect_execution_set_pipeline_ext,
    p_next: ?*const anyopaque = null,
    index: u32,
    pipeline: Pipeline,
};
pub const WriteIndirectExecutionSetShaderEXT = extern struct {
    s_type: StructureType = .write_indirect_execution_set_shader_ext,
    p_next: ?*const anyopaque = null,
    index: u32,
    shader: ShaderEXT,
};
pub const IndirectCommandsLayoutCreateInfoEXT = extern struct {
    s_type: StructureType = .indirect_commands_layout_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: IndirectCommandsLayoutUsageFlagsEXT = .{},
    shader_stages: ShaderStageFlags,
    indirect_stride: u32,
    pipeline_layout: PipelineLayout = .null_handle,
    token_count: u32,
    p_tokens: [*]const IndirectCommandsLayoutTokenEXT,
};
pub const IndirectCommandsLayoutTokenEXT = extern struct {
    s_type: StructureType = .indirect_commands_layout_token_ext,
    p_next: ?*const anyopaque = null,
    type: IndirectCommandsTokenTypeEXT,
    data: IndirectCommandsTokenDataEXT,
    offset: u32,
};
pub const DrawIndirectCountIndirectCommandEXT = extern struct {
    buffer_address: DeviceAddress,
    stride: u32,
    command_count: u32,
};
pub const IndirectCommandsVertexBufferTokenEXT = extern struct {
    vertex_binding_unit: u32,
};
pub const BindVertexBufferIndirectCommandEXT = extern struct {
    buffer_address: DeviceAddress,
    size: u32,
    stride: u32,
};
pub const IndirectCommandsIndexBufferTokenEXT = extern struct {
    mode: IndirectCommandsInputModeFlagsEXT,
};
pub const BindIndexBufferIndirectCommandEXT = extern struct {
    buffer_address: DeviceAddress,
    size: u32,
    index_type: IndexType,
};
pub const IndirectCommandsPushConstantTokenEXT = extern struct {
    update_range: PushConstantRange,
};
pub const IndirectCommandsExecutionSetTokenEXT = extern struct {
    type: IndirectExecutionSetInfoTypeEXT,
    shader_stages: ShaderStageFlags,
};
pub const IndirectCommandsTokenDataEXT = extern union {
    p_push_constant: *const IndirectCommandsPushConstantTokenEXT,
    p_vertex_buffer: *const IndirectCommandsVertexBufferTokenEXT,
    p_index_buffer: *const IndirectCommandsIndexBufferTokenEXT,
    p_execution_set: *const IndirectCommandsExecutionSetTokenEXT,
};
pub const PipelineViewportDepthClipControlCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_viewport_depth_clip_control_create_info_ext,
    p_next: ?*const anyopaque = null,
    negative_one_to_one: Bool32,
};
pub const PhysicalDeviceDepthClampControlFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_depth_clamp_control_features_ext,
    p_next: ?*anyopaque = null,
    depth_clamp_control: Bool32 = .false,
};
pub const PipelineViewportDepthClampControlCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_viewport_depth_clamp_control_create_info_ext,
    p_next: ?*const anyopaque = null,
    depth_clamp_mode: DepthClampModeEXT,
    p_depth_clamp_range: ?*const DepthClampRangeEXT = null,
};
pub const PhysicalDeviceVertexInputDynamicStateFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_vertex_input_dynamic_state_features_ext,
    p_next: ?*anyopaque = null,
    vertex_input_dynamic_state: Bool32 = .false,
};
pub const PhysicalDeviceExternalMemoryRDMAFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_external_memory_rdma_features_nv,
    p_next: ?*anyopaque = null,
    external_memory_rdma: Bool32 = .false,
};
pub const PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_shader_relaxed_extended_instruction_features_khr,
    p_next: ?*anyopaque = null,
    shader_relaxed_extended_instruction: Bool32 = .false,
};
pub const VertexInputBindingDescription2EXT = extern struct {
    s_type: StructureType = .vertex_input_binding_description_2_ext,
    p_next: ?*anyopaque = null,
    binding: u32,
    stride: u32,
    input_rate: VertexInputRate,
    divisor: u32,
};
pub const VertexInputAttributeDescription2EXT = extern struct {
    s_type: StructureType = .vertex_input_attribute_description_2_ext,
    p_next: ?*anyopaque = null,
    location: u32,
    binding: u32,
    format: Format,
    offset: u32,
};
pub const PhysicalDeviceColorWriteEnableFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_color_write_enable_features_ext,
    p_next: ?*anyopaque = null,
    color_write_enable: Bool32 = .false,
};
pub const PipelineColorWriteCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_color_write_create_info_ext,
    p_next: ?*const anyopaque = null,
    attachment_count: u32 = 0,
    p_color_write_enables: ?[*]const Bool32 = null,
};
pub const MemoryBarrier2 = extern struct {
    s_type: StructureType = .memory_barrier_2,
    p_next: ?*const anyopaque = null,
    src_stage_mask: PipelineStageFlags2 = .{},
    src_access_mask: AccessFlags2 = .{},
    dst_stage_mask: PipelineStageFlags2 = .{},
    dst_access_mask: AccessFlags2 = .{},
};
pub const MemoryBarrier2KHR = MemoryBarrier2;
pub const ImageMemoryBarrier2 = extern struct {
    s_type: StructureType = .image_memory_barrier_2,
    p_next: ?*const anyopaque = null,
    src_stage_mask: PipelineStageFlags2 = .{},
    src_access_mask: AccessFlags2 = .{},
    dst_stage_mask: PipelineStageFlags2 = .{},
    dst_access_mask: AccessFlags2 = .{},
    old_layout: ImageLayout,
    new_layout: ImageLayout,
    src_queue_family_index: u32,
    dst_queue_family_index: u32,
    image: Image,
    subresource_range: ImageSubresourceRange,
};
pub const ImageMemoryBarrier2KHR = ImageMemoryBarrier2;
pub const BufferMemoryBarrier2 = extern struct {
    s_type: StructureType = .buffer_memory_barrier_2,
    p_next: ?*const anyopaque = null,
    src_stage_mask: PipelineStageFlags2 = .{},
    src_access_mask: AccessFlags2 = .{},
    dst_stage_mask: PipelineStageFlags2 = .{},
    dst_access_mask: AccessFlags2 = .{},
    src_queue_family_index: u32,
    dst_queue_family_index: u32,
    buffer: Buffer,
    offset: DeviceSize,
    size: DeviceSize,
};
pub const BufferMemoryBarrier2KHR = BufferMemoryBarrier2;
pub const MemoryBarrierAccessFlags3KHR = extern struct {
    s_type: StructureType = .memory_barrier_access_flags_3_khr,
    p_next: ?*const anyopaque = null,
    src_access_mask_3: AccessFlags3KHR = .{},
    dst_access_mask_3: AccessFlags3KHR = .{},
};
pub const DependencyInfo = extern struct {
    s_type: StructureType = .dependency_info,
    p_next: ?*const anyopaque = null,
    dependency_flags: DependencyFlags = .{},
    memory_barrier_count: u32 = 0,
    p_memory_barriers: ?[*]const MemoryBarrier2 = null,
    buffer_memory_barrier_count: u32 = 0,
    p_buffer_memory_barriers: ?[*]const BufferMemoryBarrier2 = null,
    image_memory_barrier_count: u32 = 0,
    p_image_memory_barriers: ?[*]const ImageMemoryBarrier2 = null,
};
pub const DependencyInfoKHR = DependencyInfo;
pub const SemaphoreSubmitInfo = extern struct {
    s_type: StructureType = .semaphore_submit_info,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore,
    value: u64,
    stage_mask: PipelineStageFlags2 = .{},
    device_index: u32,
};
pub const SemaphoreSubmitInfoKHR = SemaphoreSubmitInfo;
pub const CommandBufferSubmitInfo = extern struct {
    s_type: StructureType = .command_buffer_submit_info,
    p_next: ?*const anyopaque = null,
    command_buffer: CommandBuffer,
    device_mask: u32,
};
pub const CommandBufferSubmitInfoKHR = CommandBufferSubmitInfo;
pub const SubmitInfo2 = extern struct {
    s_type: StructureType = .submit_info_2,
    p_next: ?*const anyopaque = null,
    flags: SubmitFlags = .{},
    wait_semaphore_info_count: u32 = 0,
    p_wait_semaphore_infos: ?[*]const SemaphoreSubmitInfo = null,
    command_buffer_info_count: u32 = 0,
    p_command_buffer_infos: ?[*]const CommandBufferSubmitInfo = null,
    signal_semaphore_info_count: u32 = 0,
    p_signal_semaphore_infos: ?[*]const SemaphoreSubmitInfo = null,
};
pub const SubmitInfo2KHR = SubmitInfo2;
pub const QueueFamilyCheckpointProperties2NV = extern struct {
    s_type: StructureType = .queue_family_checkpoint_properties_2_nv,
    p_next: ?*anyopaque = null,
    checkpoint_execution_stage_mask: PipelineStageFlags2,
};
pub const CheckpointData2NV = extern struct {
    s_type: StructureType = .checkpoint_data_2_nv,
    p_next: ?*anyopaque = null,
    stage: PipelineStageFlags2,
    p_checkpoint_marker: *anyopaque,
};
pub const PhysicalDeviceSynchronization2Features = extern struct {
    s_type: StructureType = .physical_device_synchronization_2_features,
    p_next: ?*anyopaque = null,
    synchronization_2: Bool32 = .false,
};
pub const PhysicalDeviceSynchronization2FeaturesKHR = PhysicalDeviceSynchronization2Features;
pub const PhysicalDeviceUnifiedImageLayoutsFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_unified_image_layouts_features_khr,
    p_next: ?*anyopaque = null,
    unified_image_layouts: Bool32 = .false,
    unified_image_layouts_video: Bool32 = .false,
};
pub const PhysicalDeviceHostImageCopyFeatures = extern struct {
    s_type: StructureType = .physical_device_host_image_copy_features,
    p_next: ?*anyopaque = null,
    host_image_copy: Bool32 = .false,
};
pub const PhysicalDeviceHostImageCopyFeaturesEXT = PhysicalDeviceHostImageCopyFeatures;
pub const PhysicalDeviceHostImageCopyProperties = extern struct {
    s_type: StructureType = .physical_device_host_image_copy_properties,
    p_next: ?*anyopaque = null,
    copy_src_layout_count: u32 = 0,
    p_copy_src_layouts: ?[*]ImageLayout = null,
    copy_dst_layout_count: u32 = 0,
    p_copy_dst_layouts: ?[*]ImageLayout = null,
    optimal_tiling_layout_uuid: [UUID_SIZE]u8,
    identical_memory_type_requirements: Bool32,
};
pub const PhysicalDeviceHostImageCopyPropertiesEXT = PhysicalDeviceHostImageCopyProperties;
pub const MemoryToImageCopy = extern struct {
    s_type: StructureType = .memory_to_image_copy,
    p_next: ?*const anyopaque = null,
    p_host_pointer: *const anyopaque,
    memory_row_length: u32,
    memory_image_height: u32,
    image_subresource: ImageSubresourceLayers,
    image_offset: Offset3D,
    image_extent: Extent3D,
};
pub const MemoryToImageCopyEXT = MemoryToImageCopy;
pub const ImageToMemoryCopy = extern struct {
    s_type: StructureType = .image_to_memory_copy,
    p_next: ?*const anyopaque = null,
    p_host_pointer: *anyopaque,
    memory_row_length: u32,
    memory_image_height: u32,
    image_subresource: ImageSubresourceLayers,
    image_offset: Offset3D,
    image_extent: Extent3D,
};
pub const ImageToMemoryCopyEXT = ImageToMemoryCopy;
pub const CopyMemoryToImageInfo = extern struct {
    s_type: StructureType = .copy_memory_to_image_info,
    p_next: ?*const anyopaque = null,
    flags: HostImageCopyFlags = .{},
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: [*]const MemoryToImageCopy,
};
pub const CopyMemoryToImageInfoEXT = CopyMemoryToImageInfo;
pub const CopyImageToMemoryInfo = extern struct {
    s_type: StructureType = .copy_image_to_memory_info,
    p_next: ?*const anyopaque = null,
    flags: HostImageCopyFlags = .{},
    src_image: Image,
    src_image_layout: ImageLayout,
    region_count: u32,
    p_regions: [*]const ImageToMemoryCopy,
};
pub const CopyImageToMemoryInfoEXT = CopyImageToMemoryInfo;
pub const CopyImageToImageInfo = extern struct {
    s_type: StructureType = .copy_image_to_image_info,
    p_next: ?*const anyopaque = null,
    flags: HostImageCopyFlags = .{},
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: [*]const ImageCopy2,
};
pub const CopyImageToImageInfoEXT = CopyImageToImageInfo;
pub const HostImageLayoutTransitionInfo = extern struct {
    s_type: StructureType = .host_image_layout_transition_info,
    p_next: ?*const anyopaque = null,
    image: Image,
    old_layout: ImageLayout,
    new_layout: ImageLayout,
    subresource_range: ImageSubresourceRange,
};
pub const HostImageLayoutTransitionInfoEXT = HostImageLayoutTransitionInfo;
pub const SubresourceHostMemcpySize = extern struct {
    s_type: StructureType = .subresource_host_memcpy_size,
    p_next: ?*anyopaque = null,
    size: DeviceSize,
};
pub const SubresourceHostMemcpySizeEXT = SubresourceHostMemcpySize;
pub const HostImageCopyDevicePerformanceQuery = extern struct {
    s_type: StructureType = .host_image_copy_device_performance_query,
    p_next: ?*anyopaque = null,
    optimal_device_access: Bool32,
    identical_memory_layout: Bool32,
};
pub const HostImageCopyDevicePerformanceQueryEXT = HostImageCopyDevicePerformanceQuery;
pub const PhysicalDeviceVulkanSC10Properties = extern struct {
    s_type: StructureType,
    p_next: ?*anyopaque = null,
    device_no_dynamic_host_allocations: Bool32,
    device_destroy_frees_memory: Bool32,
    command_pool_multiple_command_buffers_recording: Bool32,
    command_pool_reset_command_buffer: Bool32,
    command_buffer_simultaneous_use: Bool32,
    secondary_command_buffer_null_or_imageless_framebuffer: Bool32,
    recycle_descriptor_set_memory: Bool32,
    recycle_pipeline_memory: Bool32,
    max_render_pass_subpasses: u32,
    max_render_pass_dependencies: u32,
    max_subpass_input_attachments: u32,
    max_subpass_preserve_attachments: u32,
    max_framebuffer_attachments: u32,
    max_descriptor_set_layout_bindings: u32,
    max_query_fault_count: u32,
    max_callback_fault_count: u32,
    max_command_pool_command_buffers: u32,
    max_command_buffer_size: DeviceSize,
};
pub const PipelinePoolSize = extern struct {
    s_type: StructureType,
    p_next: ?*const anyopaque = null,
    pool_entry_size: DeviceSize,
    pool_entry_count: u32,
};
pub const DeviceObjectReservationCreateInfo = extern struct {
    s_type: StructureType,
    p_next: ?*const anyopaque = null,
    pipeline_cache_create_info_count: u32 = 0,
    p_pipeline_cache_create_infos: ?[*]const PipelineCacheCreateInfo = null,
    pipeline_pool_size_count: u32 = 0,
    p_pipeline_pool_sizes: ?[*]const PipelinePoolSize = null,
    semaphore_request_count: u32 = 0,
    command_buffer_request_count: u32 = 0,
    fence_request_count: u32 = 0,
    device_memory_request_count: u32 = 0,
    buffer_request_count: u32 = 0,
    image_request_count: u32 = 0,
    event_request_count: u32 = 0,
    query_pool_request_count: u32 = 0,
    buffer_view_request_count: u32 = 0,
    image_view_request_count: u32 = 0,
    layered_image_view_request_count: u32 = 0,
    pipeline_cache_request_count: u32 = 0,
    pipeline_layout_request_count: u32 = 0,
    render_pass_request_count: u32 = 0,
    graphics_pipeline_request_count: u32 = 0,
    compute_pipeline_request_count: u32 = 0,
    descriptor_set_layout_request_count: u32 = 0,
    sampler_request_count: u32 = 0,
    descriptor_pool_request_count: u32 = 0,
    descriptor_set_request_count: u32 = 0,
    framebuffer_request_count: u32 = 0,
    command_pool_request_count: u32 = 0,
    sampler_ycbcr_conversion_request_count: u32 = 0,
    surface_request_count: u32 = 0,
    swapchain_request_count: u32 = 0,
    display_mode_request_count: u32 = 0,
    subpass_description_request_count: u32 = 0,
    attachment_description_request_count: u32 = 0,
    descriptor_set_layout_binding_request_count: u32 = 0,
    descriptor_set_layout_binding_limit: u32,
    max_image_view_mip_levels: u32,
    max_image_view_array_layers: u32,
    max_layered_image_view_mip_levels: u32,
    max_occlusion_queries_per_pool: u32,
    max_pipeline_statistics_queries_per_pool: u32,
    max_timestamp_queries_per_pool: u32,
    max_immutable_samplers_per_descriptor_set_layout: u32,
};
pub const CommandPoolMemoryReservationCreateInfo = extern struct {
    s_type: StructureType,
    p_next: ?*const anyopaque = null,
    command_pool_reserved_size: DeviceSize,
    command_pool_max_command_buffers: u32,
};
pub const CommandPoolMemoryConsumption = extern struct {
    s_type: StructureType,
    p_next: ?*anyopaque = null,
    command_pool_allocated: DeviceSize,
    command_pool_reserved_size: DeviceSize,
    command_buffer_allocated: DeviceSize,
};
pub const PhysicalDeviceVulkanSC10Features = extern struct {
    s_type: StructureType,
    p_next: ?*anyopaque = null,
    shader_atomic_instructions: Bool32 = .false,
};
pub const PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_primitives_generated_query_features_ext,
    p_next: ?*anyopaque = null,
    primitives_generated_query: Bool32 = .false,
    primitives_generated_query_with_rasterizer_discard: Bool32 = .false,
    primitives_generated_query_with_non_zero_streams: Bool32 = .false,
};
pub const PhysicalDeviceLegacyDitheringFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_legacy_dithering_features_ext,
    p_next: ?*anyopaque = null,
    legacy_dithering: Bool32 = .false,
};
pub const PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_multisampled_render_to_single_sampled_features_ext,
    p_next: ?*anyopaque = null,
    multisampled_render_to_single_sampled: Bool32 = .false,
};
pub const SurfaceCapabilitiesPresentId2KHR = extern struct {
    s_type: StructureType = .surface_capabilities_present_id_2_khr,
    p_next: ?*anyopaque = null,
    present_id_2_supported: Bool32,
};
pub const SurfaceCapabilitiesPresentWait2KHR = extern struct {
    s_type: StructureType = .surface_capabilities_present_wait_2_khr,
    p_next: ?*anyopaque = null,
    present_wait_2_supported: Bool32,
};
pub const SubpassResolvePerformanceQueryEXT = extern struct {
    s_type: StructureType = .subpass_resolve_performance_query_ext,
    p_next: ?*anyopaque = null,
    optimal: Bool32,
};
pub const MultisampledRenderToSingleSampledInfoEXT = extern struct {
    s_type: StructureType = .multisampled_render_to_single_sampled_info_ext,
    p_next: ?*const anyopaque = null,
    multisampled_render_to_single_sampled_enable: Bool32,
    rasterization_samples: SampleCountFlags,
};
pub const PhysicalDevicePipelineProtectedAccessFeatures = extern struct {
    s_type: StructureType = .physical_device_pipeline_protected_access_features,
    p_next: ?*anyopaque = null,
    pipeline_protected_access: Bool32 = .false,
};
pub const PhysicalDevicePipelineProtectedAccessFeaturesEXT = PhysicalDevicePipelineProtectedAccessFeatures;
pub const QueueFamilyVideoPropertiesKHR = extern struct {
    s_type: StructureType = .queue_family_video_properties_khr,
    p_next: ?*anyopaque = null,
    video_codec_operations: VideoCodecOperationFlagsKHR,
};
pub const QueueFamilyQueryResultStatusPropertiesKHR = extern struct {
    s_type: StructureType = .queue_family_query_result_status_properties_khr,
    p_next: ?*anyopaque = null,
    query_result_status_support: Bool32,
};
pub const VideoProfileListInfoKHR = extern struct {
    s_type: StructureType = .video_profile_list_info_khr,
    p_next: ?*const anyopaque = null,
    profile_count: u32 = 0,
    p_profiles: ?[*]const VideoProfileInfoKHR = null,
};
pub const PhysicalDeviceVideoFormatInfoKHR = extern struct {
    s_type: StructureType = .physical_device_video_format_info_khr,
    p_next: ?*const anyopaque = null,
    image_usage: ImageUsageFlags,
};
pub const VideoFormatPropertiesKHR = extern struct {
    s_type: StructureType = .video_format_properties_khr,
    p_next: ?*anyopaque = null,
    format: Format,
    component_mapping: ComponentMapping,
    image_create_flags: ImageCreateFlags,
    image_type: ImageType,
    image_tiling: ImageTiling,
    image_usage_flags: ImageUsageFlags,
};
pub const VideoEncodeQuantizationMapCapabilitiesKHR = extern struct {
    s_type: StructureType = .video_encode_quantization_map_capabilities_khr,
    p_next: ?*anyopaque = null,
    max_quantization_map_extent: Extent2D,
};
pub const VideoEncodeH264QuantizationMapCapabilitiesKHR = extern struct {
    s_type: StructureType = .video_encode_h264_quantization_map_capabilities_khr,
    p_next: ?*anyopaque = null,
    min_qp_delta: i32,
    max_qp_delta: i32,
};
pub const VideoEncodeH265QuantizationMapCapabilitiesKHR = extern struct {
    s_type: StructureType = .video_encode_h265_quantization_map_capabilities_khr,
    p_next: ?*anyopaque = null,
    min_qp_delta: i32,
    max_qp_delta: i32,
};
pub const VideoEncodeAV1QuantizationMapCapabilitiesKHR = extern struct {
    s_type: StructureType = .video_encode_av1_quantization_map_capabilities_khr,
    p_next: ?*anyopaque = null,
    min_q_index_delta: i32,
    max_q_index_delta: i32,
};
pub const VideoFormatQuantizationMapPropertiesKHR = extern struct {
    s_type: StructureType = .video_format_quantization_map_properties_khr,
    p_next: ?*anyopaque = null,
    quantization_map_texel_size: Extent2D,
};
pub const VideoFormatH265QuantizationMapPropertiesKHR = extern struct {
    s_type: StructureType = .video_format_h265_quantization_map_properties_khr,
    p_next: ?*anyopaque = null,
    compatible_ctb_sizes: VideoEncodeH265CtbSizeFlagsKHR,
};
pub const VideoFormatAV1QuantizationMapPropertiesKHR = extern struct {
    s_type: StructureType = .video_format_av1_quantization_map_properties_khr,
    p_next: ?*anyopaque = null,
    compatible_superblock_sizes: VideoEncodeAV1SuperblockSizeFlagsKHR,
};
pub const VideoProfileInfoKHR = extern struct {
    s_type: StructureType = .video_profile_info_khr,
    p_next: ?*const anyopaque = null,
    video_codec_operation: VideoCodecOperationFlagsKHR,
    chroma_subsampling: VideoChromaSubsamplingFlagsKHR,
    luma_bit_depth: VideoComponentBitDepthFlagsKHR,
    chroma_bit_depth: VideoComponentBitDepthFlagsKHR = .{},
};
pub const VideoCapabilitiesKHR = extern struct {
    s_type: StructureType = .video_capabilities_khr,
    p_next: ?*anyopaque = null,
    flags: VideoCapabilityFlagsKHR,
    min_bitstream_buffer_offset_alignment: DeviceSize,
    min_bitstream_buffer_size_alignment: DeviceSize,
    picture_access_granularity: Extent2D,
    min_coded_extent: Extent2D,
    max_coded_extent: Extent2D,
    max_dpb_slots: u32,
    max_active_reference_pictures: u32,
    std_header_version: ExtensionProperties,
};
pub const VideoSessionMemoryRequirementsKHR = extern struct {
    s_type: StructureType = .video_session_memory_requirements_khr,
    p_next: ?*anyopaque = null,
    memory_bind_index: u32,
    memory_requirements: MemoryRequirements,
};
pub const BindVideoSessionMemoryInfoKHR = extern struct {
    s_type: StructureType = .bind_video_session_memory_info_khr,
    p_next: ?*const anyopaque = null,
    memory_bind_index: u32,
    memory: DeviceMemory,
    memory_offset: DeviceSize,
    memory_size: DeviceSize,
};
pub const VideoPictureResourceInfoKHR = extern struct {
    s_type: StructureType = .video_picture_resource_info_khr,
    p_next: ?*const anyopaque = null,
    coded_offset: Offset2D,
    coded_extent: Extent2D,
    base_array_layer: u32,
    image_view_binding: ImageView,
};
pub const VideoReferenceSlotInfoKHR = extern struct {
    s_type: StructureType = .video_reference_slot_info_khr,
    p_next: ?*const anyopaque = null,
    slot_index: i32,
    p_picture_resource: ?*const VideoPictureResourceInfoKHR = null,
};
pub const VideoDecodeCapabilitiesKHR = extern struct {
    s_type: StructureType = .video_decode_capabilities_khr,
    p_next: ?*anyopaque = null,
    flags: VideoDecodeCapabilityFlagsKHR,
};
pub const VideoDecodeUsageInfoKHR = extern struct {
    s_type: StructureType = .video_decode_usage_info_khr,
    p_next: ?*const anyopaque = null,
    video_usage_hints: VideoDecodeUsageFlagsKHR = .{},
};
pub const VideoDecodeInfoKHR = extern struct {
    s_type: StructureType = .video_decode_info_khr,
    p_next: ?*const anyopaque = null,
    flags: VideoDecodeFlagsKHR = .{},
    src_buffer: Buffer,
    src_buffer_offset: DeviceSize,
    src_buffer_range: DeviceSize,
    dst_picture_resource: VideoPictureResourceInfoKHR,
    p_setup_reference_slot: ?*const VideoReferenceSlotInfoKHR = null,
    reference_slot_count: u32 = 0,
    p_reference_slots: ?[*]const VideoReferenceSlotInfoKHR = null,
};
pub const PhysicalDeviceVideoMaintenance1FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_video_maintenance_1_features_khr,
    p_next: ?*anyopaque = null,
    video_maintenance_1: Bool32 = .false,
};
pub const PhysicalDeviceVideoMaintenance2FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_video_maintenance_2_features_khr,
    p_next: ?*anyopaque = null,
    video_maintenance_2: Bool32 = .false,
};
pub const VideoInlineQueryInfoKHR = extern struct {
    s_type: StructureType = .video_inline_query_info_khr,
    p_next: ?*const anyopaque = null,
    query_pool: QueryPool = .null_handle,
    first_query: u32,
    query_count: u32,
};
pub const StdVideoH264ProfileIdc = if (@hasDecl(root, "StdVideoH264ProfileIdc")) root.StdVideoH264ProfileIdc else opaque {};
pub const StdVideoH264LevelIdc = if (@hasDecl(root, "StdVideoH264LevelIdc")) root.StdVideoH264LevelIdc else opaque {};
pub const StdVideoDecodeH264PictureInfo = if (@hasDecl(root, "StdVideoDecodeH264PictureInfo")) root.StdVideoDecodeH264PictureInfo else opaque {};
pub const StdVideoDecodeH264ReferenceInfo = if (@hasDecl(root, "StdVideoDecodeH264ReferenceInfo")) root.StdVideoDecodeH264ReferenceInfo else opaque {};
pub const VideoDecodeH264ProfileInfoKHR = extern struct {
    s_type: StructureType = .video_decode_h264_profile_info_khr,
    p_next: ?*const anyopaque = null,
    std_profile_idc: StdVideoH264ProfileIdc,
    picture_layout: VideoDecodeH264PictureLayoutFlagsKHR,
};
pub const VideoDecodeH264CapabilitiesKHR = extern struct {
    s_type: StructureType = .video_decode_h264_capabilities_khr,
    p_next: ?*anyopaque = null,
    max_level_idc: StdVideoH264LevelIdc,
    field_offset_granularity: Offset2D,
};
pub const StdVideoH264SequenceParameterSet = if (@hasDecl(root, "StdVideoH264SequenceParameterSet")) root.StdVideoH264SequenceParameterSet else opaque {};
pub const StdVideoH264PictureParameterSet = if (@hasDecl(root, "StdVideoH264PictureParameterSet")) root.StdVideoH264PictureParameterSet else opaque {};
pub const VideoDecodeH264SessionParametersAddInfoKHR = extern struct {
    s_type: StructureType = .video_decode_h264_session_parameters_add_info_khr,
    p_next: ?*const anyopaque = null,
    std_sps_count: u32 = 0,
    p_std_sp_ss: ?[*]const StdVideoH264SequenceParameterSet = null,
    std_pps_count: u32 = 0,
    p_std_pp_ss: ?[*]const StdVideoH264PictureParameterSet = null,
};
pub const VideoDecodeH264SessionParametersCreateInfoKHR = extern struct {
    s_type: StructureType = .video_decode_h264_session_parameters_create_info_khr,
    p_next: ?*const anyopaque = null,
    max_std_sps_count: u32,
    max_std_pps_count: u32,
    p_parameters_add_info: ?*const VideoDecodeH264SessionParametersAddInfoKHR = null,
};
pub const VideoDecodeH264InlineSessionParametersInfoKHR = extern struct {
    s_type: StructureType = .video_decode_h264_inline_session_parameters_info_khr,
    p_next: ?*const anyopaque = null,
    p_std_sps: ?*const StdVideoH264SequenceParameterSet = null,
    p_std_pps: ?*const StdVideoH264PictureParameterSet = null,
};
pub const VideoDecodeH264PictureInfoKHR = extern struct {
    s_type: StructureType = .video_decode_h264_picture_info_khr,
    p_next: ?*const anyopaque = null,
    p_std_picture_info: *const StdVideoDecodeH264PictureInfo,
    slice_count: u32,
    p_slice_offsets: [*]const u32,
};
pub const VideoDecodeH264DpbSlotInfoKHR = extern struct {
    s_type: StructureType = .video_decode_h264_dpb_slot_info_khr,
    p_next: ?*const anyopaque = null,
    p_std_reference_info: *const StdVideoDecodeH264ReferenceInfo,
};
pub const StdVideoH265ProfileIdc = if (@hasDecl(root, "StdVideoH265ProfileIdc")) root.StdVideoH265ProfileIdc else opaque {};
pub const StdVideoH265VideoParameterSet = if (@hasDecl(root, "StdVideoH265VideoParameterSet")) root.StdVideoH265VideoParameterSet else opaque {};
pub const StdVideoH265SequenceParameterSet = if (@hasDecl(root, "StdVideoH265SequenceParameterSet")) root.StdVideoH265SequenceParameterSet else opaque {};
pub const StdVideoH265PictureParameterSet = if (@hasDecl(root, "StdVideoH265PictureParameterSet")) root.StdVideoH265PictureParameterSet else opaque {};
pub const StdVideoH265LevelIdc = if (@hasDecl(root, "StdVideoH265LevelIdc")) root.StdVideoH265LevelIdc else opaque {};
pub const StdVideoDecodeH265PictureInfo = if (@hasDecl(root, "StdVideoDecodeH265PictureInfo")) root.StdVideoDecodeH265PictureInfo else opaque {};
pub const StdVideoDecodeH265ReferenceInfo = if (@hasDecl(root, "StdVideoDecodeH265ReferenceInfo")) root.StdVideoDecodeH265ReferenceInfo else opaque {};
pub const VideoDecodeH265ProfileInfoKHR = extern struct {
    s_type: StructureType = .video_decode_h265_profile_info_khr,
    p_next: ?*const anyopaque = null,
    std_profile_idc: StdVideoH265ProfileIdc,
};
pub const VideoDecodeH265CapabilitiesKHR = extern struct {
    s_type: StructureType = .video_decode_h265_capabilities_khr,
    p_next: ?*anyopaque = null,
    max_level_idc: StdVideoH265LevelIdc,
};
pub const VideoDecodeH265SessionParametersAddInfoKHR = extern struct {
    s_type: StructureType = .video_decode_h265_session_parameters_add_info_khr,
    p_next: ?*const anyopaque = null,
    std_vps_count: u32 = 0,
    p_std_vp_ss: ?[*]const StdVideoH265VideoParameterSet = null,
    std_sps_count: u32 = 0,
    p_std_sp_ss: ?[*]const StdVideoH265SequenceParameterSet = null,
    std_pps_count: u32 = 0,
    p_std_pp_ss: ?[*]const StdVideoH265PictureParameterSet = null,
};
pub const VideoDecodeH265SessionParametersCreateInfoKHR = extern struct {
    s_type: StructureType = .video_decode_h265_session_parameters_create_info_khr,
    p_next: ?*const anyopaque = null,
    max_std_vps_count: u32,
    max_std_sps_count: u32,
    max_std_pps_count: u32,
    p_parameters_add_info: ?*const VideoDecodeH265SessionParametersAddInfoKHR = null,
};
pub const VideoDecodeH265InlineSessionParametersInfoKHR = extern struct {
    s_type: StructureType = .video_decode_h265_inline_session_parameters_info_khr,
    p_next: ?*const anyopaque = null,
    p_std_vps: ?*const StdVideoH265VideoParameterSet = null,
    p_std_sps: ?*const StdVideoH265SequenceParameterSet = null,
    p_std_pps: ?*const StdVideoH265PictureParameterSet = null,
};
pub const VideoDecodeH265PictureInfoKHR = extern struct {
    s_type: StructureType = .video_decode_h265_picture_info_khr,
    p_next: ?*const anyopaque = null,
    p_std_picture_info: *const StdVideoDecodeH265PictureInfo,
    slice_segment_count: u32,
    p_slice_segment_offsets: [*]const u32,
};
pub const VideoDecodeH265DpbSlotInfoKHR = extern struct {
    s_type: StructureType = .video_decode_h265_dpb_slot_info_khr,
    p_next: ?*const anyopaque = null,
    p_std_reference_info: *const StdVideoDecodeH265ReferenceInfo,
};
pub const StdVideoVP9Profile = if (@hasDecl(root, "StdVideoVP9Profile")) root.StdVideoVP9Profile else u32;
pub const StdVideoVP9Level = if (@hasDecl(root, "StdVideoVP9Level")) root.StdVideoVP9Level else u32;
pub const StdVideoDecodeVP9PictureInfo = if (@hasDecl(root, "StdVideoDecodeVP9PictureInfo")) root.StdVideoDecodeVP9PictureInfo else opaque {};
pub const PhysicalDeviceVideoDecodeVP9FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_video_decode_vp9_features_khr,
    p_next: ?*anyopaque = null,
    video_decode_vp9: Bool32 = .false,
};
pub const VideoDecodeVP9ProfileInfoKHR = extern struct {
    s_type: StructureType = .video_decode_vp9_profile_info_khr,
    p_next: ?*const anyopaque = null,
    std_profile: StdVideoVP9Profile,
};
pub const VideoDecodeVP9CapabilitiesKHR = extern struct {
    s_type: StructureType = .video_decode_vp9_capabilities_khr,
    p_next: ?*anyopaque = null,
    max_level: StdVideoVP9Level,
};
pub const VideoDecodeVP9PictureInfoKHR = extern struct {
    s_type: StructureType = .video_decode_vp9_picture_info_khr,
    p_next: ?*const anyopaque = null,
    p_std_picture_info: *const StdVideoDecodeVP9PictureInfo,
    reference_name_slot_indices: [MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR]i32,
    uncompressed_header_offset: u32,
    compressed_header_offset: u32,
    tiles_offset: u32,
};
pub const StdVideoAV1Profile = if (@hasDecl(root, "StdVideoAV1Profile")) root.StdVideoAV1Profile else opaque {};
pub const StdVideoAV1Level = if (@hasDecl(root, "StdVideoAV1Level")) root.StdVideoAV1Level else opaque {};
pub const StdVideoAV1SequenceHeader = if (@hasDecl(root, "StdVideoAV1SequenceHeader")) root.StdVideoAV1SequenceHeader else opaque {};
pub const StdVideoDecodeAV1PictureInfo = if (@hasDecl(root, "StdVideoDecodeAV1PictureInfo")) root.StdVideoDecodeAV1PictureInfo else opaque {};
pub const StdVideoDecodeAV1ReferenceInfo = if (@hasDecl(root, "StdVideoDecodeAV1ReferenceInfo")) root.StdVideoDecodeAV1ReferenceInfo else opaque {};
pub const VideoDecodeAV1ProfileInfoKHR = extern struct {
    s_type: StructureType = .video_decode_av1_profile_info_khr,
    p_next: ?*const anyopaque = null,
    std_profile: StdVideoAV1Profile,
    film_grain_support: Bool32,
};
pub const VideoDecodeAV1CapabilitiesKHR = extern struct {
    s_type: StructureType = .video_decode_av1_capabilities_khr,
    p_next: ?*anyopaque = null,
    max_level: StdVideoAV1Level,
};
pub const VideoDecodeAV1SessionParametersCreateInfoKHR = extern struct {
    s_type: StructureType = .video_decode_av1_session_parameters_create_info_khr,
    p_next: ?*const anyopaque = null,
    p_std_sequence_header: *const StdVideoAV1SequenceHeader,
};
pub const VideoDecodeAV1InlineSessionParametersInfoKHR = extern struct {
    s_type: StructureType = .video_decode_av1_inline_session_parameters_info_khr,
    p_next: ?*const anyopaque = null,
    p_std_sequence_header: ?*const StdVideoAV1SequenceHeader = null,
};
pub const VideoDecodeAV1PictureInfoKHR = extern struct {
    s_type: StructureType = .video_decode_av1_picture_info_khr,
    p_next: ?*const anyopaque = null,
    p_std_picture_info: *const StdVideoDecodeAV1PictureInfo,
    reference_name_slot_indices: [MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR]i32,
    frame_header_offset: u32,
    tile_count: u32,
    p_tile_offsets: [*]const u32,
    p_tile_sizes: [*]const u32,
};
pub const VideoDecodeAV1DpbSlotInfoKHR = extern struct {
    s_type: StructureType = .video_decode_av1_dpb_slot_info_khr,
    p_next: ?*const anyopaque = null,
    p_std_reference_info: *const StdVideoDecodeAV1ReferenceInfo,
};
pub const VideoSessionCreateInfoKHR = extern struct {
    s_type: StructureType = .video_session_create_info_khr,
    p_next: ?*const anyopaque = null,
    queue_family_index: u32,
    flags: VideoSessionCreateFlagsKHR = .{},
    p_video_profile: *const VideoProfileInfoKHR,
    picture_format: Format,
    max_coded_extent: Extent2D,
    reference_picture_format: Format,
    max_dpb_slots: u32,
    max_active_reference_pictures: u32,
    p_std_header_version: *const ExtensionProperties,
};
pub const VideoSessionParametersCreateInfoKHR = extern struct {
    s_type: StructureType = .video_session_parameters_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: VideoSessionParametersCreateFlagsKHR = .{},
    video_session_parameters_template: VideoSessionParametersKHR = .null_handle,
    video_session: VideoSessionKHR,
};
pub const VideoSessionParametersUpdateInfoKHR = extern struct {
    s_type: StructureType = .video_session_parameters_update_info_khr,
    p_next: ?*const anyopaque = null,
    update_sequence_count: u32,
};
pub const VideoEncodeSessionParametersGetInfoKHR = extern struct {
    s_type: StructureType = .video_encode_session_parameters_get_info_khr,
    p_next: ?*const anyopaque = null,
    video_session_parameters: VideoSessionParametersKHR,
};
pub const VideoEncodeSessionParametersFeedbackInfoKHR = extern struct {
    s_type: StructureType = .video_encode_session_parameters_feedback_info_khr,
    p_next: ?*anyopaque = null,
    has_overrides: Bool32,
};
pub const VideoBeginCodingInfoKHR = extern struct {
    s_type: StructureType = .video_begin_coding_info_khr,
    p_next: ?*const anyopaque = null,
    flags: VideoBeginCodingFlagsKHR = .{},
    video_session: VideoSessionKHR,
    video_session_parameters: VideoSessionParametersKHR = .null_handle,
    reference_slot_count: u32 = 0,
    p_reference_slots: ?[*]const VideoReferenceSlotInfoKHR = null,
};
pub const VideoEndCodingInfoKHR = extern struct {
    s_type: StructureType = .video_end_coding_info_khr,
    p_next: ?*const anyopaque = null,
    flags: VideoEndCodingFlagsKHR = .{},
};
pub const VideoCodingControlInfoKHR = extern struct {
    s_type: StructureType = .video_coding_control_info_khr,
    p_next: ?*const anyopaque = null,
    flags: VideoCodingControlFlagsKHR,
};
pub const VideoEncodeUsageInfoKHR = extern struct {
    s_type: StructureType = .video_encode_usage_info_khr,
    p_next: ?*const anyopaque = null,
    video_usage_hints: VideoEncodeUsageFlagsKHR = .{},
    video_content_hints: VideoEncodeContentFlagsKHR = .{},
    tuning_mode: VideoEncodeTuningModeKHR,
};
pub const VideoEncodeInfoKHR = extern struct {
    s_type: StructureType = .video_encode_info_khr,
    p_next: ?*const anyopaque = null,
    flags: VideoEncodeFlagsKHR = .{},
    dst_buffer: Buffer,
    dst_buffer_offset: DeviceSize,
    dst_buffer_range: DeviceSize,
    src_picture_resource: VideoPictureResourceInfoKHR,
    p_setup_reference_slot: ?*const VideoReferenceSlotInfoKHR = null,
    reference_slot_count: u32 = 0,
    p_reference_slots: ?[*]const VideoReferenceSlotInfoKHR = null,
    preceding_externally_encoded_bytes: u32,
};
pub const VideoEncodeQuantizationMapInfoKHR = extern struct {
    s_type: StructureType = .video_encode_quantization_map_info_khr,
    p_next: ?*const anyopaque = null,
    quantization_map: ImageView = .null_handle,
    quantization_map_extent: Extent2D,
};
pub const VideoEncodeQuantizationMapSessionParametersCreateInfoKHR = extern struct {
    s_type: StructureType = .video_encode_quantization_map_session_parameters_create_info_khr,
    p_next: ?*const anyopaque = null,
    quantization_map_texel_size: Extent2D,
};
pub const PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_video_encode_quantization_map_features_khr,
    p_next: ?*anyopaque = null,
    video_encode_quantization_map: Bool32 = .false,
};
pub const QueryPoolVideoEncodeFeedbackCreateInfoKHR = extern struct {
    s_type: StructureType = .query_pool_video_encode_feedback_create_info_khr,
    p_next: ?*const anyopaque = null,
    encode_feedback_flags: VideoEncodeFeedbackFlagsKHR,
};
pub const VideoEncodeQualityLevelInfoKHR = extern struct {
    s_type: StructureType = .video_encode_quality_level_info_khr,
    p_next: ?*const anyopaque = null,
    quality_level: u32,
};
pub const PhysicalDeviceVideoEncodeQualityLevelInfoKHR = extern struct {
    s_type: StructureType = .physical_device_video_encode_quality_level_info_khr,
    p_next: ?*const anyopaque = null,
    p_video_profile: *const VideoProfileInfoKHR,
    quality_level: u32,
};
pub const VideoEncodeQualityLevelPropertiesKHR = extern struct {
    s_type: StructureType = .video_encode_quality_level_properties_khr,
    p_next: ?*anyopaque = null,
    preferred_rate_control_mode: VideoEncodeRateControlModeFlagsKHR,
    preferred_rate_control_layer_count: u32,
};
pub const VideoEncodeRateControlInfoKHR = extern struct {
    s_type: StructureType = .video_encode_rate_control_info_khr,
    p_next: ?*const anyopaque = null,
    flags: VideoEncodeRateControlFlagsKHR = .{},
    rate_control_mode: VideoEncodeRateControlModeFlagsKHR,
    layer_count: u32 = 0,
    p_layers: ?[*]const VideoEncodeRateControlLayerInfoKHR = null,
    virtual_buffer_size_in_ms: u32,
    initial_virtual_buffer_size_in_ms: u32,
};
pub const VideoEncodeRateControlLayerInfoKHR = extern struct {
    s_type: StructureType = .video_encode_rate_control_layer_info_khr,
    p_next: ?*const anyopaque = null,
    average_bitrate: u64,
    max_bitrate: u64,
    frame_rate_numerator: u32,
    frame_rate_denominator: u32,
};
pub const VideoEncodeCapabilitiesKHR = extern struct {
    s_type: StructureType = .video_encode_capabilities_khr,
    p_next: ?*anyopaque = null,
    flags: VideoEncodeCapabilityFlagsKHR,
    rate_control_modes: VideoEncodeRateControlModeFlagsKHR,
    max_rate_control_layers: u32,
    max_bitrate: u64,
    max_quality_levels: u32,
    encode_input_picture_granularity: Extent2D,
    supported_encode_feedback_flags: VideoEncodeFeedbackFlagsKHR,
};
pub const VideoEncodeH264CapabilitiesKHR = extern struct {
    s_type: StructureType = .video_encode_h264_capabilities_khr,
    p_next: ?*anyopaque = null,
    flags: VideoEncodeH264CapabilityFlagsKHR,
    max_level_idc: StdVideoH264LevelIdc,
    max_slice_count: u32,
    max_p_picture_l0_reference_count: u32,
    max_b_picture_l0_reference_count: u32,
    max_l1_reference_count: u32,
    max_temporal_layer_count: u32,
    expect_dyadic_temporal_layer_pattern: Bool32,
    min_qp: i32,
    max_qp: i32,
    prefers_gop_remaining_frames: Bool32,
    requires_gop_remaining_frames: Bool32,
    std_syntax_flags: VideoEncodeH264StdFlagsKHR,
};
pub const VideoEncodeH264QualityLevelPropertiesKHR = extern struct {
    s_type: StructureType = .video_encode_h264_quality_level_properties_khr,
    p_next: ?*anyopaque = null,
    preferred_rate_control_flags: VideoEncodeH264RateControlFlagsKHR,
    preferred_gop_frame_count: u32,
    preferred_idr_period: u32,
    preferred_consecutive_b_frame_count: u32,
    preferred_temporal_layer_count: u32,
    preferred_constant_qp: VideoEncodeH264QpKHR,
    preferred_max_l0_reference_count: u32,
    preferred_max_l1_reference_count: u32,
    preferred_std_entropy_coding_mode_flag: Bool32,
};
pub const StdVideoEncodeH264SliceHeader = if (@hasDecl(root, "StdVideoEncodeH264SliceHeader")) root.StdVideoEncodeH264SliceHeader else opaque {};
pub const StdVideoEncodeH264PictureInfo = if (@hasDecl(root, "StdVideoEncodeH264PictureInfo")) root.StdVideoEncodeH264PictureInfo else opaque {};
pub const StdVideoEncodeH264ReferenceInfo = if (@hasDecl(root, "StdVideoEncodeH264ReferenceInfo")) root.StdVideoEncodeH264ReferenceInfo else opaque {};
pub const VideoEncodeH264SessionCreateInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h264_session_create_info_khr,
    p_next: ?*const anyopaque = null,
    use_max_level_idc: Bool32,
    max_level_idc: StdVideoH264LevelIdc,
};
pub const VideoEncodeH264SessionParametersAddInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h264_session_parameters_add_info_khr,
    p_next: ?*const anyopaque = null,
    std_sps_count: u32 = 0,
    p_std_sp_ss: ?[*]const StdVideoH264SequenceParameterSet = null,
    std_pps_count: u32 = 0,
    p_std_pp_ss: ?[*]const StdVideoH264PictureParameterSet = null,
};
pub const VideoEncodeH264SessionParametersCreateInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h264_session_parameters_create_info_khr,
    p_next: ?*const anyopaque = null,
    max_std_sps_count: u32,
    max_std_pps_count: u32,
    p_parameters_add_info: ?*const VideoEncodeH264SessionParametersAddInfoKHR = null,
};
pub const VideoEncodeH264SessionParametersGetInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h264_session_parameters_get_info_khr,
    p_next: ?*const anyopaque = null,
    write_std_sps: Bool32,
    write_std_pps: Bool32,
    std_sps_id: u32,
    std_pps_id: u32,
};
pub const VideoEncodeH264SessionParametersFeedbackInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h264_session_parameters_feedback_info_khr,
    p_next: ?*anyopaque = null,
    has_std_sps_overrides: Bool32,
    has_std_pps_overrides: Bool32,
};
pub const VideoEncodeH264DpbSlotInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h264_dpb_slot_info_khr,
    p_next: ?*const anyopaque = null,
    p_std_reference_info: *const StdVideoEncodeH264ReferenceInfo,
};
pub const VideoEncodeH264PictureInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h264_picture_info_khr,
    p_next: ?*const anyopaque = null,
    nalu_slice_entry_count: u32,
    p_nalu_slice_entries: [*]const VideoEncodeH264NaluSliceInfoKHR,
    p_std_picture_info: *const StdVideoEncodeH264PictureInfo,
    generate_prefix_nalu: Bool32,
};
pub const VideoEncodeH264ProfileInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h264_profile_info_khr,
    p_next: ?*const anyopaque = null,
    std_profile_idc: StdVideoH264ProfileIdc,
};
pub const VideoEncodeH264NaluSliceInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h264_nalu_slice_info_khr,
    p_next: ?*const anyopaque = null,
    constant_qp: i32,
    p_std_slice_header: *const StdVideoEncodeH264SliceHeader,
};
pub const VideoEncodeH264RateControlInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h264_rate_control_info_khr,
    p_next: ?*const anyopaque = null,
    flags: VideoEncodeH264RateControlFlagsKHR = .{},
    gop_frame_count: u32,
    idr_period: u32,
    consecutive_b_frame_count: u32,
    temporal_layer_count: u32,
};
pub const VideoEncodeH264QpKHR = extern struct {
    qp_i: i32,
    qp_p: i32,
    qp_b: i32,
};
pub const VideoEncodeH264FrameSizeKHR = extern struct {
    frame_i_size: u32,
    frame_p_size: u32,
    frame_b_size: u32,
};
pub const VideoEncodeH264GopRemainingFrameInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h264_gop_remaining_frame_info_khr,
    p_next: ?*const anyopaque = null,
    use_gop_remaining_frames: Bool32,
    gop_remaining_i: u32,
    gop_remaining_p: u32,
    gop_remaining_b: u32,
};
pub const VideoEncodeH264RateControlLayerInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h264_rate_control_layer_info_khr,
    p_next: ?*const anyopaque = null,
    use_min_qp: Bool32,
    min_qp: VideoEncodeH264QpKHR,
    use_max_qp: Bool32,
    max_qp: VideoEncodeH264QpKHR,
    use_max_frame_size: Bool32,
    max_frame_size: VideoEncodeH264FrameSizeKHR,
};
pub const VideoEncodeH265CapabilitiesKHR = extern struct {
    s_type: StructureType = .video_encode_h265_capabilities_khr,
    p_next: ?*anyopaque = null,
    flags: VideoEncodeH265CapabilityFlagsKHR,
    max_level_idc: StdVideoH265LevelIdc,
    max_slice_segment_count: u32,
    max_tiles: Extent2D,
    ctb_sizes: VideoEncodeH265CtbSizeFlagsKHR,
    transform_block_sizes: VideoEncodeH265TransformBlockSizeFlagsKHR,
    max_p_picture_l0_reference_count: u32,
    max_b_picture_l0_reference_count: u32,
    max_l1_reference_count: u32,
    max_sub_layer_count: u32,
    expect_dyadic_temporal_sub_layer_pattern: Bool32,
    min_qp: i32,
    max_qp: i32,
    prefers_gop_remaining_frames: Bool32,
    requires_gop_remaining_frames: Bool32,
    std_syntax_flags: VideoEncodeH265StdFlagsKHR,
};
pub const VideoEncodeH265QualityLevelPropertiesKHR = extern struct {
    s_type: StructureType = .video_encode_h265_quality_level_properties_khr,
    p_next: ?*anyopaque = null,
    preferred_rate_control_flags: VideoEncodeH265RateControlFlagsKHR,
    preferred_gop_frame_count: u32,
    preferred_idr_period: u32,
    preferred_consecutive_b_frame_count: u32,
    preferred_sub_layer_count: u32,
    preferred_constant_qp: VideoEncodeH265QpKHR,
    preferred_max_l0_reference_count: u32,
    preferred_max_l1_reference_count: u32,
};
pub const StdVideoEncodeH265PictureInfo = if (@hasDecl(root, "StdVideoEncodeH265PictureInfo")) root.StdVideoEncodeH265PictureInfo else opaque {};
pub const StdVideoEncodeH265SliceSegmentHeader = if (@hasDecl(root, "StdVideoEncodeH265SliceSegmentHeader")) root.StdVideoEncodeH265SliceSegmentHeader else opaque {};
pub const StdVideoEncodeH265ReferenceInfo = if (@hasDecl(root, "StdVideoEncodeH265ReferenceInfo")) root.StdVideoEncodeH265ReferenceInfo else opaque {};
pub const VideoEncodeH265SessionCreateInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h265_session_create_info_khr,
    p_next: ?*const anyopaque = null,
    use_max_level_idc: Bool32,
    max_level_idc: StdVideoH265LevelIdc,
};
pub const VideoEncodeH265SessionParametersAddInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h265_session_parameters_add_info_khr,
    p_next: ?*const anyopaque = null,
    std_vps_count: u32 = 0,
    p_std_vp_ss: ?[*]const StdVideoH265VideoParameterSet = null,
    std_sps_count: u32 = 0,
    p_std_sp_ss: ?[*]const StdVideoH265SequenceParameterSet = null,
    std_pps_count: u32 = 0,
    p_std_pp_ss: ?[*]const StdVideoH265PictureParameterSet = null,
};
pub const VideoEncodeH265SessionParametersCreateInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h265_session_parameters_create_info_khr,
    p_next: ?*const anyopaque = null,
    max_std_vps_count: u32,
    max_std_sps_count: u32,
    max_std_pps_count: u32,
    p_parameters_add_info: ?*const VideoEncodeH265SessionParametersAddInfoKHR = null,
};
pub const VideoEncodeH265SessionParametersGetInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h265_session_parameters_get_info_khr,
    p_next: ?*const anyopaque = null,
    write_std_vps: Bool32,
    write_std_sps: Bool32,
    write_std_pps: Bool32,
    std_vps_id: u32,
    std_sps_id: u32,
    std_pps_id: u32,
};
pub const VideoEncodeH265SessionParametersFeedbackInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h265_session_parameters_feedback_info_khr,
    p_next: ?*anyopaque = null,
    has_std_vps_overrides: Bool32,
    has_std_sps_overrides: Bool32,
    has_std_pps_overrides: Bool32,
};
pub const VideoEncodeH265PictureInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h265_picture_info_khr,
    p_next: ?*const anyopaque = null,
    nalu_slice_segment_entry_count: u32,
    p_nalu_slice_segment_entries: [*]const VideoEncodeH265NaluSliceSegmentInfoKHR,
    p_std_picture_info: *const StdVideoEncodeH265PictureInfo,
};
pub const VideoEncodeH265NaluSliceSegmentInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h265_nalu_slice_segment_info_khr,
    p_next: ?*const anyopaque = null,
    constant_qp: i32,
    p_std_slice_segment_header: *const StdVideoEncodeH265SliceSegmentHeader,
};
pub const VideoEncodeH265RateControlInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h265_rate_control_info_khr,
    p_next: ?*const anyopaque = null,
    flags: VideoEncodeH265RateControlFlagsKHR = .{},
    gop_frame_count: u32,
    idr_period: u32,
    consecutive_b_frame_count: u32,
    sub_layer_count: u32,
};
pub const VideoEncodeH265QpKHR = extern struct {
    qp_i: i32,
    qp_p: i32,
    qp_b: i32,
};
pub const VideoEncodeH265FrameSizeKHR = extern struct {
    frame_i_size: u32,
    frame_p_size: u32,
    frame_b_size: u32,
};
pub const VideoEncodeH265GopRemainingFrameInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h265_gop_remaining_frame_info_khr,
    p_next: ?*const anyopaque = null,
    use_gop_remaining_frames: Bool32,
    gop_remaining_i: u32,
    gop_remaining_p: u32,
    gop_remaining_b: u32,
};
pub const VideoEncodeH265RateControlLayerInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h265_rate_control_layer_info_khr,
    p_next: ?*const anyopaque = null,
    use_min_qp: Bool32,
    min_qp: VideoEncodeH265QpKHR,
    use_max_qp: Bool32,
    max_qp: VideoEncodeH265QpKHR,
    use_max_frame_size: Bool32,
    max_frame_size: VideoEncodeH265FrameSizeKHR,
};
pub const VideoEncodeH265ProfileInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h265_profile_info_khr,
    p_next: ?*const anyopaque = null,
    std_profile_idc: StdVideoH265ProfileIdc,
};
pub const VideoEncodeH265DpbSlotInfoKHR = extern struct {
    s_type: StructureType = .video_encode_h265_dpb_slot_info_khr,
    p_next: ?*const anyopaque = null,
    p_std_reference_info: *const StdVideoEncodeH265ReferenceInfo,
};
pub const VideoEncodeAV1CapabilitiesKHR = extern struct {
    s_type: StructureType = .video_encode_av1_capabilities_khr,
    p_next: ?*anyopaque = null,
    flags: VideoEncodeAV1CapabilityFlagsKHR,
    max_level: StdVideoAV1Level,
    coded_picture_alignment: Extent2D,
    max_tiles: Extent2D,
    min_tile_size: Extent2D,
    max_tile_size: Extent2D,
    superblock_sizes: VideoEncodeAV1SuperblockSizeFlagsKHR,
    max_single_reference_count: u32,
    single_reference_name_mask: u32,
    max_unidirectional_compound_reference_count: u32,
    max_unidirectional_compound_group_1_reference_count: u32,
    unidirectional_compound_reference_name_mask: u32,
    max_bidirectional_compound_reference_count: u32,
    max_bidirectional_compound_group_1_reference_count: u32,
    max_bidirectional_compound_group_2_reference_count: u32,
    bidirectional_compound_reference_name_mask: u32,
    max_temporal_layer_count: u32,
    max_spatial_layer_count: u32,
    max_operating_points: u32,
    min_q_index: u32,
    max_q_index: u32,
    prefers_gop_remaining_frames: Bool32,
    requires_gop_remaining_frames: Bool32,
    std_syntax_flags: VideoEncodeAV1StdFlagsKHR,
};
pub const VideoEncodeAV1QualityLevelPropertiesKHR = extern struct {
    s_type: StructureType = .video_encode_av1_quality_level_properties_khr,
    p_next: ?*anyopaque = null,
    preferred_rate_control_flags: VideoEncodeAV1RateControlFlagsKHR,
    preferred_gop_frame_count: u32,
    preferred_key_frame_period: u32,
    preferred_consecutive_bipredictive_frame_count: u32,
    preferred_temporal_layer_count: u32,
    preferred_constant_q_index: VideoEncodeAV1QIndexKHR,
    preferred_max_single_reference_count: u32,
    preferred_single_reference_name_mask: u32,
    preferred_max_unidirectional_compound_reference_count: u32,
    preferred_max_unidirectional_compound_group_1_reference_count: u32,
    preferred_unidirectional_compound_reference_name_mask: u32,
    preferred_max_bidirectional_compound_reference_count: u32,
    preferred_max_bidirectional_compound_group_1_reference_count: u32,
    preferred_max_bidirectional_compound_group_2_reference_count: u32,
    preferred_bidirectional_compound_reference_name_mask: u32,
};
pub const StdVideoEncodeAV1ExtensionHeader = if (@hasDecl(root, "StdVideoEncodeAV1ExtensionHeader")) root.StdVideoEncodeAV1ExtensionHeader else opaque {};
pub const StdVideoEncodeAV1DecoderModelInfo = if (@hasDecl(root, "StdVideoEncodeAV1DecoderModelInfo")) root.StdVideoEncodeAV1DecoderModelInfo else opaque {};
pub const StdVideoEncodeAV1OperatingPointInfo = if (@hasDecl(root, "StdVideoEncodeAV1OperatingPointInfo")) root.StdVideoEncodeAV1OperatingPointInfo else opaque {};
pub const StdVideoEncodeAV1PictureInfo = if (@hasDecl(root, "StdVideoEncodeAV1PictureInfo")) root.StdVideoEncodeAV1PictureInfo else opaque {};
pub const StdVideoEncodeAV1ReferenceInfo = if (@hasDecl(root, "StdVideoEncodeAV1ReferenceInfo")) root.StdVideoEncodeAV1ReferenceInfo else opaque {};
pub const PhysicalDeviceVideoEncodeAV1FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_video_encode_av1_features_khr,
    p_next: ?*anyopaque = null,
    video_encode_av1: Bool32 = .false,
};
pub const VideoEncodeAV1SessionCreateInfoKHR = extern struct {
    s_type: StructureType = .video_encode_av1_session_create_info_khr,
    p_next: ?*const anyopaque = null,
    use_max_level: Bool32,
    max_level: StdVideoAV1Level,
};
pub const VideoEncodeAV1SessionParametersCreateInfoKHR = extern struct {
    s_type: StructureType = .video_encode_av1_session_parameters_create_info_khr,
    p_next: ?*const anyopaque = null,
    p_std_sequence_header: *const StdVideoAV1SequenceHeader,
    p_std_decoder_model_info: ?*const StdVideoEncodeAV1DecoderModelInfo = null,
    std_operating_point_count: u32 = 0,
    p_std_operating_points: ?[*]const StdVideoEncodeAV1OperatingPointInfo = null,
};
pub const VideoEncodeAV1DpbSlotInfoKHR = extern struct {
    s_type: StructureType = .video_encode_av1_dpb_slot_info_khr,
    p_next: ?*const anyopaque = null,
    p_std_reference_info: *const StdVideoEncodeAV1ReferenceInfo,
};
pub const VideoEncodeAV1PictureInfoKHR = extern struct {
    s_type: StructureType = .video_encode_av1_picture_info_khr,
    p_next: ?*const anyopaque = null,
    prediction_mode: VideoEncodeAV1PredictionModeKHR,
    rate_control_group: VideoEncodeAV1RateControlGroupKHR,
    constant_q_index: u32,
    p_std_picture_info: *const StdVideoEncodeAV1PictureInfo,
    reference_name_slot_indices: [MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR]i32,
    primary_reference_cdf_only: Bool32,
    generate_obu_extension_header: Bool32,
};
pub const VideoEncodeAV1ProfileInfoKHR = extern struct {
    s_type: StructureType = .video_encode_av1_profile_info_khr,
    p_next: ?*const anyopaque = null,
    std_profile: StdVideoAV1Profile,
};
pub const VideoEncodeAV1RateControlInfoKHR = extern struct {
    s_type: StructureType = .video_encode_av1_rate_control_info_khr,
    p_next: ?*const anyopaque = null,
    flags: VideoEncodeAV1RateControlFlagsKHR = .{},
    gop_frame_count: u32,
    key_frame_period: u32,
    consecutive_bipredictive_frame_count: u32,
    temporal_layer_count: u32,
};
pub const VideoEncodeAV1QIndexKHR = extern struct {
    intra_q_index: u32,
    predictive_q_index: u32,
    bipredictive_q_index: u32,
};
pub const VideoEncodeAV1FrameSizeKHR = extern struct {
    intra_frame_size: u32,
    predictive_frame_size: u32,
    bipredictive_frame_size: u32,
};
pub const VideoEncodeAV1GopRemainingFrameInfoKHR = extern struct {
    s_type: StructureType = .video_encode_av1_gop_remaining_frame_info_khr,
    p_next: ?*const anyopaque = null,
    use_gop_remaining_frames: Bool32,
    gop_remaining_intra: u32,
    gop_remaining_predictive: u32,
    gop_remaining_bipredictive: u32,
};
pub const VideoEncodeAV1RateControlLayerInfoKHR = extern struct {
    s_type: StructureType = .video_encode_av1_rate_control_layer_info_khr,
    p_next: ?*const anyopaque = null,
    use_min_q_index: Bool32,
    min_q_index: VideoEncodeAV1QIndexKHR,
    use_max_q_index: Bool32,
    max_q_index: VideoEncodeAV1QIndexKHR,
    use_max_frame_size: Bool32,
    max_frame_size: VideoEncodeAV1FrameSizeKHR,
};
pub const PhysicalDeviceInheritedViewportScissorFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_inherited_viewport_scissor_features_nv,
    p_next: ?*anyopaque = null,
    inherited_viewport_scissor_2d: Bool32 = .false,
};
pub const CommandBufferInheritanceViewportScissorInfoNV = extern struct {
    s_type: StructureType = .command_buffer_inheritance_viewport_scissor_info_nv,
    p_next: ?*const anyopaque = null,
    viewport_scissor_2d: Bool32,
    viewport_depth_count: u32,
    p_viewport_depths: *const Viewport,
};
pub const PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_ycbcr_2_plane_444_formats_features_ext,
    p_next: ?*anyopaque = null,
    ycbcr_2plane_444_formats: Bool32 = .false,
};
pub const PhysicalDeviceProvokingVertexFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_provoking_vertex_features_ext,
    p_next: ?*anyopaque = null,
    provoking_vertex_last: Bool32 = .false,
    transform_feedback_preserves_provoking_vertex: Bool32 = .false,
};
pub const PhysicalDeviceProvokingVertexPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_provoking_vertex_properties_ext,
    p_next: ?*anyopaque = null,
    provoking_vertex_mode_per_pipeline: Bool32,
    transform_feedback_preserves_triangle_fan_provoking_vertex: Bool32,
};
pub const PipelineRasterizationProvokingVertexStateCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_rasterization_provoking_vertex_state_create_info_ext,
    p_next: ?*const anyopaque = null,
    provoking_vertex_mode: ProvokingVertexModeEXT,
};
pub const VideoEncodeIntraRefreshCapabilitiesKHR = extern struct {
    s_type: StructureType = .video_encode_intra_refresh_capabilities_khr,
    p_next: ?*anyopaque = null,
    intra_refresh_modes: VideoEncodeIntraRefreshModeFlagsKHR = .{},
    max_intra_refresh_cycle_duration: u32,
    max_intra_refresh_active_reference_pictures: u32,
    partition_independent_intra_refresh_regions: Bool32,
    non_rectangular_intra_refresh_regions: Bool32,
};
pub const VideoEncodeSessionIntraRefreshCreateInfoKHR = extern struct {
    s_type: StructureType = .video_encode_session_intra_refresh_create_info_khr,
    p_next: ?*const anyopaque = null,
    intra_refresh_mode: VideoEncodeIntraRefreshModeFlagsKHR,
};
pub const VideoEncodeIntraRefreshInfoKHR = extern struct {
    s_type: StructureType = .video_encode_intra_refresh_info_khr,
    p_next: ?*const anyopaque = null,
    intra_refresh_cycle_duration: u32,
    intra_refresh_index: u32,
};
pub const VideoReferenceIntraRefreshInfoKHR = extern struct {
    s_type: StructureType = .video_reference_intra_refresh_info_khr,
    p_next: ?*const anyopaque = null,
    dirty_intra_refresh_regions: u32,
};
pub const PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_video_encode_intra_refresh_features_khr,
    p_next: ?*anyopaque = null,
    video_encode_intra_refresh: Bool32 = .false,
};
pub const CuModuleCreateInfoNVX = extern struct {
    s_type: StructureType = .cu_module_create_info_nvx,
    p_next: ?*const anyopaque = null,
    data_size: usize = 0,
    p_data: ?*const anyopaque = null,
};
pub const CuModuleTexturingModeCreateInfoNVX = extern struct {
    s_type: StructureType = .cu_module_texturing_mode_create_info_nvx,
    p_next: ?*const anyopaque = null,
    use_6_4bit_texturing: Bool32,
};
pub const CuFunctionCreateInfoNVX = extern struct {
    s_type: StructureType = .cu_function_create_info_nvx,
    p_next: ?*const anyopaque = null,
    module: CuModuleNVX,
    p_name: [*:0]const u8,
};
pub const CuLaunchInfoNVX = extern struct {
    s_type: StructureType = .cu_launch_info_nvx,
    p_next: ?*const anyopaque = null,
    function: CuFunctionNVX,
    grid_dim_x: u32,
    grid_dim_y: u32,
    grid_dim_z: u32,
    block_dim_x: u32,
    block_dim_y: u32,
    block_dim_z: u32,
    shared_mem_bytes: u32,
    param_count: usize = 0,
    p_params: ?[*]const *const anyopaque = null,
    extra_count: usize = 0,
    p_extras: ?[*]const *const anyopaque = null,
};
pub const PhysicalDeviceDescriptorBufferFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_descriptor_buffer_features_ext,
    p_next: ?*anyopaque = null,
    descriptor_buffer: Bool32 = .false,
    descriptor_buffer_capture_replay: Bool32 = .false,
    descriptor_buffer_image_layout_ignored: Bool32 = .false,
    descriptor_buffer_push_descriptors: Bool32 = .false,
};
pub const PhysicalDeviceDescriptorBufferPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_descriptor_buffer_properties_ext,
    p_next: ?*anyopaque = null,
    combined_image_sampler_descriptor_single_array: Bool32,
    bufferless_push_descriptors: Bool32,
    allow_sampler_image_view_post_submit_creation: Bool32,
    descriptor_buffer_offset_alignment: DeviceSize,
    max_descriptor_buffer_bindings: u32,
    max_resource_descriptor_buffer_bindings: u32,
    max_sampler_descriptor_buffer_bindings: u32,
    max_embedded_immutable_sampler_bindings: u32,
    max_embedded_immutable_samplers: u32,
    buffer_capture_replay_descriptor_data_size: usize,
    image_capture_replay_descriptor_data_size: usize,
    image_view_capture_replay_descriptor_data_size: usize,
    sampler_capture_replay_descriptor_data_size: usize,
    acceleration_structure_capture_replay_descriptor_data_size: usize,
    sampler_descriptor_size: usize,
    combined_image_sampler_descriptor_size: usize,
    sampled_image_descriptor_size: usize,
    storage_image_descriptor_size: usize,
    uniform_texel_buffer_descriptor_size: usize,
    robust_uniform_texel_buffer_descriptor_size: usize,
    storage_texel_buffer_descriptor_size: usize,
    robust_storage_texel_buffer_descriptor_size: usize,
    uniform_buffer_descriptor_size: usize,
    robust_uniform_buffer_descriptor_size: usize,
    storage_buffer_descriptor_size: usize,
    robust_storage_buffer_descriptor_size: usize,
    input_attachment_descriptor_size: usize,
    acceleration_structure_descriptor_size: usize,
    max_sampler_descriptor_buffer_range: DeviceSize,
    max_resource_descriptor_buffer_range: DeviceSize,
    sampler_descriptor_buffer_address_space_size: DeviceSize,
    resource_descriptor_buffer_address_space_size: DeviceSize,
    descriptor_buffer_address_space_size: DeviceSize,
};
pub const PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_descriptor_buffer_density_map_properties_ext,
    p_next: ?*anyopaque = null,
    combined_image_sampler_density_map_descriptor_size: usize,
};
pub const DescriptorAddressInfoEXT = extern struct {
    s_type: StructureType = .descriptor_address_info_ext,
    p_next: ?*anyopaque = null,
    address: DeviceAddress,
    range: DeviceSize,
    format: Format,
};
pub const DescriptorBufferBindingInfoEXT = extern struct {
    s_type: StructureType = .descriptor_buffer_binding_info_ext,
    p_next: ?*const anyopaque = null,
    address: DeviceAddress,
    usage: BufferUsageFlags = .{},
};
pub const DescriptorBufferBindingPushDescriptorBufferHandleEXT = extern struct {
    s_type: StructureType = .descriptor_buffer_binding_push_descriptor_buffer_handle_ext,
    p_next: ?*const anyopaque = null,
    buffer: Buffer,
};
pub const DescriptorDataEXT = extern union {
    p_sampler: *const Sampler,
    p_combined_image_sampler: *const DescriptorImageInfo,
    p_input_attachment_image: *const DescriptorImageInfo,
    p_sampled_image: ?*const DescriptorImageInfo,
    p_storage_image: ?*const DescriptorImageInfo,
    p_uniform_texel_buffer: ?*const DescriptorAddressInfoEXT,
    p_storage_texel_buffer: ?*const DescriptorAddressInfoEXT,
    p_uniform_buffer: ?*const DescriptorAddressInfoEXT,
    p_storage_buffer: ?*const DescriptorAddressInfoEXT,
    acceleration_structure: DeviceAddress,
};
pub const DescriptorGetInfoEXT = extern struct {
    s_type: StructureType = .descriptor_get_info_ext,
    p_next: ?*const anyopaque = null,
    type: DescriptorType,
    data: DescriptorDataEXT,
};
pub const BufferCaptureDescriptorDataInfoEXT = extern struct {
    s_type: StructureType = .buffer_capture_descriptor_data_info_ext,
    p_next: ?*const anyopaque = null,
    buffer: Buffer,
};
pub const ImageCaptureDescriptorDataInfoEXT = extern struct {
    s_type: StructureType = .image_capture_descriptor_data_info_ext,
    p_next: ?*const anyopaque = null,
    image: Image,
};
pub const ImageViewCaptureDescriptorDataInfoEXT = extern struct {
    s_type: StructureType = .image_view_capture_descriptor_data_info_ext,
    p_next: ?*const anyopaque = null,
    image_view: ImageView,
};
pub const SamplerCaptureDescriptorDataInfoEXT = extern struct {
    s_type: StructureType = .sampler_capture_descriptor_data_info_ext,
    p_next: ?*const anyopaque = null,
    sampler: Sampler,
};
pub const AccelerationStructureCaptureDescriptorDataInfoEXT = extern struct {
    s_type: StructureType = .acceleration_structure_capture_descriptor_data_info_ext,
    p_next: ?*const anyopaque = null,
    acceleration_structure: AccelerationStructureKHR = .null_handle,
    acceleration_structure_nv: AccelerationStructureNV = .null_handle,
};
pub const OpaqueCaptureDescriptorDataCreateInfoEXT = extern struct {
    s_type: StructureType = .opaque_capture_descriptor_data_create_info_ext,
    p_next: ?*const anyopaque = null,
    opaque_capture_descriptor_data: *const anyopaque,
};
pub const PhysicalDeviceShaderIntegerDotProductFeatures = extern struct {
    s_type: StructureType = .physical_device_shader_integer_dot_product_features,
    p_next: ?*anyopaque = null,
    shader_integer_dot_product: Bool32 = .false,
};
pub const PhysicalDeviceShaderIntegerDotProductFeaturesKHR = PhysicalDeviceShaderIntegerDotProductFeatures;
pub const PhysicalDeviceShaderIntegerDotProductProperties = extern struct {
    s_type: StructureType = .physical_device_shader_integer_dot_product_properties,
    p_next: ?*anyopaque = null,
    integer_dot_product_8_bit_unsigned_accelerated: Bool32,
    integer_dot_product_8_bit_signed_accelerated: Bool32,
    integer_dot_product_8_bit_mixed_signedness_accelerated: Bool32,
    integer_dot_product_4x_8_bit_packed_unsigned_accelerated: Bool32,
    integer_dot_product_4x_8_bit_packed_signed_accelerated: Bool32,
    integer_dot_product_4x_8_bit_packed_mixed_signedness_accelerated: Bool32,
    integer_dot_product_16_bit_unsigned_accelerated: Bool32,
    integer_dot_product_16_bit_signed_accelerated: Bool32,
    integer_dot_product_16_bit_mixed_signedness_accelerated: Bool32,
    integer_dot_product_32_bit_unsigned_accelerated: Bool32,
    integer_dot_product_32_bit_signed_accelerated: Bool32,
    integer_dot_product_32_bit_mixed_signedness_accelerated: Bool32,
    integer_dot_product_64_bit_unsigned_accelerated: Bool32,
    integer_dot_product_64_bit_signed_accelerated: Bool32,
    integer_dot_product_64_bit_mixed_signedness_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_8_bit_unsigned_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_8_bit_signed_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_8_bit_mixed_signedness_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_4x_8_bit_packed_unsigned_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_4x_8_bit_packed_signed_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_4x_8_bit_packed_mixed_signedness_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_16_bit_unsigned_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_16_bit_signed_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_16_bit_mixed_signedness_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_32_bit_unsigned_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_32_bit_signed_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_32_bit_mixed_signedness_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_64_bit_unsigned_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_64_bit_signed_accelerated: Bool32,
    integer_dot_product_accumulating_saturating_64_bit_mixed_signedness_accelerated: Bool32,
};
pub const PhysicalDeviceShaderIntegerDotProductPropertiesKHR = PhysicalDeviceShaderIntegerDotProductProperties;
pub const PhysicalDeviceDrmPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_drm_properties_ext,
    p_next: ?*anyopaque = null,
    has_primary: Bool32,
    has_render: Bool32,
    primary_major: i64,
    primary_minor: i64,
    render_major: i64,
    render_minor: i64,
};
pub const PhysicalDeviceFragmentShaderBarycentricFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_fragment_shader_barycentric_features_khr,
    p_next: ?*anyopaque = null,
    fragment_shader_barycentric: Bool32 = .false,
};
pub const PhysicalDeviceFragmentShaderBarycentricPropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_fragment_shader_barycentric_properties_khr,
    p_next: ?*anyopaque = null,
    tri_strip_vertex_order_independent_of_provoking_vertex: Bool32,
};
pub const PhysicalDeviceRayTracingMotionBlurFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_motion_blur_features_nv,
    p_next: ?*anyopaque = null,
    ray_tracing_motion_blur: Bool32 = .false,
    ray_tracing_motion_blur_pipeline_trace_rays_indirect: Bool32 = .false,
};
pub const PhysicalDeviceRayTracingValidationFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_validation_features_nv,
    p_next: ?*anyopaque = null,
    ray_tracing_validation: Bool32 = .false,
};
pub const PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_linear_swept_spheres_features_nv,
    p_next: ?*anyopaque = null,
    spheres: Bool32 = .false,
    linear_swept_spheres: Bool32 = .false,
};
pub const AccelerationStructureGeometryMotionTrianglesDataNV = extern struct {
    s_type: StructureType = .acceleration_structure_geometry_motion_triangles_data_nv,
    p_next: ?*const anyopaque = null,
    vertex_data: DeviceOrHostAddressConstKHR,
};
pub const AccelerationStructureMotionInfoNV = extern struct {
    s_type: StructureType = .acceleration_structure_motion_info_nv,
    p_next: ?*const anyopaque = null,
    max_instances: u32,
    flags: AccelerationStructureMotionInfoFlagsNV = .{},
};
pub const SRTDataNV = extern struct {
    sx: f32,
    a: f32,
    b: f32,
    pvx: f32,
    sy: f32,
    c: f32,
    pvy: f32,
    sz: f32,
    pvz: f32,
    qx: f32,
    qy: f32,
    qz: f32,
    qw: f32,
    tx: f32,
    ty: f32,
    tz: f32,
};
pub const AccelerationStructureSRTMotionInstanceNV = extern struct {
    transform_t0: SRTDataNV,
    transform_t1: SRTDataNV,
    instance_custom_index_and_mask: packed struct(u32) {
        instance_custom_index: u24,
        mask: u8,
    },
    instance_shader_binding_table_record_offset_and_flags: packed struct(u32) {
        instance_shader_binding_table_record_offset: u24,
        flags: u8, // GeometryInstanceFlagsKHR
    },
    acceleration_structure_reference: u64,
};
pub const AccelerationStructureMatrixMotionInstanceNV = extern struct {
    transform_t0: TransformMatrixNV,
    transform_t1: TransformMatrixNV,
    instance_custom_index_and_mask: packed struct(u32) {
        instance_custom_index: u24,
        mask: u8,
    },
    instance_shader_binding_table_record_offset_and_flags: packed struct(u32) {
        instance_shader_binding_table_record_offset: u24,
        flags: u8, // GeometryInstanceFlagsKHR
    },
    acceleration_structure_reference: u64,
};
pub const AccelerationStructureMotionInstanceDataNV = extern union {
    static_instance: AccelerationStructureInstanceKHR,
    matrix_motion_instance: AccelerationStructureMatrixMotionInstanceNV,
    srt_motion_instance: AccelerationStructureSRTMotionInstanceNV,
};
pub const AccelerationStructureMotionInstanceNV = extern struct {
    type: AccelerationStructureMotionInstanceTypeNV,
    flags: AccelerationStructureMotionInstanceFlagsNV = .{},
    data: AccelerationStructureMotionInstanceDataNV,
};
pub const RemoteAddressNV = *anyopaque;
pub const MemoryGetRemoteAddressInfoNV = extern struct {
    s_type: StructureType = .memory_get_remote_address_info_nv,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory,
    handle_type: ExternalMemoryHandleTypeFlags,
};
pub const ImportMemoryBufferCollectionFUCHSIA = extern struct {
    s_type: StructureType = .import_memory_buffer_collection_fuchsia,
    p_next: ?*const anyopaque = null,
    collection: BufferCollectionFUCHSIA,
    index: u32,
};
pub const BufferCollectionImageCreateInfoFUCHSIA = extern struct {
    s_type: StructureType = .buffer_collection_image_create_info_fuchsia,
    p_next: ?*const anyopaque = null,
    collection: BufferCollectionFUCHSIA,
    index: u32,
};
pub const BufferCollectionBufferCreateInfoFUCHSIA = extern struct {
    s_type: StructureType = .buffer_collection_buffer_create_info_fuchsia,
    p_next: ?*const anyopaque = null,
    collection: BufferCollectionFUCHSIA,
    index: u32,
};
pub const BufferCollectionCreateInfoFUCHSIA = extern struct {
    s_type: StructureType = .buffer_collection_create_info_fuchsia,
    p_next: ?*const anyopaque = null,
    collection_token: zx_handle_t,
};
pub const BufferCollectionPropertiesFUCHSIA = extern struct {
    s_type: StructureType = .buffer_collection_properties_fuchsia,
    p_next: ?*anyopaque = null,
    memory_type_bits: u32,
    buffer_count: u32,
    create_info_index: u32,
    sysmem_pixel_format: u64,
    format_features: FormatFeatureFlags,
    sysmem_color_space_index: SysmemColorSpaceFUCHSIA,
    sampler_ycbcr_conversion_components: ComponentMapping,
    suggested_ycbcr_model: SamplerYcbcrModelConversion,
    suggested_ycbcr_range: SamplerYcbcrRange,
    suggested_x_chroma_offset: ChromaLocation,
    suggested_y_chroma_offset: ChromaLocation,
};
pub const BufferConstraintsInfoFUCHSIA = extern struct {
    s_type: StructureType = .buffer_constraints_info_fuchsia,
    p_next: ?*const anyopaque = null,
    create_info: BufferCreateInfo,
    required_format_features: FormatFeatureFlags = .{},
    buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA,
};
pub const SysmemColorSpaceFUCHSIA = extern struct {
    s_type: StructureType = .sysmem_color_space_fuchsia,
    p_next: ?*const anyopaque = null,
    color_space: u32,
};
pub const ImageFormatConstraintsInfoFUCHSIA = extern struct {
    s_type: StructureType = .image_format_constraints_info_fuchsia,
    p_next: ?*const anyopaque = null,
    image_create_info: ImageCreateInfo,
    required_format_features: FormatFeatureFlags,
    flags: ImageFormatConstraintsFlagsFUCHSIA = .{},
    sysmem_pixel_format: u64 = 0,
    color_space_count: u32,
    p_color_spaces: [*]const SysmemColorSpaceFUCHSIA,
};
pub const ImageConstraintsInfoFUCHSIA = extern struct {
    s_type: StructureType = .image_constraints_info_fuchsia,
    p_next: ?*const anyopaque = null,
    format_constraints_count: u32,
    p_format_constraints: [*]const ImageFormatConstraintsInfoFUCHSIA,
    buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA,
    flags: ImageConstraintsInfoFlagsFUCHSIA = .{},
};
pub const BufferCollectionConstraintsInfoFUCHSIA = extern struct {
    s_type: StructureType = .buffer_collection_constraints_info_fuchsia,
    p_next: ?*const anyopaque = null,
    min_buffer_count: u32,
    max_buffer_count: u32,
    min_buffer_count_for_camping: u32,
    min_buffer_count_for_dedicated_slack: u32,
    min_buffer_count_for_shared_slack: u32,
};
pub const CudaModuleNV = enum(u64) { null_handle = 0, _ };
pub const CudaFunctionNV = enum(u64) { null_handle = 0, _ };
pub const CudaModuleCreateInfoNV = extern struct {
    s_type: StructureType = .cuda_module_create_info_nv,
    p_next: ?*const anyopaque = null,
    data_size: usize,
    p_data: *const anyopaque,
};
pub const CudaFunctionCreateInfoNV = extern struct {
    s_type: StructureType = .cuda_function_create_info_nv,
    p_next: ?*const anyopaque = null,
    module: CudaModuleNV,
    p_name: [*:0]const u8,
};
pub const CudaLaunchInfoNV = extern struct {
    s_type: StructureType = .cuda_launch_info_nv,
    p_next: ?*const anyopaque = null,
    function: CudaFunctionNV,
    grid_dim_x: u32,
    grid_dim_y: u32,
    grid_dim_z: u32,
    block_dim_x: u32,
    block_dim_y: u32,
    block_dim_z: u32,
    shared_mem_bytes: u32,
    param_count: usize = 0,
    p_params: ?[*]const *const anyopaque = null,
    extra_count: usize = 0,
    p_extras: ?[*]const *const anyopaque = null,
};
pub const PhysicalDeviceRGBA10X6FormatsFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_rgba10x6_formats_features_ext,
    p_next: ?*anyopaque = null,
    format_rgba_1_0x_6_without_y_cb_cr_sampler: Bool32 = .false,
};
pub const FormatProperties3 = extern struct {
    s_type: StructureType = .format_properties_3,
    p_next: ?*anyopaque = null,
    linear_tiling_features: FormatFeatureFlags2 = .{},
    optimal_tiling_features: FormatFeatureFlags2 = .{},
    buffer_features: FormatFeatureFlags2 = .{},
};
pub const FormatProperties3KHR = FormatProperties3;
pub const DrmFormatModifierPropertiesList2EXT = extern struct {
    s_type: StructureType = .drm_format_modifier_properties_list_2_ext,
    p_next: ?*anyopaque = null,
    drm_format_modifier_count: u32 = 0,
    p_drm_format_modifier_properties: ?[*]DrmFormatModifierProperties2EXT = null,
};
pub const DrmFormatModifierProperties2EXT = extern struct {
    drm_format_modifier: u64,
    drm_format_modifier_plane_count: u32,
    drm_format_modifier_tiling_features: FormatFeatureFlags2,
};
pub const AndroidHardwareBufferFormatProperties2ANDROID = extern struct {
    s_type: StructureType = .android_hardware_buffer_format_properties_2_android,
    p_next: ?*anyopaque = null,
    format: Format,
    external_format: u64,
    format_features: FormatFeatureFlags2,
    sampler_ycbcr_conversion_components: ComponentMapping,
    suggested_ycbcr_model: SamplerYcbcrModelConversion,
    suggested_ycbcr_range: SamplerYcbcrRange,
    suggested_x_chroma_offset: ChromaLocation,
    suggested_y_chroma_offset: ChromaLocation,
};
pub const PipelineRenderingCreateInfo = extern struct {
    s_type: StructureType = .pipeline_rendering_create_info,
    p_next: ?*const anyopaque = null,
    view_mask: u32,
    color_attachment_count: u32 = 0,
    p_color_attachment_formats: ?[*]const Format = null,
    depth_attachment_format: Format,
    stencil_attachment_format: Format,
};
pub const PipelineRenderingCreateInfoKHR = PipelineRenderingCreateInfo;
pub const RenderingInfo = extern struct {
    s_type: StructureType = .rendering_info,
    p_next: ?*const anyopaque = null,
    flags: RenderingFlags = .{},
    render_area: Rect2D,
    layer_count: u32,
    view_mask: u32,
    color_attachment_count: u32 = 0,
    p_color_attachments: ?[*]const RenderingAttachmentInfo = null,
    p_depth_attachment: ?*const RenderingAttachmentInfo = null,
    p_stencil_attachment: ?*const RenderingAttachmentInfo = null,
};
pub const RenderingInfoKHR = RenderingInfo;
pub const RenderingEndInfoEXT = extern struct {
    s_type: StructureType = .rendering_end_info_ext,
    p_next: ?*const anyopaque = null,
};
pub const RenderingAttachmentInfo = extern struct {
    s_type: StructureType = .rendering_attachment_info,
    p_next: ?*const anyopaque = null,
    image_view: ImageView = .null_handle,
    image_layout: ImageLayout,
    resolve_mode: ResolveModeFlags,
    resolve_image_view: ImageView = .null_handle,
    resolve_image_layout: ImageLayout,
    load_op: AttachmentLoadOp,
    store_op: AttachmentStoreOp,
    clear_value: ClearValue,
};
pub const RenderingAttachmentInfoKHR = RenderingAttachmentInfo;
pub const RenderingFragmentShadingRateAttachmentInfoKHR = extern struct {
    s_type: StructureType = .rendering_fragment_shading_rate_attachment_info_khr,
    p_next: ?*const anyopaque = null,
    image_view: ImageView = .null_handle,
    image_layout: ImageLayout,
    shading_rate_attachment_texel_size: Extent2D,
};
pub const RenderingFragmentDensityMapAttachmentInfoEXT = extern struct {
    s_type: StructureType = .rendering_fragment_density_map_attachment_info_ext,
    p_next: ?*const anyopaque = null,
    image_view: ImageView,
    image_layout: ImageLayout,
};
pub const PhysicalDeviceDynamicRenderingFeatures = extern struct {
    s_type: StructureType = .physical_device_dynamic_rendering_features,
    p_next: ?*anyopaque = null,
    dynamic_rendering: Bool32 = .false,
};
pub const PhysicalDeviceDynamicRenderingFeaturesKHR = PhysicalDeviceDynamicRenderingFeatures;
pub const CommandBufferInheritanceRenderingInfo = extern struct {
    s_type: StructureType = .command_buffer_inheritance_rendering_info,
    p_next: ?*const anyopaque = null,
    flags: RenderingFlags = .{},
    view_mask: u32,
    color_attachment_count: u32 = 0,
    p_color_attachment_formats: ?[*]const Format = null,
    depth_attachment_format: Format,
    stencil_attachment_format: Format,
    rasterization_samples: SampleCountFlags,
};
pub const CommandBufferInheritanceRenderingInfoKHR = CommandBufferInheritanceRenderingInfo;
pub const AttachmentSampleCountInfoAMD = extern struct {
    s_type: StructureType = .attachment_sample_count_info_amd,
    p_next: ?*const anyopaque = null,
    color_attachment_count: u32 = 0,
    p_color_attachment_samples: ?[*]const SampleCountFlags = null,
    depth_stencil_attachment_samples: SampleCountFlags,
};
pub const AttachmentSampleCountInfoNV = AttachmentSampleCountInfoAMD;
pub const MultiviewPerViewAttributesInfoNVX = extern struct {
    s_type: StructureType = .multiview_per_view_attributes_info_nvx,
    p_next: ?*const anyopaque = null,
    per_view_attributes: Bool32,
    per_view_attributes_position_x_only: Bool32,
};
pub const PhysicalDeviceImageViewMinLodFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_image_view_min_lod_features_ext,
    p_next: ?*anyopaque = null,
    min_lod: Bool32 = .false,
};
pub const ImageViewMinLodCreateInfoEXT = extern struct {
    s_type: StructureType = .image_view_min_lod_create_info_ext,
    p_next: ?*const anyopaque = null,
    min_lod: f32,
};
pub const PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_rasterization_order_attachment_access_features_ext,
    p_next: ?*anyopaque = null,
    rasterization_order_color_attachment_access: Bool32 = .false,
    rasterization_order_depth_attachment_access: Bool32 = .false,
    rasterization_order_stencil_attachment_access: Bool32 = .false,
};
pub const PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
pub const PhysicalDeviceLinearColorAttachmentFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_linear_color_attachment_features_nv,
    p_next: ?*anyopaque = null,
    linear_color_attachment: Bool32 = .false,
};
pub const PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_graphics_pipeline_library_features_ext,
    p_next: ?*anyopaque = null,
    graphics_pipeline_library: Bool32 = .false,
};
pub const PhysicalDevicePipelineBinaryFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_pipeline_binary_features_khr,
    p_next: ?*anyopaque = null,
    pipeline_binaries: Bool32 = .false,
};
pub const DevicePipelineBinaryInternalCacheControlKHR = extern struct {
    s_type: StructureType = .device_pipeline_binary_internal_cache_control_khr,
    p_next: ?*const anyopaque = null,
    disable_internal_cache: Bool32 = .false,
};
pub const PhysicalDevicePipelineBinaryPropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_pipeline_binary_properties_khr,
    p_next: ?*anyopaque = null,
    pipeline_binary_internal_cache: Bool32,
    pipeline_binary_internal_cache_control: Bool32,
    pipeline_binary_prefers_internal_cache: Bool32,
    pipeline_binary_precompiled_internal_cache: Bool32,
    pipeline_binary_compressed_data: Bool32,
};
pub const PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_graphics_pipeline_library_properties_ext,
    p_next: ?*anyopaque = null,
    graphics_pipeline_library_fast_linking: Bool32,
    graphics_pipeline_library_independent_interpolation_decoration: Bool32,
};
pub const GraphicsPipelineLibraryCreateInfoEXT = extern struct {
    s_type: StructureType = .graphics_pipeline_library_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: GraphicsPipelineLibraryFlagsEXT,
};
pub const PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE = extern struct {
    s_type: StructureType = .physical_device_descriptor_set_host_mapping_features_valve,
    p_next: ?*anyopaque = null,
    descriptor_set_host_mapping: Bool32 = .false,
};
pub const DescriptorSetBindingReferenceVALVE = extern struct {
    s_type: StructureType = .descriptor_set_binding_reference_valve,
    p_next: ?*const anyopaque = null,
    descriptor_set_layout: DescriptorSetLayout,
    binding: u32,
};
pub const DescriptorSetLayoutHostMappingInfoVALVE = extern struct {
    s_type: StructureType = .descriptor_set_layout_host_mapping_info_valve,
    p_next: ?*anyopaque = null,
    descriptor_offset: usize,
    descriptor_size: u32,
};
pub const PhysicalDeviceNestedCommandBufferFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_nested_command_buffer_features_ext,
    p_next: ?*anyopaque = null,
    nested_command_buffer: Bool32 = .false,
    nested_command_buffer_rendering: Bool32 = .false,
    nested_command_buffer_simultaneous_use: Bool32 = .false,
};
pub const PhysicalDeviceNestedCommandBufferPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_nested_command_buffer_properties_ext,
    p_next: ?*anyopaque = null,
    max_command_buffer_nesting_level: u32,
};
pub const PhysicalDeviceShaderModuleIdentifierFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_module_identifier_features_ext,
    p_next: ?*anyopaque = null,
    shader_module_identifier: Bool32 = .false,
};
pub const PhysicalDeviceShaderModuleIdentifierPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_module_identifier_properties_ext,
    p_next: ?*anyopaque = null,
    shader_module_identifier_algorithm_uuid: [UUID_SIZE]u8,
};
pub const PipelineShaderStageModuleIdentifierCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_shader_stage_module_identifier_create_info_ext,
    p_next: ?*const anyopaque = null,
    identifier_size: u32 = 0,
    p_identifier: ?[*]const u8 = null,
};
pub const ShaderModuleIdentifierEXT = extern struct {
    s_type: StructureType = .shader_module_identifier_ext,
    p_next: ?*anyopaque = null,
    identifier_size: u32,
    identifier: [MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT]u8,
};
pub const ImageCompressionControlEXT = extern struct {
    s_type: StructureType = .image_compression_control_ext,
    p_next: ?*const anyopaque = null,
    flags: ImageCompressionFlagsEXT,
    compression_control_plane_count: u32 = 0,
    p_fixed_rate_flags: ?[*]ImageCompressionFixedRateFlagsEXT = null,
};
pub const PhysicalDeviceImageCompressionControlFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_image_compression_control_features_ext,
    p_next: ?*anyopaque = null,
    image_compression_control: Bool32 = .false,
};
pub const ImageCompressionPropertiesEXT = extern struct {
    s_type: StructureType = .image_compression_properties_ext,
    p_next: ?*anyopaque = null,
    image_compression_flags: ImageCompressionFlagsEXT,
    image_compression_fixed_rate_flags: ImageCompressionFixedRateFlagsEXT,
};
pub const PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_image_compression_control_swapchain_features_ext,
    p_next: ?*anyopaque = null,
    image_compression_control_swapchain: Bool32 = .false,
};
pub const ImageSubresource2 = extern struct {
    s_type: StructureType = .image_subresource_2,
    p_next: ?*anyopaque = null,
    image_subresource: ImageSubresource,
};
pub const ImageSubresource2KHR = ImageSubresource2;
pub const ImageSubresource2EXT = ImageSubresource2;
pub const SubresourceLayout2 = extern struct {
    s_type: StructureType = .subresource_layout_2,
    p_next: ?*anyopaque = null,
    subresource_layout: SubresourceLayout,
};
pub const SubresourceLayout2KHR = SubresourceLayout2;
pub const SubresourceLayout2EXT = SubresourceLayout2;
pub const RenderPassCreationControlEXT = extern struct {
    s_type: StructureType = .render_pass_creation_control_ext,
    p_next: ?*const anyopaque = null,
    disallow_merging: Bool32,
};
pub const RenderPassCreationFeedbackInfoEXT = extern struct {
    post_merge_subpass_count: u32,
};
pub const RenderPassCreationFeedbackCreateInfoEXT = extern struct {
    s_type: StructureType = .render_pass_creation_feedback_create_info_ext,
    p_next: ?*const anyopaque = null,
    p_render_pass_feedback: *RenderPassCreationFeedbackInfoEXT,
};
pub const RenderPassSubpassFeedbackInfoEXT = extern struct {
    subpass_merge_status: SubpassMergeStatusEXT,
    description: [MAX_DESCRIPTION_SIZE]u8,
    post_merge_index: u32,
};
pub const RenderPassSubpassFeedbackCreateInfoEXT = extern struct {
    s_type: StructureType = .render_pass_subpass_feedback_create_info_ext,
    p_next: ?*const anyopaque = null,
    p_subpass_feedback: *RenderPassSubpassFeedbackInfoEXT,
};
pub const PhysicalDeviceSubpassMergeFeedbackFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_subpass_merge_feedback_features_ext,
    p_next: ?*anyopaque = null,
    subpass_merge_feedback: Bool32 = .false,
};
pub const MicromapBuildInfoEXT = extern struct {
    s_type: StructureType = .micromap_build_info_ext,
    p_next: ?*const anyopaque = null,
    type: MicromapTypeEXT,
    flags: BuildMicromapFlagsEXT = .{},
    mode: BuildMicromapModeEXT,
    dst_micromap: MicromapEXT = .null_handle,
    usage_counts_count: u32 = 0,
    p_usage_counts: ?[*]const MicromapUsageEXT = null,
    pp_usage_counts: ?[*]const [*]const MicromapUsageEXT = null,
    data: DeviceOrHostAddressConstKHR,
    scratch_data: DeviceOrHostAddressKHR,
    triangle_array: DeviceOrHostAddressConstKHR,
    triangle_array_stride: DeviceSize,
};
pub const MicromapCreateInfoEXT = extern struct {
    s_type: StructureType = .micromap_create_info_ext,
    p_next: ?*const anyopaque = null,
    create_flags: MicromapCreateFlagsEXT = .{},
    buffer: Buffer,
    offset: DeviceSize,
    size: DeviceSize,
    type: MicromapTypeEXT,
    device_address: DeviceAddress = 0,
};
pub const MicromapVersionInfoEXT = extern struct {
    s_type: StructureType = .micromap_version_info_ext,
    p_next: ?*const anyopaque = null,
    p_version_data: [*]const u8,
};
pub const CopyMicromapInfoEXT = extern struct {
    s_type: StructureType = .copy_micromap_info_ext,
    p_next: ?*const anyopaque = null,
    src: MicromapEXT,
    dst: MicromapEXT,
    mode: CopyMicromapModeEXT,
};
pub const CopyMicromapToMemoryInfoEXT = extern struct {
    s_type: StructureType = .copy_micromap_to_memory_info_ext,
    p_next: ?*const anyopaque = null,
    src: MicromapEXT,
    dst: DeviceOrHostAddressKHR,
    mode: CopyMicromapModeEXT,
};
pub const CopyMemoryToMicromapInfoEXT = extern struct {
    s_type: StructureType = .copy_memory_to_micromap_info_ext,
    p_next: ?*const anyopaque = null,
    src: DeviceOrHostAddressConstKHR,
    dst: MicromapEXT,
    mode: CopyMicromapModeEXT,
};
pub const MicromapBuildSizesInfoEXT = extern struct {
    s_type: StructureType = .micromap_build_sizes_info_ext,
    p_next: ?*const anyopaque = null,
    micromap_size: DeviceSize,
    build_scratch_size: DeviceSize,
    discardable: Bool32,
};
pub const MicromapUsageEXT = extern struct {
    count: u32,
    subdivision_level: u32,
    format: u32,
};
pub const MicromapTriangleEXT = extern struct {
    data_offset: u32,
    subdivision_level: u16,
    format: u16,
};
pub const PhysicalDeviceOpacityMicromapFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_opacity_micromap_features_ext,
    p_next: ?*anyopaque = null,
    micromap: Bool32 = .false,
    micromap_capture_replay: Bool32 = .false,
    micromap_host_commands: Bool32 = .false,
};
pub const PhysicalDeviceOpacityMicromapPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_opacity_micromap_properties_ext,
    p_next: ?*anyopaque = null,
    max_opacity_2_state_subdivision_level: u32,
    max_opacity_4_state_subdivision_level: u32,
};
pub const AccelerationStructureTrianglesOpacityMicromapEXT = extern struct {
    s_type: StructureType = .acceleration_structure_triangles_opacity_micromap_ext,
    p_next: ?*anyopaque = null,
    index_type: IndexType,
    index_buffer: DeviceOrHostAddressConstKHR,
    index_stride: DeviceSize,
    base_triangle: u32,
    usage_counts_count: u32 = 0,
    p_usage_counts: ?[*]const MicromapUsageEXT = null,
    pp_usage_counts: ?[*]const [*]const MicromapUsageEXT = null,
    micromap: MicromapEXT = .null_handle,
};
pub const PhysicalDeviceDisplacementMicromapFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_displacement_micromap_features_nv,
    p_next: ?*anyopaque = null,
    displacement_micromap: Bool32 = .false,
};
pub const PhysicalDeviceDisplacementMicromapPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_displacement_micromap_properties_nv,
    p_next: ?*anyopaque = null,
    max_displacement_micromap_subdivision_level: u32,
};
pub const AccelerationStructureTrianglesDisplacementMicromapNV = extern struct {
    s_type: StructureType = .acceleration_structure_triangles_displacement_micromap_nv,
    p_next: ?*anyopaque = null,
    displacement_bias_and_scale_format: Format,
    displacement_vector_format: Format,
    displacement_bias_and_scale_buffer: DeviceOrHostAddressConstKHR,
    displacement_bias_and_scale_stride: DeviceSize,
    displacement_vector_buffer: DeviceOrHostAddressConstKHR,
    displacement_vector_stride: DeviceSize,
    displaced_micromap_primitive_flags: DeviceOrHostAddressConstKHR,
    displaced_micromap_primitive_flags_stride: DeviceSize,
    index_type: IndexType,
    index_buffer: DeviceOrHostAddressConstKHR,
    index_stride: DeviceSize,
    base_triangle: u32,
    usage_counts_count: u32 = 0,
    p_usage_counts: ?[*]const MicromapUsageEXT = null,
    pp_usage_counts: ?[*]const [*]const MicromapUsageEXT = null,
    micromap: MicromapEXT = .null_handle,
};
pub const PipelinePropertiesIdentifierEXT = extern struct {
    s_type: StructureType = .pipeline_properties_identifier_ext,
    p_next: ?*anyopaque = null,
    pipeline_identifier: [UUID_SIZE]u8,
};
pub const PhysicalDevicePipelinePropertiesFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_pipeline_properties_features_ext,
    p_next: ?*anyopaque = null,
    pipeline_properties_identifier: Bool32 = .false,
};
pub const PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD = extern struct {
    s_type: StructureType = .physical_device_shader_early_and_late_fragment_tests_features_amd,
    p_next: ?*anyopaque = null,
    shader_early_and_late_fragment_tests: Bool32 = .false,
};
pub const ExternalMemoryAcquireUnmodifiedEXT = extern struct {
    s_type: StructureType = .external_memory_acquire_unmodified_ext,
    p_next: ?*const anyopaque = null,
    acquire_unmodified_memory: Bool32,
};
pub const ExportMetalObjectCreateInfoEXT = extern struct {
    s_type: StructureType = .export_metal_object_create_info_ext,
    p_next: ?*const anyopaque = null,
    export_object_type: ExportMetalObjectTypeFlagsEXT,
};
pub const ExportMetalObjectsInfoEXT = extern struct {
    s_type: StructureType = .export_metal_objects_info_ext,
    p_next: ?*const anyopaque = null,
};
pub const ExportMetalDeviceInfoEXT = extern struct {
    s_type: StructureType = .export_metal_device_info_ext,
    p_next: ?*const anyopaque = null,
    mtl_device: MTLDevice_id,
};
pub const ExportMetalCommandQueueInfoEXT = extern struct {
    s_type: StructureType = .export_metal_command_queue_info_ext,
    p_next: ?*const anyopaque = null,
    queue: Queue,
    mtl_command_queue: MTLCommandQueue_id,
};
pub const ExportMetalBufferInfoEXT = extern struct {
    s_type: StructureType = .export_metal_buffer_info_ext,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory,
    mtl_buffer: MTLBuffer_id,
};
pub const ImportMetalBufferInfoEXT = extern struct {
    s_type: StructureType = .import_metal_buffer_info_ext,
    p_next: ?*const anyopaque = null,
    mtl_buffer: MTLBuffer_id,
};
pub const ExportMetalTextureInfoEXT = extern struct {
    s_type: StructureType = .export_metal_texture_info_ext,
    p_next: ?*const anyopaque = null,
    image: Image = .null_handle,
    image_view: ImageView = .null_handle,
    buffer_view: BufferView = .null_handle,
    plane: ImageAspectFlags,
    mtl_texture: MTLTexture_id,
};
pub const ImportMetalTextureInfoEXT = extern struct {
    s_type: StructureType = .import_metal_texture_info_ext,
    p_next: ?*const anyopaque = null,
    plane: ImageAspectFlags,
    mtl_texture: MTLTexture_id,
};
pub const ExportMetalIOSurfaceInfoEXT = extern struct {
    s_type: StructureType = .export_metal_io_surface_info_ext,
    p_next: ?*const anyopaque = null,
    image: Image,
    io_surface: IOSurfaceRef,
};
pub const ImportMetalIOSurfaceInfoEXT = extern struct {
    s_type: StructureType = .import_metal_io_surface_info_ext,
    p_next: ?*const anyopaque = null,
    io_surface: IOSurfaceRef,
};
pub const ExportMetalSharedEventInfoEXT = extern struct {
    s_type: StructureType = .export_metal_shared_event_info_ext,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore = .null_handle,
    event: Event = .null_handle,
    mtl_shared_event: MTLSharedEvent_id,
};
pub const ImportMetalSharedEventInfoEXT = extern struct {
    s_type: StructureType = .import_metal_shared_event_info_ext,
    p_next: ?*const anyopaque = null,
    mtl_shared_event: MTLSharedEvent_id,
};
pub const PhysicalDeviceNonSeamlessCubeMapFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_non_seamless_cube_map_features_ext,
    p_next: ?*anyopaque = null,
    non_seamless_cube_map: Bool32 = .false,
};
pub const PhysicalDevicePipelineRobustnessFeatures = extern struct {
    s_type: StructureType = .physical_device_pipeline_robustness_features,
    p_next: ?*anyopaque = null,
    pipeline_robustness: Bool32 = .false,
};
pub const PhysicalDevicePipelineRobustnessFeaturesEXT = PhysicalDevicePipelineRobustnessFeatures;
pub const PipelineRobustnessCreateInfo = extern struct {
    s_type: StructureType = .pipeline_robustness_create_info,
    p_next: ?*const anyopaque = null,
    storage_buffers: PipelineRobustnessBufferBehavior,
    uniform_buffers: PipelineRobustnessBufferBehavior,
    vertex_inputs: PipelineRobustnessBufferBehavior,
    images: PipelineRobustnessImageBehavior,
};
pub const PipelineRobustnessCreateInfoEXT = PipelineRobustnessCreateInfo;
pub const PhysicalDevicePipelineRobustnessProperties = extern struct {
    s_type: StructureType = .physical_device_pipeline_robustness_properties,
    p_next: ?*anyopaque = null,
    default_robustness_storage_buffers: PipelineRobustnessBufferBehavior,
    default_robustness_uniform_buffers: PipelineRobustnessBufferBehavior,
    default_robustness_vertex_inputs: PipelineRobustnessBufferBehavior,
    default_robustness_images: PipelineRobustnessImageBehavior,
};
pub const PhysicalDevicePipelineRobustnessPropertiesEXT = PhysicalDevicePipelineRobustnessProperties;
pub const ImageViewSampleWeightCreateInfoQCOM = extern struct {
    s_type: StructureType = .image_view_sample_weight_create_info_qcom,
    p_next: ?*const anyopaque = null,
    filter_center: Offset2D,
    filter_size: Extent2D,
    num_phases: u32,
};
pub const PhysicalDeviceImageProcessingFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_image_processing_features_qcom,
    p_next: ?*anyopaque = null,
    texture_sample_weighted: Bool32 = .false,
    texture_box_filter: Bool32 = .false,
    texture_block_match: Bool32 = .false,
};
pub const PhysicalDeviceImageProcessingPropertiesQCOM = extern struct {
    s_type: StructureType = .physical_device_image_processing_properties_qcom,
    p_next: ?*anyopaque = null,
    max_weight_filter_phases: u32 = 0,
    max_weight_filter_dimension: Extent2D,
    max_block_match_region: Extent2D,
    max_box_filter_block_size: Extent2D,
};
pub const PhysicalDeviceTilePropertiesFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_tile_properties_features_qcom,
    p_next: ?*anyopaque = null,
    tile_properties: Bool32 = .false,
};
pub const TilePropertiesQCOM = extern struct {
    s_type: StructureType = .tile_properties_qcom,
    p_next: ?*anyopaque = null,
    tile_size: Extent3D,
    apron_size: Extent2D,
    origin: Offset2D,
};
pub const TileMemoryBindInfoQCOM = extern struct {
    s_type: StructureType = .tile_memory_bind_info_qcom,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory,
};
pub const PhysicalDeviceAmigoProfilingFeaturesSEC = extern struct {
    s_type: StructureType = .physical_device_amigo_profiling_features_sec,
    p_next: ?*anyopaque = null,
    amigo_profiling: Bool32 = .false,
};
pub const AmigoProfilingSubmitInfoSEC = extern struct {
    s_type: StructureType = .amigo_profiling_submit_info_sec,
    p_next: ?*const anyopaque = null,
    first_draw_timestamp: u64,
    swap_buffer_timestamp: u64,
};
pub const PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_attachment_feedback_loop_layout_features_ext,
    p_next: ?*anyopaque = null,
    attachment_feedback_loop_layout: Bool32 = .false,
};
pub const PhysicalDeviceDepthClampZeroOneFeaturesEXT = PhysicalDeviceDepthClampZeroOneFeaturesKHR;
pub const AttachmentFeedbackLoopInfoEXT = extern struct {
    s_type: StructureType = .attachment_feedback_loop_info_ext,
    p_next: ?*const anyopaque = null,
    feedback_loop_enable: Bool32,
};
pub const PhysicalDeviceAddressBindingReportFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_address_binding_report_features_ext,
    p_next: ?*anyopaque = null,
    report_address_binding: Bool32 = .false,
};
pub const DeviceAddressBindingCallbackDataEXT = extern struct {
    s_type: StructureType = .device_address_binding_callback_data_ext,
    p_next: ?*anyopaque = null,
    flags: DeviceAddressBindingFlagsEXT = .{},
    base_address: DeviceAddress,
    size: DeviceSize,
    binding_type: DeviceAddressBindingTypeEXT,
};
pub const PhysicalDeviceOpticalFlowFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_optical_flow_features_nv,
    p_next: ?*anyopaque = null,
    optical_flow: Bool32 = .false,
};
pub const PhysicalDeviceOpticalFlowPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_optical_flow_properties_nv,
    p_next: ?*anyopaque = null,
    supported_output_grid_sizes: OpticalFlowGridSizeFlagsNV,
    supported_hint_grid_sizes: OpticalFlowGridSizeFlagsNV,
    hint_supported: Bool32,
    cost_supported: Bool32,
    bidirectional_flow_supported: Bool32,
    global_flow_supported: Bool32,
    min_width: u32,
    min_height: u32,
    max_width: u32,
    max_height: u32,
    max_num_regions_of_interest: u32,
};
pub const OpticalFlowImageFormatInfoNV = extern struct {
    s_type: StructureType = .optical_flow_image_format_info_nv,
    p_next: ?*const anyopaque = null,
    usage: OpticalFlowUsageFlagsNV,
};
pub const OpticalFlowImageFormatPropertiesNV = extern struct {
    s_type: StructureType = .optical_flow_image_format_properties_nv,
    p_next: ?*const anyopaque = null,
    format: Format,
};
pub const OpticalFlowSessionCreateInfoNV = extern struct {
    s_type: StructureType = .optical_flow_session_create_info_nv,
    p_next: ?*anyopaque = null,
    width: u32,
    height: u32,
    image_format: Format,
    flow_vector_format: Format,
    cost_format: Format,
    output_grid_size: OpticalFlowGridSizeFlagsNV,
    hint_grid_size: OpticalFlowGridSizeFlagsNV = .{},
    performance_level: OpticalFlowPerformanceLevelNV,
    flags: OpticalFlowSessionCreateFlagsNV = .{},
};
pub const OpticalFlowSessionCreatePrivateDataInfoNV = extern struct {
    s_type: StructureType = .optical_flow_session_create_private_data_info_nv,
    p_next: ?*anyopaque = null,
    id: u32,
    size: u32,
    p_private_data: *const anyopaque,
};
pub const OpticalFlowExecuteInfoNV = extern struct {
    s_type: StructureType = .optical_flow_execute_info_nv,
    p_next: ?*anyopaque = null,
    flags: OpticalFlowExecuteFlagsNV = .{},
    region_count: u32 = 0,
    p_regions: ?[*]const Rect2D = null,
};
pub const PhysicalDeviceFaultFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_fault_features_ext,
    p_next: ?*anyopaque = null,
    device_fault: Bool32 = .false,
    device_fault_vendor_binary: Bool32 = .false,
};
pub const DeviceFaultAddressInfoEXT = extern struct {
    address_type: DeviceFaultAddressTypeEXT,
    reported_address: DeviceAddress,
    address_precision: DeviceSize,
};
pub const DeviceFaultVendorInfoEXT = extern struct {
    description: [MAX_DESCRIPTION_SIZE]u8,
    vendor_fault_code: u64,
    vendor_fault_data: u64,
};
pub const DeviceFaultCountsEXT = extern struct {
    s_type: StructureType = .device_fault_counts_ext,
    p_next: ?*anyopaque = null,
    address_info_count: u32 = 0,
    vendor_info_count: u32 = 0,
    vendor_binary_size: DeviceSize = 0,
};
pub const DeviceFaultInfoEXT = extern struct {
    s_type: StructureType = .device_fault_info_ext,
    p_next: ?*anyopaque = null,
    description: [MAX_DESCRIPTION_SIZE]u8,
    p_address_infos: ?*DeviceFaultAddressInfoEXT = null,
    p_vendor_infos: ?*DeviceFaultVendorInfoEXT = null,
    p_vendor_binary_data: ?*anyopaque = null,
};
pub const DeviceFaultVendorBinaryHeaderVersionOneEXT = extern struct {
    header_size: u32,
    header_version: DeviceFaultVendorBinaryHeaderVersionEXT,
    vendor_id: u32,
    device_id: u32,
    driver_version: u32,
    pipeline_cache_uuid: [UUID_SIZE]u8,
    application_name_offset: u32,
    application_version: u32,
    engine_name_offset: u32,
    engine_version: u32,
    api_version: u32,
};
pub const PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_pipeline_library_group_handles_features_ext,
    p_next: ?*anyopaque = null,
    pipeline_library_group_handles: Bool32 = .false,
};
pub const DepthBiasInfoEXT = extern struct {
    s_type: StructureType = .depth_bias_info_ext,
    p_next: ?*const anyopaque = null,
    depth_bias_constant_factor: f32,
    depth_bias_clamp: f32,
    depth_bias_slope_factor: f32,
};
pub const DepthBiasRepresentationInfoEXT = extern struct {
    s_type: StructureType = .depth_bias_representation_info_ext,
    p_next: ?*const anyopaque = null,
    depth_bias_representation: DepthBiasRepresentationEXT,
    depth_bias_exact: Bool32,
};
pub const DecompressMemoryRegionNV = extern struct {
    src_address: DeviceAddress,
    dst_address: DeviceAddress,
    compressed_size: DeviceSize,
    decompressed_size: DeviceSize,
    decompression_method: MemoryDecompressionMethodFlagsNV,
};
pub const PhysicalDeviceShaderCoreBuiltinsPropertiesARM = extern struct {
    s_type: StructureType = .physical_device_shader_core_builtins_properties_arm,
    p_next: ?*anyopaque = null,
    shader_core_mask: u64,
    shader_core_count: u32,
    shader_warps_per_core: u32,
};
pub const PhysicalDeviceShaderCoreBuiltinsFeaturesARM = extern struct {
    s_type: StructureType = .physical_device_shader_core_builtins_features_arm,
    p_next: ?*anyopaque = null,
    shader_core_builtins: Bool32 = .false,
};
pub const FrameBoundaryEXT = extern struct {
    s_type: StructureType = .frame_boundary_ext,
    p_next: ?*const anyopaque = null,
    flags: FrameBoundaryFlagsEXT = .{},
    frame_id: u64,
    image_count: u32 = 0,
    p_images: ?[*]const Image = null,
    buffer_count: u32 = 0,
    p_buffers: ?[*]const Buffer = null,
    tag_name: u64 = 0,
    tag_size: usize = 0,
    p_tag: ?*const anyopaque = null,
};
pub const PhysicalDeviceFrameBoundaryFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_frame_boundary_features_ext,
    p_next: ?*anyopaque = null,
    frame_boundary: Bool32 = .false,
};
pub const PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_dynamic_rendering_unused_attachments_features_ext,
    p_next: ?*anyopaque = null,
    dynamic_rendering_unused_attachments: Bool32 = .false,
};
pub const SurfacePresentModeKHR = extern struct {
    s_type: StructureType = .surface_present_mode_khr,
    p_next: ?*anyopaque = null,
    present_mode: PresentModeKHR,
};
pub const SurfacePresentModeEXT = SurfacePresentModeKHR;
pub const SurfacePresentScalingCapabilitiesKHR = extern struct {
    s_type: StructureType = .surface_present_scaling_capabilities_khr,
    p_next: ?*anyopaque = null,
    supported_present_scaling: PresentScalingFlagsKHR = .{},
    supported_present_gravity_x: PresentGravityFlagsKHR = .{},
    supported_present_gravity_y: PresentGravityFlagsKHR = .{},
    min_scaled_image_extent: Extent2D,
    max_scaled_image_extent: Extent2D,
};
pub const SurfacePresentScalingCapabilitiesEXT = SurfacePresentScalingCapabilitiesKHR;
pub const SurfacePresentModeCompatibilityKHR = extern struct {
    s_type: StructureType = .surface_present_mode_compatibility_khr,
    p_next: ?*anyopaque = null,
    present_mode_count: u32 = 0,
    p_present_modes: ?[*]PresentModeKHR = null,
};
pub const SurfacePresentModeCompatibilityEXT = SurfacePresentModeCompatibilityKHR;
pub const PhysicalDeviceSwapchainMaintenance1FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_swapchain_maintenance_1_features_khr,
    p_next: ?*anyopaque = null,
    swapchain_maintenance_1: Bool32 = .false,
};
pub const PhysicalDeviceSwapchainMaintenance1FeaturesEXT = PhysicalDeviceSwapchainMaintenance1FeaturesKHR;
pub const SwapchainPresentFenceInfoKHR = extern struct {
    s_type: StructureType = .swapchain_present_fence_info_khr,
    p_next: ?*const anyopaque = null,
    swapchain_count: u32,
    p_fences: [*]const Fence,
};
pub const SwapchainPresentFenceInfoEXT = SwapchainPresentFenceInfoKHR;
pub const SwapchainPresentModesCreateInfoKHR = extern struct {
    s_type: StructureType = .swapchain_present_modes_create_info_khr,
    p_next: ?*const anyopaque = null,
    present_mode_count: u32,
    p_present_modes: [*]const PresentModeKHR,
};
pub const SwapchainPresentModesCreateInfoEXT = SwapchainPresentModesCreateInfoKHR;
pub const SwapchainPresentModeInfoKHR = extern struct {
    s_type: StructureType = .swapchain_present_mode_info_khr,
    p_next: ?*const anyopaque = null,
    swapchain_count: u32,
    p_present_modes: [*]const PresentModeKHR,
};
pub const SwapchainPresentModeInfoEXT = SwapchainPresentModeInfoKHR;
pub const SwapchainPresentScalingCreateInfoKHR = extern struct {
    s_type: StructureType = .swapchain_present_scaling_create_info_khr,
    p_next: ?*const anyopaque = null,
    scaling_behavior: PresentScalingFlagsKHR = .{},
    present_gravity_x: PresentGravityFlagsKHR = .{},
    present_gravity_y: PresentGravityFlagsKHR = .{},
};
pub const SwapchainPresentScalingCreateInfoEXT = SwapchainPresentScalingCreateInfoKHR;
pub const ReleaseSwapchainImagesInfoKHR = extern struct {
    s_type: StructureType = .release_swapchain_images_info_khr,
    p_next: ?*const anyopaque = null,
    swapchain: SwapchainKHR,
    image_index_count: u32,
    p_image_indices: [*]const u32,
};
pub const ReleaseSwapchainImagesInfoEXT = ReleaseSwapchainImagesInfoKHR;
pub const PhysicalDeviceDepthBiasControlFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_depth_bias_control_features_ext,
    p_next: ?*anyopaque = null,
    depth_bias_control: Bool32 = .false,
    least_representable_value_force_unorm_representation: Bool32 = .false,
    float_representation: Bool32 = .false,
    depth_bias_exact: Bool32 = .false,
};
pub const PhysicalDeviceRayTracingInvocationReorderFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_invocation_reorder_features_nv,
    p_next: ?*anyopaque = null,
    ray_tracing_invocation_reorder: Bool32 = .false,
};
pub const PhysicalDeviceRayTracingInvocationReorderPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_invocation_reorder_properties_nv,
    p_next: ?*anyopaque = null,
    ray_tracing_invocation_reorder_reordering_hint: RayTracingInvocationReorderModeNV,
};
pub const PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_extended_sparse_address_space_features_nv,
    p_next: ?*anyopaque = null,
    extended_sparse_address_space: Bool32 = .false,
};
pub const PhysicalDeviceExtendedSparseAddressSpacePropertiesNV = extern struct {
    s_type: StructureType = .physical_device_extended_sparse_address_space_properties_nv,
    p_next: ?*anyopaque = null,
    extended_sparse_address_space_size: DeviceSize,
    extended_sparse_image_usage_flags: ImageUsageFlags,
    extended_sparse_buffer_usage_flags: BufferUsageFlags,
};
pub const DirectDriverLoadingInfoLUNARG = extern struct {
    s_type: StructureType = .direct_driver_loading_info_lunarg,
    p_next: ?*anyopaque = null,
    flags: DirectDriverLoadingFlagsLUNARG,
    pfn_get_instance_proc_addr: PfnGetInstanceProcAddrLUNARG,
};
pub const DirectDriverLoadingListLUNARG = extern struct {
    s_type: StructureType = .direct_driver_loading_list_lunarg,
    p_next: ?*const anyopaque = null,
    mode: DirectDriverLoadingModeLUNARG,
    driver_count: u32,
    p_drivers: [*]const DirectDriverLoadingInfoLUNARG,
};
pub const PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_multiview_per_view_viewports_features_qcom,
    p_next: ?*anyopaque = null,
    multiview_per_view_viewports: Bool32 = .false,
};
pub const PhysicalDeviceRayTracingPositionFetchFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_position_fetch_features_khr,
    p_next: ?*anyopaque = null,
    ray_tracing_position_fetch: Bool32 = .false,
};
pub const DeviceImageSubresourceInfo = extern struct {
    s_type: StructureType = .device_image_subresource_info,
    p_next: ?*const anyopaque = null,
    p_create_info: *const ImageCreateInfo,
    p_subresource: *const ImageSubresource2,
};
pub const DeviceImageSubresourceInfoKHR = DeviceImageSubresourceInfo;
pub const PhysicalDeviceShaderCorePropertiesARM = extern struct {
    s_type: StructureType = .physical_device_shader_core_properties_arm,
    p_next: ?*anyopaque = null,
    pixel_rate: u32,
    texel_rate: u32,
    fma_rate: u32,
};
pub const PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_multiview_per_view_render_areas_features_qcom,
    p_next: ?*anyopaque = null,
    multiview_per_view_render_areas: Bool32 = .false,
};
pub const MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM = extern struct {
    s_type: StructureType = .multiview_per_view_render_areas_render_pass_begin_info_qcom,
    p_next: ?*const anyopaque = null,
    per_view_render_area_count: u32 = 0,
    p_per_view_render_areas: ?[*]const Rect2D = null,
};
pub const QueryLowLatencySupportNV = extern struct {
    s_type: StructureType = .query_low_latency_support_nv,
    p_next: ?*const anyopaque = null,
    p_queried_low_latency_data: *anyopaque,
};
pub const MemoryMapInfo = extern struct {
    s_type: StructureType = .memory_map_info,
    p_next: ?*const anyopaque = null,
    flags: MemoryMapFlags = .{},
    memory: DeviceMemory,
    offset: DeviceSize,
    size: DeviceSize,
};
pub const MemoryMapInfoKHR = MemoryMapInfo;
pub const MemoryUnmapInfo = extern struct {
    s_type: StructureType = .memory_unmap_info,
    p_next: ?*const anyopaque = null,
    flags: MemoryUnmapFlags = .{},
    memory: DeviceMemory,
};
pub const MemoryUnmapInfoKHR = MemoryUnmapInfo;
pub const PhysicalDeviceShaderObjectFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_object_features_ext,
    p_next: ?*anyopaque = null,
    shader_object: Bool32 = .false,
};
pub const PhysicalDeviceShaderObjectPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_object_properties_ext,
    p_next: ?*anyopaque = null,
    shader_binary_uuid: [UUID_SIZE]u8,
    shader_binary_version: u32,
};
pub const ShaderCreateInfoEXT = extern struct {
    s_type: StructureType = .shader_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: ShaderCreateFlagsEXT = .{},
    stage: ShaderStageFlags,
    next_stage: ShaderStageFlags = .{},
    code_type: ShaderCodeTypeEXT,
    code_size: usize,
    p_code: *const anyopaque,
    p_name: ?[*:0]const u8 = null,
    set_layout_count: u32 = 0,
    p_set_layouts: ?[*]const DescriptorSetLayout = null,
    push_constant_range_count: u32 = 0,
    p_push_constant_ranges: ?[*]const PushConstantRange = null,
    p_specialization_info: ?*const SpecializationInfo = null,
};
pub const PhysicalDeviceShaderTileImageFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_tile_image_features_ext,
    p_next: ?*anyopaque = null,
    shader_tile_image_color_read_access: Bool32 = .false,
    shader_tile_image_depth_read_access: Bool32 = .false,
    shader_tile_image_stencil_read_access: Bool32 = .false,
};
pub const PhysicalDeviceShaderTileImagePropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_tile_image_properties_ext,
    p_next: ?*anyopaque = null,
    shader_tile_image_coherent_read_accelerated: Bool32,
    shader_tile_image_read_sample_from_pixel_rate_invocation: Bool32,
    shader_tile_image_read_from_helper_invocation: Bool32,
};
pub const ImportScreenBufferInfoQNX = extern struct {
    s_type: StructureType = .import_screen_buffer_info_qnx,
    p_next: ?*const anyopaque = null,
    buffer: *_screen_buffer,
};
pub const ScreenBufferPropertiesQNX = extern struct {
    s_type: StructureType = .screen_buffer_properties_qnx,
    p_next: ?*anyopaque = null,
    allocation_size: DeviceSize,
    memory_type_bits: u32,
};
pub const ScreenBufferFormatPropertiesQNX = extern struct {
    s_type: StructureType = .screen_buffer_format_properties_qnx,
    p_next: ?*anyopaque = null,
    format: Format,
    external_format: u64,
    screen_usage: u64,
    format_features: FormatFeatureFlags,
    sampler_ycbcr_conversion_components: ComponentMapping,
    suggested_ycbcr_model: SamplerYcbcrModelConversion,
    suggested_ycbcr_range: SamplerYcbcrRange,
    suggested_x_chroma_offset: ChromaLocation,
    suggested_y_chroma_offset: ChromaLocation,
};
pub const ExternalFormatQNX = extern struct {
    s_type: StructureType = .external_format_qnx,
    p_next: ?*anyopaque = null,
    external_format: u64,
};
pub const PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX = extern struct {
    s_type: StructureType = .physical_device_external_memory_screen_buffer_features_qnx,
    p_next: ?*anyopaque = null,
    screen_buffer_import: Bool32 = .false,
};
pub const PhysicalDeviceCooperativeMatrixFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_cooperative_matrix_features_khr,
    p_next: ?*anyopaque = null,
    cooperative_matrix: Bool32 = .false,
    cooperative_matrix_robust_buffer_access: Bool32 = .false,
};
pub const CooperativeMatrixPropertiesKHR = extern struct {
    s_type: StructureType = .cooperative_matrix_properties_khr,
    p_next: ?*anyopaque = null,
    m_size: u32,
    n_size: u32,
    k_size: u32,
    a_type: ComponentTypeKHR,
    b_type: ComponentTypeKHR,
    c_type: ComponentTypeKHR,
    result_type: ComponentTypeKHR,
    saturating_accumulation: Bool32,
    scope: ScopeKHR,
};
pub const PhysicalDeviceCooperativeMatrixPropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_cooperative_matrix_properties_khr,
    p_next: ?*anyopaque = null,
    cooperative_matrix_supported_stages: ShaderStageFlags,
};
pub const PhysicalDeviceShaderEnqueuePropertiesAMDX = extern struct {
    s_type: StructureType = .physical_device_shader_enqueue_properties_amdx,
    p_next: ?*anyopaque = null,
    max_execution_graph_depth: u32,
    max_execution_graph_shader_output_nodes: u32,
    max_execution_graph_shader_payload_size: u32,
    max_execution_graph_shader_payload_count: u32,
    execution_graph_dispatch_address_alignment: u32,
    max_execution_graph_workgroup_count: [3]u32,
    max_execution_graph_workgroups: u32,
};
pub const PhysicalDeviceShaderEnqueueFeaturesAMDX = extern struct {
    s_type: StructureType = .physical_device_shader_enqueue_features_amdx,
    p_next: ?*anyopaque = null,
    shader_enqueue: Bool32 = .false,
    shader_mesh_enqueue: Bool32 = .false,
};
pub const ExecutionGraphPipelineCreateInfoAMDX = extern struct {
    s_type: StructureType = .execution_graph_pipeline_create_info_amdx,
    p_next: ?*const anyopaque = null,
    flags: PipelineCreateFlags = .{},
    stage_count: u32 = 0,
    p_stages: ?[*]const PipelineShaderStageCreateInfo = null,
    p_library_info: ?*const PipelineLibraryCreateInfoKHR = null,
    layout: PipelineLayout,
    base_pipeline_handle: Pipeline = .null_handle,
    base_pipeline_index: i32,
};
pub const PipelineShaderStageNodeCreateInfoAMDX = extern struct {
    s_type: StructureType = .pipeline_shader_stage_node_create_info_amdx,
    p_next: ?*const anyopaque = null,
    p_name: ?[*:0]const u8 = null,
    index: u32,
};
pub const ExecutionGraphPipelineScratchSizeAMDX = extern struct {
    s_type: StructureType = .execution_graph_pipeline_scratch_size_amdx,
    p_next: ?*anyopaque = null,
    min_size: DeviceSize,
    max_size: DeviceSize,
    size_granularity: DeviceSize,
};
pub const DispatchGraphInfoAMDX = extern struct {
    node_index: u32,
    payload_count: u32 = 0,
    payloads: DeviceOrHostAddressConstAMDX,
    payload_stride: u64,
};
pub const DispatchGraphCountInfoAMDX = extern struct {
    count: u32 = 0,
    infos: DeviceOrHostAddressConstAMDX,
    stride: u64,
};
pub const PhysicalDeviceAntiLagFeaturesAMD = extern struct {
    s_type: StructureType = .physical_device_anti_lag_features_amd,
    p_next: ?*anyopaque = null,
    anti_lag: Bool32 = .false,
};
pub const AntiLagDataAMD = extern struct {
    s_type: StructureType = .anti_lag_data_amd,
    p_next: ?*const anyopaque = null,
    mode: AntiLagModeAMD,
    max_fps: u32,
    p_presentation_info: ?*const AntiLagPresentationInfoAMD = null,
};
pub const AntiLagPresentationInfoAMD = extern struct {
    s_type: StructureType = .anti_lag_presentation_info_amd,
    p_next: ?*anyopaque = null,
    stage: AntiLagStageAMD,
    frame_index: u64,
};
pub const BindMemoryStatus = extern struct {
    s_type: StructureType = .bind_memory_status,
    p_next: ?*const anyopaque = null,
    p_result: *Result,
};
pub const PhysicalDeviceTileMemoryHeapFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_tile_memory_heap_features_qcom,
    p_next: ?*anyopaque = null,
    tile_memory_heap: Bool32 = .false,
};
pub const PhysicalDeviceTileMemoryHeapPropertiesQCOM = extern struct {
    s_type: StructureType = .physical_device_tile_memory_heap_properties_qcom,
    p_next: ?*anyopaque = null,
    queue_submit_boundary: Bool32,
    tile_buffer_transfers: Bool32,
};
pub const TileMemorySizeInfoQCOM = extern struct {
    s_type: StructureType = .tile_memory_size_info_qcom,
    p_next: ?*const anyopaque = null,
    size: DeviceSize,
};
pub const TileMemoryRequirementsQCOM = extern struct {
    s_type: StructureType = .tile_memory_requirements_qcom,
    p_next: ?*anyopaque = null,
    size: DeviceSize,
    alignment: DeviceSize,
};
pub const BindMemoryStatusKHR = BindMemoryStatus;
pub const BindDescriptorSetsInfo = extern struct {
    s_type: StructureType = .bind_descriptor_sets_info,
    p_next: ?*const anyopaque = null,
    stage_flags: ShaderStageFlags,
    layout: PipelineLayout = .null_handle,
    first_set: u32 = 0,
    descriptor_set_count: u32,
    p_descriptor_sets: [*]const DescriptorSet,
    dynamic_offset_count: u32 = 0,
    p_dynamic_offsets: ?[*]const u32 = null,
};
pub const BindDescriptorSetsInfoKHR = BindDescriptorSetsInfo;
pub const PushConstantsInfo = extern struct {
    s_type: StructureType = .push_constants_info,
    p_next: ?*const anyopaque = null,
    layout: PipelineLayout = .null_handle,
    stage_flags: ShaderStageFlags,
    offset: u32 = 0,
    size: u32,
    p_values: *const anyopaque,
};
pub const PushConstantsInfoKHR = PushConstantsInfo;
pub const PushDescriptorSetInfo = extern struct {
    s_type: StructureType = .push_descriptor_set_info,
    p_next: ?*const anyopaque = null,
    stage_flags: ShaderStageFlags,
    layout: PipelineLayout = .null_handle,
    set: u32 = 0,
    descriptor_write_count: u32,
    p_descriptor_writes: [*]const WriteDescriptorSet,
};
pub const PushDescriptorSetInfoKHR = PushDescriptorSetInfo;
pub const PushDescriptorSetWithTemplateInfo = extern struct {
    s_type: StructureType = .push_descriptor_set_with_template_info,
    p_next: ?*const anyopaque = null,
    descriptor_update_template: DescriptorUpdateTemplate,
    layout: PipelineLayout = .null_handle,
    set: u32 = 0,
    p_data: *const anyopaque,
};
pub const PushDescriptorSetWithTemplateInfoKHR = PushDescriptorSetWithTemplateInfo;
pub const SetDescriptorBufferOffsetsInfoEXT = extern struct {
    s_type: StructureType = .set_descriptor_buffer_offsets_info_ext,
    p_next: ?*const anyopaque = null,
    stage_flags: ShaderStageFlags,
    layout: PipelineLayout = .null_handle,
    first_set: u32 = 0,
    set_count: u32,
    p_buffer_indices: [*]const u32,
    p_offsets: [*]const DeviceSize,
};
pub const BindDescriptorBufferEmbeddedSamplersInfoEXT = extern struct {
    s_type: StructureType = .bind_descriptor_buffer_embedded_samplers_info_ext,
    p_next: ?*const anyopaque = null,
    stage_flags: ShaderStageFlags,
    layout: PipelineLayout = .null_handle,
    set: u32 = 0,
};
pub const PhysicalDeviceCubicClampFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_cubic_clamp_features_qcom,
    p_next: ?*anyopaque = null,
    cubic_range_clamp: Bool32 = .false,
};
pub const PhysicalDeviceYcbcrDegammaFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_ycbcr_degamma_features_qcom,
    p_next: ?*anyopaque = null,
    ycbcr_degamma: Bool32 = .false,
};
pub const SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM = extern struct {
    s_type: StructureType = .sampler_ycbcr_conversion_ycbcr_degamma_create_info_qcom,
    p_next: ?*anyopaque = null,
    enable_y_degamma: Bool32,
    enable_cb_cr_degamma: Bool32,
};
pub const PhysicalDeviceCubicWeightsFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_cubic_weights_features_qcom,
    p_next: ?*anyopaque = null,
    selectable_cubic_weights: Bool32 = .false,
};
pub const SamplerCubicWeightsCreateInfoQCOM = extern struct {
    s_type: StructureType = .sampler_cubic_weights_create_info_qcom,
    p_next: ?*const anyopaque = null,
    cubic_weights: CubicFilterWeightsQCOM,
};
pub const BlitImageCubicWeightsInfoQCOM = extern struct {
    s_type: StructureType = .blit_image_cubic_weights_info_qcom,
    p_next: ?*const anyopaque = null,
    cubic_weights: CubicFilterWeightsQCOM,
};
pub const PhysicalDeviceImageProcessing2FeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_image_processing_2_features_qcom,
    p_next: ?*anyopaque = null,
    texture_block_match_2: Bool32 = .false,
};
pub const PhysicalDeviceImageProcessing2PropertiesQCOM = extern struct {
    s_type: StructureType = .physical_device_image_processing_2_properties_qcom,
    p_next: ?*anyopaque = null,
    max_block_match_window: Extent2D,
};
pub const SamplerBlockMatchWindowCreateInfoQCOM = extern struct {
    s_type: StructureType = .sampler_block_match_window_create_info_qcom,
    p_next: ?*const anyopaque = null,
    window_extent: Extent2D,
    window_compare_mode: BlockMatchWindowCompareModeQCOM,
};
pub const PhysicalDeviceDescriptorPoolOverallocationFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_descriptor_pool_overallocation_features_nv,
    p_next: ?*anyopaque = null,
    descriptor_pool_overallocation: Bool32 = .false,
};
pub const PhysicalDeviceLayeredDriverPropertiesMSFT = extern struct {
    s_type: StructureType = .physical_device_layered_driver_properties_msft,
    p_next: ?*anyopaque = null,
    underlying_api: LayeredDriverUnderlyingApiMSFT,
};
pub const PhysicalDevicePerStageDescriptorSetFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_per_stage_descriptor_set_features_nv,
    p_next: ?*anyopaque = null,
    per_stage_descriptor_set: Bool32 = .false,
    dynamic_pipeline_layout: Bool32 = .false,
};
pub const PhysicalDeviceExternalFormatResolveFeaturesANDROID = extern struct {
    s_type: StructureType = .physical_device_external_format_resolve_features_android,
    p_next: ?*anyopaque = null,
    external_format_resolve: Bool32 = .false,
};
pub const PhysicalDeviceExternalFormatResolvePropertiesANDROID = extern struct {
    s_type: StructureType = .physical_device_external_format_resolve_properties_android,
    p_next: ?*anyopaque = null,
    null_color_attachment_with_external_format_resolve: Bool32,
    external_format_resolve_chroma_offset_x: ChromaLocation,
    external_format_resolve_chroma_offset_y: ChromaLocation,
};
pub const AndroidHardwareBufferFormatResolvePropertiesANDROID = extern struct {
    s_type: StructureType = .android_hardware_buffer_format_resolve_properties_android,
    p_next: ?*anyopaque = null,
    color_attachment_format: Format,
};
pub const LatencySleepModeInfoNV = extern struct {
    s_type: StructureType = .latency_sleep_mode_info_nv,
    p_next: ?*const anyopaque = null,
    low_latency_mode: Bool32,
    low_latency_boost: Bool32,
    minimum_interval_us: u32,
};
pub const LatencySleepInfoNV = extern struct {
    s_type: StructureType = .latency_sleep_info_nv,
    p_next: ?*const anyopaque = null,
    signal_semaphore: Semaphore,
    value: u64,
};
pub const SetLatencyMarkerInfoNV = extern struct {
    s_type: StructureType = .set_latency_marker_info_nv,
    p_next: ?*const anyopaque = null,
    present_id: u64,
    marker: LatencyMarkerNV,
};
pub const GetLatencyMarkerInfoNV = extern struct {
    s_type: StructureType = .get_latency_marker_info_nv,
    p_next: ?*const anyopaque = null,
    timing_count: u32 = 0,
    p_timings: ?[*]LatencyTimingsFrameReportNV = null,
};
pub const LatencyTimingsFrameReportNV = extern struct {
    s_type: StructureType = .latency_timings_frame_report_nv,
    p_next: ?*const anyopaque = null,
    present_id: u64,
    input_sample_time_us: u64,
    sim_start_time_us: u64,
    sim_end_time_us: u64,
    render_submit_start_time_us: u64,
    render_submit_end_time_us: u64,
    present_start_time_us: u64,
    present_end_time_us: u64,
    driver_start_time_us: u64,
    driver_end_time_us: u64,
    os_render_queue_start_time_us: u64,
    os_render_queue_end_time_us: u64,
    gpu_render_start_time_us: u64,
    gpu_render_end_time_us: u64,
};
pub const OutOfBandQueueTypeInfoNV = extern struct {
    s_type: StructureType = .out_of_band_queue_type_info_nv,
    p_next: ?*const anyopaque = null,
    queue_type: OutOfBandQueueTypeNV,
};
pub const LatencySubmissionPresentIdNV = extern struct {
    s_type: StructureType = .latency_submission_present_id_nv,
    p_next: ?*const anyopaque = null,
    present_id: u64,
};
pub const SwapchainLatencyCreateInfoNV = extern struct {
    s_type: StructureType = .swapchain_latency_create_info_nv,
    p_next: ?*const anyopaque = null,
    latency_mode_enable: Bool32 = .false,
};
pub const LatencySurfaceCapabilitiesNV = extern struct {
    s_type: StructureType = .latency_surface_capabilities_nv,
    p_next: ?*const anyopaque = null,
    present_mode_count: u32 = 0,
    p_present_modes: ?[*]PresentModeKHR = null,
};
pub const PhysicalDeviceCudaKernelLaunchFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_cuda_kernel_launch_features_nv,
    p_next: ?*anyopaque = null,
    cuda_kernel_launch_features: Bool32 = .false,
};
pub const PhysicalDeviceCudaKernelLaunchPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_cuda_kernel_launch_properties_nv,
    p_next: ?*anyopaque = null,
    compute_capability_minor: u32,
    compute_capability_major: u32,
};
pub const DeviceQueueShaderCoreControlCreateInfoARM = extern struct {
    s_type: StructureType = .device_queue_shader_core_control_create_info_arm,
    p_next: ?*anyopaque = null,
    shader_core_count: u32,
};
pub const PhysicalDeviceSchedulingControlsFeaturesARM = extern struct {
    s_type: StructureType = .physical_device_scheduling_controls_features_arm,
    p_next: ?*anyopaque = null,
    scheduling_controls: Bool32 = .false,
};
pub const PhysicalDeviceSchedulingControlsPropertiesARM = extern struct {
    s_type: StructureType = .physical_device_scheduling_controls_properties_arm,
    p_next: ?*anyopaque = null,
    scheduling_controls_flags: PhysicalDeviceSchedulingControlsFlagsARM,
};
pub const PhysicalDeviceRelaxedLineRasterizationFeaturesIMG = extern struct {
    s_type: StructureType = .physical_device_relaxed_line_rasterization_features_img,
    p_next: ?*anyopaque = null,
    relaxed_line_rasterization: Bool32 = .false,
};
pub const PhysicalDeviceRenderPassStripedFeaturesARM = extern struct {
    s_type: StructureType = .physical_device_render_pass_striped_features_arm,
    p_next: ?*anyopaque = null,
    render_pass_striped: Bool32 = .false,
};
pub const PhysicalDeviceRenderPassStripedPropertiesARM = extern struct {
    s_type: StructureType = .physical_device_render_pass_striped_properties_arm,
    p_next: ?*anyopaque = null,
    render_pass_stripe_granularity: Extent2D,
    max_render_pass_stripes: u32,
};
pub const RenderPassStripeInfoARM = extern struct {
    s_type: StructureType = .render_pass_stripe_info_arm,
    p_next: ?*const anyopaque = null,
    stripe_area: Rect2D,
};
pub const RenderPassStripeBeginInfoARM = extern struct {
    s_type: StructureType = .render_pass_stripe_begin_info_arm,
    p_next: ?*const anyopaque = null,
    stripe_info_count: u32,
    p_stripe_infos: [*]const RenderPassStripeInfoARM,
};
pub const RenderPassStripeSubmitInfoARM = extern struct {
    s_type: StructureType = .render_pass_stripe_submit_info_arm,
    p_next: ?*const anyopaque = null,
    stripe_semaphore_info_count: u32,
    p_stripe_semaphore_infos: [*]const SemaphoreSubmitInfo,
};
pub const PhysicalDevicePipelineOpacityMicromapFeaturesARM = extern struct {
    s_type: StructureType = .physical_device_pipeline_opacity_micromap_features_arm,
    p_next: ?*anyopaque = null,
    pipeline_opacity_micromap: Bool32 = .false,
};
pub const PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_shader_maximal_reconvergence_features_khr,
    p_next: ?*anyopaque = null,
    shader_maximal_reconvergence: Bool32 = .false,
};
pub const PhysicalDeviceShaderSubgroupRotateFeatures = extern struct {
    s_type: StructureType = .physical_device_shader_subgroup_rotate_features,
    p_next: ?*anyopaque = null,
    shader_subgroup_rotate: Bool32 = .false,
    shader_subgroup_rotate_clustered: Bool32 = .false,
};
pub const PhysicalDeviceShaderSubgroupRotateFeaturesKHR = PhysicalDeviceShaderSubgroupRotateFeatures;
pub const PhysicalDeviceShaderExpectAssumeFeatures = extern struct {
    s_type: StructureType = .physical_device_shader_expect_assume_features,
    p_next: ?*anyopaque = null,
    shader_expect_assume: Bool32 = .false,
};
pub const PhysicalDeviceShaderExpectAssumeFeaturesKHR = PhysicalDeviceShaderExpectAssumeFeatures;
pub const PhysicalDeviceShaderFloatControls2Features = extern struct {
    s_type: StructureType = .physical_device_shader_float_controls_2_features,
    p_next: ?*anyopaque = null,
    shader_float_controls_2: Bool32 = .false,
};
pub const PhysicalDeviceShaderFloatControls2FeaturesKHR = PhysicalDeviceShaderFloatControls2Features;
pub const PhysicalDeviceDynamicRenderingLocalReadFeatures = extern struct {
    s_type: StructureType = .physical_device_dynamic_rendering_local_read_features,
    p_next: ?*anyopaque = null,
    dynamic_rendering_local_read: Bool32 = .false,
};
pub const PhysicalDeviceDynamicRenderingLocalReadFeaturesKHR = PhysicalDeviceDynamicRenderingLocalReadFeatures;
pub const RenderingAttachmentLocationInfo = extern struct {
    s_type: StructureType = .rendering_attachment_location_info,
    p_next: ?*const anyopaque = null,
    color_attachment_count: u32 = 0,
    p_color_attachment_locations: ?[*]const u32 = null,
};
pub const RenderingAttachmentLocationInfoKHR = RenderingAttachmentLocationInfo;
pub const RenderingInputAttachmentIndexInfo = extern struct {
    s_type: StructureType = .rendering_input_attachment_index_info,
    p_next: ?*const anyopaque = null,
    color_attachment_count: u32 = 0,
    p_color_attachment_input_indices: ?[*]const u32 = null,
    p_depth_input_attachment_index: ?*const u32 = null,
    p_stencil_input_attachment_index: ?*const u32 = null,
};
pub const RenderingInputAttachmentIndexInfoKHR = RenderingInputAttachmentIndexInfo;
pub const PhysicalDeviceShaderQuadControlFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_shader_quad_control_features_khr,
    p_next: ?*anyopaque = null,
    shader_quad_control: Bool32 = .false,
};
pub const PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_shader_atomic_float16_vector_features_nv,
    p_next: ?*anyopaque = null,
    shader_float_16_vector_atomics: Bool32 = .false,
};
pub const PhysicalDeviceMapMemoryPlacedFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_map_memory_placed_features_ext,
    p_next: ?*anyopaque = null,
    memory_map_placed: Bool32 = .false,
    memory_map_range_placed: Bool32 = .false,
    memory_unmap_reserve: Bool32 = .false,
};
pub const PhysicalDeviceMapMemoryPlacedPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_map_memory_placed_properties_ext,
    p_next: ?*anyopaque = null,
    min_placed_memory_map_alignment: DeviceSize,
};
pub const MemoryMapPlacedInfoEXT = extern struct {
    s_type: StructureType = .memory_map_placed_info_ext,
    p_next: ?*const anyopaque = null,
    p_placed_address: *anyopaque,
};
pub const PhysicalDeviceShaderBfloat16FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_shader_bfloat16_features_khr,
    p_next: ?*anyopaque = null,
    shader_b_float_16_type: Bool32 = .false,
    shader_b_float_16_dot_product: Bool32 = .false,
    shader_b_float_16_cooperative_matrix: Bool32 = .false,
};
pub const PhysicalDeviceRawAccessChainsFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_raw_access_chains_features_nv,
    p_next: ?*anyopaque = null,
    shader_raw_access_chains: Bool32 = .false,
};
pub const PhysicalDeviceCommandBufferInheritanceFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_command_buffer_inheritance_features_nv,
    p_next: ?*anyopaque = null,
    command_buffer_inheritance: Bool32 = .false,
};
pub const PhysicalDeviceImageAlignmentControlFeaturesMESA = extern struct {
    s_type: StructureType = .physical_device_image_alignment_control_features_mesa,
    p_next: ?*anyopaque = null,
    image_alignment_control: Bool32 = .false,
};
pub const PhysicalDeviceImageAlignmentControlPropertiesMESA = extern struct {
    s_type: StructureType = .physical_device_image_alignment_control_properties_mesa,
    p_next: ?*anyopaque = null,
    supported_image_alignment_mask: u32,
};
pub const ImageAlignmentControlCreateInfoMESA = extern struct {
    s_type: StructureType = .image_alignment_control_create_info_mesa,
    p_next: ?*const anyopaque = null,
    maximum_requested_alignment: u32,
};
pub const PhysicalDeviceShaderReplicatedCompositesFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_replicated_composites_features_ext,
    p_next: ?*anyopaque = null,
    shader_replicated_composites: Bool32 = .false,
};
pub const PhysicalDevicePresentModeFifoLatestReadyFeaturesEXT = PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR;
pub const PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_present_mode_fifo_latest_ready_features_khr,
    p_next: ?*anyopaque = null,
    present_mode_fifo_latest_ready: Bool32 = .false,
};
pub const DepthClampRangeEXT = extern struct {
    min_depth_clamp: f32,
    max_depth_clamp: f32,
};
pub const PhysicalDeviceCooperativeMatrix2FeaturesNV = extern struct {
    s_type: StructureType = .physical_device_cooperative_matrix_2_features_nv,
    p_next: ?*anyopaque = null,
    cooperative_matrix_workgroup_scope: Bool32 = .false,
    cooperative_matrix_flexible_dimensions: Bool32 = .false,
    cooperative_matrix_reductions: Bool32 = .false,
    cooperative_matrix_conversions: Bool32 = .false,
    cooperative_matrix_per_element_operations: Bool32 = .false,
    cooperative_matrix_tensor_addressing: Bool32 = .false,
    cooperative_matrix_block_loads: Bool32 = .false,
};
pub const PhysicalDeviceCooperativeMatrix2PropertiesNV = extern struct {
    s_type: StructureType = .physical_device_cooperative_matrix_2_properties_nv,
    p_next: ?*anyopaque = null,
    cooperative_matrix_workgroup_scope_max_workgroup_size: u32,
    cooperative_matrix_flexible_dimensions_max_dimension: u32,
    cooperative_matrix_workgroup_scope_reserved_shared_memory: u32,
};
pub const CooperativeMatrixFlexibleDimensionsPropertiesNV = extern struct {
    s_type: StructureType = .cooperative_matrix_flexible_dimensions_properties_nv,
    p_next: ?*anyopaque = null,
    m_granularity: u32,
    n_granularity: u32,
    k_granularity: u32,
    a_type: ComponentTypeKHR,
    b_type: ComponentTypeKHR,
    c_type: ComponentTypeKHR,
    result_type: ComponentTypeKHR,
    saturating_accumulation: Bool32,
    scope: ScopeKHR,
    workgroup_invocations: u32,
};
pub const PhysicalDeviceHdrVividFeaturesHUAWEI = extern struct {
    s_type: StructureType = .physical_device_hdr_vivid_features_huawei,
    p_next: ?*anyopaque = null,
    hdr_vivid: Bool32 = .false,
};
pub const PhysicalDeviceVertexAttributeRobustnessFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_vertex_attribute_robustness_features_ext,
    p_next: ?*anyopaque = null,
    vertex_attribute_robustness: Bool32 = .false,
};
pub const PhysicalDeviceDepthClampZeroOneFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_depth_clamp_zero_one_features_khr,
    p_next: ?*anyopaque = null,
    depth_clamp_zero_one: Bool32 = .false,
};
pub const PhysicalDeviceCooperativeVectorFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_cooperative_vector_features_nv,
    p_next: ?*anyopaque = null,
    cooperative_vector: Bool32 = .false,
    cooperative_vector_training: Bool32 = .false,
};
pub const CooperativeVectorPropertiesNV = extern struct {
    s_type: StructureType = .cooperative_vector_properties_nv,
    p_next: ?*anyopaque = null,
    input_type: ComponentTypeKHR,
    input_interpretation: ComponentTypeKHR,
    matrix_interpretation: ComponentTypeKHR,
    bias_interpretation: ComponentTypeKHR,
    result_type: ComponentTypeKHR,
    transpose: Bool32,
};
pub const PhysicalDeviceCooperativeVectorPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_cooperative_vector_properties_nv,
    p_next: ?*anyopaque = null,
    cooperative_vector_supported_stages: ShaderStageFlags,
    cooperative_vector_training_float_16_accumulation: Bool32,
    cooperative_vector_training_float_32_accumulation: Bool32,
    max_cooperative_vector_components: u32,
};
pub const ConvertCooperativeVectorMatrixInfoNV = extern struct {
    s_type: StructureType = .convert_cooperative_vector_matrix_info_nv,
    p_next: ?*const anyopaque = null,
    src_size: usize,
    src_data: DeviceOrHostAddressConstKHR,
    p_dst_size: *usize,
    dst_data: DeviceOrHostAddressKHR,
    src_component_type: ComponentTypeKHR,
    dst_component_type: ComponentTypeKHR,
    num_rows: u32,
    num_columns: u32,
    src_layout: CooperativeVectorMatrixLayoutNV,
    src_stride: usize,
    dst_layout: CooperativeVectorMatrixLayoutNV,
    dst_stride: usize,
};
pub const PhysicalDeviceTileShadingFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_tile_shading_features_qcom,
    p_next: ?*anyopaque = null,
    tile_shading: Bool32 = .false,
    tile_shading_fragment_stage: Bool32 = .false,
    tile_shading_color_attachments: Bool32 = .false,
    tile_shading_depth_attachments: Bool32 = .false,
    tile_shading_stencil_attachments: Bool32 = .false,
    tile_shading_input_attachments: Bool32 = .false,
    tile_shading_sampled_attachments: Bool32 = .false,
    tile_shading_per_tile_draw: Bool32 = .false,
    tile_shading_per_tile_dispatch: Bool32 = .false,
    tile_shading_dispatch_tile: Bool32 = .false,
    tile_shading_apron: Bool32 = .false,
    tile_shading_anisotropic_apron: Bool32 = .false,
    tile_shading_atomic_ops: Bool32 = .false,
    tile_shading_image_processing: Bool32 = .false,
};
pub const PhysicalDeviceTileShadingPropertiesQCOM = extern struct {
    s_type: StructureType = .physical_device_tile_shading_properties_qcom,
    p_next: ?*anyopaque = null,
    max_apron_size: u32,
    prefer_non_coherent: Bool32,
    tile_granularity: Extent2D,
    max_tile_shading_rate: Extent2D,
};
pub const RenderPassTileShadingCreateInfoQCOM = extern struct {
    s_type: StructureType = .render_pass_tile_shading_create_info_qcom,
    p_next: ?*const anyopaque = null,
    flags: TileShadingRenderPassFlagsQCOM = .{},
    tile_apron_size: Extent2D,
};
pub const PerTileBeginInfoQCOM = extern struct {
    s_type: StructureType = .per_tile_begin_info_qcom,
    p_next: ?*const anyopaque = null,
};
pub const PerTileEndInfoQCOM = extern struct {
    s_type: StructureType = .per_tile_end_info_qcom,
    p_next: ?*const anyopaque = null,
};
pub const DispatchTileInfoQCOM = extern struct {
    s_type: StructureType = .dispatch_tile_info_qcom,
    p_next: ?*const anyopaque = null,
};
pub const PhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE = extern struct {
    s_type: StructureType = .physical_device_fragment_density_map_layered_properties_valve,
    p_next: ?*anyopaque = null,
    max_fragment_density_map_layers: u32,
};
pub const PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE = extern struct {
    s_type: StructureType = .physical_device_fragment_density_map_layered_features_valve,
    p_next: ?*anyopaque = null,
    fragment_density_map_layered: Bool32 = .false,
};
pub const PipelineFragmentDensityMapLayeredCreateInfoVALVE = extern struct {
    s_type: StructureType = .pipeline_fragment_density_map_layered_create_info_valve,
    p_next: ?*const anyopaque = null,
    max_fragment_density_map_layers: u32,
};
pub const SetPresentConfigNV = extern struct {
    s_type: StructureType = .set_present_config_nv,
    p_next: ?*const anyopaque = null,
    num_frames_per_batch: u32,
    present_config_feedback: u32,
};
pub const PhysicalDevicePresentMeteringFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_present_metering_features_nv,
    p_next: ?*anyopaque = null,
    present_metering: Bool32 = .false,
};
pub const ExternalComputeQueueDeviceCreateInfoNV = extern struct {
    s_type: StructureType = .external_compute_queue_device_create_info_nv,
    p_next: ?*const anyopaque = null,
    reserved_external_queues: u32,
};
pub const ExternalComputeQueueCreateInfoNV = extern struct {
    s_type: StructureType = .external_compute_queue_create_info_nv,
    p_next: ?*const anyopaque = null,
    preferred_queue: Queue,
};
pub const ExternalComputeQueueDataParamsNV = extern struct {
    s_type: StructureType = .external_compute_queue_data_params_nv,
    p_next: ?*const anyopaque = null,
    device_index: u32,
};
pub const PhysicalDeviceExternalComputeQueuePropertiesNV = extern struct {
    s_type: StructureType = .physical_device_external_compute_queue_properties_nv,
    p_next: ?*anyopaque = null,
    external_data_size: u32,
    max_external_queues: u32,
};
pub const ExternalComputeQueueNV = enum(usize) { null_handle = 0, _ };
pub const PhysicalDeviceFormatPackFeaturesARM = extern struct {
    s_type: StructureType = .physical_device_format_pack_features_arm,
    p_next: ?*anyopaque = null,
    format_pack: Bool32 = .false,
};
pub const TensorDescriptionARM = extern struct {
    s_type: StructureType = .tensor_description_arm,
    p_next: ?*const anyopaque = null,
    tiling: TensorTilingARM,
    format: Format,
    dimension_count: u32,
    p_dimensions: [*]const i64,
    p_strides: ?[*]const i64 = null,
    usage: TensorUsageFlagsARM,
};
pub const TensorCreateInfoARM = extern struct {
    s_type: StructureType = .tensor_create_info_arm,
    p_next: ?*const anyopaque = null,
    flags: TensorCreateFlagsARM = .{},
    p_description: *const TensorDescriptionARM,
    sharing_mode: SharingMode,
    queue_family_index_count: u32 = 0,
    p_queue_family_indices: ?[*]const u32 = null,
};
pub const TensorViewCreateInfoARM = extern struct {
    s_type: StructureType = .tensor_view_create_info_arm,
    p_next: ?*const anyopaque = null,
    flags: TensorViewCreateFlagsARM = .{},
    tensor: TensorARM,
    format: Format,
};
pub const TensorMemoryRequirementsInfoARM = extern struct {
    s_type: StructureType = .tensor_memory_requirements_info_arm,
    p_next: ?*const anyopaque = null,
    tensor: TensorARM,
};
pub const BindTensorMemoryInfoARM = extern struct {
    s_type: StructureType = .bind_tensor_memory_info_arm,
    p_next: ?*const anyopaque = null,
    tensor: TensorARM,
    memory: DeviceMemory,
    memory_offset: DeviceSize,
};
pub const WriteDescriptorSetTensorARM = extern struct {
    s_type: StructureType = .write_descriptor_set_tensor_arm,
    p_next: ?*const anyopaque = null,
    tensor_view_count: u32,
    p_tensor_views: [*]const TensorViewARM,
};
pub const TensorFormatPropertiesARM = extern struct {
    s_type: StructureType = .tensor_format_properties_arm,
    p_next: ?*const anyopaque = null,
    optimal_tiling_tensor_features: FormatFeatureFlags2,
    linear_tiling_tensor_features: FormatFeatureFlags2,
};
pub const PhysicalDeviceTensorPropertiesARM = extern struct {
    s_type: StructureType = .physical_device_tensor_properties_arm,
    p_next: ?*anyopaque = null,
    max_tensor_dimension_count: u32,
    max_tensor_elements: u64,
    max_per_dimension_tensor_elements: u64,
    max_tensor_stride: i64,
    max_tensor_size: u64,
    max_tensor_shader_access_array_length: u32,
    max_tensor_shader_access_size: u32,
    max_descriptor_set_storage_tensors: u32,
    max_per_stage_descriptor_set_storage_tensors: u32,
    max_descriptor_set_update_after_bind_storage_tensors: u32,
    max_per_stage_descriptor_update_after_bind_storage_tensors: u32,
    shader_storage_tensor_array_non_uniform_indexing_native: Bool32,
    shader_tensor_supported_stages: ShaderStageFlags,
};
pub const TensorMemoryBarrierARM = extern struct {
    s_type: StructureType = .tensor_memory_barrier_arm,
    p_next: ?*const anyopaque = null,
    src_stage_mask: PipelineStageFlags2 = .{},
    src_access_mask: AccessFlags2 = .{},
    dst_stage_mask: PipelineStageFlags2 = .{},
    dst_access_mask: AccessFlags2 = .{},
    src_queue_family_index: u32,
    dst_queue_family_index: u32,
    tensor: TensorARM,
};
pub const TensorDependencyInfoARM = extern struct {
    s_type: StructureType = .tensor_dependency_info_arm,
    p_next: ?*const anyopaque = null,
    tensor_memory_barrier_count: u32,
    p_tensor_memory_barriers: *const TensorMemoryBarrierARM,
};
pub const PhysicalDeviceTensorFeaturesARM = extern struct {
    s_type: StructureType = .physical_device_tensor_features_arm,
    p_next: ?*anyopaque = null,
    tensor_non_packed: Bool32 = .false,
    shader_tensor_access: Bool32 = .false,
    shader_storage_tensor_array_dynamic_indexing: Bool32 = .false,
    shader_storage_tensor_array_non_uniform_indexing: Bool32 = .false,
    descriptor_binding_storage_tensor_update_after_bind: Bool32 = .false,
    tensors: Bool32 = .false,
};
pub const DeviceTensorMemoryRequirementsARM = extern struct {
    s_type: StructureType = .device_tensor_memory_requirements_arm,
    p_next: ?*const anyopaque = null,
    p_create_info: *const TensorCreateInfoARM,
};
pub const CopyTensorInfoARM = extern struct {
    s_type: StructureType = .copy_tensor_info_arm,
    p_next: ?*const anyopaque = null,
    src_tensor: TensorARM,
    dst_tensor: TensorARM,
    region_count: u32,
    p_regions: [*]const TensorCopyARM,
};
pub const TensorCopyARM = extern struct {
    s_type: StructureType = .tensor_copy_arm,
    p_next: ?*const anyopaque = null,
    dimension_count: u32,
    p_src_offset: ?[*]const u64 = null,
    p_dst_offset: ?[*]const u64 = null,
    p_extent: ?[*]const u64 = null,
};
pub const MemoryDedicatedAllocateInfoTensorARM = extern struct {
    s_type: StructureType = .memory_dedicated_allocate_info_tensor_arm,
    p_next: ?*const anyopaque = null,
    tensor: TensorARM,
};
pub const PhysicalDeviceDescriptorBufferTensorPropertiesARM = extern struct {
    s_type: StructureType = .physical_device_descriptor_buffer_tensor_properties_arm,
    p_next: ?*anyopaque = null,
    tensor_capture_replay_descriptor_data_size: usize,
    tensor_view_capture_replay_descriptor_data_size: usize,
    tensor_descriptor_size: usize,
};
pub const PhysicalDeviceDescriptorBufferTensorFeaturesARM = extern struct {
    s_type: StructureType = .physical_device_descriptor_buffer_tensor_features_arm,
    p_next: ?*anyopaque = null,
    descriptor_buffer_tensor_descriptors: Bool32 = .false,
};
pub const TensorCaptureDescriptorDataInfoARM = extern struct {
    s_type: StructureType = .tensor_capture_descriptor_data_info_arm,
    p_next: ?*const anyopaque = null,
    tensor: TensorARM,
};
pub const TensorViewCaptureDescriptorDataInfoARM = extern struct {
    s_type: StructureType = .tensor_view_capture_descriptor_data_info_arm,
    p_next: ?*const anyopaque = null,
    tensor_view: TensorViewARM,
};
pub const DescriptorGetTensorInfoARM = extern struct {
    s_type: StructureType = .descriptor_get_tensor_info_arm,
    p_next: ?*const anyopaque = null,
    tensor_view: TensorViewARM,
};
pub const FrameBoundaryTensorsARM = extern struct {
    s_type: StructureType = .frame_boundary_tensors_arm,
    p_next: ?*const anyopaque = null,
    tensor_count: u32,
    p_tensors: [*]const TensorARM,
};
pub const PhysicalDeviceExternalTensorInfoARM = extern struct {
    s_type: StructureType = .physical_device_external_tensor_info_arm,
    p_next: ?*const anyopaque = null,
    flags: TensorCreateFlagsARM = .{},
    p_description: *const TensorDescriptionARM,
    handle_type: ExternalMemoryHandleTypeFlags,
};
pub const ExternalTensorPropertiesARM = extern struct {
    s_type: StructureType = .external_tensor_properties_arm,
    p_next: ?*const anyopaque = null,
    external_memory_properties: ExternalMemoryProperties,
};
pub const ExternalMemoryTensorCreateInfoARM = extern struct {
    s_type: StructureType = .external_memory_tensor_create_info_arm,
    p_next: ?*const anyopaque = null,
    handle_types: ExternalMemoryHandleTypeFlags = .{},
};
pub const PhysicalDeviceShaderFloat8FeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_float8_features_ext,
    p_next: ?*anyopaque = null,
    shader_float_8: Bool32 = .false,
    shader_float_8_cooperative_matrix: Bool32 = .false,
};
pub const OHSurfaceCreateInfoOHOS = extern struct {
    s_type: StructureType = .oh_surface_create_info_ohos,
    p_next: ?*const anyopaque = null,
    flags: SurfaceCreateFlagsOHOS = .{},
    window: *OHNativeWindow,
};
pub const SurfaceCreateInfoOHOS = OHSurfaceCreateInfoOHOS;
pub const PhysicalDeviceDataGraphFeaturesARM = extern struct {
    s_type: StructureType = .physical_device_data_graph_features_arm,
    p_next: ?*anyopaque = null,
    data_graph: Bool32 = .false,
    data_graph_update_after_bind: Bool32 = .false,
    data_graph_specialization_constants: Bool32 = .false,
    data_graph_descriptor_buffer: Bool32 = .false,
    data_graph_shader_module: Bool32 = .false,
};
pub const DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_constant_tensor_semi_structured_sparsity_info_arm,
    p_next: ?*const anyopaque = null,
    dimension: u32,
    zero_count: u32,
    group_size: u32,
};
pub const DataGraphPipelineConstantARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_constant_arm,
    p_next: ?*const anyopaque = null,
    id: u32,
    p_constant_data: *const anyopaque,
};
pub const DataGraphPipelineResourceInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_resource_info_arm,
    p_next: ?*const anyopaque = null,
    descriptor_set: u32,
    binding: u32,
    array_element: u32 = 0,
};
pub const DataGraphPipelineCompilerControlCreateInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_compiler_control_create_info_arm,
    p_next: ?*const anyopaque = null,
    p_vendor_options: [*:0]const u8,
};
pub const DataGraphPipelineCreateInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_create_info_arm,
    p_next: ?*const anyopaque = null,
    flags: PipelineCreateFlags2KHR = .{},
    layout: PipelineLayout,
    resource_info_count: u32,
    p_resource_infos: [*]const DataGraphPipelineResourceInfoARM,
};
pub const DataGraphPipelineShaderModuleCreateInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_shader_module_create_info_arm,
    p_next: ?*const anyopaque = null,
    module: ShaderModule = .null_handle,
    p_name: [*:0]const u8,
    p_specialization_info: ?*const SpecializationInfo = null,
    constant_count: u32 = 0,
    p_constants: ?[*]const DataGraphPipelineConstantARM = null,
};
pub const DataGraphPipelineSessionCreateInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_session_create_info_arm,
    p_next: ?*const anyopaque = null,
    flags: DataGraphPipelineSessionCreateFlagsARM = .{},
    data_graph_pipeline: Pipeline,
};
pub const DataGraphPipelineSessionBindPointRequirementsInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_session_bind_point_requirements_info_arm,
    p_next: ?*const anyopaque = null,
    session: DataGraphPipelineSessionARM,
};
pub const DataGraphPipelineSessionBindPointRequirementARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_session_bind_point_requirement_arm,
    p_next: ?*const anyopaque = null,
    bind_point: DataGraphPipelineSessionBindPointARM,
    bind_point_type: DataGraphPipelineSessionBindPointTypeARM,
    num_objects: u32,
};
pub const DataGraphPipelineSessionMemoryRequirementsInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_session_memory_requirements_info_arm,
    p_next: ?*const anyopaque = null,
    session: DataGraphPipelineSessionARM,
    bind_point: DataGraphPipelineSessionBindPointARM,
    object_index: u32,
};
pub const BindDataGraphPipelineSessionMemoryInfoARM = extern struct {
    s_type: StructureType = .bind_data_graph_pipeline_session_memory_info_arm,
    p_next: ?*const anyopaque = null,
    session: DataGraphPipelineSessionARM,
    bind_point: DataGraphPipelineSessionBindPointARM,
    object_index: u32,
    memory: DeviceMemory,
    memory_offset: DeviceSize,
};
pub const DataGraphPipelineInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_info_arm,
    p_next: ?*const anyopaque = null,
    data_graph_pipeline: Pipeline,
};
pub const DataGraphPipelinePropertyQueryResultARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_property_query_result_arm,
    p_next: ?*const anyopaque = null,
    property: DataGraphPipelinePropertyARM,
    is_text: Bool32,
    data_size: usize = 0,
    p_data: ?*anyopaque = null,
};
pub const DataGraphPipelineIdentifierCreateInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_identifier_create_info_arm,
    p_next: ?*const anyopaque = null,
    identifier_size: u32,
    p_identifier: [*]const u8,
};
pub const DataGraphPipelineDispatchInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_dispatch_info_arm,
    p_next: ?*anyopaque = null,
    flags: DataGraphPipelineDispatchFlagsARM = .{},
};
pub const PhysicalDeviceDataGraphProcessingEngineARM = extern struct {
    type: PhysicalDeviceDataGraphProcessingEngineTypeARM,
    is_foreign: Bool32,
};
pub const PhysicalDeviceDataGraphOperationSupportARM = extern struct {
    operation_type: PhysicalDeviceDataGraphOperationTypeARM,
    name: [MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM]u8,
    version: u32,
};
pub const QueueFamilyDataGraphPropertiesARM = extern struct {
    s_type: StructureType = .queue_family_data_graph_properties_arm,
    p_next: ?*const anyopaque = null,
    engine: PhysicalDeviceDataGraphProcessingEngineARM,
    operation: PhysicalDeviceDataGraphOperationSupportARM,
};
pub const PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM = extern struct {
    s_type: StructureType = .physical_device_queue_family_data_graph_processing_engine_info_arm,
    p_next: ?*const anyopaque = null,
    queue_family_index: u32,
    engine_type: PhysicalDeviceDataGraphProcessingEngineTypeARM,
};
pub const QueueFamilyDataGraphProcessingEnginePropertiesARM = extern struct {
    s_type: StructureType = .queue_family_data_graph_processing_engine_properties_arm,
    p_next: ?*const anyopaque = null,
    foreign_semaphore_handle_types: ExternalSemaphoreHandleTypeFlags,
    foreign_memory_handle_types: ExternalMemoryHandleTypeFlags,
};
pub const DataGraphProcessingEngineCreateInfoARM = extern struct {
    s_type: StructureType = .data_graph_processing_engine_create_info_arm,
    p_next: ?*const anyopaque = null,
    processing_engine_count: u32,
    p_processing_engines: [*]PhysicalDeviceDataGraphProcessingEngineARM,
};
pub const PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC = extern struct {
    s_type: StructureType = .physical_device_pipeline_cache_incremental_mode_features_sec,
    p_next: ?*anyopaque = null,
    pipeline_cache_incremental_mode: Bool32 = .false,
};
pub const ImageLayout = enum(i32) {
    undefined = 0,
    general = 1,
    color_attachment_optimal = 2,
    depth_stencil_attachment_optimal = 3,
    depth_stencil_read_only_optimal = 4,
    shader_read_only_optimal = 5,
    transfer_src_optimal = 6,
    transfer_dst_optimal = 7,
    preinitialized = 8,
    depth_read_only_stencil_attachment_optimal = 1000117000,
    depth_attachment_stencil_read_only_optimal = 1000117001,
    depth_attachment_optimal = 1000241000,
    depth_read_only_optimal = 1000241001,
    stencil_attachment_optimal = 1000241002,
    stencil_read_only_optimal = 1000241003,
    read_only_optimal = 1000314000,
    attachment_optimal = 1000314001,
    rendering_local_read = 1000232000,
    present_src_khr = 1000001002,
    video_decode_dst_khr = 1000024000,
    video_decode_src_khr = 1000024001,
    video_decode_dpb_khr = 1000024002,
    shared_present_khr = 1000111000,
    fragment_density_map_optimal_ext = 1000218000,
    fragment_shading_rate_attachment_optimal_khr = 1000164003,
    video_encode_dst_khr = 1000299000,
    video_encode_src_khr = 1000299001,
    video_encode_dpb_khr = 1000299002,
    attachment_feedback_loop_optimal_ext = 1000339000,
    tensor_aliasing_arm = 1000460000,
    video_encode_quantization_map_khr = 1000553000,
    zero_initialized_ext = 1000620000,
    _,
    pub const depth_read_only_stencil_attachment_optimal_khr = ImageLayout.depth_read_only_stencil_attachment_optimal;
    pub const depth_attachment_stencil_read_only_optimal_khr = ImageLayout.depth_attachment_stencil_read_only_optimal;
    pub const shading_rate_optimal_nv = ImageLayout.fragment_shading_rate_attachment_optimal_khr;
    pub const rendering_local_read_khr = ImageLayout.rendering_local_read;
    pub const depth_attachment_optimal_khr = ImageLayout.depth_attachment_optimal;
    pub const depth_read_only_optimal_khr = ImageLayout.depth_read_only_optimal;
    pub const stencil_attachment_optimal_khr = ImageLayout.stencil_attachment_optimal;
    pub const stencil_read_only_optimal_khr = ImageLayout.stencil_read_only_optimal;
    pub const read_only_optimal_khr = ImageLayout.read_only_optimal;
    pub const attachment_optimal_khr = ImageLayout.attachment_optimal;
};
pub const AttachmentLoadOp = enum(i32) {
    load = 0,
    clear = 1,
    dont_care = 2,
    none = 1000400000,
    _,
    pub const none_ext = AttachmentLoadOp.none;
    pub const none_khr = AttachmentLoadOp.none;
};
pub const AttachmentStoreOp = enum(i32) {
    store = 0,
    dont_care = 1,
    none = 1000301000,
    _,
    pub const none_khr = AttachmentStoreOp.none;
    pub const none_qcom = AttachmentStoreOp.none;
    pub const none_ext = AttachmentStoreOp.none;
};
pub const ImageType = enum(i32) {
    @"1d" = 0,
    @"2d" = 1,
    @"3d" = 2,
    _,
};
pub const ImageTiling = enum(i32) {
    optimal = 0,
    linear = 1,
    drm_format_modifier_ext = 1000158000,
    _,
};
pub const ImageViewType = enum(i32) {
    @"1d" = 0,
    @"2d" = 1,
    @"3d" = 2,
    cube = 3,
    @"1d_array" = 4,
    @"2d_array" = 5,
    cube_array = 6,
    _,
};
pub const CommandBufferLevel = enum(i32) {
    primary = 0,
    secondary = 1,
    _,
};
pub const ComponentSwizzle = enum(i32) {
    identity = 0,
    zero = 1,
    one = 2,
    r = 3,
    g = 4,
    b = 5,
    a = 6,
    _,
};
pub const DescriptorType = enum(i32) {
    sampler = 0,
    combined_image_sampler = 1,
    sampled_image = 2,
    storage_image = 3,
    uniform_texel_buffer = 4,
    storage_texel_buffer = 5,
    uniform_buffer = 6,
    storage_buffer = 7,
    uniform_buffer_dynamic = 8,
    storage_buffer_dynamic = 9,
    input_attachment = 10,
    inline_uniform_block = 1000138000,
    acceleration_structure_khr = 1000150000,
    acceleration_structure_nv = 1000165000,
    sample_weight_image_qcom = 1000440000,
    block_match_image_qcom = 1000440001,
    tensor_arm = 1000460000,
    mutable_ext = 1000351000,
    partitioned_acceleration_structure_nv = 1000570000,
    _,
    pub const inline_uniform_block_ext = DescriptorType.inline_uniform_block;
    pub const mutable_valve = DescriptorType.mutable_ext;
};
pub const QueryType = enum(i32) {
    occlusion = 0,
    pipeline_statistics = 1,
    timestamp = 2,
    result_status_only_khr = 1000023000,
    transform_feedback_stream_ext = 1000028004,
    performance_query_khr = 1000116000,
    acceleration_structure_compacted_size_khr = 1000150000,
    acceleration_structure_serialization_size_khr = 1000150001,
    acceleration_structure_compacted_size_nv = 1000165000,
    performance_query_intel = 1000210000,
    video_encode_feedback_khr = 1000299000,
    mesh_primitives_generated_ext = 1000328000,
    primitives_generated_ext = 1000382000,
    acceleration_structure_serialization_bottom_level_pointers_khr = 1000386000,
    acceleration_structure_size_khr = 1000386001,
    micromap_serialization_size_ext = 1000396000,
    micromap_compacted_size_ext = 1000396001,
    _,
};
pub const BorderColor = enum(i32) {
    float_transparent_black = 0,
    int_transparent_black = 1,
    float_opaque_black = 2,
    int_opaque_black = 3,
    float_opaque_white = 4,
    int_opaque_white = 5,
    float_custom_ext = 1000287003,
    int_custom_ext = 1000287004,
    _,
};
pub const PipelineBindPoint = enum(i32) {
    graphics = 0,
    compute = 1,
    execution_graph_amdx = 1000134000,
    ray_tracing_khr = 1000165000,
    subpass_shading_huawei = 1000369003,
    data_graph_arm = 1000507000,
    _,
    pub const ray_tracing_nv = PipelineBindPoint.ray_tracing_khr;
};
pub const PipelineCacheHeaderVersion = enum(i32) {
    one = 1,
    _,
};
pub const PipelineCacheCreateFlags = packed struct(Flags) {
    externally_synchronized_bit: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    internally_synchronized_merge_bit_khr: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(PipelineCacheCreateFlags).toInt;
    pub const fromInt = FlagsMixin(PipelineCacheCreateFlags).fromInt;
    pub const merge = FlagsMixin(PipelineCacheCreateFlags).merge;
    pub const intersect = FlagsMixin(PipelineCacheCreateFlags).intersect;
    pub const complement = FlagsMixin(PipelineCacheCreateFlags).complement;
    pub const subtract = FlagsMixin(PipelineCacheCreateFlags).subtract;
    pub const contains = FlagsMixin(PipelineCacheCreateFlags).contains;
    pub const format = FlagFormatMixin(PipelineCacheCreateFlags).format;
};
pub const PrimitiveTopology = enum(i32) {
    point_list = 0,
    line_list = 1,
    line_strip = 2,
    triangle_list = 3,
    triangle_strip = 4,
    triangle_fan = 5,
    line_list_with_adjacency = 6,
    line_strip_with_adjacency = 7,
    triangle_list_with_adjacency = 8,
    triangle_strip_with_adjacency = 9,
    patch_list = 10,
    _,
};
pub const SharingMode = enum(i32) {
    exclusive = 0,
    concurrent = 1,
    _,
};
pub const IndexType = enum(i32) {
    uint16 = 0,
    uint32 = 1,
    uint8 = 1000265000,
    none_khr = 1000165000,
    _,
    pub const none_nv = IndexType.none_khr;
    pub const uint8_ext = IndexType.uint8;
    pub const uint8_khr = IndexType.uint8;
};
pub const Filter = enum(i32) {
    nearest = 0,
    linear = 1,
    cubic_ext = 1000015000,
    _,
    pub const cubic_img = Filter.cubic_ext;
};
pub const SamplerMipmapMode = enum(i32) {
    nearest = 0,
    linear = 1,
    _,
};
pub const SamplerAddressMode = enum(i32) {
    repeat = 0,
    mirrored_repeat = 1,
    clamp_to_edge = 2,
    clamp_to_border = 3,
    mirror_clamp_to_edge = 4,
    _,
    pub const mirror_clamp_to_edge_khr = SamplerAddressMode.mirror_clamp_to_edge;
};
pub const CompareOp = enum(i32) {
    never = 0,
    less = 1,
    equal = 2,
    less_or_equal = 3,
    greater = 4,
    not_equal = 5,
    greater_or_equal = 6,
    always = 7,
    _,
};
pub const PolygonMode = enum(i32) {
    fill = 0,
    line = 1,
    point = 2,
    fill_rectangle_nv = 1000153000,
    _,
};
pub const FrontFace = enum(i32) {
    counter_clockwise = 0,
    clockwise = 1,
    _,
};
pub const BlendFactor = enum(i32) {
    zero = 0,
    one = 1,
    src_color = 2,
    one_minus_src_color = 3,
    dst_color = 4,
    one_minus_dst_color = 5,
    src_alpha = 6,
    one_minus_src_alpha = 7,
    dst_alpha = 8,
    one_minus_dst_alpha = 9,
    constant_color = 10,
    one_minus_constant_color = 11,
    constant_alpha = 12,
    one_minus_constant_alpha = 13,
    src_alpha_saturate = 14,
    src1_color = 15,
    one_minus_src1_color = 16,
    src1_alpha = 17,
    one_minus_src1_alpha = 18,
    _,
};
pub const BlendOp = enum(i32) {
    add = 0,
    subtract = 1,
    reverse_subtract = 2,
    min = 3,
    max = 4,
    zero_ext = 1000148000,
    src_ext = 1000148001,
    dst_ext = 1000148002,
    src_over_ext = 1000148003,
    dst_over_ext = 1000148004,
    src_in_ext = 1000148005,
    dst_in_ext = 1000148006,
    src_out_ext = 1000148007,
    dst_out_ext = 1000148008,
    src_atop_ext = 1000148009,
    dst_atop_ext = 1000148010,
    xor_ext = 1000148011,
    multiply_ext = 1000148012,
    screen_ext = 1000148013,
    overlay_ext = 1000148014,
    darken_ext = 1000148015,
    lighten_ext = 1000148016,
    colordodge_ext = 1000148017,
    colorburn_ext = 1000148018,
    hardlight_ext = 1000148019,
    softlight_ext = 1000148020,
    difference_ext = 1000148021,
    exclusion_ext = 1000148022,
    invert_ext = 1000148023,
    invert_rgb_ext = 1000148024,
    lineardodge_ext = 1000148025,
    linearburn_ext = 1000148026,
    vividlight_ext = 1000148027,
    linearlight_ext = 1000148028,
    pinlight_ext = 1000148029,
    hardmix_ext = 1000148030,
    hsl_hue_ext = 1000148031,
    hsl_saturation_ext = 1000148032,
    hsl_color_ext = 1000148033,
    hsl_luminosity_ext = 1000148034,
    plus_ext = 1000148035,
    plus_clamped_ext = 1000148036,
    plus_clamped_alpha_ext = 1000148037,
    plus_darker_ext = 1000148038,
    minus_ext = 1000148039,
    minus_clamped_ext = 1000148040,
    contrast_ext = 1000148041,
    invert_ovg_ext = 1000148042,
    red_ext = 1000148043,
    green_ext = 1000148044,
    blue_ext = 1000148045,
    _,
};
pub const StencilOp = enum(i32) {
    keep = 0,
    zero = 1,
    replace = 2,
    increment_and_clamp = 3,
    decrement_and_clamp = 4,
    invert = 5,
    increment_and_wrap = 6,
    decrement_and_wrap = 7,
    _,
};
pub const LogicOp = enum(i32) {
    clear = 0,
    @"and" = 1,
    and_reverse = 2,
    copy = 3,
    and_inverted = 4,
    no_op = 5,
    xor = 6,
    @"or" = 7,
    nor = 8,
    equivalent = 9,
    invert = 10,
    or_reverse = 11,
    copy_inverted = 12,
    or_inverted = 13,
    nand = 14,
    set = 15,
    _,
};
pub const InternalAllocationType = enum(i32) {
    executable = 0,
    _,
};
pub const SystemAllocationScope = enum(i32) {
    command = 0,
    object = 1,
    cache = 2,
    device = 3,
    instance = 4,
    _,
};
pub const PhysicalDeviceType = enum(i32) {
    other = 0,
    integrated_gpu = 1,
    discrete_gpu = 2,
    virtual_gpu = 3,
    cpu = 4,
    _,
};
pub const VertexInputRate = enum(i32) {
    vertex = 0,
    instance = 1,
    _,
};
pub const Format = enum(i32) {
    undefined = 0,
    r4g4_unorm_pack8 = 1,
    r4g4b4a4_unorm_pack16 = 2,
    b4g4r4a4_unorm_pack16 = 3,
    r5g6b5_unorm_pack16 = 4,
    b5g6r5_unorm_pack16 = 5,
    r5g5b5a1_unorm_pack16 = 6,
    b5g5r5a1_unorm_pack16 = 7,
    a1r5g5b5_unorm_pack16 = 8,
    r8_unorm = 9,
    r8_snorm = 10,
    r8_uscaled = 11,
    r8_sscaled = 12,
    r8_uint = 13,
    r8_sint = 14,
    r8_srgb = 15,
    r8g8_unorm = 16,
    r8g8_snorm = 17,
    r8g8_uscaled = 18,
    r8g8_sscaled = 19,
    r8g8_uint = 20,
    r8g8_sint = 21,
    r8g8_srgb = 22,
    r8g8b8_unorm = 23,
    r8g8b8_snorm = 24,
    r8g8b8_uscaled = 25,
    r8g8b8_sscaled = 26,
    r8g8b8_uint = 27,
    r8g8b8_sint = 28,
    r8g8b8_srgb = 29,
    b8g8r8_unorm = 30,
    b8g8r8_snorm = 31,
    b8g8r8_uscaled = 32,
    b8g8r8_sscaled = 33,
    b8g8r8_uint = 34,
    b8g8r8_sint = 35,
    b8g8r8_srgb = 36,
    r8g8b8a8_unorm = 37,
    r8g8b8a8_snorm = 38,
    r8g8b8a8_uscaled = 39,
    r8g8b8a8_sscaled = 40,
    r8g8b8a8_uint = 41,
    r8g8b8a8_sint = 42,
    r8g8b8a8_srgb = 43,
    b8g8r8a8_unorm = 44,
    b8g8r8a8_snorm = 45,
    b8g8r8a8_uscaled = 46,
    b8g8r8a8_sscaled = 47,
    b8g8r8a8_uint = 48,
    b8g8r8a8_sint = 49,
    b8g8r8a8_srgb = 50,
    a8b8g8r8_unorm_pack32 = 51,
    a8b8g8r8_snorm_pack32 = 52,
    a8b8g8r8_uscaled_pack32 = 53,
    a8b8g8r8_sscaled_pack32 = 54,
    a8b8g8r8_uint_pack32 = 55,
    a8b8g8r8_sint_pack32 = 56,
    a8b8g8r8_srgb_pack32 = 57,
    a2r10g10b10_unorm_pack32 = 58,
    a2r10g10b10_snorm_pack32 = 59,
    a2r10g10b10_uscaled_pack32 = 60,
    a2r10g10b10_sscaled_pack32 = 61,
    a2r10g10b10_uint_pack32 = 62,
    a2r10g10b10_sint_pack32 = 63,
    a2b10g10r10_unorm_pack32 = 64,
    a2b10g10r10_snorm_pack32 = 65,
    a2b10g10r10_uscaled_pack32 = 66,
    a2b10g10r10_sscaled_pack32 = 67,
    a2b10g10r10_uint_pack32 = 68,
    a2b10g10r10_sint_pack32 = 69,
    r16_unorm = 70,
    r16_snorm = 71,
    r16_uscaled = 72,
    r16_sscaled = 73,
    r16_uint = 74,
    r16_sint = 75,
    r16_sfloat = 76,
    r16g16_unorm = 77,
    r16g16_snorm = 78,
    r16g16_uscaled = 79,
    r16g16_sscaled = 80,
    r16g16_uint = 81,
    r16g16_sint = 82,
    r16g16_sfloat = 83,
    r16g16b16_unorm = 84,
    r16g16b16_snorm = 85,
    r16g16b16_uscaled = 86,
    r16g16b16_sscaled = 87,
    r16g16b16_uint = 88,
    r16g16b16_sint = 89,
    r16g16b16_sfloat = 90,
    r16g16b16a16_unorm = 91,
    r16g16b16a16_snorm = 92,
    r16g16b16a16_uscaled = 93,
    r16g16b16a16_sscaled = 94,
    r16g16b16a16_uint = 95,
    r16g16b16a16_sint = 96,
    r16g16b16a16_sfloat = 97,
    r32_uint = 98,
    r32_sint = 99,
    r32_sfloat = 100,
    r32g32_uint = 101,
    r32g32_sint = 102,
    r32g32_sfloat = 103,
    r32g32b32_uint = 104,
    r32g32b32_sint = 105,
    r32g32b32_sfloat = 106,
    r32g32b32a32_uint = 107,
    r32g32b32a32_sint = 108,
    r32g32b32a32_sfloat = 109,
    r64_uint = 110,
    r64_sint = 111,
    r64_sfloat = 112,
    r64g64_uint = 113,
    r64g64_sint = 114,
    r64g64_sfloat = 115,
    r64g64b64_uint = 116,
    r64g64b64_sint = 117,
    r64g64b64_sfloat = 118,
    r64g64b64a64_uint = 119,
    r64g64b64a64_sint = 120,
    r64g64b64a64_sfloat = 121,
    b10g11r11_ufloat_pack32 = 122,
    e5b9g9r9_ufloat_pack32 = 123,
    d16_unorm = 124,
    x8_d24_unorm_pack32 = 125,
    d32_sfloat = 126,
    s8_uint = 127,
    d16_unorm_s8_uint = 128,
    d24_unorm_s8_uint = 129,
    d32_sfloat_s8_uint = 130,
    bc1_rgb_unorm_block = 131,
    bc1_rgb_srgb_block = 132,
    bc1_rgba_unorm_block = 133,
    bc1_rgba_srgb_block = 134,
    bc2_unorm_block = 135,
    bc2_srgb_block = 136,
    bc3_unorm_block = 137,
    bc3_srgb_block = 138,
    bc4_unorm_block = 139,
    bc4_snorm_block = 140,
    bc5_unorm_block = 141,
    bc5_snorm_block = 142,
    bc6h_ufloat_block = 143,
    bc6h_sfloat_block = 144,
    bc7_unorm_block = 145,
    bc7_srgb_block = 146,
    etc2_r8g8b8_unorm_block = 147,
    etc2_r8g8b8_srgb_block = 148,
    etc2_r8g8b8a1_unorm_block = 149,
    etc2_r8g8b8a1_srgb_block = 150,
    etc2_r8g8b8a8_unorm_block = 151,
    etc2_r8g8b8a8_srgb_block = 152,
    eac_r11_unorm_block = 153,
    eac_r11_snorm_block = 154,
    eac_r11g11_unorm_block = 155,
    eac_r11g11_snorm_block = 156,
    astc_4x_4_unorm_block = 157,
    astc_4x_4_srgb_block = 158,
    astc_5x_4_unorm_block = 159,
    astc_5x_4_srgb_block = 160,
    astc_5x_5_unorm_block = 161,
    astc_5x_5_srgb_block = 162,
    astc_6x_5_unorm_block = 163,
    astc_6x_5_srgb_block = 164,
    astc_6x_6_unorm_block = 165,
    astc_6x_6_srgb_block = 166,
    astc_8x_5_unorm_block = 167,
    astc_8x_5_srgb_block = 168,
    astc_8x_6_unorm_block = 169,
    astc_8x_6_srgb_block = 170,
    astc_8x_8_unorm_block = 171,
    astc_8x_8_srgb_block = 172,
    astc_1_0x_5_unorm_block = 173,
    astc_1_0x_5_srgb_block = 174,
    astc_1_0x_6_unorm_block = 175,
    astc_1_0x_6_srgb_block = 176,
    astc_1_0x_8_unorm_block = 177,
    astc_1_0x_8_srgb_block = 178,
    astc_1_0x_10_unorm_block = 179,
    astc_1_0x_10_srgb_block = 180,
    astc_1_2x_10_unorm_block = 181,
    astc_1_2x_10_srgb_block = 182,
    astc_1_2x_12_unorm_block = 183,
    astc_1_2x_12_srgb_block = 184,
    g8b8g8r8_422_unorm = 1000156000,
    b8g8r8g8_422_unorm = 1000156001,
    g8_b8_r8_3plane_420_unorm = 1000156002,
    g8_b8r8_2plane_420_unorm = 1000156003,
    g8_b8_r8_3plane_422_unorm = 1000156004,
    g8_b8r8_2plane_422_unorm = 1000156005,
    g8_b8_r8_3plane_444_unorm = 1000156006,
    r10x6_unorm_pack16 = 1000156007,
    r10x6g10x6_unorm_2pack16 = 1000156008,
    r10x6g10x6b10x6a10x6_unorm_4pack16 = 1000156009,
    g10x6b10x6g10x6r10x6_422_unorm_4pack16 = 1000156010,
    b10x6g10x6r10x6g10x6_422_unorm_4pack16 = 1000156011,
    g10x6_b10x6_r10x6_3plane_420_unorm_3pack16 = 1000156012,
    g10x6_b10x6r10x6_2plane_420_unorm_3pack16 = 1000156013,
    g10x6_b10x6_r10x6_3plane_422_unorm_3pack16 = 1000156014,
    g10x6_b10x6r10x6_2plane_422_unorm_3pack16 = 1000156015,
    g10x6_b10x6_r10x6_3plane_444_unorm_3pack16 = 1000156016,
    r12x4_unorm_pack16 = 1000156017,
    r12x4g12x4_unorm_2pack16 = 1000156018,
    r12x4g12x4b12x4a12x4_unorm_4pack16 = 1000156019,
    g12x4b12x4g12x4r12x4_422_unorm_4pack16 = 1000156020,
    b12x4g12x4r12x4g12x4_422_unorm_4pack16 = 1000156021,
    g12x4_b12x4_r12x4_3plane_420_unorm_3pack16 = 1000156022,
    g12x4_b12x4r12x4_2plane_420_unorm_3pack16 = 1000156023,
    g12x4_b12x4_r12x4_3plane_422_unorm_3pack16 = 1000156024,
    g12x4_b12x4r12x4_2plane_422_unorm_3pack16 = 1000156025,
    g12x4_b12x4_r12x4_3plane_444_unorm_3pack16 = 1000156026,
    g16b16g16r16_422_unorm = 1000156027,
    b16g16r16g16_422_unorm = 1000156028,
    g16_b16_r16_3plane_420_unorm = 1000156029,
    g16_b16r16_2plane_420_unorm = 1000156030,
    g16_b16_r16_3plane_422_unorm = 1000156031,
    g16_b16r16_2plane_422_unorm = 1000156032,
    g16_b16_r16_3plane_444_unorm = 1000156033,
    g8_b8r8_2plane_444_unorm = 1000330000,
    g10x6_b10x6r10x6_2plane_444_unorm_3pack16 = 1000330001,
    g12x4_b12x4r12x4_2plane_444_unorm_3pack16 = 1000330002,
    g16_b16r16_2plane_444_unorm = 1000330003,
    a4r4g4b4_unorm_pack16 = 1000340000,
    a4b4g4r4_unorm_pack16 = 1000340001,
    astc_4x_4_sfloat_block = 1000066000,
    astc_5x_4_sfloat_block = 1000066001,
    astc_5x_5_sfloat_block = 1000066002,
    astc_6x_5_sfloat_block = 1000066003,
    astc_6x_6_sfloat_block = 1000066004,
    astc_8x_5_sfloat_block = 1000066005,
    astc_8x_6_sfloat_block = 1000066006,
    astc_8x_8_sfloat_block = 1000066007,
    astc_1_0x_5_sfloat_block = 1000066008,
    astc_1_0x_6_sfloat_block = 1000066009,
    astc_1_0x_8_sfloat_block = 1000066010,
    astc_1_0x_10_sfloat_block = 1000066011,
    astc_1_2x_10_sfloat_block = 1000066012,
    astc_1_2x_12_sfloat_block = 1000066013,
    a1b5g5r5_unorm_pack16 = 1000470000,
    a8_unorm = 1000470001,
    pvrtc1_2bpp_unorm_block_img = 1000054000,
    pvrtc1_4bpp_unorm_block_img = 1000054001,
    pvrtc2_2bpp_unorm_block_img = 1000054002,
    pvrtc2_4bpp_unorm_block_img = 1000054003,
    pvrtc1_2bpp_srgb_block_img = 1000054004,
    pvrtc1_4bpp_srgb_block_img = 1000054005,
    pvrtc2_2bpp_srgb_block_img = 1000054006,
    pvrtc2_4bpp_srgb_block_img = 1000054007,
    r8_bool_arm = 1000460000,
    r16g16_sfixed5_nv = 1000464000,
    r10x6_uint_pack16_arm = 1000609000,
    r10x6g10x6_uint_2pack16_arm = 1000609001,
    r10x6g10x6b10x6a10x6_uint_4pack16_arm = 1000609002,
    r12x4_uint_pack16_arm = 1000609003,
    r12x4g12x4_uint_2pack16_arm = 1000609004,
    r12x4g12x4b12x4a12x4_uint_4pack16_arm = 1000609005,
    r14x2_uint_pack16_arm = 1000609006,
    r14x2g14x2_uint_2pack16_arm = 1000609007,
    r14x2g14x2b14x2a14x2_uint_4pack16_arm = 1000609008,
    r14x2_unorm_pack16_arm = 1000609009,
    r14x2g14x2_unorm_2pack16_arm = 1000609010,
    r14x2g14x2b14x2a14x2_unorm_4pack16_arm = 1000609011,
    g14x2_b14x2r14x2_2plane_420_unorm_3pack16_arm = 1000609012,
    g14x2_b14x2r14x2_2plane_422_unorm_3pack16_arm = 1000609013,
    _,
    pub const astc_4x_4_sfloat_block_ext = Format.astc_4x_4_sfloat_block;
    pub const astc_5x_4_sfloat_block_ext = Format.astc_5x_4_sfloat_block;
    pub const astc_5x_5_sfloat_block_ext = Format.astc_5x_5_sfloat_block;
    pub const astc_6x_5_sfloat_block_ext = Format.astc_6x_5_sfloat_block;
    pub const astc_6x_6_sfloat_block_ext = Format.astc_6x_6_sfloat_block;
    pub const astc_8x_5_sfloat_block_ext = Format.astc_8x_5_sfloat_block;
    pub const astc_8x_6_sfloat_block_ext = Format.astc_8x_6_sfloat_block;
    pub const astc_8x_8_sfloat_block_ext = Format.astc_8x_8_sfloat_block;
    pub const astc_1_0x_5_sfloat_block_ext = Format.astc_1_0x_5_sfloat_block;
    pub const astc_1_0x_6_sfloat_block_ext = Format.astc_1_0x_6_sfloat_block;
    pub const astc_1_0x_8_sfloat_block_ext = Format.astc_1_0x_8_sfloat_block;
    pub const astc_1_0x_10_sfloat_block_ext = Format.astc_1_0x_10_sfloat_block;
    pub const astc_1_2x_10_sfloat_block_ext = Format.astc_1_2x_10_sfloat_block;
    pub const astc_1_2x_12_sfloat_block_ext = Format.astc_1_2x_12_sfloat_block;
    pub const g8b8g8r8_422_unorm_khr = Format.g8b8g8r8_422_unorm;
    pub const b8g8r8g8_422_unorm_khr = Format.b8g8r8g8_422_unorm;
    pub const g8_b8_r8_3plane_420_unorm_khr = Format.g8_b8_r8_3plane_420_unorm;
    pub const g8_b8r8_2plane_420_unorm_khr = Format.g8_b8r8_2plane_420_unorm;
    pub const g8_b8_r8_3plane_422_unorm_khr = Format.g8_b8_r8_3plane_422_unorm;
    pub const g8_b8r8_2plane_422_unorm_khr = Format.g8_b8r8_2plane_422_unorm;
    pub const g8_b8_r8_3plane_444_unorm_khr = Format.g8_b8_r8_3plane_444_unorm;
    pub const r10x6_unorm_pack16_khr = Format.r10x6_unorm_pack16;
    pub const r10x6g10x6_unorm_2pack16_khr = Format.r10x6g10x6_unorm_2pack16;
    pub const r10x6g10x6b10x6a10x6_unorm_4pack16_khr = Format.r10x6g10x6b10x6a10x6_unorm_4pack16;
    pub const g10x6b10x6g10x6r10x6_422_unorm_4pack16_khr = Format.g10x6b10x6g10x6r10x6_422_unorm_4pack16;
    pub const b10x6g10x6r10x6g10x6_422_unorm_4pack16_khr = Format.b10x6g10x6r10x6g10x6_422_unorm_4pack16;
    pub const g10x6_b10x6_r10x6_3plane_420_unorm_3pack16_khr = Format.g10x6_b10x6_r10x6_3plane_420_unorm_3pack16;
    pub const g10x6_b10x6r10x6_2plane_420_unorm_3pack16_khr = Format.g10x6_b10x6r10x6_2plane_420_unorm_3pack16;
    pub const g10x6_b10x6_r10x6_3plane_422_unorm_3pack16_khr = Format.g10x6_b10x6_r10x6_3plane_422_unorm_3pack16;
    pub const g10x6_b10x6r10x6_2plane_422_unorm_3pack16_khr = Format.g10x6_b10x6r10x6_2plane_422_unorm_3pack16;
    pub const g10x6_b10x6_r10x6_3plane_444_unorm_3pack16_khr = Format.g10x6_b10x6_r10x6_3plane_444_unorm_3pack16;
    pub const r12x4_unorm_pack16_khr = Format.r12x4_unorm_pack16;
    pub const r12x4g12x4_unorm_2pack16_khr = Format.r12x4g12x4_unorm_2pack16;
    pub const r12x4g12x4b12x4a12x4_unorm_4pack16_khr = Format.r12x4g12x4b12x4a12x4_unorm_4pack16;
    pub const g12x4b12x4g12x4r12x4_422_unorm_4pack16_khr = Format.g12x4b12x4g12x4r12x4_422_unorm_4pack16;
    pub const b12x4g12x4r12x4g12x4_422_unorm_4pack16_khr = Format.b12x4g12x4r12x4g12x4_422_unorm_4pack16;
    pub const g12x4_b12x4_r12x4_3plane_420_unorm_3pack16_khr = Format.g12x4_b12x4_r12x4_3plane_420_unorm_3pack16;
    pub const g12x4_b12x4r12x4_2plane_420_unorm_3pack16_khr = Format.g12x4_b12x4r12x4_2plane_420_unorm_3pack16;
    pub const g12x4_b12x4_r12x4_3plane_422_unorm_3pack16_khr = Format.g12x4_b12x4_r12x4_3plane_422_unorm_3pack16;
    pub const g12x4_b12x4r12x4_2plane_422_unorm_3pack16_khr = Format.g12x4_b12x4r12x4_2plane_422_unorm_3pack16;
    pub const g12x4_b12x4_r12x4_3plane_444_unorm_3pack16_khr = Format.g12x4_b12x4_r12x4_3plane_444_unorm_3pack16;
    pub const g16b16g16r16_422_unorm_khr = Format.g16b16g16r16_422_unorm;
    pub const b16g16r16g16_422_unorm_khr = Format.b16g16r16g16_422_unorm;
    pub const g16_b16_r16_3plane_420_unorm_khr = Format.g16_b16_r16_3plane_420_unorm;
    pub const g16_b16r16_2plane_420_unorm_khr = Format.g16_b16r16_2plane_420_unorm;
    pub const g16_b16_r16_3plane_422_unorm_khr = Format.g16_b16_r16_3plane_422_unorm;
    pub const g16_b16r16_2plane_422_unorm_khr = Format.g16_b16r16_2plane_422_unorm;
    pub const g16_b16_r16_3plane_444_unorm_khr = Format.g16_b16_r16_3plane_444_unorm;
    pub const g8_b8r8_2plane_444_unorm_ext = Format.g8_b8r8_2plane_444_unorm;
    pub const g10x6_b10x6r10x6_2plane_444_unorm_3pack16_ext = Format.g10x6_b10x6r10x6_2plane_444_unorm_3pack16;
    pub const g12x4_b12x4r12x4_2plane_444_unorm_3pack16_ext = Format.g12x4_b12x4r12x4_2plane_444_unorm_3pack16;
    pub const g16_b16r16_2plane_444_unorm_ext = Format.g16_b16r16_2plane_444_unorm;
    pub const a4r4g4b4_unorm_pack16_ext = Format.a4r4g4b4_unorm_pack16;
    pub const a4b4g4r4_unorm_pack16_ext = Format.a4b4g4r4_unorm_pack16;
    pub const r16g16_s10_5_nv = Format.r16g16_sfixed5_nv;
    pub const a1b5g5r5_unorm_pack16_khr = Format.a1b5g5r5_unorm_pack16;
    pub const a8_unorm_khr = Format.a8_unorm;
};
pub const StructureType = enum(i32) {
    application_info = 0,
    instance_create_info = 1,
    device_queue_create_info = 2,
    device_create_info = 3,
    submit_info = 4,
    memory_allocate_info = 5,
    mapped_memory_range = 6,
    bind_sparse_info = 7,
    fence_create_info = 8,
    semaphore_create_info = 9,
    event_create_info = 10,
    query_pool_create_info = 11,
    buffer_create_info = 12,
    buffer_view_create_info = 13,
    image_create_info = 14,
    image_view_create_info = 15,
    shader_module_create_info = 16,
    pipeline_cache_create_info = 17,
    pipeline_shader_stage_create_info = 18,
    pipeline_vertex_input_state_create_info = 19,
    pipeline_input_assembly_state_create_info = 20,
    pipeline_tessellation_state_create_info = 21,
    pipeline_viewport_state_create_info = 22,
    pipeline_rasterization_state_create_info = 23,
    pipeline_multisample_state_create_info = 24,
    pipeline_depth_stencil_state_create_info = 25,
    pipeline_color_blend_state_create_info = 26,
    pipeline_dynamic_state_create_info = 27,
    graphics_pipeline_create_info = 28,
    compute_pipeline_create_info = 29,
    pipeline_layout_create_info = 30,
    sampler_create_info = 31,
    descriptor_set_layout_create_info = 32,
    descriptor_pool_create_info = 33,
    descriptor_set_allocate_info = 34,
    write_descriptor_set = 35,
    copy_descriptor_set = 36,
    framebuffer_create_info = 37,
    render_pass_create_info = 38,
    command_pool_create_info = 39,
    command_buffer_allocate_info = 40,
    command_buffer_inheritance_info = 41,
    command_buffer_begin_info = 42,
    render_pass_begin_info = 43,
    buffer_memory_barrier = 44,
    image_memory_barrier = 45,
    memory_barrier = 46,
    loader_instance_create_info = 47,
    loader_device_create_info = 48,
    physical_device_subgroup_properties = 1000094000,
    bind_buffer_memory_info = 1000157000,
    bind_image_memory_info = 1000157001,
    physical_device_16bit_storage_features = 1000083000,
    memory_dedicated_requirements = 1000127000,
    memory_dedicated_allocate_info = 1000127001,
    memory_allocate_flags_info = 1000060000,
    device_group_render_pass_begin_info = 1000060003,
    device_group_command_buffer_begin_info = 1000060004,
    device_group_submit_info = 1000060005,
    device_group_bind_sparse_info = 1000060006,
    bind_buffer_memory_device_group_info = 1000060013,
    bind_image_memory_device_group_info = 1000060014,
    physical_device_group_properties = 1000070000,
    device_group_device_create_info = 1000070001,
    buffer_memory_requirements_info_2 = 1000146000,
    image_memory_requirements_info_2 = 1000146001,
    image_sparse_memory_requirements_info_2 = 1000146002,
    memory_requirements_2 = 1000146003,
    sparse_image_memory_requirements_2 = 1000146004,
    physical_device_features_2 = 1000059000,
    physical_device_properties_2 = 1000059001,
    format_properties_2 = 1000059002,
    image_format_properties_2 = 1000059003,
    physical_device_image_format_info_2 = 1000059004,
    queue_family_properties_2 = 1000059005,
    physical_device_memory_properties_2 = 1000059006,
    sparse_image_format_properties_2 = 1000059007,
    physical_device_sparse_image_format_info_2 = 1000059008,
    physical_device_point_clipping_properties = 1000117000,
    render_pass_input_attachment_aspect_create_info = 1000117001,
    image_view_usage_create_info = 1000117002,
    pipeline_tessellation_domain_origin_state_create_info = 1000117003,
    render_pass_multiview_create_info = 1000053000,
    physical_device_multiview_features = 1000053001,
    physical_device_multiview_properties = 1000053002,
    physical_device_variable_pointers_features = 1000120000,
    protected_submit_info = 1000145000,
    physical_device_protected_memory_features = 1000145001,
    physical_device_protected_memory_properties = 1000145002,
    device_queue_info_2 = 1000145003,
    sampler_ycbcr_conversion_create_info = 1000156000,
    sampler_ycbcr_conversion_info = 1000156001,
    bind_image_plane_memory_info = 1000156002,
    image_plane_memory_requirements_info = 1000156003,
    physical_device_sampler_ycbcr_conversion_features = 1000156004,
    sampler_ycbcr_conversion_image_format_properties = 1000156005,
    descriptor_update_template_create_info = 1000085000,
    physical_device_external_image_format_info = 1000071000,
    external_image_format_properties = 1000071001,
    physical_device_external_buffer_info = 1000071002,
    external_buffer_properties = 1000071003,
    physical_device_id_properties = 1000071004,
    external_memory_buffer_create_info = 1000072000,
    external_memory_image_create_info = 1000072001,
    export_memory_allocate_info = 1000072002,
    physical_device_external_fence_info = 1000112000,
    external_fence_properties = 1000112001,
    export_fence_create_info = 1000113000,
    export_semaphore_create_info = 1000077000,
    physical_device_external_semaphore_info = 1000076000,
    external_semaphore_properties = 1000076001,
    physical_device_maintenance_3_properties = 1000168000,
    descriptor_set_layout_support = 1000168001,
    physical_device_shader_draw_parameters_features = 1000063000,
    physical_device_vulkan_1_1_features = 49,
    physical_device_vulkan_1_1_properties = 50,
    physical_device_vulkan_1_2_features = 51,
    physical_device_vulkan_1_2_properties = 52,
    image_format_list_create_info = 1000147000,
    attachment_description_2 = 1000109000,
    attachment_reference_2 = 1000109001,
    subpass_description_2 = 1000109002,
    subpass_dependency_2 = 1000109003,
    render_pass_create_info_2 = 1000109004,
    subpass_begin_info = 1000109005,
    subpass_end_info = 1000109006,
    physical_device_8bit_storage_features = 1000177000,
    physical_device_driver_properties = 1000196000,
    physical_device_shader_atomic_int64_features = 1000180000,
    physical_device_shader_float16_int8_features = 1000082000,
    physical_device_float_controls_properties = 1000197000,
    descriptor_set_layout_binding_flags_create_info = 1000161000,
    physical_device_descriptor_indexing_features = 1000161001,
    physical_device_descriptor_indexing_properties = 1000161002,
    descriptor_set_variable_descriptor_count_allocate_info = 1000161003,
    descriptor_set_variable_descriptor_count_layout_support = 1000161004,
    physical_device_depth_stencil_resolve_properties = 1000199000,
    subpass_description_depth_stencil_resolve = 1000199001,
    physical_device_scalar_block_layout_features = 1000221000,
    image_stencil_usage_create_info = 1000246000,
    physical_device_sampler_filter_minmax_properties = 1000130000,
    sampler_reduction_mode_create_info = 1000130001,
    physical_device_vulkan_memory_model_features = 1000211000,
    physical_device_imageless_framebuffer_features = 1000108000,
    framebuffer_attachments_create_info = 1000108001,
    framebuffer_attachment_image_info = 1000108002,
    render_pass_attachment_begin_info = 1000108003,
    physical_device_uniform_buffer_standard_layout_features = 1000253000,
    physical_device_shader_subgroup_extended_types_features = 1000175000,
    physical_device_separate_depth_stencil_layouts_features = 1000241000,
    attachment_reference_stencil_layout = 1000241001,
    attachment_description_stencil_layout = 1000241002,
    physical_device_host_query_reset_features = 1000261000,
    physical_device_timeline_semaphore_features = 1000207000,
    physical_device_timeline_semaphore_properties = 1000207001,
    semaphore_type_create_info = 1000207002,
    timeline_semaphore_submit_info = 1000207003,
    semaphore_wait_info = 1000207004,
    semaphore_signal_info = 1000207005,
    physical_device_buffer_device_address_features = 1000257000,
    buffer_device_address_info = 1000244001,
    buffer_opaque_capture_address_create_info = 1000257002,
    memory_opaque_capture_address_allocate_info = 1000257003,
    device_memory_opaque_capture_address_info = 1000257004,
    physical_device_vulkan_1_3_features = 53,
    physical_device_vulkan_1_3_properties = 54,
    pipeline_creation_feedback_create_info = 1000192000,
    physical_device_shader_terminate_invocation_features = 1000215000,
    physical_device_tool_properties = 1000245000,
    physical_device_shader_demote_to_helper_invocation_features = 1000276000,
    physical_device_private_data_features = 1000295000,
    device_private_data_create_info = 1000295001,
    private_data_slot_create_info = 1000295002,
    physical_device_pipeline_creation_cache_control_features = 1000297000,
    memory_barrier_2 = 1000314000,
    buffer_memory_barrier_2 = 1000314001,
    image_memory_barrier_2 = 1000314002,
    dependency_info = 1000314003,
    submit_info_2 = 1000314004,
    semaphore_submit_info = 1000314005,
    command_buffer_submit_info = 1000314006,
    physical_device_synchronization_2_features = 1000314007,
    physical_device_zero_initialize_workgroup_memory_features = 1000325000,
    physical_device_image_robustness_features = 1000335000,
    copy_buffer_info_2 = 1000337000,
    copy_image_info_2 = 1000337001,
    copy_buffer_to_image_info_2 = 1000337002,
    copy_image_to_buffer_info_2 = 1000337003,
    blit_image_info_2 = 1000337004,
    resolve_image_info_2 = 1000337005,
    buffer_copy_2 = 1000337006,
    image_copy_2 = 1000337007,
    image_blit_2 = 1000337008,
    buffer_image_copy_2 = 1000337009,
    image_resolve_2 = 1000337010,
    physical_device_subgroup_size_control_properties = 1000225000,
    pipeline_shader_stage_required_subgroup_size_create_info = 1000225001,
    physical_device_subgroup_size_control_features = 1000225002,
    physical_device_inline_uniform_block_features = 1000138000,
    physical_device_inline_uniform_block_properties = 1000138001,
    write_descriptor_set_inline_uniform_block = 1000138002,
    descriptor_pool_inline_uniform_block_create_info = 1000138003,
    physical_device_texture_compression_astc_hdr_features = 1000066000,
    rendering_info = 1000044000,
    rendering_attachment_info = 1000044001,
    pipeline_rendering_create_info = 1000044002,
    physical_device_dynamic_rendering_features = 1000044003,
    command_buffer_inheritance_rendering_info = 1000044004,
    physical_device_shader_integer_dot_product_features = 1000280000,
    physical_device_shader_integer_dot_product_properties = 1000280001,
    physical_device_texel_buffer_alignment_properties = 1000281001,
    format_properties_3 = 1000360000,
    physical_device_maintenance_4_features = 1000413000,
    physical_device_maintenance_4_properties = 1000413001,
    device_buffer_memory_requirements = 1000413002,
    device_image_memory_requirements = 1000413003,
    physical_device_vulkan_1_4_features = 55,
    physical_device_vulkan_1_4_properties = 56,
    device_queue_global_priority_create_info = 1000174000,
    physical_device_global_priority_query_features = 1000388000,
    queue_family_global_priority_properties = 1000388001,
    physical_device_shader_subgroup_rotate_features = 1000416000,
    physical_device_shader_float_controls_2_features = 1000528000,
    physical_device_shader_expect_assume_features = 1000544000,
    physical_device_line_rasterization_features = 1000259000,
    pipeline_rasterization_line_state_create_info = 1000259001,
    physical_device_line_rasterization_properties = 1000259002,
    physical_device_vertex_attribute_divisor_properties = 1000525000,
    pipeline_vertex_input_divisor_state_create_info = 1000190001,
    physical_device_vertex_attribute_divisor_features = 1000190002,
    physical_device_index_type_uint8_features = 1000265000,
    memory_map_info = 1000271000,
    memory_unmap_info = 1000271001,
    physical_device_maintenance_5_features = 1000470000,
    physical_device_maintenance_5_properties = 1000470001,
    rendering_area_info = 1000470003,
    device_image_subresource_info = 1000470004,
    subresource_layout_2 = 1000338002,
    image_subresource_2 = 1000338003,
    pipeline_create_flags_2_create_info = 1000470005,
    buffer_usage_flags_2_create_info = 1000470006,
    physical_device_push_descriptor_properties = 1000080000,
    physical_device_dynamic_rendering_local_read_features = 1000232000,
    rendering_attachment_location_info = 1000232001,
    rendering_input_attachment_index_info = 1000232002,
    physical_device_maintenance_6_features = 1000545000,
    physical_device_maintenance_6_properties = 1000545001,
    bind_memory_status = 1000545002,
    bind_descriptor_sets_info = 1000545003,
    push_constants_info = 1000545004,
    push_descriptor_set_info = 1000545005,
    push_descriptor_set_with_template_info = 1000545006,
    physical_device_pipeline_protected_access_features = 1000466000,
    pipeline_robustness_create_info = 1000068000,
    physical_device_pipeline_robustness_features = 1000068001,
    physical_device_pipeline_robustness_properties = 1000068002,
    physical_device_host_image_copy_features = 1000270000,
    physical_device_host_image_copy_properties = 1000270001,
    memory_to_image_copy = 1000270002,
    image_to_memory_copy = 1000270003,
    copy_image_to_memory_info = 1000270004,
    copy_memory_to_image_info = 1000270005,
    host_image_layout_transition_info = 1000270006,
    copy_image_to_image_info = 1000270007,
    subresource_host_memcpy_size = 1000270008,
    host_image_copy_device_performance_query = 1000270009,
    swapchain_create_info_khr = 1000001000,
    present_info_khr = 1000001001,
    device_group_present_capabilities_khr = 1000060007,
    image_swapchain_create_info_khr = 1000060008,
    bind_image_memory_swapchain_info_khr = 1000060009,
    acquire_next_image_info_khr = 1000060010,
    device_group_present_info_khr = 1000060011,
    device_group_swapchain_create_info_khr = 1000060012,
    display_mode_create_info_khr = 1000002000,
    display_surface_create_info_khr = 1000002001,
    display_present_info_khr = 1000003000,
    xlib_surface_create_info_khr = 1000004000,
    xcb_surface_create_info_khr = 1000005000,
    wayland_surface_create_info_khr = 1000006000,
    android_surface_create_info_khr = 1000008000,
    win32_surface_create_info_khr = 1000009000,
    debug_report_callback_create_info_ext = 1000011000,
    pipeline_rasterization_state_rasterization_order_amd = 1000018000,
    debug_marker_object_name_info_ext = 1000022000,
    debug_marker_object_tag_info_ext = 1000022001,
    debug_marker_marker_info_ext = 1000022002,
    video_profile_info_khr = 1000023000,
    video_capabilities_khr = 1000023001,
    video_picture_resource_info_khr = 1000023002,
    video_session_memory_requirements_khr = 1000023003,
    bind_video_session_memory_info_khr = 1000023004,
    video_session_create_info_khr = 1000023005,
    video_session_parameters_create_info_khr = 1000023006,
    video_session_parameters_update_info_khr = 1000023007,
    video_begin_coding_info_khr = 1000023008,
    video_end_coding_info_khr = 1000023009,
    video_coding_control_info_khr = 1000023010,
    video_reference_slot_info_khr = 1000023011,
    queue_family_video_properties_khr = 1000023012,
    video_profile_list_info_khr = 1000023013,
    physical_device_video_format_info_khr = 1000023014,
    video_format_properties_khr = 1000023015,
    queue_family_query_result_status_properties_khr = 1000023016,
    video_decode_info_khr = 1000024000,
    video_decode_capabilities_khr = 1000024001,
    video_decode_usage_info_khr = 1000024002,
    dedicated_allocation_image_create_info_nv = 1000026000,
    dedicated_allocation_buffer_create_info_nv = 1000026001,
    dedicated_allocation_memory_allocate_info_nv = 1000026002,
    physical_device_transform_feedback_features_ext = 1000028000,
    physical_device_transform_feedback_properties_ext = 1000028001,
    pipeline_rasterization_state_stream_create_info_ext = 1000028002,
    cu_module_create_info_nvx = 1000029000,
    cu_function_create_info_nvx = 1000029001,
    cu_launch_info_nvx = 1000029002,
    cu_module_texturing_mode_create_info_nvx = 1000029004,
    image_view_handle_info_nvx = 1000030000,
    image_view_address_properties_nvx = 1000030001,
    video_encode_h264_capabilities_khr = 1000038000,
    video_encode_h264_session_parameters_create_info_khr = 1000038001,
    video_encode_h264_session_parameters_add_info_khr = 1000038002,
    video_encode_h264_picture_info_khr = 1000038003,
    video_encode_h264_dpb_slot_info_khr = 1000038004,
    video_encode_h264_nalu_slice_info_khr = 1000038005,
    video_encode_h264_gop_remaining_frame_info_khr = 1000038006,
    video_encode_h264_profile_info_khr = 1000038007,
    video_encode_h264_rate_control_info_khr = 1000038008,
    video_encode_h264_rate_control_layer_info_khr = 1000038009,
    video_encode_h264_session_create_info_khr = 1000038010,
    video_encode_h264_quality_level_properties_khr = 1000038011,
    video_encode_h264_session_parameters_get_info_khr = 1000038012,
    video_encode_h264_session_parameters_feedback_info_khr = 1000038013,
    video_encode_h265_capabilities_khr = 1000039000,
    video_encode_h265_session_parameters_create_info_khr = 1000039001,
    video_encode_h265_session_parameters_add_info_khr = 1000039002,
    video_encode_h265_picture_info_khr = 1000039003,
    video_encode_h265_dpb_slot_info_khr = 1000039004,
    video_encode_h265_nalu_slice_segment_info_khr = 1000039005,
    video_encode_h265_gop_remaining_frame_info_khr = 1000039006,
    video_encode_h265_profile_info_khr = 1000039007,
    video_encode_h265_rate_control_info_khr = 1000039009,
    video_encode_h265_rate_control_layer_info_khr = 1000039010,
    video_encode_h265_session_create_info_khr = 1000039011,
    video_encode_h265_quality_level_properties_khr = 1000039012,
    video_encode_h265_session_parameters_get_info_khr = 1000039013,
    video_encode_h265_session_parameters_feedback_info_khr = 1000039014,
    video_decode_h264_capabilities_khr = 1000040000,
    video_decode_h264_picture_info_khr = 1000040001,
    video_decode_h264_profile_info_khr = 1000040003,
    video_decode_h264_session_parameters_create_info_khr = 1000040004,
    video_decode_h264_session_parameters_add_info_khr = 1000040005,
    video_decode_h264_dpb_slot_info_khr = 1000040006,
    texture_lod_gather_format_properties_amd = 1000041000,
    stream_descriptor_surface_create_info_ggp = 1000049000,
    physical_device_corner_sampled_image_features_nv = 1000050000,
    private_vendor_info_placeholder_offset_0_nv = 1000051000,
    external_memory_image_create_info_nv = 1000056000,
    export_memory_allocate_info_nv = 1000056001,
    import_memory_win32_handle_info_nv = 1000057000,
    export_memory_win32_handle_info_nv = 1000057001,
    win32_keyed_mutex_acquire_release_info_nv = 1000058000,
    validation_flags_ext = 1000061000,
    vi_surface_create_info_nn = 1000062000,
    image_view_astc_decode_mode_ext = 1000067000,
    physical_device_astc_decode_features_ext = 1000067001,
    import_memory_win32_handle_info_khr = 1000073000,
    export_memory_win32_handle_info_khr = 1000073001,
    memory_win32_handle_properties_khr = 1000073002,
    memory_get_win32_handle_info_khr = 1000073003,
    import_memory_fd_info_khr = 1000074000,
    memory_fd_properties_khr = 1000074001,
    memory_get_fd_info_khr = 1000074002,
    win32_keyed_mutex_acquire_release_info_khr = 1000075000,
    import_semaphore_win32_handle_info_khr = 1000078000,
    export_semaphore_win32_handle_info_khr = 1000078001,
    d3d12_fence_submit_info_khr = 1000078002,
    semaphore_get_win32_handle_info_khr = 1000078003,
    import_semaphore_fd_info_khr = 1000079000,
    semaphore_get_fd_info_khr = 1000079001,
    command_buffer_inheritance_conditional_rendering_info_ext = 1000081000,
    physical_device_conditional_rendering_features_ext = 1000081001,
    conditional_rendering_begin_info_ext = 1000081002,
    present_regions_khr = 1000084000,
    pipeline_viewport_w_scaling_state_create_info_nv = 1000087000,
    surface_capabilities_2_ext = 1000090000,
    display_power_info_ext = 1000091000,
    device_event_info_ext = 1000091001,
    display_event_info_ext = 1000091002,
    swapchain_counter_create_info_ext = 1000091003,
    present_times_info_google = 1000092000,
    physical_device_multiview_per_view_attributes_properties_nvx = 1000097000,
    multiview_per_view_attributes_info_nvx = 1000044009,
    pipeline_viewport_swizzle_state_create_info_nv = 1000098000,
    physical_device_discard_rectangle_properties_ext = 1000099000,
    pipeline_discard_rectangle_state_create_info_ext = 1000099001,
    physical_device_conservative_rasterization_properties_ext = 1000101000,
    pipeline_rasterization_conservative_state_create_info_ext = 1000101001,
    physical_device_depth_clip_enable_features_ext = 1000102000,
    pipeline_rasterization_depth_clip_state_create_info_ext = 1000102001,
    hdr_metadata_ext = 1000105000,
    physical_device_relaxed_line_rasterization_features_img = 1000110000,
    shared_present_surface_capabilities_khr = 1000111000,
    import_fence_win32_handle_info_khr = 1000114000,
    export_fence_win32_handle_info_khr = 1000114001,
    fence_get_win32_handle_info_khr = 1000114002,
    import_fence_fd_info_khr = 1000115000,
    fence_get_fd_info_khr = 1000115001,
    physical_device_performance_query_features_khr = 1000116000,
    physical_device_performance_query_properties_khr = 1000116001,
    query_pool_performance_create_info_khr = 1000116002,
    performance_query_submit_info_khr = 1000116003,
    acquire_profiling_lock_info_khr = 1000116004,
    performance_counter_khr = 1000116005,
    performance_counter_description_khr = 1000116006,
    physical_device_surface_info_2_khr = 1000119000,
    surface_capabilities_2_khr = 1000119001,
    surface_format_2_khr = 1000119002,
    display_properties_2_khr = 1000121000,
    display_plane_properties_2_khr = 1000121001,
    display_mode_properties_2_khr = 1000121002,
    display_plane_info_2_khr = 1000121003,
    display_plane_capabilities_2_khr = 1000121004,
    ios_surface_create_info_mvk = 1000122000,
    macos_surface_create_info_mvk = 1000123000,
    debug_utils_object_name_info_ext = 1000128000,
    debug_utils_object_tag_info_ext = 1000128001,
    debug_utils_label_ext = 1000128002,
    debug_utils_messenger_callback_data_ext = 1000128003,
    debug_utils_messenger_create_info_ext = 1000128004,
    android_hardware_buffer_usage_android = 1000129000,
    android_hardware_buffer_properties_android = 1000129001,
    android_hardware_buffer_format_properties_android = 1000129002,
    import_android_hardware_buffer_info_android = 1000129003,
    memory_get_android_hardware_buffer_info_android = 1000129004,
    external_format_android = 1000129005,
    android_hardware_buffer_format_properties_2_android = 1000129006,
    physical_device_shader_enqueue_features_amdx = 1000134000,
    physical_device_shader_enqueue_properties_amdx = 1000134001,
    execution_graph_pipeline_scratch_size_amdx = 1000134002,
    execution_graph_pipeline_create_info_amdx = 1000134003,
    pipeline_shader_stage_node_create_info_amdx = 1000134004,
    attachment_sample_count_info_amd = 1000044008,
    physical_device_shader_bfloat16_features_khr = 1000141000,
    sample_locations_info_ext = 1000143000,
    render_pass_sample_locations_begin_info_ext = 1000143001,
    pipeline_sample_locations_state_create_info_ext = 1000143002,
    physical_device_sample_locations_properties_ext = 1000143003,
    multisample_properties_ext = 1000143004,
    physical_device_blend_operation_advanced_features_ext = 1000148000,
    physical_device_blend_operation_advanced_properties_ext = 1000148001,
    pipeline_color_blend_advanced_state_create_info_ext = 1000148002,
    pipeline_coverage_to_color_state_create_info_nv = 1000149000,
    write_descriptor_set_acceleration_structure_khr = 1000150007,
    acceleration_structure_build_geometry_info_khr = 1000150000,
    acceleration_structure_device_address_info_khr = 1000150002,
    acceleration_structure_geometry_aabbs_data_khr = 1000150003,
    acceleration_structure_geometry_instances_data_khr = 1000150004,
    acceleration_structure_geometry_triangles_data_khr = 1000150005,
    acceleration_structure_geometry_khr = 1000150006,
    acceleration_structure_version_info_khr = 1000150009,
    copy_acceleration_structure_info_khr = 1000150010,
    copy_acceleration_structure_to_memory_info_khr = 1000150011,
    copy_memory_to_acceleration_structure_info_khr = 1000150012,
    physical_device_acceleration_structure_features_khr = 1000150013,
    physical_device_acceleration_structure_properties_khr = 1000150014,
    acceleration_structure_create_info_khr = 1000150017,
    acceleration_structure_build_sizes_info_khr = 1000150020,
    physical_device_ray_tracing_pipeline_features_khr = 1000347000,
    physical_device_ray_tracing_pipeline_properties_khr = 1000347001,
    ray_tracing_pipeline_create_info_khr = 1000150015,
    ray_tracing_shader_group_create_info_khr = 1000150016,
    ray_tracing_pipeline_interface_create_info_khr = 1000150018,
    physical_device_ray_query_features_khr = 1000348013,
    pipeline_coverage_modulation_state_create_info_nv = 1000152000,
    physical_device_shader_sm_builtins_features_nv = 1000154000,
    physical_device_shader_sm_builtins_properties_nv = 1000154001,
    drm_format_modifier_properties_list_ext = 1000158000,
    physical_device_image_drm_format_modifier_info_ext = 1000158002,
    image_drm_format_modifier_list_create_info_ext = 1000158003,
    image_drm_format_modifier_explicit_create_info_ext = 1000158004,
    image_drm_format_modifier_properties_ext = 1000158005,
    drm_format_modifier_properties_list_2_ext = 1000158006,
    validation_cache_create_info_ext = 1000160000,
    shader_module_validation_cache_create_info_ext = 1000160001,
    physical_device_portability_subset_features_khr = 1000163000,
    physical_device_portability_subset_properties_khr = 1000163001,
    pipeline_viewport_shading_rate_image_state_create_info_nv = 1000164000,
    physical_device_shading_rate_image_features_nv = 1000164001,
    physical_device_shading_rate_image_properties_nv = 1000164002,
    pipeline_viewport_coarse_sample_order_state_create_info_nv = 1000164005,
    ray_tracing_pipeline_create_info_nv = 1000165000,
    acceleration_structure_create_info_nv = 1000165001,
    geometry_nv = 1000165003,
    geometry_triangles_nv = 1000165004,
    geometry_aabb_nv = 1000165005,
    bind_acceleration_structure_memory_info_nv = 1000165006,
    write_descriptor_set_acceleration_structure_nv = 1000165007,
    acceleration_structure_memory_requirements_info_nv = 1000165008,
    physical_device_ray_tracing_properties_nv = 1000165009,
    ray_tracing_shader_group_create_info_nv = 1000165011,
    acceleration_structure_info_nv = 1000165012,
    physical_device_representative_fragment_test_features_nv = 1000166000,
    pipeline_representative_fragment_test_state_create_info_nv = 1000166001,
    physical_device_image_view_image_format_info_ext = 1000170000,
    filter_cubic_image_view_image_format_properties_ext = 1000170001,
    import_memory_host_pointer_info_ext = 1000178000,
    memory_host_pointer_properties_ext = 1000178001,
    physical_device_external_memory_host_properties_ext = 1000178002,
    physical_device_shader_clock_features_khr = 1000181000,
    pipeline_compiler_control_create_info_amd = 1000183000,
    physical_device_shader_core_properties_amd = 1000185000,
    video_decode_h265_capabilities_khr = 1000187000,
    video_decode_h265_session_parameters_create_info_khr = 1000187001,
    video_decode_h265_session_parameters_add_info_khr = 1000187002,
    video_decode_h265_profile_info_khr = 1000187003,
    video_decode_h265_picture_info_khr = 1000187004,
    video_decode_h265_dpb_slot_info_khr = 1000187005,
    device_memory_overallocation_create_info_amd = 1000189000,
    physical_device_vertex_attribute_divisor_properties_ext = 1000190000,
    present_frame_token_ggp = 1000191000,
    physical_device_mesh_shader_features_nv = 1000202000,
    physical_device_mesh_shader_properties_nv = 1000202001,
    physical_device_shader_image_footprint_features_nv = 1000204000,
    pipeline_viewport_exclusive_scissor_state_create_info_nv = 1000205000,
    physical_device_exclusive_scissor_features_nv = 1000205002,
    checkpoint_data_nv = 1000206000,
    queue_family_checkpoint_properties_nv = 1000206001,
    queue_family_checkpoint_properties_2_nv = 1000314008,
    checkpoint_data_2_nv = 1000314009,
    physical_device_shader_integer_functions_2_features_intel = 1000209000,
    query_pool_performance_query_create_info_intel = 1000210000,
    initialize_performance_api_info_intel = 1000210001,
    performance_marker_info_intel = 1000210002,
    performance_stream_marker_info_intel = 1000210003,
    performance_override_info_intel = 1000210004,
    performance_configuration_acquire_info_intel = 1000210005,
    physical_device_pci_bus_info_properties_ext = 1000212000,
    display_native_hdr_surface_capabilities_amd = 1000213000,
    swapchain_display_native_hdr_create_info_amd = 1000213001,
    imagepipe_surface_create_info_fuchsia = 1000214000,
    metal_surface_create_info_ext = 1000217000,
    physical_device_fragment_density_map_features_ext = 1000218000,
    physical_device_fragment_density_map_properties_ext = 1000218001,
    render_pass_fragment_density_map_create_info_ext = 1000218002,
    rendering_fragment_density_map_attachment_info_ext = 1000044007,
    fragment_shading_rate_attachment_info_khr = 1000226000,
    pipeline_fragment_shading_rate_state_create_info_khr = 1000226001,
    physical_device_fragment_shading_rate_properties_khr = 1000226002,
    physical_device_fragment_shading_rate_features_khr = 1000226003,
    physical_device_fragment_shading_rate_khr = 1000226004,
    rendering_fragment_shading_rate_attachment_info_khr = 1000044006,
    physical_device_shader_core_properties_2_amd = 1000227000,
    physical_device_coherent_memory_features_amd = 1000229000,
    physical_device_shader_image_atomic_int64_features_ext = 1000234000,
    physical_device_shader_quad_control_features_khr = 1000235000,
    physical_device_memory_budget_properties_ext = 1000237000,
    physical_device_memory_priority_features_ext = 1000238000,
    memory_priority_allocate_info_ext = 1000238001,
    surface_protected_capabilities_khr = 1000239000,
    physical_device_dedicated_allocation_image_aliasing_features_nv = 1000240000,
    physical_device_buffer_device_address_features_ext = 1000244000,
    buffer_device_address_create_info_ext = 1000244002,
    validation_features_ext = 1000247000,
    physical_device_present_wait_features_khr = 1000248000,
    physical_device_cooperative_matrix_features_nv = 1000249000,
    cooperative_matrix_properties_nv = 1000249001,
    physical_device_cooperative_matrix_properties_nv = 1000249002,
    physical_device_coverage_reduction_mode_features_nv = 1000250000,
    pipeline_coverage_reduction_state_create_info_nv = 1000250001,
    framebuffer_mixed_samples_combination_nv = 1000250002,
    physical_device_fragment_shader_interlock_features_ext = 1000251000,
    physical_device_ycbcr_image_arrays_features_ext = 1000252000,
    physical_device_provoking_vertex_features_ext = 1000254000,
    pipeline_rasterization_provoking_vertex_state_create_info_ext = 1000254001,
    physical_device_provoking_vertex_properties_ext = 1000254002,
    surface_full_screen_exclusive_info_ext = 1000255000,
    surface_capabilities_full_screen_exclusive_ext = 1000255002,
    surface_full_screen_exclusive_win32_info_ext = 1000255001,
    headless_surface_create_info_ext = 1000256000,
    physical_device_shader_atomic_float_features_ext = 1000260000,
    physical_device_extended_dynamic_state_features_ext = 1000267000,
    physical_device_pipeline_executable_properties_features_khr = 1000269000,
    pipeline_info_khr = 1000269001,
    pipeline_executable_properties_khr = 1000269002,
    pipeline_executable_info_khr = 1000269003,
    pipeline_executable_statistic_khr = 1000269004,
    pipeline_executable_internal_representation_khr = 1000269005,
    physical_device_map_memory_placed_features_ext = 1000272000,
    physical_device_map_memory_placed_properties_ext = 1000272001,
    memory_map_placed_info_ext = 1000272002,
    physical_device_shader_atomic_float_2_features_ext = 1000273000,
    physical_device_device_generated_commands_properties_nv = 1000277000,
    graphics_shader_group_create_info_nv = 1000277001,
    graphics_pipeline_shader_groups_create_info_nv = 1000277002,
    indirect_commands_layout_token_nv = 1000277003,
    indirect_commands_layout_create_info_nv = 1000277004,
    generated_commands_info_nv = 1000277005,
    generated_commands_memory_requirements_info_nv = 1000277006,
    physical_device_device_generated_commands_features_nv = 1000277007,
    physical_device_inherited_viewport_scissor_features_nv = 1000278000,
    command_buffer_inheritance_viewport_scissor_info_nv = 1000278001,
    physical_device_texel_buffer_alignment_features_ext = 1000281000,
    command_buffer_inheritance_render_pass_transform_info_qcom = 1000282000,
    render_pass_transform_begin_info_qcom = 1000282001,
    physical_device_depth_bias_control_features_ext = 1000283000,
    depth_bias_info_ext = 1000283001,
    depth_bias_representation_info_ext = 1000283002,
    physical_device_device_memory_report_features_ext = 1000284000,
    device_device_memory_report_create_info_ext = 1000284001,
    device_memory_report_callback_data_ext = 1000284002,
    sampler_custom_border_color_create_info_ext = 1000287000,
    physical_device_custom_border_color_properties_ext = 1000287001,
    physical_device_custom_border_color_features_ext = 1000287002,
    pipeline_library_create_info_khr = 1000290000,
    physical_device_present_barrier_features_nv = 1000292000,
    surface_capabilities_present_barrier_nv = 1000292001,
    swapchain_present_barrier_create_info_nv = 1000292002,
    present_id_khr = 1000294000,
    physical_device_present_id_features_khr = 1000294001,
    video_encode_info_khr = 1000299000,
    video_encode_rate_control_info_khr = 1000299001,
    video_encode_rate_control_layer_info_khr = 1000299002,
    video_encode_capabilities_khr = 1000299003,
    video_encode_usage_info_khr = 1000299004,
    query_pool_video_encode_feedback_create_info_khr = 1000299005,
    physical_device_video_encode_quality_level_info_khr = 1000299006,
    video_encode_quality_level_properties_khr = 1000299007,
    video_encode_quality_level_info_khr = 1000299008,
    video_encode_session_parameters_get_info_khr = 1000299009,
    video_encode_session_parameters_feedback_info_khr = 1000299010,
    physical_device_diagnostics_config_features_nv = 1000300000,
    device_diagnostics_config_create_info_nv = 1000300001,
    cuda_module_create_info_nv = 1000307000,
    cuda_function_create_info_nv = 1000307001,
    cuda_launch_info_nv = 1000307002,
    physical_device_cuda_kernel_launch_features_nv = 1000307003,
    physical_device_cuda_kernel_launch_properties_nv = 1000307004,
    refresh_object_list_khr = 1000308000,
    physical_device_tile_shading_features_qcom = 1000309000,
    physical_device_tile_shading_properties_qcom = 1000309001,
    render_pass_tile_shading_create_info_qcom = 1000309002,
    per_tile_begin_info_qcom = 1000309003,
    per_tile_end_info_qcom = 1000309004,
    dispatch_tile_info_qcom = 1000309005,
    query_low_latency_support_nv = 1000310000,
    export_metal_object_create_info_ext = 1000311000,
    export_metal_objects_info_ext = 1000311001,
    export_metal_device_info_ext = 1000311002,
    export_metal_command_queue_info_ext = 1000311003,
    export_metal_buffer_info_ext = 1000311004,
    import_metal_buffer_info_ext = 1000311005,
    export_metal_texture_info_ext = 1000311006,
    import_metal_texture_info_ext = 1000311007,
    export_metal_io_surface_info_ext = 1000311008,
    import_metal_io_surface_info_ext = 1000311009,
    export_metal_shared_event_info_ext = 1000311010,
    import_metal_shared_event_info_ext = 1000311011,
    physical_device_descriptor_buffer_properties_ext = 1000316000,
    physical_device_descriptor_buffer_density_map_properties_ext = 1000316001,
    physical_device_descriptor_buffer_features_ext = 1000316002,
    descriptor_address_info_ext = 1000316003,
    descriptor_get_info_ext = 1000316004,
    buffer_capture_descriptor_data_info_ext = 1000316005,
    image_capture_descriptor_data_info_ext = 1000316006,
    image_view_capture_descriptor_data_info_ext = 1000316007,
    sampler_capture_descriptor_data_info_ext = 1000316008,
    opaque_capture_descriptor_data_create_info_ext = 1000316010,
    descriptor_buffer_binding_info_ext = 1000316011,
    descriptor_buffer_binding_push_descriptor_buffer_handle_ext = 1000316012,
    acceleration_structure_capture_descriptor_data_info_ext = 1000316009,
    physical_device_graphics_pipeline_library_features_ext = 1000320000,
    physical_device_graphics_pipeline_library_properties_ext = 1000320001,
    graphics_pipeline_library_create_info_ext = 1000320002,
    physical_device_shader_early_and_late_fragment_tests_features_amd = 1000321000,
    physical_device_fragment_shader_barycentric_features_khr = 1000203000,
    physical_device_fragment_shader_barycentric_properties_khr = 1000322000,
    physical_device_shader_subgroup_uniform_control_flow_features_khr = 1000323000,
    physical_device_fragment_shading_rate_enums_properties_nv = 1000326000,
    physical_device_fragment_shading_rate_enums_features_nv = 1000326001,
    pipeline_fragment_shading_rate_enum_state_create_info_nv = 1000326002,
    acceleration_structure_geometry_motion_triangles_data_nv = 1000327000,
    physical_device_ray_tracing_motion_blur_features_nv = 1000327001,
    acceleration_structure_motion_info_nv = 1000327002,
    physical_device_mesh_shader_features_ext = 1000328000,
    physical_device_mesh_shader_properties_ext = 1000328001,
    physical_device_ycbcr_2_plane_444_formats_features_ext = 1000330000,
    physical_device_fragment_density_map_2_features_ext = 1000332000,
    physical_device_fragment_density_map_2_properties_ext = 1000332001,
    copy_command_transform_info_qcom = 1000333000,
    physical_device_workgroup_memory_explicit_layout_features_khr = 1000336000,
    physical_device_image_compression_control_features_ext = 1000338000,
    image_compression_control_ext = 1000338001,
    image_compression_properties_ext = 1000338004,
    physical_device_attachment_feedback_loop_layout_features_ext = 1000339000,
    physical_device_4444_formats_features_ext = 1000340000,
    physical_device_fault_features_ext = 1000341000,
    device_fault_counts_ext = 1000341001,
    device_fault_info_ext = 1000341002,
    physical_device_rgba10x6_formats_features_ext = 1000344000,
    directfb_surface_create_info_ext = 1000346000,
    physical_device_vertex_input_dynamic_state_features_ext = 1000352000,
    vertex_input_binding_description_2_ext = 1000352001,
    vertex_input_attribute_description_2_ext = 1000352002,
    physical_device_drm_properties_ext = 1000353000,
    physical_device_address_binding_report_features_ext = 1000354000,
    device_address_binding_callback_data_ext = 1000354001,
    physical_device_depth_clip_control_features_ext = 1000355000,
    pipeline_viewport_depth_clip_control_create_info_ext = 1000355001,
    physical_device_primitive_topology_list_restart_features_ext = 1000356000,
    import_memory_zircon_handle_info_fuchsia = 1000364000,
    memory_zircon_handle_properties_fuchsia = 1000364001,
    memory_get_zircon_handle_info_fuchsia = 1000364002,
    import_semaphore_zircon_handle_info_fuchsia = 1000365000,
    semaphore_get_zircon_handle_info_fuchsia = 1000365001,
    buffer_collection_create_info_fuchsia = 1000366000,
    import_memory_buffer_collection_fuchsia = 1000366001,
    buffer_collection_image_create_info_fuchsia = 1000366002,
    buffer_collection_properties_fuchsia = 1000366003,
    buffer_constraints_info_fuchsia = 1000366004,
    buffer_collection_buffer_create_info_fuchsia = 1000366005,
    image_constraints_info_fuchsia = 1000366006,
    image_format_constraints_info_fuchsia = 1000366007,
    sysmem_color_space_fuchsia = 1000366008,
    buffer_collection_constraints_info_fuchsia = 1000366009,
    subpass_shading_pipeline_create_info_huawei = 1000369000,
    physical_device_subpass_shading_features_huawei = 1000369001,
    physical_device_subpass_shading_properties_huawei = 1000369002,
    physical_device_invocation_mask_features_huawei = 1000370000,
    memory_get_remote_address_info_nv = 1000371000,
    physical_device_external_memory_rdma_features_nv = 1000371001,
    pipeline_properties_identifier_ext = 1000372000,
    physical_device_pipeline_properties_features_ext = 1000372001,
    import_fence_sci_sync_info_nv = 1000373000,
    export_fence_sci_sync_info_nv = 1000373001,
    fence_get_sci_sync_info_nv = 1000373002,
    sci_sync_attributes_info_nv = 1000373003,
    import_semaphore_sci_sync_info_nv = 1000373004,
    export_semaphore_sci_sync_info_nv = 1000373005,
    semaphore_get_sci_sync_info_nv = 1000373006,
    physical_device_external_sci_sync_features_nv = 1000373007,
    import_memory_sci_buf_info_nv = 1000374000,
    export_memory_sci_buf_info_nv = 1000374001,
    memory_get_sci_buf_info_nv = 1000374002,
    memory_sci_buf_properties_nv = 1000374003,
    physical_device_external_memory_sci_buf_features_nv = 1000374004,
    physical_device_frame_boundary_features_ext = 1000375000,
    frame_boundary_ext = 1000375001,
    physical_device_multisampled_render_to_single_sampled_features_ext = 1000376000,
    subpass_resolve_performance_query_ext = 1000376001,
    multisampled_render_to_single_sampled_info_ext = 1000376002,
    physical_device_extended_dynamic_state_2_features_ext = 1000377000,
    screen_surface_create_info_qnx = 1000378000,
    physical_device_color_write_enable_features_ext = 1000381000,
    pipeline_color_write_create_info_ext = 1000381001,
    physical_device_primitives_generated_query_features_ext = 1000382000,
    physical_device_ray_tracing_maintenance_1_features_khr = 1000386000,
    physical_device_image_view_min_lod_features_ext = 1000391000,
    image_view_min_lod_create_info_ext = 1000391001,
    physical_device_multi_draw_features_ext = 1000392000,
    physical_device_multi_draw_properties_ext = 1000392001,
    physical_device_image_2d_view_of_3d_features_ext = 1000393000,
    physical_device_shader_tile_image_features_ext = 1000395000,
    physical_device_shader_tile_image_properties_ext = 1000395001,
    micromap_build_info_ext = 1000396000,
    micromap_version_info_ext = 1000396001,
    copy_micromap_info_ext = 1000396002,
    copy_micromap_to_memory_info_ext = 1000396003,
    copy_memory_to_micromap_info_ext = 1000396004,
    physical_device_opacity_micromap_features_ext = 1000396005,
    physical_device_opacity_micromap_properties_ext = 1000396006,
    micromap_create_info_ext = 1000396007,
    micromap_build_sizes_info_ext = 1000396008,
    acceleration_structure_triangles_opacity_micromap_ext = 1000396009,
    physical_device_displacement_micromap_features_nv = 1000397000,
    physical_device_displacement_micromap_properties_nv = 1000397001,
    acceleration_structure_triangles_displacement_micromap_nv = 1000397002,
    physical_device_cluster_culling_shader_features_huawei = 1000404000,
    physical_device_cluster_culling_shader_properties_huawei = 1000404001,
    physical_device_cluster_culling_shader_vrs_features_huawei = 1000404002,
    physical_device_border_color_swizzle_features_ext = 1000411000,
    sampler_border_color_component_mapping_create_info_ext = 1000411001,
    physical_device_pageable_device_local_memory_features_ext = 1000412000,
    physical_device_shader_core_properties_arm = 1000415000,
    device_queue_shader_core_control_create_info_arm = 1000417000,
    physical_device_scheduling_controls_features_arm = 1000417001,
    physical_device_scheduling_controls_properties_arm = 1000417002,
    physical_device_image_sliced_view_of_3d_features_ext = 1000418000,
    image_view_sliced_create_info_ext = 1000418001,
    physical_device_descriptor_set_host_mapping_features_valve = 1000420000,
    descriptor_set_binding_reference_valve = 1000420001,
    descriptor_set_layout_host_mapping_info_valve = 1000420002,
    physical_device_non_seamless_cube_map_features_ext = 1000422000,
    physical_device_render_pass_striped_features_arm = 1000424000,
    physical_device_render_pass_striped_properties_arm = 1000424001,
    render_pass_stripe_begin_info_arm = 1000424002,
    render_pass_stripe_info_arm = 1000424003,
    render_pass_stripe_submit_info_arm = 1000424004,
    physical_device_copy_memory_indirect_features_nv = 1000426000,
    physical_device_copy_memory_indirect_properties_nv = 1000426001,
    physical_device_memory_decompression_features_nv = 1000427000,
    physical_device_memory_decompression_properties_nv = 1000427001,
    physical_device_device_generated_commands_compute_features_nv = 1000428000,
    compute_pipeline_indirect_buffer_info_nv = 1000428001,
    pipeline_indirect_device_address_info_nv = 1000428002,
    physical_device_ray_tracing_linear_swept_spheres_features_nv = 1000429008,
    acceleration_structure_geometry_linear_swept_spheres_data_nv = 1000429009,
    acceleration_structure_geometry_spheres_data_nv = 1000429010,
    physical_device_linear_color_attachment_features_nv = 1000430000,
    physical_device_shader_maximal_reconvergence_features_khr = 1000434000,
    application_parameters_ext = 1000435000,
    physical_device_image_compression_control_swapchain_features_ext = 1000437000,
    physical_device_image_processing_features_qcom = 1000440000,
    physical_device_image_processing_properties_qcom = 1000440001,
    image_view_sample_weight_create_info_qcom = 1000440002,
    physical_device_nested_command_buffer_features_ext = 1000451000,
    physical_device_nested_command_buffer_properties_ext = 1000451001,
    external_memory_acquire_unmodified_ext = 1000453000,
    physical_device_extended_dynamic_state_3_features_ext = 1000455000,
    physical_device_extended_dynamic_state_3_properties_ext = 1000455001,
    physical_device_subpass_merge_feedback_features_ext = 1000458000,
    render_pass_creation_control_ext = 1000458001,
    render_pass_creation_feedback_create_info_ext = 1000458002,
    render_pass_subpass_feedback_create_info_ext = 1000458003,
    direct_driver_loading_info_lunarg = 1000459000,
    direct_driver_loading_list_lunarg = 1000459001,
    tensor_create_info_arm = 1000460000,
    tensor_view_create_info_arm = 1000460001,
    bind_tensor_memory_info_arm = 1000460002,
    write_descriptor_set_tensor_arm = 1000460003,
    physical_device_tensor_properties_arm = 1000460004,
    tensor_format_properties_arm = 1000460005,
    tensor_description_arm = 1000460006,
    tensor_memory_requirements_info_arm = 1000460007,
    tensor_memory_barrier_arm = 1000460008,
    physical_device_tensor_features_arm = 1000460009,
    device_tensor_memory_requirements_arm = 1000460010,
    copy_tensor_info_arm = 1000460011,
    tensor_copy_arm = 1000460012,
    tensor_dependency_info_arm = 1000460013,
    memory_dedicated_allocate_info_tensor_arm = 1000460014,
    physical_device_external_tensor_info_arm = 1000460015,
    external_tensor_properties_arm = 1000460016,
    external_memory_tensor_create_info_arm = 1000460017,
    physical_device_descriptor_buffer_tensor_features_arm = 1000460018,
    physical_device_descriptor_buffer_tensor_properties_arm = 1000460019,
    descriptor_get_tensor_info_arm = 1000460020,
    tensor_capture_descriptor_data_info_arm = 1000460021,
    tensor_view_capture_descriptor_data_info_arm = 1000460022,
    frame_boundary_tensors_arm = 1000460023,
    physical_device_shader_module_identifier_features_ext = 1000462000,
    physical_device_shader_module_identifier_properties_ext = 1000462001,
    pipeline_shader_stage_module_identifier_create_info_ext = 1000462002,
    shader_module_identifier_ext = 1000462003,
    physical_device_rasterization_order_attachment_access_features_ext = 1000342000,
    physical_device_optical_flow_features_nv = 1000464000,
    physical_device_optical_flow_properties_nv = 1000464001,
    optical_flow_image_format_info_nv = 1000464002,
    optical_flow_image_format_properties_nv = 1000464003,
    optical_flow_session_create_info_nv = 1000464004,
    optical_flow_execute_info_nv = 1000464005,
    optical_flow_session_create_private_data_info_nv = 1000464010,
    physical_device_legacy_dithering_features_ext = 1000465000,
    physical_device_external_format_resolve_features_android = 1000468000,
    physical_device_external_format_resolve_properties_android = 1000468001,
    android_hardware_buffer_format_resolve_properties_android = 1000468002,
    physical_device_anti_lag_features_amd = 1000476000,
    anti_lag_data_amd = 1000476001,
    anti_lag_presentation_info_amd = 1000476002,
    surface_capabilities_present_id_2_khr = 1000479000,
    present_id_2_khr = 1000479001,
    physical_device_present_id_2_features_khr = 1000479002,
    surface_capabilities_present_wait_2_khr = 1000480000,
    physical_device_present_wait_2_features_khr = 1000480001,
    present_wait_2_info_khr = 1000480002,
    physical_device_ray_tracing_position_fetch_features_khr = 1000481000,
    physical_device_shader_object_features_ext = 1000482000,
    physical_device_shader_object_properties_ext = 1000482001,
    shader_create_info_ext = 1000482002,
    physical_device_pipeline_binary_features_khr = 1000483000,
    pipeline_binary_create_info_khr = 1000483001,
    pipeline_binary_info_khr = 1000483002,
    pipeline_binary_key_khr = 1000483003,
    physical_device_pipeline_binary_properties_khr = 1000483004,
    release_captured_pipeline_data_info_khr = 1000483005,
    pipeline_binary_data_info_khr = 1000483006,
    pipeline_create_info_khr = 1000483007,
    device_pipeline_binary_internal_cache_control_khr = 1000483008,
    pipeline_binary_handles_info_khr = 1000483009,
    physical_device_tile_properties_features_qcom = 1000484000,
    tile_properties_qcom = 1000484001,
    physical_device_amigo_profiling_features_sec = 1000485000,
    amigo_profiling_submit_info_sec = 1000485001,
    surface_present_mode_khr = 1000274000,
    surface_present_scaling_capabilities_khr = 1000274001,
    surface_present_mode_compatibility_khr = 1000274002,
    physical_device_swapchain_maintenance_1_features_khr = 1000275000,
    swapchain_present_fence_info_khr = 1000275001,
    swapchain_present_modes_create_info_khr = 1000275002,
    swapchain_present_mode_info_khr = 1000275003,
    swapchain_present_scaling_create_info_khr = 1000275004,
    release_swapchain_images_info_khr = 1000275005,
    physical_device_multiview_per_view_viewports_features_qcom = 1000488000,
    semaphore_sci_sync_pool_create_info_nv = 1000489000,
    semaphore_sci_sync_create_info_nv = 1000489001,
    physical_device_external_sci_sync_2_features_nv = 1000489002,
    physical_device_ray_tracing_invocation_reorder_features_nv = 1000490000,
    physical_device_ray_tracing_invocation_reorder_properties_nv = 1000490001,
    physical_device_cooperative_vector_features_nv = 1000491000,
    physical_device_cooperative_vector_properties_nv = 1000491001,
    cooperative_vector_properties_nv = 1000491002,
    convert_cooperative_vector_matrix_info_nv = 1000491004,
    physical_device_extended_sparse_address_space_features_nv = 1000492000,
    physical_device_extended_sparse_address_space_properties_nv = 1000492001,
    physical_device_mutable_descriptor_type_features_ext = 1000351000,
    mutable_descriptor_type_create_info_ext = 1000351002,
    physical_device_legacy_vertex_attributes_features_ext = 1000495000,
    physical_device_legacy_vertex_attributes_properties_ext = 1000495001,
    layer_settings_create_info_ext = 1000496000,
    physical_device_shader_core_builtins_features_arm = 1000497000,
    physical_device_shader_core_builtins_properties_arm = 1000497001,
    physical_device_pipeline_library_group_handles_features_ext = 1000498000,
    physical_device_dynamic_rendering_unused_attachments_features_ext = 1000499000,
    latency_sleep_mode_info_nv = 1000505000,
    latency_sleep_info_nv = 1000505001,
    set_latency_marker_info_nv = 1000505002,
    get_latency_marker_info_nv = 1000505003,
    latency_timings_frame_report_nv = 1000505004,
    latency_submission_present_id_nv = 1000505005,
    out_of_band_queue_type_info_nv = 1000505006,
    swapchain_latency_create_info_nv = 1000505007,
    latency_surface_capabilities_nv = 1000505008,
    physical_device_cooperative_matrix_features_khr = 1000506000,
    cooperative_matrix_properties_khr = 1000506001,
    physical_device_cooperative_matrix_properties_khr = 1000506002,
    data_graph_pipeline_create_info_arm = 1000507000,
    data_graph_pipeline_session_create_info_arm = 1000507001,
    data_graph_pipeline_resource_info_arm = 1000507002,
    data_graph_pipeline_constant_arm = 1000507003,
    data_graph_pipeline_session_memory_requirements_info_arm = 1000507004,
    bind_data_graph_pipeline_session_memory_info_arm = 1000507005,
    physical_device_data_graph_features_arm = 1000507006,
    data_graph_pipeline_shader_module_create_info_arm = 1000507007,
    data_graph_pipeline_property_query_result_arm = 1000507008,
    data_graph_pipeline_info_arm = 1000507009,
    data_graph_pipeline_compiler_control_create_info_arm = 1000507010,
    data_graph_pipeline_session_bind_point_requirements_info_arm = 1000507011,
    data_graph_pipeline_session_bind_point_requirement_arm = 1000507012,
    data_graph_pipeline_identifier_create_info_arm = 1000507013,
    data_graph_pipeline_dispatch_info_arm = 1000507014,
    data_graph_processing_engine_create_info_arm = 1000507016,
    queue_family_data_graph_processing_engine_properties_arm = 1000507017,
    queue_family_data_graph_properties_arm = 1000507018,
    physical_device_queue_family_data_graph_processing_engine_info_arm = 1000507019,
    data_graph_pipeline_constant_tensor_semi_structured_sparsity_info_arm = 1000507015,
    physical_device_multiview_per_view_render_areas_features_qcom = 1000510000,
    multiview_per_view_render_areas_render_pass_begin_info_qcom = 1000510001,
    physical_device_compute_shader_derivatives_features_khr = 1000201000,
    physical_device_compute_shader_derivatives_properties_khr = 1000511000,
    video_decode_av1_capabilities_khr = 1000512000,
    video_decode_av1_picture_info_khr = 1000512001,
    video_decode_av1_profile_info_khr = 1000512003,
    video_decode_av1_session_parameters_create_info_khr = 1000512004,
    video_decode_av1_dpb_slot_info_khr = 1000512005,
    video_encode_av1_capabilities_khr = 1000513000,
    video_encode_av1_session_parameters_create_info_khr = 1000513001,
    video_encode_av1_picture_info_khr = 1000513002,
    video_encode_av1_dpb_slot_info_khr = 1000513003,
    physical_device_video_encode_av1_features_khr = 1000513004,
    video_encode_av1_profile_info_khr = 1000513005,
    video_encode_av1_rate_control_info_khr = 1000513006,
    video_encode_av1_rate_control_layer_info_khr = 1000513007,
    video_encode_av1_quality_level_properties_khr = 1000513008,
    video_encode_av1_session_create_info_khr = 1000513009,
    video_encode_av1_gop_remaining_frame_info_khr = 1000513010,
    physical_device_video_decode_vp9_features_khr = 1000514000,
    video_decode_vp9_capabilities_khr = 1000514001,
    video_decode_vp9_picture_info_khr = 1000514002,
    video_decode_vp9_profile_info_khr = 1000514003,
    physical_device_video_maintenance_1_features_khr = 1000515000,
    video_inline_query_info_khr = 1000515001,
    physical_device_per_stage_descriptor_set_features_nv = 1000516000,
    physical_device_image_processing_2_features_qcom = 1000518000,
    physical_device_image_processing_2_properties_qcom = 1000518001,
    sampler_block_match_window_create_info_qcom = 1000518002,
    sampler_cubic_weights_create_info_qcom = 1000519000,
    physical_device_cubic_weights_features_qcom = 1000519001,
    blit_image_cubic_weights_info_qcom = 1000519002,
    physical_device_ycbcr_degamma_features_qcom = 1000520000,
    sampler_ycbcr_conversion_ycbcr_degamma_create_info_qcom = 1000520001,
    physical_device_cubic_clamp_features_qcom = 1000521000,
    physical_device_attachment_feedback_loop_dynamic_state_features_ext = 1000524000,
    physical_device_unified_image_layouts_features_khr = 1000527000,
    attachment_feedback_loop_info_ext = 1000527001,
    screen_buffer_properties_qnx = 1000529000,
    screen_buffer_format_properties_qnx = 1000529001,
    import_screen_buffer_info_qnx = 1000529002,
    external_format_qnx = 1000529003,
    physical_device_external_memory_screen_buffer_features_qnx = 1000529004,
    physical_device_layered_driver_properties_msft = 1000530000,
    calibrated_timestamp_info_khr = 1000184000,
    set_descriptor_buffer_offsets_info_ext = 1000545007,
    bind_descriptor_buffer_embedded_samplers_info_ext = 1000545008,
    physical_device_descriptor_pool_overallocation_features_nv = 1000546000,
    physical_device_tile_memory_heap_features_qcom = 1000547000,
    physical_device_tile_memory_heap_properties_qcom = 1000547001,
    tile_memory_requirements_qcom = 1000547002,
    tile_memory_bind_info_qcom = 1000547003,
    tile_memory_size_info_qcom = 1000547004,
    display_surface_stereo_create_info_nv = 1000551000,
    display_mode_stereo_properties_nv = 1000551001,
    video_encode_intra_refresh_capabilities_khr = 1000552000,
    video_encode_session_intra_refresh_create_info_khr = 1000552001,
    video_encode_intra_refresh_info_khr = 1000552002,
    video_reference_intra_refresh_info_khr = 1000552003,
    physical_device_video_encode_intra_refresh_features_khr = 1000552004,
    video_encode_quantization_map_capabilities_khr = 1000553000,
    video_format_quantization_map_properties_khr = 1000553001,
    video_encode_quantization_map_info_khr = 1000553002,
    video_encode_quantization_map_session_parameters_create_info_khr = 1000553005,
    physical_device_video_encode_quantization_map_features_khr = 1000553009,
    video_encode_h264_quantization_map_capabilities_khr = 1000553003,
    video_encode_h265_quantization_map_capabilities_khr = 1000553004,
    video_format_h265_quantization_map_properties_khr = 1000553006,
    video_encode_av1_quantization_map_capabilities_khr = 1000553007,
    video_format_av1_quantization_map_properties_khr = 1000553008,
    physical_device_raw_access_chains_features_nv = 1000555000,
    external_compute_queue_device_create_info_nv = 1000556000,
    external_compute_queue_create_info_nv = 1000556001,
    external_compute_queue_data_params_nv = 1000556002,
    physical_device_external_compute_queue_properties_nv = 1000556003,
    physical_device_shader_relaxed_extended_instruction_features_khr = 1000558000,
    physical_device_command_buffer_inheritance_features_nv = 1000559000,
    physical_device_maintenance_7_features_khr = 1000562000,
    physical_device_maintenance_7_properties_khr = 1000562001,
    physical_device_layered_api_properties_list_khr = 1000562002,
    physical_device_layered_api_properties_khr = 1000562003,
    physical_device_layered_api_vulkan_properties_khr = 1000562004,
    physical_device_shader_atomic_float16_vector_features_nv = 1000563000,
    physical_device_shader_replicated_composites_features_ext = 1000564000,
    physical_device_shader_float8_features_ext = 1000567000,
    physical_device_ray_tracing_validation_features_nv = 1000568000,
    physical_device_cluster_acceleration_structure_features_nv = 1000569000,
    physical_device_cluster_acceleration_structure_properties_nv = 1000569001,
    cluster_acceleration_structure_clusters_bottom_level_input_nv = 1000569002,
    cluster_acceleration_structure_triangle_cluster_input_nv = 1000569003,
    cluster_acceleration_structure_move_objects_input_nv = 1000569004,
    cluster_acceleration_structure_input_info_nv = 1000569005,
    cluster_acceleration_structure_commands_info_nv = 1000569006,
    ray_tracing_pipeline_cluster_acceleration_structure_create_info_nv = 1000569007,
    physical_device_partitioned_acceleration_structure_features_nv = 1000570000,
    physical_device_partitioned_acceleration_structure_properties_nv = 1000570001,
    write_descriptor_set_partitioned_acceleration_structure_nv = 1000570002,
    partitioned_acceleration_structure_instances_input_nv = 1000570003,
    build_partitioned_acceleration_structure_info_nv = 1000570004,
    partitioned_acceleration_structure_flags_nv = 1000570005,
    physical_device_device_generated_commands_features_ext = 1000572000,
    physical_device_device_generated_commands_properties_ext = 1000572001,
    generated_commands_memory_requirements_info_ext = 1000572002,
    indirect_execution_set_create_info_ext = 1000572003,
    generated_commands_info_ext = 1000572004,
    indirect_commands_layout_create_info_ext = 1000572006,
    indirect_commands_layout_token_ext = 1000572007,
    write_indirect_execution_set_pipeline_ext = 1000572008,
    write_indirect_execution_set_shader_ext = 1000572009,
    indirect_execution_set_pipeline_info_ext = 1000572010,
    indirect_execution_set_shader_info_ext = 1000572011,
    indirect_execution_set_shader_layout_info_ext = 1000572012,
    generated_commands_pipeline_info_ext = 1000572013,
    generated_commands_shader_info_ext = 1000572014,
    physical_device_maintenance_8_features_khr = 1000574000,
    memory_barrier_access_flags_3_khr = 1000574002,
    physical_device_image_alignment_control_features_mesa = 1000575000,
    physical_device_image_alignment_control_properties_mesa = 1000575001,
    image_alignment_control_create_info_mesa = 1000575002,
    physical_device_depth_clamp_control_features_ext = 1000582000,
    pipeline_viewport_depth_clamp_control_create_info_ext = 1000582001,
    physical_device_maintenance_9_features_khr = 1000584000,
    physical_device_maintenance_9_properties_khr = 1000584001,
    queue_family_ownership_transfer_properties_khr = 1000584002,
    physical_device_video_maintenance_2_features_khr = 1000586000,
    video_decode_h264_inline_session_parameters_info_khr = 1000586001,
    video_decode_h265_inline_session_parameters_info_khr = 1000586002,
    video_decode_av1_inline_session_parameters_info_khr = 1000586003,
    oh_surface_create_info_ohos = 1000587000,
    physical_device_hdr_vivid_features_huawei = 1000590000,
    hdr_vivid_dynamic_metadata_huawei = 1000590001,
    physical_device_cooperative_matrix_2_features_nv = 1000593000,
    cooperative_matrix_flexible_dimensions_properties_nv = 1000593001,
    physical_device_cooperative_matrix_2_properties_nv = 1000593002,
    physical_device_pipeline_opacity_micromap_features_arm = 1000596000,
    import_memory_metal_handle_info_ext = 1000602000,
    memory_metal_handle_properties_ext = 1000602001,
    memory_get_metal_handle_info_ext = 1000602002,
    physical_device_depth_clamp_zero_one_features_khr = 1000421000,
    physical_device_vertex_attribute_robustness_features_ext = 1000608000,
    physical_device_format_pack_features_arm = 1000609000,
    physical_device_fragment_density_map_layered_features_valve = 1000611000,
    physical_device_fragment_density_map_layered_properties_valve = 1000611001,
    pipeline_fragment_density_map_layered_create_info_valve = 1000611002,
    physical_device_robustness_2_features_khr = 1000286000,
    physical_device_robustness_2_properties_khr = 1000286001,
    set_present_config_nv = 1000613000,
    physical_device_present_metering_features_nv = 1000613001,
    physical_device_fragment_density_map_offset_features_ext = 1000425000,
    physical_device_fragment_density_map_offset_properties_ext = 1000425001,
    render_pass_fragment_density_map_offset_end_info_ext = 1000425002,
    rendering_end_info_ext = 1000619003,
    physical_device_zero_initialize_device_memory_features_ext = 1000620000,
    physical_device_present_mode_fifo_latest_ready_features_khr = 1000361000,
    physical_device_pipeline_cache_incremental_mode_features_sec = 1000637000,
    _,
    pub const physical_device_variable_pointer_features = StructureType.physical_device_variable_pointers_features;
    pub const physical_device_shader_draw_parameter_features = StructureType.physical_device_shader_draw_parameters_features;
    pub const debug_report_create_info_ext = StructureType.debug_report_callback_create_info_ext;
    pub const rendering_info_khr = StructureType.rendering_info;
    pub const rendering_attachment_info_khr = StructureType.rendering_attachment_info;
    pub const pipeline_rendering_create_info_khr = StructureType.pipeline_rendering_create_info;
    pub const physical_device_dynamic_rendering_features_khr = StructureType.physical_device_dynamic_rendering_features;
    pub const command_buffer_inheritance_rendering_info_khr = StructureType.command_buffer_inheritance_rendering_info;
    pub const render_pass_multiview_create_info_khr = StructureType.render_pass_multiview_create_info;
    pub const physical_device_multiview_features_khr = StructureType.physical_device_multiview_features;
    pub const physical_device_multiview_properties_khr = StructureType.physical_device_multiview_properties;
    pub const physical_device_features_2_khr = StructureType.physical_device_features_2;
    pub const physical_device_properties_2_khr = StructureType.physical_device_properties_2;
    pub const format_properties_2_khr = StructureType.format_properties_2;
    pub const image_format_properties_2_khr = StructureType.image_format_properties_2;
    pub const physical_device_image_format_info_2_khr = StructureType.physical_device_image_format_info_2;
    pub const queue_family_properties_2_khr = StructureType.queue_family_properties_2;
    pub const physical_device_memory_properties_2_khr = StructureType.physical_device_memory_properties_2;
    pub const sparse_image_format_properties_2_khr = StructureType.sparse_image_format_properties_2;
    pub const physical_device_sparse_image_format_info_2_khr = StructureType.physical_device_sparse_image_format_info_2;
    pub const memory_allocate_flags_info_khr = StructureType.memory_allocate_flags_info;
    pub const device_group_render_pass_begin_info_khr = StructureType.device_group_render_pass_begin_info;
    pub const device_group_command_buffer_begin_info_khr = StructureType.device_group_command_buffer_begin_info;
    pub const device_group_submit_info_khr = StructureType.device_group_submit_info;
    pub const device_group_bind_sparse_info_khr = StructureType.device_group_bind_sparse_info;
    pub const bind_buffer_memory_device_group_info_khr = StructureType.bind_buffer_memory_device_group_info;
    pub const bind_image_memory_device_group_info_khr = StructureType.bind_image_memory_device_group_info;
    pub const physical_device_texture_compression_astc_hdr_features_ext = StructureType.physical_device_texture_compression_astc_hdr_features;
    pub const pipeline_robustness_create_info_ext = StructureType.pipeline_robustness_create_info;
    pub const physical_device_pipeline_robustness_features_ext = StructureType.physical_device_pipeline_robustness_features;
    pub const physical_device_pipeline_robustness_properties_ext = StructureType.physical_device_pipeline_robustness_properties;
    pub const physical_device_group_properties_khr = StructureType.physical_device_group_properties;
    pub const device_group_device_create_info_khr = StructureType.device_group_device_create_info;
    pub const physical_device_external_image_format_info_khr = StructureType.physical_device_external_image_format_info;
    pub const external_image_format_properties_khr = StructureType.external_image_format_properties;
    pub const physical_device_external_buffer_info_khr = StructureType.physical_device_external_buffer_info;
    pub const external_buffer_properties_khr = StructureType.external_buffer_properties;
    pub const physical_device_id_properties_khr = StructureType.physical_device_id_properties;
    pub const external_memory_buffer_create_info_khr = StructureType.external_memory_buffer_create_info;
    pub const external_memory_image_create_info_khr = StructureType.external_memory_image_create_info;
    pub const export_memory_allocate_info_khr = StructureType.export_memory_allocate_info;
    pub const physical_device_external_semaphore_info_khr = StructureType.physical_device_external_semaphore_info;
    pub const external_semaphore_properties_khr = StructureType.external_semaphore_properties;
    pub const export_semaphore_create_info_khr = StructureType.export_semaphore_create_info;
    pub const physical_device_push_descriptor_properties_khr = StructureType.physical_device_push_descriptor_properties;
    pub const physical_device_shader_float16_int8_features_khr = StructureType.physical_device_shader_float16_int8_features;
    pub const physical_device_float16_int8_features_khr = StructureType.physical_device_shader_float16_int8_features;
    pub const physical_device_16bit_storage_features_khr = StructureType.physical_device_16bit_storage_features;
    pub const descriptor_update_template_create_info_khr = StructureType.descriptor_update_template_create_info;
    pub const surface_capabilities2_ext = StructureType.surface_capabilities_2_ext;
    pub const physical_device_imageless_framebuffer_features_khr = StructureType.physical_device_imageless_framebuffer_features;
    pub const framebuffer_attachments_create_info_khr = StructureType.framebuffer_attachments_create_info;
    pub const framebuffer_attachment_image_info_khr = StructureType.framebuffer_attachment_image_info;
    pub const render_pass_attachment_begin_info_khr = StructureType.render_pass_attachment_begin_info;
    pub const attachment_description_2_khr = StructureType.attachment_description_2;
    pub const attachment_reference_2_khr = StructureType.attachment_reference_2;
    pub const subpass_description_2_khr = StructureType.subpass_description_2;
    pub const subpass_dependency_2_khr = StructureType.subpass_dependency_2;
    pub const render_pass_create_info_2_khr = StructureType.render_pass_create_info_2;
    pub const subpass_begin_info_khr = StructureType.subpass_begin_info;
    pub const subpass_end_info_khr = StructureType.subpass_end_info;
    pub const physical_device_external_fence_info_khr = StructureType.physical_device_external_fence_info;
    pub const external_fence_properties_khr = StructureType.external_fence_properties;
    pub const export_fence_create_info_khr = StructureType.export_fence_create_info;
    pub const physical_device_point_clipping_properties_khr = StructureType.physical_device_point_clipping_properties;
    pub const render_pass_input_attachment_aspect_create_info_khr = StructureType.render_pass_input_attachment_aspect_create_info;
    pub const image_view_usage_create_info_khr = StructureType.image_view_usage_create_info;
    pub const pipeline_tessellation_domain_origin_state_create_info_khr = StructureType.pipeline_tessellation_domain_origin_state_create_info;
    pub const physical_device_variable_pointers_features_khr = StructureType.physical_device_variable_pointers_features;
    pub const physical_device_variable_pointer_features_khr = StructureType.physical_device_variable_pointers_features_khr;
    pub const memory_dedicated_requirements_khr = StructureType.memory_dedicated_requirements;
    pub const memory_dedicated_allocate_info_khr = StructureType.memory_dedicated_allocate_info;
    pub const physical_device_sampler_filter_minmax_properties_ext = StructureType.physical_device_sampler_filter_minmax_properties;
    pub const sampler_reduction_mode_create_info_ext = StructureType.sampler_reduction_mode_create_info;
    pub const physical_device_inline_uniform_block_features_ext = StructureType.physical_device_inline_uniform_block_features;
    pub const physical_device_inline_uniform_block_properties_ext = StructureType.physical_device_inline_uniform_block_properties;
    pub const write_descriptor_set_inline_uniform_block_ext = StructureType.write_descriptor_set_inline_uniform_block;
    pub const descriptor_pool_inline_uniform_block_create_info_ext = StructureType.descriptor_pool_inline_uniform_block_create_info;
    pub const buffer_memory_requirements_info_2_khr = StructureType.buffer_memory_requirements_info_2;
    pub const image_memory_requirements_info_2_khr = StructureType.image_memory_requirements_info_2;
    pub const image_sparse_memory_requirements_info_2_khr = StructureType.image_sparse_memory_requirements_info_2;
    pub const memory_requirements_2_khr = StructureType.memory_requirements_2;
    pub const sparse_image_memory_requirements_2_khr = StructureType.sparse_image_memory_requirements_2;
    pub const image_format_list_create_info_khr = StructureType.image_format_list_create_info;
    pub const attachment_sample_count_info_nv = StructureType.attachment_sample_count_info_amd;
    pub const sampler_ycbcr_conversion_create_info_khr = StructureType.sampler_ycbcr_conversion_create_info;
    pub const sampler_ycbcr_conversion_info_khr = StructureType.sampler_ycbcr_conversion_info;
    pub const bind_image_plane_memory_info_khr = StructureType.bind_image_plane_memory_info;
    pub const image_plane_memory_requirements_info_khr = StructureType.image_plane_memory_requirements_info;
    pub const physical_device_sampler_ycbcr_conversion_features_khr = StructureType.physical_device_sampler_ycbcr_conversion_features;
    pub const sampler_ycbcr_conversion_image_format_properties_khr = StructureType.sampler_ycbcr_conversion_image_format_properties;
    pub const bind_buffer_memory_info_khr = StructureType.bind_buffer_memory_info;
    pub const bind_image_memory_info_khr = StructureType.bind_image_memory_info;
    pub const descriptor_set_layout_binding_flags_create_info_ext = StructureType.descriptor_set_layout_binding_flags_create_info;
    pub const physical_device_descriptor_indexing_features_ext = StructureType.physical_device_descriptor_indexing_features;
    pub const physical_device_descriptor_indexing_properties_ext = StructureType.physical_device_descriptor_indexing_properties;
    pub const descriptor_set_variable_descriptor_count_allocate_info_ext = StructureType.descriptor_set_variable_descriptor_count_allocate_info;
    pub const descriptor_set_variable_descriptor_count_layout_support_ext = StructureType.descriptor_set_variable_descriptor_count_layout_support;
    pub const physical_device_maintenance_3_properties_khr = StructureType.physical_device_maintenance_3_properties;
    pub const descriptor_set_layout_support_khr = StructureType.descriptor_set_layout_support;
    pub const device_queue_global_priority_create_info_ext = StructureType.device_queue_global_priority_create_info;
    pub const physical_device_shader_subgroup_extended_types_features_khr = StructureType.physical_device_shader_subgroup_extended_types_features;
    pub const physical_device_8bit_storage_features_khr = StructureType.physical_device_8bit_storage_features;
    pub const physical_device_shader_atomic_int64_features_khr = StructureType.physical_device_shader_atomic_int64_features;
    pub const calibrated_timestamp_info_ext = StructureType.calibrated_timestamp_info_khr;
    pub const device_queue_global_priority_create_info_khr = StructureType.device_queue_global_priority_create_info;
    pub const physical_device_global_priority_query_features_khr = StructureType.physical_device_global_priority_query_features;
    pub const queue_family_global_priority_properties_khr = StructureType.queue_family_global_priority_properties;
    pub const pipeline_vertex_input_divisor_state_create_info_ext = StructureType.pipeline_vertex_input_divisor_state_create_info;
    pub const physical_device_vertex_attribute_divisor_features_ext = StructureType.physical_device_vertex_attribute_divisor_features;
    pub const pipeline_creation_feedback_create_info_ext = StructureType.pipeline_creation_feedback_create_info;
    pub const physical_device_driver_properties_khr = StructureType.physical_device_driver_properties;
    pub const physical_device_float_controls_properties_khr = StructureType.physical_device_float_controls_properties;
    pub const physical_device_depth_stencil_resolve_properties_khr = StructureType.physical_device_depth_stencil_resolve_properties;
    pub const subpass_description_depth_stencil_resolve_khr = StructureType.subpass_description_depth_stencil_resolve;
    pub const physical_device_compute_shader_derivatives_features_nv = StructureType.physical_device_compute_shader_derivatives_features_khr;
    pub const physical_device_fragment_shader_barycentric_features_nv = StructureType.physical_device_fragment_shader_barycentric_features_khr;
    pub const physical_device_timeline_semaphore_features_khr = StructureType.physical_device_timeline_semaphore_features;
    pub const physical_device_timeline_semaphore_properties_khr = StructureType.physical_device_timeline_semaphore_properties;
    pub const semaphore_type_create_info_khr = StructureType.semaphore_type_create_info;
    pub const timeline_semaphore_submit_info_khr = StructureType.timeline_semaphore_submit_info;
    pub const semaphore_wait_info_khr = StructureType.semaphore_wait_info;
    pub const semaphore_signal_info_khr = StructureType.semaphore_signal_info;
    pub const query_pool_create_info_intel = StructureType.query_pool_performance_query_create_info_intel;
    pub const physical_device_vulkan_memory_model_features_khr = StructureType.physical_device_vulkan_memory_model_features;
    pub const physical_device_shader_terminate_invocation_features_khr = StructureType.physical_device_shader_terminate_invocation_features;
    pub const physical_device_scalar_block_layout_features_ext = StructureType.physical_device_scalar_block_layout_features;
    pub const physical_device_subgroup_size_control_properties_ext = StructureType.physical_device_subgroup_size_control_properties;
    pub const pipeline_shader_stage_required_subgroup_size_create_info_ext = StructureType.pipeline_shader_stage_required_subgroup_size_create_info;
    pub const physical_device_subgroup_size_control_features_ext = StructureType.physical_device_subgroup_size_control_features;
    pub const physical_device_dynamic_rendering_local_read_features_khr = StructureType.physical_device_dynamic_rendering_local_read_features;
    pub const rendering_attachment_location_info_khr = StructureType.rendering_attachment_location_info;
    pub const rendering_input_attachment_index_info_khr = StructureType.rendering_input_attachment_index_info;
    pub const physical_device_separate_depth_stencil_layouts_features_khr = StructureType.physical_device_separate_depth_stencil_layouts_features;
    pub const attachment_reference_stencil_layout_khr = StructureType.attachment_reference_stencil_layout;
    pub const attachment_description_stencil_layout_khr = StructureType.attachment_description_stencil_layout;
    pub const physical_device_buffer_address_features_ext = StructureType.physical_device_buffer_device_address_features_ext;
    pub const buffer_device_address_info_ext = StructureType.buffer_device_address_info;
    pub const physical_device_tool_properties_ext = StructureType.physical_device_tool_properties;
    pub const image_stencil_usage_create_info_ext = StructureType.image_stencil_usage_create_info;
    pub const physical_device_uniform_buffer_standard_layout_features_khr = StructureType.physical_device_uniform_buffer_standard_layout_features;
    pub const physical_device_buffer_device_address_features_khr = StructureType.physical_device_buffer_device_address_features;
    pub const buffer_device_address_info_khr = StructureType.buffer_device_address_info;
    pub const buffer_opaque_capture_address_create_info_khr = StructureType.buffer_opaque_capture_address_create_info;
    pub const memory_opaque_capture_address_allocate_info_khr = StructureType.memory_opaque_capture_address_allocate_info;
    pub const device_memory_opaque_capture_address_info_khr = StructureType.device_memory_opaque_capture_address_info;
    pub const physical_device_line_rasterization_features_ext = StructureType.physical_device_line_rasterization_features;
    pub const pipeline_rasterization_line_state_create_info_ext = StructureType.pipeline_rasterization_line_state_create_info;
    pub const physical_device_line_rasterization_properties_ext = StructureType.physical_device_line_rasterization_properties;
    pub const physical_device_host_query_reset_features_ext = StructureType.physical_device_host_query_reset_features;
    pub const physical_device_index_type_uint8_features_ext = StructureType.physical_device_index_type_uint8_features;
    pub const physical_device_host_image_copy_features_ext = StructureType.physical_device_host_image_copy_features;
    pub const physical_device_host_image_copy_properties_ext = StructureType.physical_device_host_image_copy_properties;
    pub const memory_to_image_copy_ext = StructureType.memory_to_image_copy;
    pub const image_to_memory_copy_ext = StructureType.image_to_memory_copy;
    pub const copy_image_to_memory_info_ext = StructureType.copy_image_to_memory_info;
    pub const copy_memory_to_image_info_ext = StructureType.copy_memory_to_image_info;
    pub const host_image_layout_transition_info_ext = StructureType.host_image_layout_transition_info;
    pub const copy_image_to_image_info_ext = StructureType.copy_image_to_image_info;
    pub const subresource_host_memcpy_size_ext = StructureType.subresource_host_memcpy_size;
    pub const host_image_copy_device_performance_query_ext = StructureType.host_image_copy_device_performance_query;
    pub const memory_map_info_khr = StructureType.memory_map_info;
    pub const memory_unmap_info_khr = StructureType.memory_unmap_info;
    pub const surface_present_mode_ext = StructureType.surface_present_mode_khr;
    pub const surface_present_scaling_capabilities_ext = StructureType.surface_present_scaling_capabilities_khr;
    pub const surface_present_mode_compatibility_ext = StructureType.surface_present_mode_compatibility_khr;
    pub const physical_device_swapchain_maintenance_1_features_ext = StructureType.physical_device_swapchain_maintenance_1_features_khr;
    pub const swapchain_present_fence_info_ext = StructureType.swapchain_present_fence_info_khr;
    pub const swapchain_present_modes_create_info_ext = StructureType.swapchain_present_modes_create_info_khr;
    pub const swapchain_present_mode_info_ext = StructureType.swapchain_present_mode_info_khr;
    pub const swapchain_present_scaling_create_info_ext = StructureType.swapchain_present_scaling_create_info_khr;
    pub const release_swapchain_images_info_ext = StructureType.release_swapchain_images_info_khr;
    pub const physical_device_shader_demote_to_helper_invocation_features_ext = StructureType.physical_device_shader_demote_to_helper_invocation_features;
    pub const physical_device_shader_integer_dot_product_features_khr = StructureType.physical_device_shader_integer_dot_product_features;
    pub const physical_device_shader_integer_dot_product_properties_khr = StructureType.physical_device_shader_integer_dot_product_properties;
    pub const physical_device_texel_buffer_alignment_properties_ext = StructureType.physical_device_texel_buffer_alignment_properties;
    pub const physical_device_robustness_2_features_ext = StructureType.physical_device_robustness_2_features_khr;
    pub const physical_device_robustness_2_properties_ext = StructureType.physical_device_robustness_2_properties_khr;
    pub const physical_device_private_data_features_ext = StructureType.physical_device_private_data_features;
    pub const device_private_data_create_info_ext = StructureType.device_private_data_create_info;
    pub const private_data_slot_create_info_ext = StructureType.private_data_slot_create_info;
    pub const physical_device_pipeline_creation_cache_control_features_ext = StructureType.physical_device_pipeline_creation_cache_control_features;
    pub const memory_barrier_2_khr = StructureType.memory_barrier_2;
    pub const buffer_memory_barrier_2_khr = StructureType.buffer_memory_barrier_2;
    pub const image_memory_barrier_2_khr = StructureType.image_memory_barrier_2;
    pub const dependency_info_khr = StructureType.dependency_info;
    pub const submit_info_2_khr = StructureType.submit_info_2;
    pub const semaphore_submit_info_khr = StructureType.semaphore_submit_info;
    pub const command_buffer_submit_info_khr = StructureType.command_buffer_submit_info;
    pub const physical_device_synchronization_2_features_khr = StructureType.physical_device_synchronization_2_features;
    pub const physical_device_zero_initialize_workgroup_memory_features_khr = StructureType.physical_device_zero_initialize_workgroup_memory_features;
    pub const physical_device_image_robustness_features_ext = StructureType.physical_device_image_robustness_features;
    pub const copy_buffer_info_2_khr = StructureType.copy_buffer_info_2;
    pub const copy_image_info_2_khr = StructureType.copy_image_info_2;
    pub const copy_buffer_to_image_info_2_khr = StructureType.copy_buffer_to_image_info_2;
    pub const copy_image_to_buffer_info_2_khr = StructureType.copy_image_to_buffer_info_2;
    pub const blit_image_info_2_khr = StructureType.blit_image_info_2;
    pub const resolve_image_info_2_khr = StructureType.resolve_image_info_2;
    pub const buffer_copy_2_khr = StructureType.buffer_copy_2;
    pub const image_copy_2_khr = StructureType.image_copy_2;
    pub const image_blit_2_khr = StructureType.image_blit_2;
    pub const buffer_image_copy_2_khr = StructureType.buffer_image_copy_2;
    pub const image_resolve_2_khr = StructureType.image_resolve_2;
    pub const subresource_layout_2_ext = StructureType.subresource_layout_2;
    pub const image_subresource_2_ext = StructureType.image_subresource_2;
    pub const physical_device_rasterization_order_attachment_access_features_arm = StructureType.physical_device_rasterization_order_attachment_access_features_ext;
    pub const physical_device_mutable_descriptor_type_features_valve = StructureType.physical_device_mutable_descriptor_type_features_ext;
    pub const mutable_descriptor_type_create_info_valve = StructureType.mutable_descriptor_type_create_info_ext;
    pub const format_properties_3_khr = StructureType.format_properties_3;
    pub const physical_device_present_mode_fifo_latest_ready_features_ext = StructureType.physical_device_present_mode_fifo_latest_ready_features_khr;
    pub const pipeline_info_ext = StructureType.pipeline_info_khr;
    pub const physical_device_external_sci_buf_features_nv = StructureType.physical_device_external_memory_sci_buf_features_nv;
    pub const physical_device_global_priority_query_features_ext = StructureType.physical_device_global_priority_query_features;
    pub const queue_family_global_priority_properties_ext = StructureType.queue_family_global_priority_properties;
    pub const physical_device_maintenance_4_features_khr = StructureType.physical_device_maintenance_4_features;
    pub const physical_device_maintenance_4_properties_khr = StructureType.physical_device_maintenance_4_properties;
    pub const device_buffer_memory_requirements_khr = StructureType.device_buffer_memory_requirements;
    pub const device_image_memory_requirements_khr = StructureType.device_image_memory_requirements;
    pub const physical_device_shader_subgroup_rotate_features_khr = StructureType.physical_device_shader_subgroup_rotate_features;
    pub const physical_device_depth_clamp_zero_one_features_ext = StructureType.physical_device_depth_clamp_zero_one_features_khr;
    pub const physical_device_fragment_density_map_offset_features_qcom = StructureType.physical_device_fragment_density_map_offset_features_ext;
    pub const physical_device_fragment_density_map_offset_properties_qcom = StructureType.physical_device_fragment_density_map_offset_properties_ext;
    pub const subpass_fragment_density_map_offset_end_info_qcom = StructureType.render_pass_fragment_density_map_offset_end_info_ext;
    pub const physical_device_pipeline_protected_access_features_ext = StructureType.physical_device_pipeline_protected_access_features;
    pub const physical_device_maintenance_5_features_khr = StructureType.physical_device_maintenance_5_features;
    pub const physical_device_maintenance_5_properties_khr = StructureType.physical_device_maintenance_5_properties;
    pub const rendering_area_info_khr = StructureType.rendering_area_info;
    pub const device_image_subresource_info_khr = StructureType.device_image_subresource_info;
    pub const subresource_layout_2_khr = StructureType.subresource_layout_2;
    pub const image_subresource_2_khr = StructureType.image_subresource_2;
    pub const pipeline_create_flags_2_create_info_khr = StructureType.pipeline_create_flags_2_create_info;
    pub const buffer_usage_flags_2_create_info_khr = StructureType.buffer_usage_flags_2_create_info;
    pub const shader_required_subgroup_size_create_info_ext = StructureType.pipeline_shader_stage_required_subgroup_size_create_info;
    pub const physical_device_vertex_attribute_divisor_properties_khr = StructureType.physical_device_vertex_attribute_divisor_properties;
    pub const pipeline_vertex_input_divisor_state_create_info_khr = StructureType.pipeline_vertex_input_divisor_state_create_info;
    pub const physical_device_vertex_attribute_divisor_features_khr = StructureType.physical_device_vertex_attribute_divisor_features;
    pub const physical_device_shader_float_controls_2_features_khr = StructureType.physical_device_shader_float_controls_2_features;
    pub const physical_device_index_type_uint8_features_khr = StructureType.physical_device_index_type_uint8_features;
    pub const physical_device_line_rasterization_features_khr = StructureType.physical_device_line_rasterization_features;
    pub const pipeline_rasterization_line_state_create_info_khr = StructureType.pipeline_rasterization_line_state_create_info;
    pub const physical_device_line_rasterization_properties_khr = StructureType.physical_device_line_rasterization_properties;
    pub const physical_device_shader_expect_assume_features_khr = StructureType.physical_device_shader_expect_assume_features;
    pub const physical_device_maintenance_6_features_khr = StructureType.physical_device_maintenance_6_features;
    pub const physical_device_maintenance_6_properties_khr = StructureType.physical_device_maintenance_6_properties;
    pub const bind_memory_status_khr = StructureType.bind_memory_status;
    pub const bind_descriptor_sets_info_khr = StructureType.bind_descriptor_sets_info;
    pub const push_constants_info_khr = StructureType.push_constants_info;
    pub const push_descriptor_set_info_khr = StructureType.push_descriptor_set_info;
    pub const push_descriptor_set_with_template_info_khr = StructureType.push_descriptor_set_with_template_info;
};
pub const SubpassContents = enum(i32) {
    @"inline" = 0,
    secondary_command_buffers = 1,
    inline_and_secondary_command_buffers_khr = 1000451000,
    _,
    pub const inline_and_secondary_command_buffers_ext = SubpassContents.inline_and_secondary_command_buffers_khr;
};
pub const Result = enum(i32) {
    success = 0,
    not_ready = 1,
    timeout = 2,
    event_set = 3,
    event_reset = 4,
    incomplete = 5,
    error_out_of_host_memory = -1,
    error_out_of_device_memory = -2,
    error_initialization_failed = -3,
    error_device_lost = -4,
    error_memory_map_failed = -5,
    error_layer_not_present = -6,
    error_extension_not_present = -7,
    error_feature_not_present = -8,
    error_incompatible_driver = -9,
    error_too_many_objects = -10,
    error_format_not_supported = -11,
    error_fragmented_pool = -12,
    error_unknown = -13,
    error_out_of_pool_memory = -1000069000,
    error_invalid_external_handle = -1000072003,
    error_fragmentation = -1000161000,
    error_invalid_opaque_capture_address = -1000257000,
    pipeline_compile_required = 1000297000,
    error_not_permitted = -1000174001,
    error_surface_lost_khr = -1000000000,
    error_native_window_in_use_khr = -1000000001,
    suboptimal_khr = 1000001003,
    error_out_of_date_khr = -1000001004,
    error_incompatible_display_khr = -1000003001,
    error_validation_failed_ext = -1000011001,
    error_invalid_shader_nv = -1000012000,
    error_image_usage_not_supported_khr = -1000023000,
    error_video_picture_layout_not_supported_khr = -1000023001,
    error_video_profile_operation_not_supported_khr = -1000023002,
    error_video_profile_format_not_supported_khr = -1000023003,
    error_video_profile_codec_not_supported_khr = -1000023004,
    error_video_std_version_not_supported_khr = -1000023005,
    error_invalid_drm_format_modifier_plane_layout_ext = -1000158000,
    error_full_screen_exclusive_mode_lost_ext = -1000255000,
    thread_idle_khr = 1000268000,
    thread_done_khr = 1000268001,
    operation_deferred_khr = 1000268002,
    operation_not_deferred_khr = 1000268003,
    error_invalid_video_std_parameters_khr = -1000299000,
    error_compression_exhausted_ext = -1000338000,
    incompatible_shader_binary_ext = 1000482000,
    pipeline_binary_missing_khr = 1000483000,
    error_not_enough_space_khr = -1000483000,
    _,
    pub const error_out_of_pool_memory_khr = Result.error_out_of_pool_memory;
    pub const error_invalid_external_handle_khr = Result.error_invalid_external_handle;
    pub const error_fragmentation_ext = Result.error_fragmentation;
    pub const error_not_permitted_ext = Result.error_not_permitted;
    pub const error_not_permitted_khr = Result.error_not_permitted;
    pub const error_invalid_device_address_ext = Result.error_invalid_opaque_capture_address;
    pub const error_invalid_opaque_capture_address_khr = Result.error_invalid_opaque_capture_address;
    pub const pipeline_compile_required_ext = Result.pipeline_compile_required;
    pub const error_pipeline_compile_required_ext = Result.pipeline_compile_required;
    pub const error_incompatible_shader_binary_ext = Result.incompatible_shader_binary_ext;
};
pub const DynamicState = enum(i32) {
    viewport = 0,
    scissor = 1,
    line_width = 2,
    depth_bias = 3,
    blend_constants = 4,
    depth_bounds = 5,
    stencil_compare_mask = 6,
    stencil_write_mask = 7,
    stencil_reference = 8,
    cull_mode = 1000267000,
    front_face = 1000267001,
    primitive_topology = 1000267002,
    viewport_with_count = 1000267003,
    scissor_with_count = 1000267004,
    vertex_input_binding_stride = 1000267005,
    depth_test_enable = 1000267006,
    depth_write_enable = 1000267007,
    depth_compare_op = 1000267008,
    depth_bounds_test_enable = 1000267009,
    stencil_test_enable = 1000267010,
    stencil_op = 1000267011,
    rasterizer_discard_enable = 1000377001,
    depth_bias_enable = 1000377002,
    primitive_restart_enable = 1000377004,
    line_stipple = 1000259000,
    viewport_w_scaling_nv = 1000087000,
    discard_rectangle_ext = 1000099000,
    discard_rectangle_enable_ext = 1000099001,
    discard_rectangle_mode_ext = 1000099002,
    sample_locations_ext = 1000143000,
    ray_tracing_pipeline_stack_size_khr = 1000347000,
    viewport_shading_rate_palette_nv = 1000164004,
    viewport_coarse_sample_order_nv = 1000164006,
    exclusive_scissor_enable_nv = 1000205000,
    exclusive_scissor_nv = 1000205001,
    fragment_shading_rate_khr = 1000226000,
    vertex_input_ext = 1000352000,
    patch_control_points_ext = 1000377000,
    logic_op_ext = 1000377003,
    color_write_enable_ext = 1000381000,
    depth_clamp_enable_ext = 1000455003,
    polygon_mode_ext = 1000455004,
    rasterization_samples_ext = 1000455005,
    sample_mask_ext = 1000455006,
    alpha_to_coverage_enable_ext = 1000455007,
    alpha_to_one_enable_ext = 1000455008,
    logic_op_enable_ext = 1000455009,
    color_blend_enable_ext = 1000455010,
    color_blend_equation_ext = 1000455011,
    color_write_mask_ext = 1000455012,
    tessellation_domain_origin_ext = 1000455002,
    rasterization_stream_ext = 1000455013,
    conservative_rasterization_mode_ext = 1000455014,
    extra_primitive_overestimation_size_ext = 1000455015,
    depth_clip_enable_ext = 1000455016,
    sample_locations_enable_ext = 1000455017,
    color_blend_advanced_ext = 1000455018,
    provoking_vertex_mode_ext = 1000455019,
    line_rasterization_mode_ext = 1000455020,
    line_stipple_enable_ext = 1000455021,
    depth_clip_negative_one_to_one_ext = 1000455022,
    viewport_w_scaling_enable_nv = 1000455023,
    viewport_swizzle_nv = 1000455024,
    coverage_to_color_enable_nv = 1000455025,
    coverage_to_color_location_nv = 1000455026,
    coverage_modulation_mode_nv = 1000455027,
    coverage_modulation_table_enable_nv = 1000455028,
    coverage_modulation_table_nv = 1000455029,
    shading_rate_image_enable_nv = 1000455030,
    representative_fragment_test_enable_nv = 1000455031,
    coverage_reduction_mode_nv = 1000455032,
    attachment_feedback_loop_enable_ext = 1000524000,
    depth_clamp_range_ext = 1000582000,
    _,
    pub const line_stipple_ext = DynamicState.line_stipple;
    pub const cull_mode_ext = DynamicState.cull_mode;
    pub const front_face_ext = DynamicState.front_face;
    pub const primitive_topology_ext = DynamicState.primitive_topology;
    pub const viewport_with_count_ext = DynamicState.viewport_with_count;
    pub const scissor_with_count_ext = DynamicState.scissor_with_count;
    pub const vertex_input_binding_stride_ext = DynamicState.vertex_input_binding_stride;
    pub const depth_test_enable_ext = DynamicState.depth_test_enable;
    pub const depth_write_enable_ext = DynamicState.depth_write_enable;
    pub const depth_compare_op_ext = DynamicState.depth_compare_op;
    pub const depth_bounds_test_enable_ext = DynamicState.depth_bounds_test_enable;
    pub const stencil_test_enable_ext = DynamicState.stencil_test_enable;
    pub const stencil_op_ext = DynamicState.stencil_op;
    pub const rasterizer_discard_enable_ext = DynamicState.rasterizer_discard_enable;
    pub const depth_bias_enable_ext = DynamicState.depth_bias_enable;
    pub const primitive_restart_enable_ext = DynamicState.primitive_restart_enable;
    pub const line_stipple_khr = DynamicState.line_stipple;
};
pub const DescriptorUpdateTemplateType = enum(i32) {
    descriptor_set = 0,
    push_descriptors = 1,
    _,
    pub const push_descriptors_khr = DescriptorUpdateTemplateType.push_descriptors;
    pub const descriptor_set_khr = DescriptorUpdateTemplateType.descriptor_set;
};
pub const ObjectType = enum(i32) {
    unknown = 0,
    instance = 1,
    physical_device = 2,
    device = 3,
    queue = 4,
    semaphore = 5,
    command_buffer = 6,
    fence = 7,
    device_memory = 8,
    buffer = 9,
    image = 10,
    event = 11,
    query_pool = 12,
    buffer_view = 13,
    image_view = 14,
    shader_module = 15,
    pipeline_cache = 16,
    pipeline_layout = 17,
    render_pass = 18,
    pipeline = 19,
    descriptor_set_layout = 20,
    sampler = 21,
    descriptor_pool = 22,
    descriptor_set = 23,
    framebuffer = 24,
    command_pool = 25,
    sampler_ycbcr_conversion = 1000156000,
    descriptor_update_template = 1000085000,
    private_data_slot = 1000295000,
    surface_khr = 1000000000,
    swapchain_khr = 1000001000,
    display_khr = 1000002000,
    display_mode_khr = 1000002001,
    debug_report_callback_ext = 1000011000,
    video_session_khr = 1000023000,
    video_session_parameters_khr = 1000023001,
    cu_module_nvx = 1000029000,
    cu_function_nvx = 1000029001,
    debug_utils_messenger_ext = 1000128000,
    acceleration_structure_khr = 1000150000,
    validation_cache_ext = 1000160000,
    acceleration_structure_nv = 1000165000,
    performance_configuration_intel = 1000210000,
    deferred_operation_khr = 1000268000,
    indirect_commands_layout_nv = 1000277000,
    cuda_module_nv = 1000307000,
    cuda_function_nv = 1000307001,
    buffer_collection_fuchsia = 1000366000,
    micromap_ext = 1000396000,
    tensor_arm = 1000460000,
    tensor_view_arm = 1000460001,
    optical_flow_session_nv = 1000464000,
    shader_ext = 1000482000,
    pipeline_binary_khr = 1000483000,
    semaphore_sci_sync_pool_nv = 1000489000,
    data_graph_pipeline_session_arm = 1000507000,
    external_compute_queue_nv = 1000556000,
    indirect_commands_layout_ext = 1000572000,
    indirect_execution_set_ext = 1000572001,
    _,
    pub const descriptor_update_template_khr = ObjectType.descriptor_update_template;
    pub const sampler_ycbcr_conversion_khr = ObjectType.sampler_ycbcr_conversion;
    pub const private_data_slot_ext = ObjectType.private_data_slot;
};
pub const RayTracingInvocationReorderModeNV = enum(i32) {
    none_nv = 0,
    reorder_nv = 1,
    _,
};
pub const RayTracingLssIndexingModeNV = enum(i32) {
    list_nv = 0,
    successive_nv = 1,
    _,
};
pub const RayTracingLssPrimitiveEndCapsModeNV = enum(i32) {
    none_nv = 0,
    chained_nv = 1,
    _,
};
pub const DirectDriverLoadingModeLUNARG = enum(i32) {
    exclusive_lunarg = 0,
    inclusive_lunarg = 1,
    _,
};
pub const AntiLagModeAMD = enum(i32) {
    driver_control_amd = 0,
    on_amd = 1,
    off_amd = 2,
    _,
};
pub const AntiLagStageAMD = enum(i32) {
    input_amd = 0,
    present_amd = 1,
    _,
};
pub const QueueFlags = packed struct(Flags) {
    graphics_bit: bool = false,
    compute_bit: bool = false,
    transfer_bit: bool = false,
    sparse_binding_bit: bool = false,
    protected_bit: bool = false,
    video_decode_bit_khr: bool = false,
    video_encode_bit_khr: bool = false,
    _reserved_bit_7: bool = false,
    optical_flow_bit_nv: bool = false,
    _reserved_bit_9: bool = false,
    data_graph_bit_arm: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(QueueFlags).toInt;
    pub const fromInt = FlagsMixin(QueueFlags).fromInt;
    pub const merge = FlagsMixin(QueueFlags).merge;
    pub const intersect = FlagsMixin(QueueFlags).intersect;
    pub const complement = FlagsMixin(QueueFlags).complement;
    pub const subtract = FlagsMixin(QueueFlags).subtract;
    pub const contains = FlagsMixin(QueueFlags).contains;
    pub const format = FlagFormatMixin(QueueFlags).format;
};
pub const CullModeFlags = packed struct(Flags) {
    front_bit: bool = false,
    back_bit: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(CullModeFlags).toInt;
    pub const fromInt = FlagsMixin(CullModeFlags).fromInt;
    pub const merge = FlagsMixin(CullModeFlags).merge;
    pub const intersect = FlagsMixin(CullModeFlags).intersect;
    pub const complement = FlagsMixin(CullModeFlags).complement;
    pub const subtract = FlagsMixin(CullModeFlags).subtract;
    pub const contains = FlagsMixin(CullModeFlags).contains;
    pub const format = FlagFormatMixin(CullModeFlags).format;
};
pub const RenderPassCreateFlags = packed struct(Flags) {
    _reserved_bit_0: bool = false,
    transform_bit_qcom: bool = false,
    per_layer_fragment_density_bit_valve: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(RenderPassCreateFlags).toInt;
    pub const fromInt = FlagsMixin(RenderPassCreateFlags).fromInt;
    pub const merge = FlagsMixin(RenderPassCreateFlags).merge;
    pub const intersect = FlagsMixin(RenderPassCreateFlags).intersect;
    pub const complement = FlagsMixin(RenderPassCreateFlags).complement;
    pub const subtract = FlagsMixin(RenderPassCreateFlags).subtract;
    pub const contains = FlagsMixin(RenderPassCreateFlags).contains;
    pub const format = FlagFormatMixin(RenderPassCreateFlags).format;
};
pub const DeviceQueueCreateFlags = packed struct(Flags) {
    protected_bit: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(DeviceQueueCreateFlags).toInt;
    pub const fromInt = FlagsMixin(DeviceQueueCreateFlags).fromInt;
    pub const merge = FlagsMixin(DeviceQueueCreateFlags).merge;
    pub const intersect = FlagsMixin(DeviceQueueCreateFlags).intersect;
    pub const complement = FlagsMixin(DeviceQueueCreateFlags).complement;
    pub const subtract = FlagsMixin(DeviceQueueCreateFlags).subtract;
    pub const contains = FlagsMixin(DeviceQueueCreateFlags).contains;
    pub const format = FlagFormatMixin(DeviceQueueCreateFlags).format;
};
pub const MemoryPropertyFlags = packed struct(Flags) {
    device_local_bit: bool = false,
    host_visible_bit: bool = false,
    host_coherent_bit: bool = false,
    host_cached_bit: bool = false,
    lazily_allocated_bit: bool = false,
    protected_bit: bool = false,
    device_coherent_bit_amd: bool = false,
    device_uncached_bit_amd: bool = false,
    rdma_capable_bit_nv: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(MemoryPropertyFlags).toInt;
    pub const fromInt = FlagsMixin(MemoryPropertyFlags).fromInt;
    pub const merge = FlagsMixin(MemoryPropertyFlags).merge;
    pub const intersect = FlagsMixin(MemoryPropertyFlags).intersect;
    pub const complement = FlagsMixin(MemoryPropertyFlags).complement;
    pub const subtract = FlagsMixin(MemoryPropertyFlags).subtract;
    pub const contains = FlagsMixin(MemoryPropertyFlags).contains;
    pub const format = FlagFormatMixin(MemoryPropertyFlags).format;
};
pub const MemoryHeapFlags = packed struct(Flags) {
    device_local_bit: bool = false,
    multi_instance_bit: bool = false,
    _reserved_bit_2: bool = false,
    tile_memory_bit_qcom: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(MemoryHeapFlags).toInt;
    pub const fromInt = FlagsMixin(MemoryHeapFlags).fromInt;
    pub const merge = FlagsMixin(MemoryHeapFlags).merge;
    pub const intersect = FlagsMixin(MemoryHeapFlags).intersect;
    pub const complement = FlagsMixin(MemoryHeapFlags).complement;
    pub const subtract = FlagsMixin(MemoryHeapFlags).subtract;
    pub const contains = FlagsMixin(MemoryHeapFlags).contains;
    pub const format = FlagFormatMixin(MemoryHeapFlags).format;
};
pub const AccessFlags = packed struct(Flags) {
    indirect_command_read_bit: bool = false,
    index_read_bit: bool = false,
    vertex_attribute_read_bit: bool = false,
    uniform_read_bit: bool = false,
    input_attachment_read_bit: bool = false,
    shader_read_bit: bool = false,
    shader_write_bit: bool = false,
    color_attachment_read_bit: bool = false,
    color_attachment_write_bit: bool = false,
    depth_stencil_attachment_read_bit: bool = false,
    depth_stencil_attachment_write_bit: bool = false,
    transfer_read_bit: bool = false,
    transfer_write_bit: bool = false,
    host_read_bit: bool = false,
    host_write_bit: bool = false,
    memory_read_bit: bool = false,
    memory_write_bit: bool = false,
    command_preprocess_read_bit_ext: bool = false,
    command_preprocess_write_bit_ext: bool = false,
    color_attachment_read_noncoherent_bit_ext: bool = false,
    conditional_rendering_read_bit_ext: bool = false,
    acceleration_structure_read_bit_khr: bool = false,
    acceleration_structure_write_bit_khr: bool = false,
    fragment_shading_rate_attachment_read_bit_khr: bool = false,
    fragment_density_map_read_bit_ext: bool = false,
    transform_feedback_write_bit_ext: bool = false,
    transform_feedback_counter_read_bit_ext: bool = false,
    transform_feedback_counter_write_bit_ext: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(AccessFlags).toInt;
    pub const fromInt = FlagsMixin(AccessFlags).fromInt;
    pub const merge = FlagsMixin(AccessFlags).merge;
    pub const intersect = FlagsMixin(AccessFlags).intersect;
    pub const complement = FlagsMixin(AccessFlags).complement;
    pub const subtract = FlagsMixin(AccessFlags).subtract;
    pub const contains = FlagsMixin(AccessFlags).contains;
    pub const format = FlagFormatMixin(AccessFlags).format;
};
pub const BufferUsageFlags = packed struct(Flags) {
    transfer_src_bit: bool = false,
    transfer_dst_bit: bool = false,
    uniform_texel_buffer_bit: bool = false,
    storage_texel_buffer_bit: bool = false,
    uniform_buffer_bit: bool = false,
    storage_buffer_bit: bool = false,
    index_buffer_bit: bool = false,
    vertex_buffer_bit: bool = false,
    indirect_buffer_bit: bool = false,
    conditional_rendering_bit_ext: bool = false,
    shader_binding_table_bit_khr: bool = false,
    transform_feedback_buffer_bit_ext: bool = false,
    transform_feedback_counter_buffer_bit_ext: bool = false,
    video_decode_src_bit_khr: bool = false,
    video_decode_dst_bit_khr: bool = false,
    video_encode_dst_bit_khr: bool = false,
    video_encode_src_bit_khr: bool = false,
    shader_device_address_bit: bool = false,
    _reserved_bit_18: bool = false,
    acceleration_structure_build_input_read_only_bit_khr: bool = false,
    acceleration_structure_storage_bit_khr: bool = false,
    sampler_descriptor_buffer_bit_ext: bool = false,
    resource_descriptor_buffer_bit_ext: bool = false,
    micromap_build_input_read_only_bit_ext: bool = false,
    micromap_storage_bit_ext: bool = false,
    execution_graph_scratch_bit_amdx: bool = false,
    push_descriptors_descriptor_buffer_bit_ext: bool = false,
    tile_memory_bit_qcom: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(BufferUsageFlags).toInt;
    pub const fromInt = FlagsMixin(BufferUsageFlags).fromInt;
    pub const merge = FlagsMixin(BufferUsageFlags).merge;
    pub const intersect = FlagsMixin(BufferUsageFlags).intersect;
    pub const complement = FlagsMixin(BufferUsageFlags).complement;
    pub const subtract = FlagsMixin(BufferUsageFlags).subtract;
    pub const contains = FlagsMixin(BufferUsageFlags).contains;
    pub const format = FlagFormatMixin(BufferUsageFlags).format;
};
pub const BufferUsageFlags2 = packed struct(Flags64) {
    transfer_src_bit: bool = false,
    transfer_dst_bit: bool = false,
    uniform_texel_buffer_bit: bool = false,
    storage_texel_buffer_bit: bool = false,
    uniform_buffer_bit: bool = false,
    storage_buffer_bit: bool = false,
    index_buffer_bit: bool = false,
    vertex_buffer_bit: bool = false,
    indirect_buffer_bit: bool = false,
    conditional_rendering_bit_ext: bool = false,
    shader_binding_table_bit_khr: bool = false,
    transform_feedback_buffer_bit_ext: bool = false,
    transform_feedback_counter_buffer_bit_ext: bool = false,
    video_decode_src_bit_khr: bool = false,
    video_decode_dst_bit_khr: bool = false,
    video_encode_dst_bit_khr: bool = false,
    video_encode_src_bit_khr: bool = false,
    shader_device_address_bit: bool = false,
    _reserved_bit_18: bool = false,
    acceleration_structure_build_input_read_only_bit_khr: bool = false,
    acceleration_structure_storage_bit_khr: bool = false,
    sampler_descriptor_buffer_bit_ext: bool = false,
    resource_descriptor_buffer_bit_ext: bool = false,
    micromap_build_input_read_only_bit_ext: bool = false,
    micromap_storage_bit_ext: bool = false,
    execution_graph_scratch_bit_amdx: bool = false,
    push_descriptors_descriptor_buffer_bit_ext: bool = false,
    tile_memory_bit_qcom: bool = false,
    _reserved_bit_28: bool = false,
    data_graph_foreign_descriptor_bit_arm: bool = false,
    _reserved_bit_30: bool = false,
    preprocess_buffer_bit_ext: bool = false,
    _reserved_bit_32: bool = false,
    _reserved_bit_33: bool = false,
    _reserved_bit_34: bool = false,
    _reserved_bit_35: bool = false,
    _reserved_bit_36: bool = false,
    _reserved_bit_37: bool = false,
    _reserved_bit_38: bool = false,
    _reserved_bit_39: bool = false,
    _reserved_bit_40: bool = false,
    _reserved_bit_41: bool = false,
    _reserved_bit_42: bool = false,
    _reserved_bit_43: bool = false,
    _reserved_bit_44: bool = false,
    _reserved_bit_45: bool = false,
    _reserved_bit_46: bool = false,
    _reserved_bit_47: bool = false,
    _reserved_bit_48: bool = false,
    _reserved_bit_49: bool = false,
    _reserved_bit_50: bool = false,
    _reserved_bit_51: bool = false,
    _reserved_bit_52: bool = false,
    _reserved_bit_53: bool = false,
    _reserved_bit_54: bool = false,
    _reserved_bit_55: bool = false,
    _reserved_bit_56: bool = false,
    _reserved_bit_57: bool = false,
    _reserved_bit_58: bool = false,
    _reserved_bit_59: bool = false,
    _reserved_bit_60: bool = false,
    _reserved_bit_61: bool = false,
    _reserved_bit_62: bool = false,
    _reserved_bit_63: bool = false,
    pub const toInt = FlagsMixin(BufferUsageFlags2).toInt;
    pub const fromInt = FlagsMixin(BufferUsageFlags2).fromInt;
    pub const merge = FlagsMixin(BufferUsageFlags2).merge;
    pub const intersect = FlagsMixin(BufferUsageFlags2).intersect;
    pub const complement = FlagsMixin(BufferUsageFlags2).complement;
    pub const subtract = FlagsMixin(BufferUsageFlags2).subtract;
    pub const contains = FlagsMixin(BufferUsageFlags2).contains;
    pub const format = FlagFormatMixin(BufferUsageFlags2).format;
};
pub const BufferCreateFlags = packed struct(Flags) {
    sparse_binding_bit: bool = false,
    sparse_residency_bit: bool = false,
    sparse_aliased_bit: bool = false,
    protected_bit: bool = false,
    device_address_capture_replay_bit: bool = false,
    descriptor_buffer_capture_replay_bit_ext: bool = false,
    video_profile_independent_bit_khr: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(BufferCreateFlags).toInt;
    pub const fromInt = FlagsMixin(BufferCreateFlags).fromInt;
    pub const merge = FlagsMixin(BufferCreateFlags).merge;
    pub const intersect = FlagsMixin(BufferCreateFlags).intersect;
    pub const complement = FlagsMixin(BufferCreateFlags).complement;
    pub const subtract = FlagsMixin(BufferCreateFlags).subtract;
    pub const contains = FlagsMixin(BufferCreateFlags).contains;
    pub const format = FlagFormatMixin(BufferCreateFlags).format;
};
pub const ShaderStageFlags = packed struct(Flags) {
    vertex_bit: bool = false,
    tessellation_control_bit: bool = false,
    tessellation_evaluation_bit: bool = false,
    geometry_bit: bool = false,
    fragment_bit: bool = false,
    compute_bit: bool = false,
    task_bit_ext: bool = false,
    mesh_bit_ext: bool = false,
    raygen_bit_khr: bool = false,
    any_hit_bit_khr: bool = false,
    closest_hit_bit_khr: bool = false,
    miss_bit_khr: bool = false,
    intersection_bit_khr: bool = false,
    callable_bit_khr: bool = false,
    subpass_shading_bit_huawei: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    cluster_culling_bit_huawei: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ShaderStageFlags).toInt;
    pub const fromInt = FlagsMixin(ShaderStageFlags).fromInt;
    pub const merge = FlagsMixin(ShaderStageFlags).merge;
    pub const intersect = FlagsMixin(ShaderStageFlags).intersect;
    pub const complement = FlagsMixin(ShaderStageFlags).complement;
    pub const subtract = FlagsMixin(ShaderStageFlags).subtract;
    pub const contains = FlagsMixin(ShaderStageFlags).contains;
    pub const format = FlagFormatMixin(ShaderStageFlags).format;
};
pub const ImageUsageFlags = packed struct(Flags) {
    transfer_src_bit: bool = false,
    transfer_dst_bit: bool = false,
    sampled_bit: bool = false,
    storage_bit: bool = false,
    color_attachment_bit: bool = false,
    depth_stencil_attachment_bit: bool = false,
    transient_attachment_bit: bool = false,
    input_attachment_bit: bool = false,
    fragment_shading_rate_attachment_bit_khr: bool = false,
    fragment_density_map_bit_ext: bool = false,
    video_decode_dst_bit_khr: bool = false,
    video_decode_src_bit_khr: bool = false,
    video_decode_dpb_bit_khr: bool = false,
    video_encode_dst_bit_khr: bool = false,
    video_encode_src_bit_khr: bool = false,
    video_encode_dpb_bit_khr: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    invocation_mask_bit_huawei: bool = false,
    attachment_feedback_loop_bit_ext: bool = false,
    sample_weight_bit_qcom: bool = false,
    sample_block_match_bit_qcom: bool = false,
    host_transfer_bit: bool = false,
    tensor_aliasing_bit_arm: bool = false,
    _reserved_bit_24: bool = false,
    video_encode_quantization_delta_map_bit_khr: bool = false,
    video_encode_emphasis_map_bit_khr: bool = false,
    tile_memory_bit_qcom: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ImageUsageFlags).toInt;
    pub const fromInt = FlagsMixin(ImageUsageFlags).fromInt;
    pub const merge = FlagsMixin(ImageUsageFlags).merge;
    pub const intersect = FlagsMixin(ImageUsageFlags).intersect;
    pub const complement = FlagsMixin(ImageUsageFlags).complement;
    pub const subtract = FlagsMixin(ImageUsageFlags).subtract;
    pub const contains = FlagsMixin(ImageUsageFlags).contains;
    pub const format = FlagFormatMixin(ImageUsageFlags).format;
};
pub const ImageCreateFlags = packed struct(Flags) {
    sparse_binding_bit: bool = false,
    sparse_residency_bit: bool = false,
    sparse_aliased_bit: bool = false,
    mutable_format_bit: bool = false,
    cube_compatible_bit: bool = false,
    @"2d_array_compatible_bit": bool = false,
    split_instance_bind_regions_bit: bool = false,
    block_texel_view_compatible_bit: bool = false,
    extended_usage_bit: bool = false,
    disjoint_bit: bool = false,
    alias_bit: bool = false,
    protected_bit: bool = false,
    sample_locations_compatible_depth_bit_ext: bool = false,
    corner_sampled_bit_nv: bool = false,
    subsampled_bit_ext: bool = false,
    fragment_density_map_offset_bit_ext: bool = false,
    descriptor_buffer_capture_replay_bit_ext: bool = false,
    @"2d_view_compatible_bit_ext": bool = false,
    multisampled_render_to_single_sampled_bit_ext: bool = false,
    _reserved_bit_19: bool = false,
    video_profile_independent_bit_khr: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ImageCreateFlags).toInt;
    pub const fromInt = FlagsMixin(ImageCreateFlags).fromInt;
    pub const merge = FlagsMixin(ImageCreateFlags).merge;
    pub const intersect = FlagsMixin(ImageCreateFlags).intersect;
    pub const complement = FlagsMixin(ImageCreateFlags).complement;
    pub const subtract = FlagsMixin(ImageCreateFlags).subtract;
    pub const contains = FlagsMixin(ImageCreateFlags).contains;
    pub const format = FlagFormatMixin(ImageCreateFlags).format;
};
pub const ImageViewCreateFlags = packed struct(Flags) {
    fragment_density_map_dynamic_bit_ext: bool = false,
    fragment_density_map_deferred_bit_ext: bool = false,
    descriptor_buffer_capture_replay_bit_ext: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ImageViewCreateFlags).toInt;
    pub const fromInt = FlagsMixin(ImageViewCreateFlags).fromInt;
    pub const merge = FlagsMixin(ImageViewCreateFlags).merge;
    pub const intersect = FlagsMixin(ImageViewCreateFlags).intersect;
    pub const complement = FlagsMixin(ImageViewCreateFlags).complement;
    pub const subtract = FlagsMixin(ImageViewCreateFlags).subtract;
    pub const contains = FlagsMixin(ImageViewCreateFlags).contains;
    pub const format = FlagFormatMixin(ImageViewCreateFlags).format;
};
pub const SamplerCreateFlags = packed struct(Flags) {
    subsampled_bit_ext: bool = false,
    subsampled_coarse_reconstruction_bit_ext: bool = false,
    non_seamless_cube_map_bit_ext: bool = false,
    descriptor_buffer_capture_replay_bit_ext: bool = false,
    image_processing_bit_qcom: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(SamplerCreateFlags).toInt;
    pub const fromInt = FlagsMixin(SamplerCreateFlags).fromInt;
    pub const merge = FlagsMixin(SamplerCreateFlags).merge;
    pub const intersect = FlagsMixin(SamplerCreateFlags).intersect;
    pub const complement = FlagsMixin(SamplerCreateFlags).complement;
    pub const subtract = FlagsMixin(SamplerCreateFlags).subtract;
    pub const contains = FlagsMixin(SamplerCreateFlags).contains;
    pub const format = FlagFormatMixin(SamplerCreateFlags).format;
};
pub const PipelineCreateFlags = packed struct(Flags) {
    disable_optimization_bit: bool = false,
    allow_derivatives_bit: bool = false,
    derivative_bit: bool = false,
    view_index_from_device_index_bit: bool = false,
    dispatch_base_bit: bool = false,
    defer_compile_bit_nv: bool = false,
    capture_statistics_bit_khr: bool = false,
    capture_internal_representations_bit_khr: bool = false,
    fail_on_pipeline_compile_required_bit: bool = false,
    early_return_on_failure_bit: bool = false,
    link_time_optimization_bit_ext: bool = false,
    library_bit_khr: bool = false,
    ray_tracing_skip_triangles_bit_khr: bool = false,
    ray_tracing_skip_aabbs_bit_khr: bool = false,
    ray_tracing_no_null_any_hit_shaders_bit_khr: bool = false,
    ray_tracing_no_null_closest_hit_shaders_bit_khr: bool = false,
    ray_tracing_no_null_miss_shaders_bit_khr: bool = false,
    ray_tracing_no_null_intersection_shaders_bit_khr: bool = false,
    indirect_bindable_bit_nv: bool = false,
    ray_tracing_shader_group_handle_capture_replay_bit_khr: bool = false,
    ray_tracing_allow_motion_bit_nv: bool = false,
    rendering_fragment_shading_rate_attachment_bit_khr: bool = false,
    rendering_fragment_density_map_attachment_bit_ext: bool = false,
    retain_link_time_optimization_info_bit_ext: bool = false,
    ray_tracing_opacity_micromap_bit_ext: bool = false,
    color_attachment_feedback_loop_bit_ext: bool = false,
    depth_stencil_attachment_feedback_loop_bit_ext: bool = false,
    no_protected_access_bit: bool = false,
    ray_tracing_displacement_micromap_bit_nv: bool = false,
    descriptor_buffer_bit_ext: bool = false,
    protected_access_only_bit: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(PipelineCreateFlags).toInt;
    pub const fromInt = FlagsMixin(PipelineCreateFlags).fromInt;
    pub const merge = FlagsMixin(PipelineCreateFlags).merge;
    pub const intersect = FlagsMixin(PipelineCreateFlags).intersect;
    pub const complement = FlagsMixin(PipelineCreateFlags).complement;
    pub const subtract = FlagsMixin(PipelineCreateFlags).subtract;
    pub const contains = FlagsMixin(PipelineCreateFlags).contains;
    pub const format = FlagFormatMixin(PipelineCreateFlags).format;
};
pub const PipelineCreateFlags2 = packed struct(Flags64) {
    disable_optimization_bit: bool = false,
    allow_derivatives_bit: bool = false,
    derivative_bit: bool = false,
    view_index_from_device_index_bit: bool = false,
    dispatch_base_bit: bool = false,
    defer_compile_bit_nv: bool = false,
    capture_statistics_bit_khr: bool = false,
    capture_internal_representations_bit_khr: bool = false,
    fail_on_pipeline_compile_required_bit: bool = false,
    early_return_on_failure_bit: bool = false,
    link_time_optimization_bit_ext: bool = false,
    library_bit_khr: bool = false,
    ray_tracing_skip_triangles_bit_khr: bool = false,
    ray_tracing_skip_aabbs_bit_khr: bool = false,
    ray_tracing_no_null_any_hit_shaders_bit_khr: bool = false,
    ray_tracing_no_null_closest_hit_shaders_bit_khr: bool = false,
    ray_tracing_no_null_miss_shaders_bit_khr: bool = false,
    ray_tracing_no_null_intersection_shaders_bit_khr: bool = false,
    indirect_bindable_bit_nv: bool = false,
    ray_tracing_shader_group_handle_capture_replay_bit_khr: bool = false,
    ray_tracing_allow_motion_bit_nv: bool = false,
    rendering_fragment_shading_rate_attachment_bit_khr: bool = false,
    rendering_fragment_density_map_attachment_bit_ext: bool = false,
    retain_link_time_optimization_info_bit_ext: bool = false,
    ray_tracing_opacity_micromap_bit_ext: bool = false,
    color_attachment_feedback_loop_bit_ext: bool = false,
    depth_stencil_attachment_feedback_loop_bit_ext: bool = false,
    no_protected_access_bit: bool = false,
    ray_tracing_displacement_micromap_bit_nv: bool = false,
    descriptor_buffer_bit_ext: bool = false,
    protected_access_only_bit: bool = false,
    capture_data_bit_khr: bool = false,
    execution_graph_bit_amdx: bool = false,
    ray_tracing_allow_spheres_and_linear_swept_spheres_bit_nv: bool = false,
    enable_legacy_dithering_bit_ext: bool = false,
    _reserved_bit_35: bool = false,
    _reserved_bit_36: bool = false,
    disallow_opacity_micromap_bit_arm: bool = false,
    indirect_bindable_bit_ext: bool = false,
    _reserved_bit_39: bool = false,
    per_layer_fragment_density_bit_valve: bool = false,
    _reserved_bit_41: bool = false,
    _reserved_bit_42: bool = false,
    _reserved_bit_43: bool = false,
    _reserved_bit_44: bool = false,
    _reserved_bit_45: bool = false,
    _reserved_bit_46: bool = false,
    _reserved_bit_47: bool = false,
    _reserved_bit_48: bool = false,
    _reserved_bit_49: bool = false,
    _reserved_bit_50: bool = false,
    _reserved_bit_51: bool = false,
    _reserved_bit_52: bool = false,
    _reserved_bit_53: bool = false,
    _reserved_bit_54: bool = false,
    _reserved_bit_55: bool = false,
    _reserved_bit_56: bool = false,
    _reserved_bit_57: bool = false,
    _reserved_bit_58: bool = false,
    _reserved_bit_59: bool = false,
    _reserved_bit_60: bool = false,
    _reserved_bit_61: bool = false,
    _reserved_bit_62: bool = false,
    _reserved_bit_63: bool = false,
    pub const toInt = FlagsMixin(PipelineCreateFlags2).toInt;
    pub const fromInt = FlagsMixin(PipelineCreateFlags2).fromInt;
    pub const merge = FlagsMixin(PipelineCreateFlags2).merge;
    pub const intersect = FlagsMixin(PipelineCreateFlags2).intersect;
    pub const complement = FlagsMixin(PipelineCreateFlags2).complement;
    pub const subtract = FlagsMixin(PipelineCreateFlags2).subtract;
    pub const contains = FlagsMixin(PipelineCreateFlags2).contains;
    pub const format = FlagFormatMixin(PipelineCreateFlags2).format;
};
pub const PipelineShaderStageCreateFlags = packed struct(Flags) {
    allow_varying_subgroup_size_bit: bool = false,
    require_full_subgroups_bit: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(PipelineShaderStageCreateFlags).toInt;
    pub const fromInt = FlagsMixin(PipelineShaderStageCreateFlags).fromInt;
    pub const merge = FlagsMixin(PipelineShaderStageCreateFlags).merge;
    pub const intersect = FlagsMixin(PipelineShaderStageCreateFlags).intersect;
    pub const complement = FlagsMixin(PipelineShaderStageCreateFlags).complement;
    pub const subtract = FlagsMixin(PipelineShaderStageCreateFlags).subtract;
    pub const contains = FlagsMixin(PipelineShaderStageCreateFlags).contains;
    pub const format = FlagFormatMixin(PipelineShaderStageCreateFlags).format;
};
pub const ColorComponentFlags = packed struct(Flags) {
    r_bit: bool = false,
    g_bit: bool = false,
    b_bit: bool = false,
    a_bit: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ColorComponentFlags).toInt;
    pub const fromInt = FlagsMixin(ColorComponentFlags).fromInt;
    pub const merge = FlagsMixin(ColorComponentFlags).merge;
    pub const intersect = FlagsMixin(ColorComponentFlags).intersect;
    pub const complement = FlagsMixin(ColorComponentFlags).complement;
    pub const subtract = FlagsMixin(ColorComponentFlags).subtract;
    pub const contains = FlagsMixin(ColorComponentFlags).contains;
    pub const format = FlagFormatMixin(ColorComponentFlags).format;
};
pub const FenceCreateFlags = packed struct(Flags) {
    signaled_bit: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(FenceCreateFlags).toInt;
    pub const fromInt = FlagsMixin(FenceCreateFlags).fromInt;
    pub const merge = FlagsMixin(FenceCreateFlags).merge;
    pub const intersect = FlagsMixin(FenceCreateFlags).intersect;
    pub const complement = FlagsMixin(FenceCreateFlags).complement;
    pub const subtract = FlagsMixin(FenceCreateFlags).subtract;
    pub const contains = FlagsMixin(FenceCreateFlags).contains;
    pub const format = FlagFormatMixin(FenceCreateFlags).format;
};
pub const FormatFeatureFlags = packed struct(Flags) {
    sampled_image_bit: bool = false,
    storage_image_bit: bool = false,
    storage_image_atomic_bit: bool = false,
    uniform_texel_buffer_bit: bool = false,
    storage_texel_buffer_bit: bool = false,
    storage_texel_buffer_atomic_bit: bool = false,
    vertex_buffer_bit: bool = false,
    color_attachment_bit: bool = false,
    color_attachment_blend_bit: bool = false,
    depth_stencil_attachment_bit: bool = false,
    blit_src_bit: bool = false,
    blit_dst_bit: bool = false,
    sampled_image_filter_linear_bit: bool = false,
    sampled_image_filter_cubic_bit_ext: bool = false,
    transfer_src_bit: bool = false,
    transfer_dst_bit: bool = false,
    sampled_image_filter_minmax_bit: bool = false,
    midpoint_chroma_samples_bit: bool = false,
    sampled_image_ycbcr_conversion_linear_filter_bit: bool = false,
    sampled_image_ycbcr_conversion_separate_reconstruction_filter_bit: bool = false,
    sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_bit: bool = false,
    sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_forceable_bit: bool = false,
    disjoint_bit: bool = false,
    cosited_chroma_samples_bit: bool = false,
    fragment_density_map_bit_ext: bool = false,
    video_decode_output_bit_khr: bool = false,
    video_decode_dpb_bit_khr: bool = false,
    video_encode_input_bit_khr: bool = false,
    video_encode_dpb_bit_khr: bool = false,
    acceleration_structure_vertex_buffer_bit_khr: bool = false,
    fragment_shading_rate_attachment_bit_khr: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(FormatFeatureFlags).toInt;
    pub const fromInt = FlagsMixin(FormatFeatureFlags).fromInt;
    pub const merge = FlagsMixin(FormatFeatureFlags).merge;
    pub const intersect = FlagsMixin(FormatFeatureFlags).intersect;
    pub const complement = FlagsMixin(FormatFeatureFlags).complement;
    pub const subtract = FlagsMixin(FormatFeatureFlags).subtract;
    pub const contains = FlagsMixin(FormatFeatureFlags).contains;
    pub const format = FlagFormatMixin(FormatFeatureFlags).format;
};
pub const QueryControlFlags = packed struct(Flags) {
    precise_bit: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(QueryControlFlags).toInt;
    pub const fromInt = FlagsMixin(QueryControlFlags).fromInt;
    pub const merge = FlagsMixin(QueryControlFlags).merge;
    pub const intersect = FlagsMixin(QueryControlFlags).intersect;
    pub const complement = FlagsMixin(QueryControlFlags).complement;
    pub const subtract = FlagsMixin(QueryControlFlags).subtract;
    pub const contains = FlagsMixin(QueryControlFlags).contains;
    pub const format = FlagFormatMixin(QueryControlFlags).format;
};
pub const QueryResultFlags = packed struct(Flags) {
    @"64_bit": bool = false,
    wait_bit: bool = false,
    with_availability_bit: bool = false,
    partial_bit: bool = false,
    with_status_bit_khr: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(QueryResultFlags).toInt;
    pub const fromInt = FlagsMixin(QueryResultFlags).fromInt;
    pub const merge = FlagsMixin(QueryResultFlags).merge;
    pub const intersect = FlagsMixin(QueryResultFlags).intersect;
    pub const complement = FlagsMixin(QueryResultFlags).complement;
    pub const subtract = FlagsMixin(QueryResultFlags).subtract;
    pub const contains = FlagsMixin(QueryResultFlags).contains;
    pub const format = FlagFormatMixin(QueryResultFlags).format;
};
pub const CommandBufferUsageFlags = packed struct(Flags) {
    one_time_submit_bit: bool = false,
    render_pass_continue_bit: bool = false,
    simultaneous_use_bit: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(CommandBufferUsageFlags).toInt;
    pub const fromInt = FlagsMixin(CommandBufferUsageFlags).fromInt;
    pub const merge = FlagsMixin(CommandBufferUsageFlags).merge;
    pub const intersect = FlagsMixin(CommandBufferUsageFlags).intersect;
    pub const complement = FlagsMixin(CommandBufferUsageFlags).complement;
    pub const subtract = FlagsMixin(CommandBufferUsageFlags).subtract;
    pub const contains = FlagsMixin(CommandBufferUsageFlags).contains;
    pub const format = FlagFormatMixin(CommandBufferUsageFlags).format;
};
pub const QueryPipelineStatisticFlags = packed struct(Flags) {
    input_assembly_vertices_bit: bool = false,
    input_assembly_primitives_bit: bool = false,
    vertex_shader_invocations_bit: bool = false,
    geometry_shader_invocations_bit: bool = false,
    geometry_shader_primitives_bit: bool = false,
    clipping_invocations_bit: bool = false,
    clipping_primitives_bit: bool = false,
    fragment_shader_invocations_bit: bool = false,
    tessellation_control_shader_patches_bit: bool = false,
    tessellation_evaluation_shader_invocations_bit: bool = false,
    compute_shader_invocations_bit: bool = false,
    task_shader_invocations_bit_ext: bool = false,
    mesh_shader_invocations_bit_ext: bool = false,
    cluster_culling_shader_invocations_bit_huawei: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(QueryPipelineStatisticFlags).toInt;
    pub const fromInt = FlagsMixin(QueryPipelineStatisticFlags).fromInt;
    pub const merge = FlagsMixin(QueryPipelineStatisticFlags).merge;
    pub const intersect = FlagsMixin(QueryPipelineStatisticFlags).intersect;
    pub const complement = FlagsMixin(QueryPipelineStatisticFlags).complement;
    pub const subtract = FlagsMixin(QueryPipelineStatisticFlags).subtract;
    pub const contains = FlagsMixin(QueryPipelineStatisticFlags).contains;
    pub const format = FlagFormatMixin(QueryPipelineStatisticFlags).format;
};
pub const MemoryMapFlags = packed struct(Flags) {
    placed_bit_ext: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(MemoryMapFlags).toInt;
    pub const fromInt = FlagsMixin(MemoryMapFlags).fromInt;
    pub const merge = FlagsMixin(MemoryMapFlags).merge;
    pub const intersect = FlagsMixin(MemoryMapFlags).intersect;
    pub const complement = FlagsMixin(MemoryMapFlags).complement;
    pub const subtract = FlagsMixin(MemoryMapFlags).subtract;
    pub const contains = FlagsMixin(MemoryMapFlags).contains;
    pub const format = FlagFormatMixin(MemoryMapFlags).format;
};
pub const ImageAspectFlags = packed struct(Flags) {
    color_bit: bool = false,
    depth_bit: bool = false,
    stencil_bit: bool = false,
    metadata_bit: bool = false,
    plane_0_bit: bool = false,
    plane_1_bit: bool = false,
    plane_2_bit: bool = false,
    memory_plane_0_bit_ext: bool = false,
    memory_plane_1_bit_ext: bool = false,
    memory_plane_2_bit_ext: bool = false,
    memory_plane_3_bit_ext: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ImageAspectFlags).toInt;
    pub const fromInt = FlagsMixin(ImageAspectFlags).fromInt;
    pub const merge = FlagsMixin(ImageAspectFlags).merge;
    pub const intersect = FlagsMixin(ImageAspectFlags).intersect;
    pub const complement = FlagsMixin(ImageAspectFlags).complement;
    pub const subtract = FlagsMixin(ImageAspectFlags).subtract;
    pub const contains = FlagsMixin(ImageAspectFlags).contains;
    pub const format = FlagFormatMixin(ImageAspectFlags).format;
};
pub const SparseImageFormatFlags = packed struct(Flags) {
    single_miptail_bit: bool = false,
    aligned_mip_size_bit: bool = false,
    nonstandard_block_size_bit: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(SparseImageFormatFlags).toInt;
    pub const fromInt = FlagsMixin(SparseImageFormatFlags).fromInt;
    pub const merge = FlagsMixin(SparseImageFormatFlags).merge;
    pub const intersect = FlagsMixin(SparseImageFormatFlags).intersect;
    pub const complement = FlagsMixin(SparseImageFormatFlags).complement;
    pub const subtract = FlagsMixin(SparseImageFormatFlags).subtract;
    pub const contains = FlagsMixin(SparseImageFormatFlags).contains;
    pub const format = FlagFormatMixin(SparseImageFormatFlags).format;
};
pub const SparseMemoryBindFlags = packed struct(Flags) {
    metadata_bit: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(SparseMemoryBindFlags).toInt;
    pub const fromInt = FlagsMixin(SparseMemoryBindFlags).fromInt;
    pub const merge = FlagsMixin(SparseMemoryBindFlags).merge;
    pub const intersect = FlagsMixin(SparseMemoryBindFlags).intersect;
    pub const complement = FlagsMixin(SparseMemoryBindFlags).complement;
    pub const subtract = FlagsMixin(SparseMemoryBindFlags).subtract;
    pub const contains = FlagsMixin(SparseMemoryBindFlags).contains;
    pub const format = FlagFormatMixin(SparseMemoryBindFlags).format;
};
pub const PipelineStageFlags = packed struct(Flags) {
    top_of_pipe_bit: bool = false,
    draw_indirect_bit: bool = false,
    vertex_input_bit: bool = false,
    vertex_shader_bit: bool = false,
    tessellation_control_shader_bit: bool = false,
    tessellation_evaluation_shader_bit: bool = false,
    geometry_shader_bit: bool = false,
    fragment_shader_bit: bool = false,
    early_fragment_tests_bit: bool = false,
    late_fragment_tests_bit: bool = false,
    color_attachment_output_bit: bool = false,
    compute_shader_bit: bool = false,
    transfer_bit: bool = false,
    bottom_of_pipe_bit: bool = false,
    host_bit: bool = false,
    all_graphics_bit: bool = false,
    all_commands_bit: bool = false,
    command_preprocess_bit_ext: bool = false,
    conditional_rendering_bit_ext: bool = false,
    task_shader_bit_ext: bool = false,
    mesh_shader_bit_ext: bool = false,
    ray_tracing_shader_bit_khr: bool = false,
    fragment_shading_rate_attachment_bit_khr: bool = false,
    fragment_density_process_bit_ext: bool = false,
    transform_feedback_bit_ext: bool = false,
    acceleration_structure_build_bit_khr: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(PipelineStageFlags).toInt;
    pub const fromInt = FlagsMixin(PipelineStageFlags).fromInt;
    pub const merge = FlagsMixin(PipelineStageFlags).merge;
    pub const intersect = FlagsMixin(PipelineStageFlags).intersect;
    pub const complement = FlagsMixin(PipelineStageFlags).complement;
    pub const subtract = FlagsMixin(PipelineStageFlags).subtract;
    pub const contains = FlagsMixin(PipelineStageFlags).contains;
    pub const format = FlagFormatMixin(PipelineStageFlags).format;
};
pub const CommandPoolCreateFlags = packed struct(Flags) {
    transient_bit: bool = false,
    reset_command_buffer_bit: bool = false,
    protected_bit: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(CommandPoolCreateFlags).toInt;
    pub const fromInt = FlagsMixin(CommandPoolCreateFlags).fromInt;
    pub const merge = FlagsMixin(CommandPoolCreateFlags).merge;
    pub const intersect = FlagsMixin(CommandPoolCreateFlags).intersect;
    pub const complement = FlagsMixin(CommandPoolCreateFlags).complement;
    pub const subtract = FlagsMixin(CommandPoolCreateFlags).subtract;
    pub const contains = FlagsMixin(CommandPoolCreateFlags).contains;
    pub const format = FlagFormatMixin(CommandPoolCreateFlags).format;
};
pub const CommandPoolResetFlags = packed struct(Flags) {
    release_resources_bit: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(CommandPoolResetFlags).toInt;
    pub const fromInt = FlagsMixin(CommandPoolResetFlags).fromInt;
    pub const merge = FlagsMixin(CommandPoolResetFlags).merge;
    pub const intersect = FlagsMixin(CommandPoolResetFlags).intersect;
    pub const complement = FlagsMixin(CommandPoolResetFlags).complement;
    pub const subtract = FlagsMixin(CommandPoolResetFlags).subtract;
    pub const contains = FlagsMixin(CommandPoolResetFlags).contains;
    pub const format = FlagFormatMixin(CommandPoolResetFlags).format;
};
pub const CommandBufferResetFlags = packed struct(Flags) {
    release_resources_bit: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(CommandBufferResetFlags).toInt;
    pub const fromInt = FlagsMixin(CommandBufferResetFlags).fromInt;
    pub const merge = FlagsMixin(CommandBufferResetFlags).merge;
    pub const intersect = FlagsMixin(CommandBufferResetFlags).intersect;
    pub const complement = FlagsMixin(CommandBufferResetFlags).complement;
    pub const subtract = FlagsMixin(CommandBufferResetFlags).subtract;
    pub const contains = FlagsMixin(CommandBufferResetFlags).contains;
    pub const format = FlagFormatMixin(CommandBufferResetFlags).format;
};
pub const SampleCountFlags = packed struct(Flags) {
    @"1_bit": bool = false,
    @"2_bit": bool = false,
    @"4_bit": bool = false,
    @"8_bit": bool = false,
    @"16_bit": bool = false,
    @"32_bit": bool = false,
    @"64_bit": bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(SampleCountFlags).toInt;
    pub const fromInt = FlagsMixin(SampleCountFlags).fromInt;
    pub const merge = FlagsMixin(SampleCountFlags).merge;
    pub const intersect = FlagsMixin(SampleCountFlags).intersect;
    pub const complement = FlagsMixin(SampleCountFlags).complement;
    pub const subtract = FlagsMixin(SampleCountFlags).subtract;
    pub const contains = FlagsMixin(SampleCountFlags).contains;
    pub const format = FlagFormatMixin(SampleCountFlags).format;
};
pub const AttachmentDescriptionFlags = packed struct(Flags) {
    may_alias_bit: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(AttachmentDescriptionFlags).toInt;
    pub const fromInt = FlagsMixin(AttachmentDescriptionFlags).fromInt;
    pub const merge = FlagsMixin(AttachmentDescriptionFlags).merge;
    pub const intersect = FlagsMixin(AttachmentDescriptionFlags).intersect;
    pub const complement = FlagsMixin(AttachmentDescriptionFlags).complement;
    pub const subtract = FlagsMixin(AttachmentDescriptionFlags).subtract;
    pub const contains = FlagsMixin(AttachmentDescriptionFlags).contains;
    pub const format = FlagFormatMixin(AttachmentDescriptionFlags).format;
};
pub const StencilFaceFlags = packed struct(Flags) {
    front_bit: bool = false,
    back_bit: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(StencilFaceFlags).toInt;
    pub const fromInt = FlagsMixin(StencilFaceFlags).fromInt;
    pub const merge = FlagsMixin(StencilFaceFlags).merge;
    pub const intersect = FlagsMixin(StencilFaceFlags).intersect;
    pub const complement = FlagsMixin(StencilFaceFlags).complement;
    pub const subtract = FlagsMixin(StencilFaceFlags).subtract;
    pub const contains = FlagsMixin(StencilFaceFlags).contains;
    pub const format = FlagFormatMixin(StencilFaceFlags).format;
};
pub const DescriptorPoolCreateFlags = packed struct(Flags) {
    free_descriptor_set_bit: bool = false,
    update_after_bind_bit: bool = false,
    host_only_bit_ext: bool = false,
    allow_overallocation_sets_bit_nv: bool = false,
    allow_overallocation_pools_bit_nv: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(DescriptorPoolCreateFlags).toInt;
    pub const fromInt = FlagsMixin(DescriptorPoolCreateFlags).fromInt;
    pub const merge = FlagsMixin(DescriptorPoolCreateFlags).merge;
    pub const intersect = FlagsMixin(DescriptorPoolCreateFlags).intersect;
    pub const complement = FlagsMixin(DescriptorPoolCreateFlags).complement;
    pub const subtract = FlagsMixin(DescriptorPoolCreateFlags).subtract;
    pub const contains = FlagsMixin(DescriptorPoolCreateFlags).contains;
    pub const format = FlagFormatMixin(DescriptorPoolCreateFlags).format;
};
pub const DependencyFlags = packed struct(Flags) {
    by_region_bit: bool = false,
    view_local_bit: bool = false,
    device_group_bit: bool = false,
    feedback_loop_bit_ext: bool = false,
    _reserved_bit_4: bool = false,
    queue_family_ownership_transfer_use_all_stages_bit_khr: bool = false,
    asymmetric_event_bit_khr: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(DependencyFlags).toInt;
    pub const fromInt = FlagsMixin(DependencyFlags).fromInt;
    pub const merge = FlagsMixin(DependencyFlags).merge;
    pub const intersect = FlagsMixin(DependencyFlags).intersect;
    pub const complement = FlagsMixin(DependencyFlags).complement;
    pub const subtract = FlagsMixin(DependencyFlags).subtract;
    pub const contains = FlagsMixin(DependencyFlags).contains;
    pub const format = FlagFormatMixin(DependencyFlags).format;
};
pub const SemaphoreType = enum(i32) {
    binary = 0,
    timeline = 1,
    _,
    pub const binary_khr = SemaphoreType.binary;
    pub const timeline_khr = SemaphoreType.timeline;
};
pub const SemaphoreWaitFlags = packed struct(Flags) {
    any_bit: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(SemaphoreWaitFlags).toInt;
    pub const fromInt = FlagsMixin(SemaphoreWaitFlags).fromInt;
    pub const merge = FlagsMixin(SemaphoreWaitFlags).merge;
    pub const intersect = FlagsMixin(SemaphoreWaitFlags).intersect;
    pub const complement = FlagsMixin(SemaphoreWaitFlags).complement;
    pub const subtract = FlagsMixin(SemaphoreWaitFlags).subtract;
    pub const contains = FlagsMixin(SemaphoreWaitFlags).contains;
    pub const format = FlagFormatMixin(SemaphoreWaitFlags).format;
};
pub const PresentModeKHR = enum(i32) {
    immediate_khr = 0,
    mailbox_khr = 1,
    fifo_khr = 2,
    fifo_relaxed_khr = 3,
    shared_demand_refresh_khr = 1000111000,
    shared_continuous_refresh_khr = 1000111001,
    fifo_latest_ready_khr = 1000361000,
    _,
    pub const fifo_latest_ready_ext = PresentModeKHR.fifo_latest_ready_khr;
};
pub const ColorSpaceKHR = enum(i32) {
    srgb_nonlinear_khr = 0,
    display_p3_nonlinear_ext = 1000104001,
    extended_srgb_linear_ext = 1000104002,
    display_p3_linear_ext = 1000104003,
    dci_p3_nonlinear_ext = 1000104004,
    bt709_linear_ext = 1000104005,
    bt709_nonlinear_ext = 1000104006,
    bt2020_linear_ext = 1000104007,
    hdr10_st2084_ext = 1000104008,
    dolbyvision_ext = 1000104009,
    hdr10_hlg_ext = 1000104010,
    adobergb_linear_ext = 1000104011,
    adobergb_nonlinear_ext = 1000104012,
    pass_through_ext = 1000104013,
    extended_srgb_nonlinear_ext = 1000104014,
    display_native_amd = 1000213000,
    _,
    pub const colorspace_srgb_nonlinear_khr = ColorSpaceKHR.srgb_nonlinear_khr;
    pub const dci_p3_linear_ext = ColorSpaceKHR.display_p3_linear_ext;
};
pub const DisplayPlaneAlphaFlagsKHR = packed struct(Flags) {
    opaque_bit_khr: bool = false,
    global_bit_khr: bool = false,
    per_pixel_bit_khr: bool = false,
    per_pixel_premultiplied_bit_khr: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(DisplayPlaneAlphaFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(DisplayPlaneAlphaFlagsKHR).fromInt;
    pub const merge = FlagsMixin(DisplayPlaneAlphaFlagsKHR).merge;
    pub const intersect = FlagsMixin(DisplayPlaneAlphaFlagsKHR).intersect;
    pub const complement = FlagsMixin(DisplayPlaneAlphaFlagsKHR).complement;
    pub const subtract = FlagsMixin(DisplayPlaneAlphaFlagsKHR).subtract;
    pub const contains = FlagsMixin(DisplayPlaneAlphaFlagsKHR).contains;
    pub const format = FlagFormatMixin(DisplayPlaneAlphaFlagsKHR).format;
};
pub const CompositeAlphaFlagsKHR = packed struct(Flags) {
    opaque_bit_khr: bool = false,
    pre_multiplied_bit_khr: bool = false,
    post_multiplied_bit_khr: bool = false,
    inherit_bit_khr: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(CompositeAlphaFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(CompositeAlphaFlagsKHR).fromInt;
    pub const merge = FlagsMixin(CompositeAlphaFlagsKHR).merge;
    pub const intersect = FlagsMixin(CompositeAlphaFlagsKHR).intersect;
    pub const complement = FlagsMixin(CompositeAlphaFlagsKHR).complement;
    pub const subtract = FlagsMixin(CompositeAlphaFlagsKHR).subtract;
    pub const contains = FlagsMixin(CompositeAlphaFlagsKHR).contains;
    pub const format = FlagFormatMixin(CompositeAlphaFlagsKHR).format;
};
pub const SurfaceTransformFlagsKHR = packed struct(Flags) {
    identity_bit_khr: bool = false,
    rotate_90_bit_khr: bool = false,
    rotate_180_bit_khr: bool = false,
    rotate_270_bit_khr: bool = false,
    horizontal_mirror_bit_khr: bool = false,
    horizontal_mirror_rotate_90_bit_khr: bool = false,
    horizontal_mirror_rotate_180_bit_khr: bool = false,
    horizontal_mirror_rotate_270_bit_khr: bool = false,
    inherit_bit_khr: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(SurfaceTransformFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(SurfaceTransformFlagsKHR).fromInt;
    pub const merge = FlagsMixin(SurfaceTransformFlagsKHR).merge;
    pub const intersect = FlagsMixin(SurfaceTransformFlagsKHR).intersect;
    pub const complement = FlagsMixin(SurfaceTransformFlagsKHR).complement;
    pub const subtract = FlagsMixin(SurfaceTransformFlagsKHR).subtract;
    pub const contains = FlagsMixin(SurfaceTransformFlagsKHR).contains;
    pub const format = FlagFormatMixin(SurfaceTransformFlagsKHR).format;
};
pub const DisplaySurfaceStereoTypeNV = enum(i32) {
    none_nv = 0,
    onboard_din_nv = 1,
    hdmi_3d_nv = 2,
    inband_displayport_nv = 3,
    _,
};
pub const SwapchainImageUsageFlagsANDROID = packed struct(Flags) {
    shared_bit_android: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(SwapchainImageUsageFlagsANDROID).toInt;
    pub const fromInt = FlagsMixin(SwapchainImageUsageFlagsANDROID).fromInt;
    pub const merge = FlagsMixin(SwapchainImageUsageFlagsANDROID).merge;
    pub const intersect = FlagsMixin(SwapchainImageUsageFlagsANDROID).intersect;
    pub const complement = FlagsMixin(SwapchainImageUsageFlagsANDROID).complement;
    pub const subtract = FlagsMixin(SwapchainImageUsageFlagsANDROID).subtract;
    pub const contains = FlagsMixin(SwapchainImageUsageFlagsANDROID).contains;
    pub const format = FlagFormatMixin(SwapchainImageUsageFlagsANDROID).format;
};
pub const TimeDomainKHR = enum(i32) {
    device_khr = 0,
    clock_monotonic_khr = 1,
    clock_monotonic_raw_khr = 2,
    query_performance_counter_khr = 3,
    _,
    pub const device_ext = TimeDomainKHR.device_khr;
    pub const clock_monotonic_ext = TimeDomainKHR.clock_monotonic_khr;
    pub const clock_monotonic_raw_ext = TimeDomainKHR.clock_monotonic_raw_khr;
    pub const query_performance_counter_ext = TimeDomainKHR.query_performance_counter_khr;
};
pub const DebugReportFlagsEXT = packed struct(Flags) {
    information_bit_ext: bool = false,
    warning_bit_ext: bool = false,
    performance_warning_bit_ext: bool = false,
    error_bit_ext: bool = false,
    debug_bit_ext: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(DebugReportFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(DebugReportFlagsEXT).fromInt;
    pub const merge = FlagsMixin(DebugReportFlagsEXT).merge;
    pub const intersect = FlagsMixin(DebugReportFlagsEXT).intersect;
    pub const complement = FlagsMixin(DebugReportFlagsEXT).complement;
    pub const subtract = FlagsMixin(DebugReportFlagsEXT).subtract;
    pub const contains = FlagsMixin(DebugReportFlagsEXT).contains;
    pub const format = FlagFormatMixin(DebugReportFlagsEXT).format;
};
pub const DebugReportObjectTypeEXT = enum(i32) {
    unknown_ext = 0,
    instance_ext = 1,
    physical_device_ext = 2,
    device_ext = 3,
    queue_ext = 4,
    semaphore_ext = 5,
    command_buffer_ext = 6,
    fence_ext = 7,
    device_memory_ext = 8,
    buffer_ext = 9,
    image_ext = 10,
    event_ext = 11,
    query_pool_ext = 12,
    buffer_view_ext = 13,
    image_view_ext = 14,
    shader_module_ext = 15,
    pipeline_cache_ext = 16,
    pipeline_layout_ext = 17,
    render_pass_ext = 18,
    pipeline_ext = 19,
    descriptor_set_layout_ext = 20,
    sampler_ext = 21,
    descriptor_pool_ext = 22,
    descriptor_set_ext = 23,
    framebuffer_ext = 24,
    command_pool_ext = 25,
    surface_khr_ext = 26,
    swapchain_khr_ext = 27,
    debug_report_callback_ext_ext = 28,
    display_khr_ext = 29,
    display_mode_khr_ext = 30,
    validation_cache_ext_ext = 33,
    sampler_ycbcr_conversion_ext = 1000156000,
    descriptor_update_template_ext = 1000085000,
    cu_module_nvx_ext = 1000029000,
    cu_function_nvx_ext = 1000029001,
    acceleration_structure_khr_ext = 1000150000,
    acceleration_structure_nv_ext = 1000165000,
    cuda_module_nv_ext = 1000307000,
    cuda_function_nv_ext = 1000307001,
    buffer_collection_fuchsia_ext = 1000366000,
    _,
    pub const debug_report_ext = DebugReportObjectTypeEXT.debug_report_callback_ext_ext;
    pub const validation_cache_ext = DebugReportObjectTypeEXT.validation_cache_ext_ext;
    pub const descriptor_update_template_khr_ext = DebugReportObjectTypeEXT.descriptor_update_template_ext;
    pub const sampler_ycbcr_conversion_khr_ext = DebugReportObjectTypeEXT.sampler_ycbcr_conversion_ext;
};
pub const DeviceMemoryReportEventTypeEXT = enum(i32) {
    allocate_ext = 0,
    free_ext = 1,
    import_ext = 2,
    unimport_ext = 3,
    allocation_failed_ext = 4,
    _,
};
pub const RasterizationOrderAMD = enum(i32) {
    strict_amd = 0,
    relaxed_amd = 1,
    _,
};
pub const ExternalMemoryHandleTypeFlagsNV = packed struct(Flags) {
    opaque_win32_bit_nv: bool = false,
    opaque_win32_kmt_bit_nv: bool = false,
    d3d11_image_bit_nv: bool = false,
    d3d11_image_kmt_bit_nv: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ExternalMemoryHandleTypeFlagsNV).toInt;
    pub const fromInt = FlagsMixin(ExternalMemoryHandleTypeFlagsNV).fromInt;
    pub const merge = FlagsMixin(ExternalMemoryHandleTypeFlagsNV).merge;
    pub const intersect = FlagsMixin(ExternalMemoryHandleTypeFlagsNV).intersect;
    pub const complement = FlagsMixin(ExternalMemoryHandleTypeFlagsNV).complement;
    pub const subtract = FlagsMixin(ExternalMemoryHandleTypeFlagsNV).subtract;
    pub const contains = FlagsMixin(ExternalMemoryHandleTypeFlagsNV).contains;
    pub const format = FlagFormatMixin(ExternalMemoryHandleTypeFlagsNV).format;
};
pub const ExternalMemoryFeatureFlagsNV = packed struct(Flags) {
    dedicated_only_bit_nv: bool = false,
    exportable_bit_nv: bool = false,
    importable_bit_nv: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ExternalMemoryFeatureFlagsNV).toInt;
    pub const fromInt = FlagsMixin(ExternalMemoryFeatureFlagsNV).fromInt;
    pub const merge = FlagsMixin(ExternalMemoryFeatureFlagsNV).merge;
    pub const intersect = FlagsMixin(ExternalMemoryFeatureFlagsNV).intersect;
    pub const complement = FlagsMixin(ExternalMemoryFeatureFlagsNV).complement;
    pub const subtract = FlagsMixin(ExternalMemoryFeatureFlagsNV).subtract;
    pub const contains = FlagsMixin(ExternalMemoryFeatureFlagsNV).contains;
    pub const format = FlagFormatMixin(ExternalMemoryFeatureFlagsNV).format;
};
pub const ClusterAccelerationStructureIndexFormatFlagsNV = packed struct(Flags) {
    @"8bit_nv": bool = false,
    @"16bit_nv": bool = false,
    @"32bit_nv": bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ClusterAccelerationStructureIndexFormatFlagsNV).toInt;
    pub const fromInt = FlagsMixin(ClusterAccelerationStructureIndexFormatFlagsNV).fromInt;
    pub const merge = FlagsMixin(ClusterAccelerationStructureIndexFormatFlagsNV).merge;
    pub const intersect = FlagsMixin(ClusterAccelerationStructureIndexFormatFlagsNV).intersect;
    pub const complement = FlagsMixin(ClusterAccelerationStructureIndexFormatFlagsNV).complement;
    pub const subtract = FlagsMixin(ClusterAccelerationStructureIndexFormatFlagsNV).subtract;
    pub const contains = FlagsMixin(ClusterAccelerationStructureIndexFormatFlagsNV).contains;
    pub const format = FlagFormatMixin(ClusterAccelerationStructureIndexFormatFlagsNV).format;
};
pub const ClusterAccelerationStructureTypeNV = enum(i32) {
    clusters_bottom_level_nv = 0,
    triangle_cluster_nv = 1,
    triangle_cluster_template_nv = 2,
    _,
};
pub const ClusterAccelerationStructureOpTypeNV = enum(i32) {
    move_objects_nv = 0,
    build_clusters_bottom_level_nv = 1,
    build_triangle_cluster_nv = 2,
    build_triangle_cluster_template_nv = 3,
    instantiate_triangle_cluster_nv = 4,
    get_cluster_template_indices_nv = 5,
    _,
};
pub const ClusterAccelerationStructureOpModeNV = enum(i32) {
    implicit_destinations_nv = 0,
    explicit_destinations_nv = 1,
    compute_sizes_nv = 2,
    _,
};
pub const ClusterAccelerationStructureClusterFlagsNV = packed struct(Flags) {
    allow_disable_opacity_micromaps_nv: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ClusterAccelerationStructureClusterFlagsNV).toInt;
    pub const fromInt = FlagsMixin(ClusterAccelerationStructureClusterFlagsNV).fromInt;
    pub const merge = FlagsMixin(ClusterAccelerationStructureClusterFlagsNV).merge;
    pub const intersect = FlagsMixin(ClusterAccelerationStructureClusterFlagsNV).intersect;
    pub const complement = FlagsMixin(ClusterAccelerationStructureClusterFlagsNV).complement;
    pub const subtract = FlagsMixin(ClusterAccelerationStructureClusterFlagsNV).subtract;
    pub const contains = FlagsMixin(ClusterAccelerationStructureClusterFlagsNV).contains;
    pub const format = FlagFormatMixin(ClusterAccelerationStructureClusterFlagsNV).format;
};
pub const ClusterAccelerationStructureGeometryFlagsNV = packed struct(Flags) {
    cull_disable_bit_nv: bool = false,
    no_duplicate_anyhit_invocation_bit_nv: bool = false,
    opaque_bit_nv: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ClusterAccelerationStructureGeometryFlagsNV).toInt;
    pub const fromInt = FlagsMixin(ClusterAccelerationStructureGeometryFlagsNV).fromInt;
    pub const merge = FlagsMixin(ClusterAccelerationStructureGeometryFlagsNV).merge;
    pub const intersect = FlagsMixin(ClusterAccelerationStructureGeometryFlagsNV).intersect;
    pub const complement = FlagsMixin(ClusterAccelerationStructureGeometryFlagsNV).complement;
    pub const subtract = FlagsMixin(ClusterAccelerationStructureGeometryFlagsNV).subtract;
    pub const contains = FlagsMixin(ClusterAccelerationStructureGeometryFlagsNV).contains;
    pub const format = FlagFormatMixin(ClusterAccelerationStructureGeometryFlagsNV).format;
};
pub const ClusterAccelerationStructureAddressResolutionFlagsNV = packed struct(Flags) {
    indirected_dst_implicit_data_bit_nv: bool = false,
    indirected_scratch_data_bit_nv: bool = false,
    indirected_dst_address_array_bit_nv: bool = false,
    indirected_dst_sizes_array_bit_nv: bool = false,
    indirected_src_infos_array_bit_nv: bool = false,
    indirected_src_infos_count_bit_nv: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ClusterAccelerationStructureAddressResolutionFlagsNV).toInt;
    pub const fromInt = FlagsMixin(ClusterAccelerationStructureAddressResolutionFlagsNV).fromInt;
    pub const merge = FlagsMixin(ClusterAccelerationStructureAddressResolutionFlagsNV).merge;
    pub const intersect = FlagsMixin(ClusterAccelerationStructureAddressResolutionFlagsNV).intersect;
    pub const complement = FlagsMixin(ClusterAccelerationStructureAddressResolutionFlagsNV).complement;
    pub const subtract = FlagsMixin(ClusterAccelerationStructureAddressResolutionFlagsNV).subtract;
    pub const contains = FlagsMixin(ClusterAccelerationStructureAddressResolutionFlagsNV).contains;
    pub const format = FlagFormatMixin(ClusterAccelerationStructureAddressResolutionFlagsNV).format;
};
pub const ValidationCheckEXT = enum(i32) {
    all_ext = 0,
    shaders_ext = 1,
    _,
};
pub const ValidationFeatureEnableEXT = enum(i32) {
    gpu_assisted_ext = 0,
    gpu_assisted_reserve_binding_slot_ext = 1,
    best_practices_ext = 2,
    debug_printf_ext = 3,
    synchronization_validation_ext = 4,
    _,
};
pub const ValidationFeatureDisableEXT = enum(i32) {
    all_ext = 0,
    shaders_ext = 1,
    thread_safety_ext = 2,
    api_parameters_ext = 3,
    object_lifetimes_ext = 4,
    core_checks_ext = 5,
    unique_handles_ext = 6,
    shader_validation_cache_ext = 7,
    _,
};
pub const LayerSettingTypeEXT = enum(i32) {
    bool32_ext = 0,
    int32_ext = 1,
    int64_ext = 2,
    uint32_ext = 3,
    uint64_ext = 4,
    float32_ext = 5,
    float64_ext = 6,
    string_ext = 7,
    _,
};
pub const SubgroupFeatureFlags = packed struct(Flags) {
    basic_bit: bool = false,
    vote_bit: bool = false,
    arithmetic_bit: bool = false,
    ballot_bit: bool = false,
    shuffle_bit: bool = false,
    shuffle_relative_bit: bool = false,
    clustered_bit: bool = false,
    quad_bit: bool = false,
    partitioned_bit_nv: bool = false,
    rotate_bit: bool = false,
    rotate_clustered_bit: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(SubgroupFeatureFlags).toInt;
    pub const fromInt = FlagsMixin(SubgroupFeatureFlags).fromInt;
    pub const merge = FlagsMixin(SubgroupFeatureFlags).merge;
    pub const intersect = FlagsMixin(SubgroupFeatureFlags).intersect;
    pub const complement = FlagsMixin(SubgroupFeatureFlags).complement;
    pub const subtract = FlagsMixin(SubgroupFeatureFlags).subtract;
    pub const contains = FlagsMixin(SubgroupFeatureFlags).contains;
    pub const format = FlagFormatMixin(SubgroupFeatureFlags).format;
};
pub const IndirectCommandsLayoutUsageFlagsNV = packed struct(Flags) {
    explicit_preprocess_bit_nv: bool = false,
    indexed_sequences_bit_nv: bool = false,
    unordered_sequences_bit_nv: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(IndirectCommandsLayoutUsageFlagsNV).toInt;
    pub const fromInt = FlagsMixin(IndirectCommandsLayoutUsageFlagsNV).fromInt;
    pub const merge = FlagsMixin(IndirectCommandsLayoutUsageFlagsNV).merge;
    pub const intersect = FlagsMixin(IndirectCommandsLayoutUsageFlagsNV).intersect;
    pub const complement = FlagsMixin(IndirectCommandsLayoutUsageFlagsNV).complement;
    pub const subtract = FlagsMixin(IndirectCommandsLayoutUsageFlagsNV).subtract;
    pub const contains = FlagsMixin(IndirectCommandsLayoutUsageFlagsNV).contains;
    pub const format = FlagFormatMixin(IndirectCommandsLayoutUsageFlagsNV).format;
};
pub const IndirectStateFlagsNV = packed struct(Flags) {
    flag_frontface_bit_nv: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(IndirectStateFlagsNV).toInt;
    pub const fromInt = FlagsMixin(IndirectStateFlagsNV).fromInt;
    pub const merge = FlagsMixin(IndirectStateFlagsNV).merge;
    pub const intersect = FlagsMixin(IndirectStateFlagsNV).intersect;
    pub const complement = FlagsMixin(IndirectStateFlagsNV).complement;
    pub const subtract = FlagsMixin(IndirectStateFlagsNV).subtract;
    pub const contains = FlagsMixin(IndirectStateFlagsNV).contains;
    pub const format = FlagFormatMixin(IndirectStateFlagsNV).format;
};
pub const IndirectCommandsTokenTypeNV = enum(i32) {
    shader_group_nv = 0,
    state_flags_nv = 1,
    index_buffer_nv = 2,
    vertex_buffer_nv = 3,
    push_constant_nv = 4,
    draw_indexed_nv = 5,
    draw_nv = 6,
    draw_tasks_nv = 7,
    draw_mesh_tasks_nv = 1000328000,
    pipeline_nv = 1000428003,
    dispatch_nv = 1000428004,
    _,
};
pub const DescriptorSetLayoutCreateFlags = packed struct(Flags) {
    push_descriptor_bit: bool = false,
    update_after_bind_pool_bit: bool = false,
    host_only_pool_bit_ext: bool = false,
    _reserved_bit_3: bool = false,
    descriptor_buffer_bit_ext: bool = false,
    embedded_immutable_samplers_bit_ext: bool = false,
    per_stage_bit_nv: bool = false,
    indirect_bindable_bit_nv: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(DescriptorSetLayoutCreateFlags).toInt;
    pub const fromInt = FlagsMixin(DescriptorSetLayoutCreateFlags).fromInt;
    pub const merge = FlagsMixin(DescriptorSetLayoutCreateFlags).merge;
    pub const intersect = FlagsMixin(DescriptorSetLayoutCreateFlags).intersect;
    pub const complement = FlagsMixin(DescriptorSetLayoutCreateFlags).complement;
    pub const subtract = FlagsMixin(DescriptorSetLayoutCreateFlags).subtract;
    pub const contains = FlagsMixin(DescriptorSetLayoutCreateFlags).contains;
    pub const format = FlagFormatMixin(DescriptorSetLayoutCreateFlags).format;
};
pub const ExternalMemoryHandleTypeFlags = packed struct(Flags) {
    opaque_fd_bit: bool = false,
    opaque_win32_bit: bool = false,
    opaque_win32_kmt_bit: bool = false,
    d3d11_texture_bit: bool = false,
    d3d11_texture_kmt_bit: bool = false,
    d3d12_heap_bit: bool = false,
    d3d12_resource_bit: bool = false,
    host_allocation_bit_ext: bool = false,
    host_mapped_foreign_memory_bit_ext: bool = false,
    dma_buf_bit_ext: bool = false,
    android_hardware_buffer_bit_android: bool = false,
    zircon_vmo_bit_fuchsia: bool = false,
    rdma_address_bit_nv: bool = false,
    sci_buf_bit_nv: bool = false,
    screen_buffer_bit_qnx: bool = false,
    _reserved_bit_15: bool = false,
    mtlbuffer_bit_ext: bool = false,
    mtltexture_bit_ext: bool = false,
    mtlheap_bit_ext: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ExternalMemoryHandleTypeFlags).toInt;
    pub const fromInt = FlagsMixin(ExternalMemoryHandleTypeFlags).fromInt;
    pub const merge = FlagsMixin(ExternalMemoryHandleTypeFlags).merge;
    pub const intersect = FlagsMixin(ExternalMemoryHandleTypeFlags).intersect;
    pub const complement = FlagsMixin(ExternalMemoryHandleTypeFlags).complement;
    pub const subtract = FlagsMixin(ExternalMemoryHandleTypeFlags).subtract;
    pub const contains = FlagsMixin(ExternalMemoryHandleTypeFlags).contains;
    pub const format = FlagFormatMixin(ExternalMemoryHandleTypeFlags).format;
};
pub const ExternalMemoryFeatureFlags = packed struct(Flags) {
    dedicated_only_bit: bool = false,
    exportable_bit: bool = false,
    importable_bit: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ExternalMemoryFeatureFlags).toInt;
    pub const fromInt = FlagsMixin(ExternalMemoryFeatureFlags).fromInt;
    pub const merge = FlagsMixin(ExternalMemoryFeatureFlags).merge;
    pub const intersect = FlagsMixin(ExternalMemoryFeatureFlags).intersect;
    pub const complement = FlagsMixin(ExternalMemoryFeatureFlags).complement;
    pub const subtract = FlagsMixin(ExternalMemoryFeatureFlags).subtract;
    pub const contains = FlagsMixin(ExternalMemoryFeatureFlags).contains;
    pub const format = FlagFormatMixin(ExternalMemoryFeatureFlags).format;
};
pub const ExternalSemaphoreHandleTypeFlags = packed struct(Flags) {
    opaque_fd_bit: bool = false,
    opaque_win32_bit: bool = false,
    opaque_win32_kmt_bit: bool = false,
    d3d12_fence_bit: bool = false,
    sync_fd_bit: bool = false,
    sci_sync_obj_bit_nv: bool = false,
    _reserved_bit_6: bool = false,
    zircon_event_bit_fuchsia: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ExternalSemaphoreHandleTypeFlags).toInt;
    pub const fromInt = FlagsMixin(ExternalSemaphoreHandleTypeFlags).fromInt;
    pub const merge = FlagsMixin(ExternalSemaphoreHandleTypeFlags).merge;
    pub const intersect = FlagsMixin(ExternalSemaphoreHandleTypeFlags).intersect;
    pub const complement = FlagsMixin(ExternalSemaphoreHandleTypeFlags).complement;
    pub const subtract = FlagsMixin(ExternalSemaphoreHandleTypeFlags).subtract;
    pub const contains = FlagsMixin(ExternalSemaphoreHandleTypeFlags).contains;
    pub const format = FlagFormatMixin(ExternalSemaphoreHandleTypeFlags).format;
};
pub const ExternalSemaphoreFeatureFlags = packed struct(Flags) {
    exportable_bit: bool = false,
    importable_bit: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ExternalSemaphoreFeatureFlags).toInt;
    pub const fromInt = FlagsMixin(ExternalSemaphoreFeatureFlags).fromInt;
    pub const merge = FlagsMixin(ExternalSemaphoreFeatureFlags).merge;
    pub const intersect = FlagsMixin(ExternalSemaphoreFeatureFlags).intersect;
    pub const complement = FlagsMixin(ExternalSemaphoreFeatureFlags).complement;
    pub const subtract = FlagsMixin(ExternalSemaphoreFeatureFlags).subtract;
    pub const contains = FlagsMixin(ExternalSemaphoreFeatureFlags).contains;
    pub const format = FlagFormatMixin(ExternalSemaphoreFeatureFlags).format;
};
pub const SemaphoreImportFlags = packed struct(Flags) {
    temporary_bit: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(SemaphoreImportFlags).toInt;
    pub const fromInt = FlagsMixin(SemaphoreImportFlags).fromInt;
    pub const merge = FlagsMixin(SemaphoreImportFlags).merge;
    pub const intersect = FlagsMixin(SemaphoreImportFlags).intersect;
    pub const complement = FlagsMixin(SemaphoreImportFlags).complement;
    pub const subtract = FlagsMixin(SemaphoreImportFlags).subtract;
    pub const contains = FlagsMixin(SemaphoreImportFlags).contains;
    pub const format = FlagFormatMixin(SemaphoreImportFlags).format;
};
pub const ExternalFenceHandleTypeFlags = packed struct(Flags) {
    opaque_fd_bit: bool = false,
    opaque_win32_bit: bool = false,
    opaque_win32_kmt_bit: bool = false,
    sync_fd_bit: bool = false,
    sci_sync_obj_bit_nv: bool = false,
    sci_sync_fence_bit_nv: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ExternalFenceHandleTypeFlags).toInt;
    pub const fromInt = FlagsMixin(ExternalFenceHandleTypeFlags).fromInt;
    pub const merge = FlagsMixin(ExternalFenceHandleTypeFlags).merge;
    pub const intersect = FlagsMixin(ExternalFenceHandleTypeFlags).intersect;
    pub const complement = FlagsMixin(ExternalFenceHandleTypeFlags).complement;
    pub const subtract = FlagsMixin(ExternalFenceHandleTypeFlags).subtract;
    pub const contains = FlagsMixin(ExternalFenceHandleTypeFlags).contains;
    pub const format = FlagFormatMixin(ExternalFenceHandleTypeFlags).format;
};
pub const ExternalFenceFeatureFlags = packed struct(Flags) {
    exportable_bit: bool = false,
    importable_bit: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ExternalFenceFeatureFlags).toInt;
    pub const fromInt = FlagsMixin(ExternalFenceFeatureFlags).fromInt;
    pub const merge = FlagsMixin(ExternalFenceFeatureFlags).merge;
    pub const intersect = FlagsMixin(ExternalFenceFeatureFlags).intersect;
    pub const complement = FlagsMixin(ExternalFenceFeatureFlags).complement;
    pub const subtract = FlagsMixin(ExternalFenceFeatureFlags).subtract;
    pub const contains = FlagsMixin(ExternalFenceFeatureFlags).contains;
    pub const format = FlagFormatMixin(ExternalFenceFeatureFlags).format;
};
pub const FenceImportFlags = packed struct(Flags) {
    temporary_bit: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(FenceImportFlags).toInt;
    pub const fromInt = FlagsMixin(FenceImportFlags).fromInt;
    pub const merge = FlagsMixin(FenceImportFlags).merge;
    pub const intersect = FlagsMixin(FenceImportFlags).intersect;
    pub const complement = FlagsMixin(FenceImportFlags).complement;
    pub const subtract = FlagsMixin(FenceImportFlags).subtract;
    pub const contains = FlagsMixin(FenceImportFlags).contains;
    pub const format = FlagFormatMixin(FenceImportFlags).format;
};
pub const SurfaceCounterFlagsEXT = packed struct(Flags) {
    vblank_bit_ext: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(SurfaceCounterFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(SurfaceCounterFlagsEXT).fromInt;
    pub const merge = FlagsMixin(SurfaceCounterFlagsEXT).merge;
    pub const intersect = FlagsMixin(SurfaceCounterFlagsEXT).intersect;
    pub const complement = FlagsMixin(SurfaceCounterFlagsEXT).complement;
    pub const subtract = FlagsMixin(SurfaceCounterFlagsEXT).subtract;
    pub const contains = FlagsMixin(SurfaceCounterFlagsEXT).contains;
    pub const format = FlagFormatMixin(SurfaceCounterFlagsEXT).format;
};
pub const DisplayPowerStateEXT = enum(i32) {
    off_ext = 0,
    suspend_ext = 1,
    on_ext = 2,
    _,
};
pub const DeviceEventTypeEXT = enum(i32) {
    display_hotplug_ext = 0,
    _,
};
pub const DisplayEventTypeEXT = enum(i32) {
    first_pixel_out_ext = 0,
    _,
};
pub const PeerMemoryFeatureFlags = packed struct(Flags) {
    copy_src_bit: bool = false,
    copy_dst_bit: bool = false,
    generic_src_bit: bool = false,
    generic_dst_bit: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(PeerMemoryFeatureFlags).toInt;
    pub const fromInt = FlagsMixin(PeerMemoryFeatureFlags).fromInt;
    pub const merge = FlagsMixin(PeerMemoryFeatureFlags).merge;
    pub const intersect = FlagsMixin(PeerMemoryFeatureFlags).intersect;
    pub const complement = FlagsMixin(PeerMemoryFeatureFlags).complement;
    pub const subtract = FlagsMixin(PeerMemoryFeatureFlags).subtract;
    pub const contains = FlagsMixin(PeerMemoryFeatureFlags).contains;
    pub const format = FlagFormatMixin(PeerMemoryFeatureFlags).format;
};
pub const MemoryAllocateFlags = packed struct(Flags) {
    device_mask_bit: bool = false,
    device_address_bit: bool = false,
    device_address_capture_replay_bit: bool = false,
    zero_initialize_bit_ext: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(MemoryAllocateFlags).toInt;
    pub const fromInt = FlagsMixin(MemoryAllocateFlags).fromInt;
    pub const merge = FlagsMixin(MemoryAllocateFlags).merge;
    pub const intersect = FlagsMixin(MemoryAllocateFlags).intersect;
    pub const complement = FlagsMixin(MemoryAllocateFlags).complement;
    pub const subtract = FlagsMixin(MemoryAllocateFlags).subtract;
    pub const contains = FlagsMixin(MemoryAllocateFlags).contains;
    pub const format = FlagFormatMixin(MemoryAllocateFlags).format;
};
pub const DeviceGroupPresentModeFlagsKHR = packed struct(Flags) {
    local_bit_khr: bool = false,
    remote_bit_khr: bool = false,
    sum_bit_khr: bool = false,
    local_multi_device_bit_khr: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(DeviceGroupPresentModeFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(DeviceGroupPresentModeFlagsKHR).fromInt;
    pub const merge = FlagsMixin(DeviceGroupPresentModeFlagsKHR).merge;
    pub const intersect = FlagsMixin(DeviceGroupPresentModeFlagsKHR).intersect;
    pub const complement = FlagsMixin(DeviceGroupPresentModeFlagsKHR).complement;
    pub const subtract = FlagsMixin(DeviceGroupPresentModeFlagsKHR).subtract;
    pub const contains = FlagsMixin(DeviceGroupPresentModeFlagsKHR).contains;
    pub const format = FlagFormatMixin(DeviceGroupPresentModeFlagsKHR).format;
};
pub const SwapchainCreateFlagsKHR = packed struct(Flags) {
    split_instance_bind_regions_bit_khr: bool = false,
    protected_bit_khr: bool = false,
    mutable_format_bit_khr: bool = false,
    deferred_memory_allocation_bit_khr: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    present_id_2_bit_khr: bool = false,
    present_wait_2_bit_khr: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(SwapchainCreateFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(SwapchainCreateFlagsKHR).fromInt;
    pub const merge = FlagsMixin(SwapchainCreateFlagsKHR).merge;
    pub const intersect = FlagsMixin(SwapchainCreateFlagsKHR).intersect;
    pub const complement = FlagsMixin(SwapchainCreateFlagsKHR).complement;
    pub const subtract = FlagsMixin(SwapchainCreateFlagsKHR).subtract;
    pub const contains = FlagsMixin(SwapchainCreateFlagsKHR).contains;
    pub const format = FlagFormatMixin(SwapchainCreateFlagsKHR).format;
};
pub const ViewportCoordinateSwizzleNV = enum(i32) {
    positive_x_nv = 0,
    negative_x_nv = 1,
    positive_y_nv = 2,
    negative_y_nv = 3,
    positive_z_nv = 4,
    negative_z_nv = 5,
    positive_w_nv = 6,
    negative_w_nv = 7,
    _,
};
pub const DiscardRectangleModeEXT = enum(i32) {
    inclusive_ext = 0,
    exclusive_ext = 1,
    _,
};
pub const SubpassDescriptionFlags = packed struct(Flags) {
    per_view_attributes_bit_nvx: bool = false,
    per_view_position_x_only_bit_nvx: bool = false,
    fragment_region_bit_qcom: bool = false,
    shader_resolve_bit_qcom: bool = false,
    rasterization_order_attachment_color_access_bit_ext: bool = false,
    rasterization_order_attachment_depth_access_bit_ext: bool = false,
    rasterization_order_attachment_stencil_access_bit_ext: bool = false,
    enable_legacy_dithering_bit_ext: bool = false,
    tile_shading_apron_bit_qcom: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(SubpassDescriptionFlags).toInt;
    pub const fromInt = FlagsMixin(SubpassDescriptionFlags).fromInt;
    pub const merge = FlagsMixin(SubpassDescriptionFlags).merge;
    pub const intersect = FlagsMixin(SubpassDescriptionFlags).intersect;
    pub const complement = FlagsMixin(SubpassDescriptionFlags).complement;
    pub const subtract = FlagsMixin(SubpassDescriptionFlags).subtract;
    pub const contains = FlagsMixin(SubpassDescriptionFlags).contains;
    pub const format = FlagFormatMixin(SubpassDescriptionFlags).format;
};
pub const PointClippingBehavior = enum(i32) {
    all_clip_planes = 0,
    user_clip_planes_only = 1,
    _,
    pub const all_clip_planes_khr = PointClippingBehavior.all_clip_planes;
    pub const user_clip_planes_only_khr = PointClippingBehavior.user_clip_planes_only;
};
pub const SamplerReductionMode = enum(i32) {
    weighted_average = 0,
    min = 1,
    max = 2,
    weighted_average_rangeclamp_qcom = 1000521000,
    _,
    pub const weighted_average_ext = SamplerReductionMode.weighted_average;
    pub const min_ext = SamplerReductionMode.min;
    pub const max_ext = SamplerReductionMode.max;
};
pub const TessellationDomainOrigin = enum(i32) {
    upper_left = 0,
    lower_left = 1,
    _,
    pub const upper_left_khr = TessellationDomainOrigin.upper_left;
    pub const lower_left_khr = TessellationDomainOrigin.lower_left;
};
pub const SamplerYcbcrModelConversion = enum(i32) {
    rgb_identity = 0,
    ycbcr_identity = 1,
    ycbcr_709 = 2,
    ycbcr_601 = 3,
    ycbcr_2020 = 4,
    _,
    pub const rgb_identity_khr = SamplerYcbcrModelConversion.rgb_identity;
    pub const ycbcr_identity_khr = SamplerYcbcrModelConversion.ycbcr_identity;
    pub const ycbcr_709_khr = SamplerYcbcrModelConversion.ycbcr_709;
    pub const ycbcr_601_khr = SamplerYcbcrModelConversion.ycbcr_601;
    pub const ycbcr_2020_khr = SamplerYcbcrModelConversion.ycbcr_2020;
};
pub const SamplerYcbcrRange = enum(i32) {
    itu_full = 0,
    itu_narrow = 1,
    _,
    pub const itu_full_khr = SamplerYcbcrRange.itu_full;
    pub const itu_narrow_khr = SamplerYcbcrRange.itu_narrow;
};
pub const ChromaLocation = enum(i32) {
    cosited_even = 0,
    midpoint = 1,
    _,
    pub const cosited_even_khr = ChromaLocation.cosited_even;
    pub const midpoint_khr = ChromaLocation.midpoint;
};
pub const BlendOverlapEXT = enum(i32) {
    uncorrelated_ext = 0,
    disjoint_ext = 1,
    conjoint_ext = 2,
    _,
};
pub const CoverageModulationModeNV = enum(i32) {
    none_nv = 0,
    rgb_nv = 1,
    alpha_nv = 2,
    rgba_nv = 3,
    _,
};
pub const CoverageReductionModeNV = enum(i32) {
    merge_nv = 0,
    truncate_nv = 1,
    _,
};
pub const ValidationCacheHeaderVersionEXT = enum(i32) {
    one_ext = 1,
    _,
};
pub const ShaderInfoTypeAMD = enum(i32) {
    statistics_amd = 0,
    binary_amd = 1,
    disassembly_amd = 2,
    _,
};
pub const QueueGlobalPriority = enum(i32) {
    low = 128,
    medium = 256,
    high = 512,
    realtime = 1024,
    _,
    pub const low_ext = QueueGlobalPriority.low;
    pub const medium_ext = QueueGlobalPriority.medium;
    pub const high_ext = QueueGlobalPriority.high;
    pub const realtime_ext = QueueGlobalPriority.realtime;
    pub const low_khr = QueueGlobalPriority.low;
    pub const medium_khr = QueueGlobalPriority.medium;
    pub const high_khr = QueueGlobalPriority.high;
    pub const realtime_khr = QueueGlobalPriority.realtime;
};
pub const DebugUtilsMessageSeverityFlagsEXT = packed struct(Flags) {
    verbose_bit_ext: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    info_bit_ext: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    warning_bit_ext: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    error_bit_ext: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(DebugUtilsMessageSeverityFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(DebugUtilsMessageSeverityFlagsEXT).fromInt;
    pub const merge = FlagsMixin(DebugUtilsMessageSeverityFlagsEXT).merge;
    pub const intersect = FlagsMixin(DebugUtilsMessageSeverityFlagsEXT).intersect;
    pub const complement = FlagsMixin(DebugUtilsMessageSeverityFlagsEXT).complement;
    pub const subtract = FlagsMixin(DebugUtilsMessageSeverityFlagsEXT).subtract;
    pub const contains = FlagsMixin(DebugUtilsMessageSeverityFlagsEXT).contains;
    pub const format = FlagFormatMixin(DebugUtilsMessageSeverityFlagsEXT).format;
};
pub const DebugUtilsMessageTypeFlagsEXT = packed struct(Flags) {
    general_bit_ext: bool = false,
    validation_bit_ext: bool = false,
    performance_bit_ext: bool = false,
    device_address_binding_bit_ext: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(DebugUtilsMessageTypeFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(DebugUtilsMessageTypeFlagsEXT).fromInt;
    pub const merge = FlagsMixin(DebugUtilsMessageTypeFlagsEXT).merge;
    pub const intersect = FlagsMixin(DebugUtilsMessageTypeFlagsEXT).intersect;
    pub const complement = FlagsMixin(DebugUtilsMessageTypeFlagsEXT).complement;
    pub const subtract = FlagsMixin(DebugUtilsMessageTypeFlagsEXT).subtract;
    pub const contains = FlagsMixin(DebugUtilsMessageTypeFlagsEXT).contains;
    pub const format = FlagFormatMixin(DebugUtilsMessageTypeFlagsEXT).format;
};
pub const ConservativeRasterizationModeEXT = enum(i32) {
    disabled_ext = 0,
    overestimate_ext = 1,
    underestimate_ext = 2,
    _,
};
pub const DescriptorBindingFlags = packed struct(Flags) {
    update_after_bind_bit: bool = false,
    update_unused_while_pending_bit: bool = false,
    partially_bound_bit: bool = false,
    variable_descriptor_count_bit: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(DescriptorBindingFlags).toInt;
    pub const fromInt = FlagsMixin(DescriptorBindingFlags).fromInt;
    pub const merge = FlagsMixin(DescriptorBindingFlags).merge;
    pub const intersect = FlagsMixin(DescriptorBindingFlags).intersect;
    pub const complement = FlagsMixin(DescriptorBindingFlags).complement;
    pub const subtract = FlagsMixin(DescriptorBindingFlags).subtract;
    pub const contains = FlagsMixin(DescriptorBindingFlags).contains;
    pub const format = FlagFormatMixin(DescriptorBindingFlags).format;
};
pub const VendorId = enum(i32) {
    khronos = 0x10000,
    _viv = 0x10001,
    _vsi = 0x10002,
    kazan = 0x10003,
    codeplay = 0x10004,
    _mesa = 0x10005,
    pocl = 0x10006,
    mobileye = 0x10007,
    _,
};
pub const DriverId = enum(i32) {
    amd_proprietary = 1,
    amd_open_source = 2,
    mesa_radv = 3,
    nvidia_proprietary = 4,
    intel_proprietary_windows = 5,
    intel_open_source_mesa = 6,
    imagination_proprietary = 7,
    qualcomm_proprietary = 8,
    arm_proprietary = 9,
    google_swiftshader = 10,
    ggp_proprietary = 11,
    broadcom_proprietary = 12,
    mesa_llvmpipe = 13,
    moltenvk = 14,
    coreavi_proprietary = 15,
    juice_proprietary = 16,
    verisilicon_proprietary = 17,
    mesa_turnip = 18,
    mesa_v3dv = 19,
    mesa_panvk = 20,
    samsung_proprietary = 21,
    mesa_venus = 22,
    mesa_dozen = 23,
    mesa_nvk = 24,
    imagination_open_source_mesa = 25,
    mesa_honeykrisp = 26,
    vulkan_sc_emulation_on_vulkan = 27,
    _,
    pub const amd_proprietary_khr = DriverId.amd_proprietary;
    pub const amd_open_source_khr = DriverId.amd_open_source;
    pub const mesa_radv_khr = DriverId.mesa_radv;
    pub const nvidia_proprietary_khr = DriverId.nvidia_proprietary;
    pub const intel_proprietary_windows_khr = DriverId.intel_proprietary_windows;
    pub const intel_open_source_mesa_khr = DriverId.intel_open_source_mesa;
    pub const imagination_proprietary_khr = DriverId.imagination_proprietary;
    pub const qualcomm_proprietary_khr = DriverId.qualcomm_proprietary;
    pub const arm_proprietary_khr = DriverId.arm_proprietary;
    pub const google_swiftshader_khr = DriverId.google_swiftshader;
    pub const ggp_proprietary_khr = DriverId.ggp_proprietary;
    pub const broadcom_proprietary_khr = DriverId.broadcom_proprietary;
};
pub const ConditionalRenderingFlagsEXT = packed struct(Flags) {
    inverted_bit_ext: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ConditionalRenderingFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(ConditionalRenderingFlagsEXT).fromInt;
    pub const merge = FlagsMixin(ConditionalRenderingFlagsEXT).merge;
    pub const intersect = FlagsMixin(ConditionalRenderingFlagsEXT).intersect;
    pub const complement = FlagsMixin(ConditionalRenderingFlagsEXT).complement;
    pub const subtract = FlagsMixin(ConditionalRenderingFlagsEXT).subtract;
    pub const contains = FlagsMixin(ConditionalRenderingFlagsEXT).contains;
    pub const format = FlagFormatMixin(ConditionalRenderingFlagsEXT).format;
};
pub const ResolveModeFlags = packed struct(Flags) {
    sample_zero_bit: bool = false,
    average_bit: bool = false,
    min_bit: bool = false,
    max_bit: bool = false,
    external_format_downsample_bit_android: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ResolveModeFlags).toInt;
    pub const fromInt = FlagsMixin(ResolveModeFlags).fromInt;
    pub const merge = FlagsMixin(ResolveModeFlags).merge;
    pub const intersect = FlagsMixin(ResolveModeFlags).intersect;
    pub const complement = FlagsMixin(ResolveModeFlags).complement;
    pub const subtract = FlagsMixin(ResolveModeFlags).subtract;
    pub const contains = FlagsMixin(ResolveModeFlags).contains;
    pub const format = FlagFormatMixin(ResolveModeFlags).format;
};
pub const ShadingRatePaletteEntryNV = enum(i32) {
    no_invocations_nv = 0,
    @"16_invocations_per_pixel_nv" = 1,
    @"8_invocations_per_pixel_nv" = 2,
    @"4_invocations_per_pixel_nv" = 3,
    @"2_invocations_per_pixel_nv" = 4,
    @"1_invocation_per_pixel_nv" = 5,
    @"1_invocation_per_2x1_pixels_nv" = 6,
    @"1_invocation_per_1x2_pixels_nv" = 7,
    @"1_invocation_per_2x2_pixels_nv" = 8,
    @"1_invocation_per_4x2_pixels_nv" = 9,
    @"1_invocation_per_2x4_pixels_nv" = 10,
    @"1_invocation_per_4x4_pixels_nv" = 11,
    _,
};
pub const CoarseSampleOrderTypeNV = enum(i32) {
    default_nv = 0,
    custom_nv = 1,
    pixel_major_nv = 2,
    sample_major_nv = 3,
    _,
};
pub const GeometryInstanceFlagsKHR = packed struct(Flags) {
    triangle_facing_cull_disable_bit_khr: bool = false,
    triangle_flip_facing_bit_khr: bool = false,
    force_opaque_bit_khr: bool = false,
    force_no_opaque_bit_khr: bool = false,
    force_opacity_micromap_2_state_bit_ext: bool = false,
    disable_opacity_micromaps_bit_ext: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(GeometryInstanceFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(GeometryInstanceFlagsKHR).fromInt;
    pub const merge = FlagsMixin(GeometryInstanceFlagsKHR).merge;
    pub const intersect = FlagsMixin(GeometryInstanceFlagsKHR).intersect;
    pub const complement = FlagsMixin(GeometryInstanceFlagsKHR).complement;
    pub const subtract = FlagsMixin(GeometryInstanceFlagsKHR).subtract;
    pub const contains = FlagsMixin(GeometryInstanceFlagsKHR).contains;
    pub const format = FlagFormatMixin(GeometryInstanceFlagsKHR).format;
};
pub const GeometryFlagsKHR = packed struct(Flags) {
    opaque_bit_khr: bool = false,
    no_duplicate_any_hit_invocation_bit_khr: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(GeometryFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(GeometryFlagsKHR).fromInt;
    pub const merge = FlagsMixin(GeometryFlagsKHR).merge;
    pub const intersect = FlagsMixin(GeometryFlagsKHR).intersect;
    pub const complement = FlagsMixin(GeometryFlagsKHR).complement;
    pub const subtract = FlagsMixin(GeometryFlagsKHR).subtract;
    pub const contains = FlagsMixin(GeometryFlagsKHR).contains;
    pub const format = FlagFormatMixin(GeometryFlagsKHR).format;
};
pub const BuildAccelerationStructureFlagsKHR = packed struct(Flags) {
    allow_update_bit_khr: bool = false,
    allow_compaction_bit_khr: bool = false,
    prefer_fast_trace_bit_khr: bool = false,
    prefer_fast_build_bit_khr: bool = false,
    low_memory_bit_khr: bool = false,
    motion_bit_nv: bool = false,
    allow_opacity_micromap_update_bit_ext: bool = false,
    allow_disable_opacity_micromaps_bit_ext: bool = false,
    allow_opacity_micromap_data_update_bit_ext: bool = false,
    allow_displacement_micromap_update_bit_nv: bool = false,
    _reserved_bit_10: bool = false,
    allow_data_access_bit_khr: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(BuildAccelerationStructureFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(BuildAccelerationStructureFlagsKHR).fromInt;
    pub const merge = FlagsMixin(BuildAccelerationStructureFlagsKHR).merge;
    pub const intersect = FlagsMixin(BuildAccelerationStructureFlagsKHR).intersect;
    pub const complement = FlagsMixin(BuildAccelerationStructureFlagsKHR).complement;
    pub const subtract = FlagsMixin(BuildAccelerationStructureFlagsKHR).subtract;
    pub const contains = FlagsMixin(BuildAccelerationStructureFlagsKHR).contains;
    pub const format = FlagFormatMixin(BuildAccelerationStructureFlagsKHR).format;
};
pub const AccelerationStructureCreateFlagsKHR = packed struct(Flags) {
    device_address_capture_replay_bit_khr: bool = false,
    _reserved_bit_1: bool = false,
    motion_bit_nv: bool = false,
    descriptor_buffer_capture_replay_bit_ext: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(AccelerationStructureCreateFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(AccelerationStructureCreateFlagsKHR).fromInt;
    pub const merge = FlagsMixin(AccelerationStructureCreateFlagsKHR).merge;
    pub const intersect = FlagsMixin(AccelerationStructureCreateFlagsKHR).intersect;
    pub const complement = FlagsMixin(AccelerationStructureCreateFlagsKHR).complement;
    pub const subtract = FlagsMixin(AccelerationStructureCreateFlagsKHR).subtract;
    pub const contains = FlagsMixin(AccelerationStructureCreateFlagsKHR).contains;
    pub const format = FlagFormatMixin(AccelerationStructureCreateFlagsKHR).format;
};
pub const CopyAccelerationStructureModeKHR = enum(i32) {
    clone_khr = 0,
    compact_khr = 1,
    serialize_khr = 2,
    deserialize_khr = 3,
    _,
    pub const clone_nv = CopyAccelerationStructureModeKHR.clone_khr;
    pub const compact_nv = CopyAccelerationStructureModeKHR.compact_khr;
};
pub const BuildAccelerationStructureModeKHR = enum(i32) {
    build_khr = 0,
    update_khr = 1,
    _,
};
pub const AccelerationStructureTypeKHR = enum(i32) {
    top_level_khr = 0,
    bottom_level_khr = 1,
    generic_khr = 2,
    _,
    pub const top_level_nv = AccelerationStructureTypeKHR.top_level_khr;
    pub const bottom_level_nv = AccelerationStructureTypeKHR.bottom_level_khr;
};
pub const GeometryTypeKHR = enum(i32) {
    triangles_khr = 0,
    aabbs_khr = 1,
    instances_khr = 2,
    spheres_nv = 1000429004,
    linear_swept_spheres_nv = 1000429005,
    _,
    pub const triangles_nv = GeometryTypeKHR.triangles_khr;
    pub const aabbs_nv = GeometryTypeKHR.aabbs_khr;
};
pub const AccelerationStructureMemoryRequirementsTypeNV = enum(i32) {
    object_nv = 0,
    build_scratch_nv = 1,
    update_scratch_nv = 2,
    _,
};
pub const AccelerationStructureBuildTypeKHR = enum(i32) {
    host_khr = 0,
    device_khr = 1,
    host_or_device_khr = 2,
    _,
};
pub const RayTracingShaderGroupTypeKHR = enum(i32) {
    general_khr = 0,
    triangles_hit_group_khr = 1,
    procedural_hit_group_khr = 2,
    _,
    pub const general_nv = RayTracingShaderGroupTypeKHR.general_khr;
    pub const triangles_hit_group_nv = RayTracingShaderGroupTypeKHR.triangles_hit_group_khr;
    pub const procedural_hit_group_nv = RayTracingShaderGroupTypeKHR.procedural_hit_group_khr;
};
pub const AccelerationStructureCompatibilityKHR = enum(i32) {
    compatible_khr = 0,
    incompatible_khr = 1,
    _,
};
pub const ShaderGroupShaderKHR = enum(i32) {
    general_khr = 0,
    closest_hit_khr = 1,
    any_hit_khr = 2,
    intersection_khr = 3,
    _,
};
pub const MemoryOverallocationBehaviorAMD = enum(i32) {
    default_amd = 0,
    allowed_amd = 1,
    disallowed_amd = 2,
    _,
};
pub const FramebufferCreateFlags = packed struct(Flags) {
    imageless_bit: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(FramebufferCreateFlags).toInt;
    pub const fromInt = FlagsMixin(FramebufferCreateFlags).fromInt;
    pub const merge = FlagsMixin(FramebufferCreateFlags).merge;
    pub const intersect = FlagsMixin(FramebufferCreateFlags).intersect;
    pub const complement = FlagsMixin(FramebufferCreateFlags).complement;
    pub const subtract = FlagsMixin(FramebufferCreateFlags).subtract;
    pub const contains = FlagsMixin(FramebufferCreateFlags).contains;
    pub const format = FlagFormatMixin(FramebufferCreateFlags).format;
};
pub const QueryPoolCreateFlags = packed struct(Flags) {
    reset_bit_khr: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(QueryPoolCreateFlags).toInt;
    pub const fromInt = FlagsMixin(QueryPoolCreateFlags).fromInt;
    pub const merge = FlagsMixin(QueryPoolCreateFlags).merge;
    pub const intersect = FlagsMixin(QueryPoolCreateFlags).intersect;
    pub const complement = FlagsMixin(QueryPoolCreateFlags).complement;
    pub const subtract = FlagsMixin(QueryPoolCreateFlags).subtract;
    pub const contains = FlagsMixin(QueryPoolCreateFlags).contains;
    pub const format = FlagFormatMixin(QueryPoolCreateFlags).format;
};
pub const DeviceDiagnosticsConfigFlagsNV = packed struct(Flags) {
    enable_shader_debug_info_bit_nv: bool = false,
    enable_resource_tracking_bit_nv: bool = false,
    enable_automatic_checkpoints_bit_nv: bool = false,
    enable_shader_error_reporting_bit_nv: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(DeviceDiagnosticsConfigFlagsNV).toInt;
    pub const fromInt = FlagsMixin(DeviceDiagnosticsConfigFlagsNV).fromInt;
    pub const merge = FlagsMixin(DeviceDiagnosticsConfigFlagsNV).merge;
    pub const intersect = FlagsMixin(DeviceDiagnosticsConfigFlagsNV).intersect;
    pub const complement = FlagsMixin(DeviceDiagnosticsConfigFlagsNV).complement;
    pub const subtract = FlagsMixin(DeviceDiagnosticsConfigFlagsNV).subtract;
    pub const contains = FlagsMixin(DeviceDiagnosticsConfigFlagsNV).contains;
    pub const format = FlagFormatMixin(DeviceDiagnosticsConfigFlagsNV).format;
};
pub const PipelineCreationFeedbackFlags = packed struct(Flags) {
    valid_bit: bool = false,
    application_pipeline_cache_hit_bit: bool = false,
    base_pipeline_acceleration_bit: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(PipelineCreationFeedbackFlags).toInt;
    pub const fromInt = FlagsMixin(PipelineCreationFeedbackFlags).fromInt;
    pub const merge = FlagsMixin(PipelineCreationFeedbackFlags).merge;
    pub const intersect = FlagsMixin(PipelineCreationFeedbackFlags).intersect;
    pub const complement = FlagsMixin(PipelineCreationFeedbackFlags).complement;
    pub const subtract = FlagsMixin(PipelineCreationFeedbackFlags).subtract;
    pub const contains = FlagsMixin(PipelineCreationFeedbackFlags).contains;
    pub const format = FlagFormatMixin(PipelineCreationFeedbackFlags).format;
};
pub const FullScreenExclusiveEXT = enum(i32) {
    default_ext = 0,
    allowed_ext = 1,
    disallowed_ext = 2,
    application_controlled_ext = 3,
    _,
};
pub const PerformanceCounterScopeKHR = enum(i32) {
    command_buffer_khr = 0,
    render_pass_khr = 1,
    command_khr = 2,
    _,
    pub const query_scope_command_buffer_khr = PerformanceCounterScopeKHR.command_buffer_khr;
    pub const query_scope_render_pass_khr = PerformanceCounterScopeKHR.render_pass_khr;
    pub const query_scope_command_khr = PerformanceCounterScopeKHR.command_khr;
};
pub const MemoryDecompressionMethodFlagsNV = packed struct(Flags64) {
    gdeflate_1_0_bit_nv: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    _reserved_bit_32: bool = false,
    _reserved_bit_33: bool = false,
    _reserved_bit_34: bool = false,
    _reserved_bit_35: bool = false,
    _reserved_bit_36: bool = false,
    _reserved_bit_37: bool = false,
    _reserved_bit_38: bool = false,
    _reserved_bit_39: bool = false,
    _reserved_bit_40: bool = false,
    _reserved_bit_41: bool = false,
    _reserved_bit_42: bool = false,
    _reserved_bit_43: bool = false,
    _reserved_bit_44: bool = false,
    _reserved_bit_45: bool = false,
    _reserved_bit_46: bool = false,
    _reserved_bit_47: bool = false,
    _reserved_bit_48: bool = false,
    _reserved_bit_49: bool = false,
    _reserved_bit_50: bool = false,
    _reserved_bit_51: bool = false,
    _reserved_bit_52: bool = false,
    _reserved_bit_53: bool = false,
    _reserved_bit_54: bool = false,
    _reserved_bit_55: bool = false,
    _reserved_bit_56: bool = false,
    _reserved_bit_57: bool = false,
    _reserved_bit_58: bool = false,
    _reserved_bit_59: bool = false,
    _reserved_bit_60: bool = false,
    _reserved_bit_61: bool = false,
    _reserved_bit_62: bool = false,
    _reserved_bit_63: bool = false,
    pub const toInt = FlagsMixin(MemoryDecompressionMethodFlagsNV).toInt;
    pub const fromInt = FlagsMixin(MemoryDecompressionMethodFlagsNV).fromInt;
    pub const merge = FlagsMixin(MemoryDecompressionMethodFlagsNV).merge;
    pub const intersect = FlagsMixin(MemoryDecompressionMethodFlagsNV).intersect;
    pub const complement = FlagsMixin(MemoryDecompressionMethodFlagsNV).complement;
    pub const subtract = FlagsMixin(MemoryDecompressionMethodFlagsNV).subtract;
    pub const contains = FlagsMixin(MemoryDecompressionMethodFlagsNV).contains;
    pub const format = FlagFormatMixin(MemoryDecompressionMethodFlagsNV).format;
};
pub const PerformanceCounterUnitKHR = enum(i32) {
    generic_khr = 0,
    percentage_khr = 1,
    nanoseconds_khr = 2,
    bytes_khr = 3,
    bytes_per_second_khr = 4,
    kelvin_khr = 5,
    watts_khr = 6,
    volts_khr = 7,
    amps_khr = 8,
    hertz_khr = 9,
    cycles_khr = 10,
    _,
};
pub const PerformanceCounterStorageKHR = enum(i32) {
    int32_khr = 0,
    int64_khr = 1,
    uint32_khr = 2,
    uint64_khr = 3,
    float32_khr = 4,
    float64_khr = 5,
    _,
};
pub const PerformanceCounterDescriptionFlagsKHR = packed struct(Flags) {
    performance_impacting_bit_khr: bool = false,
    concurrently_impacted_bit_khr: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(PerformanceCounterDescriptionFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(PerformanceCounterDescriptionFlagsKHR).fromInt;
    pub const merge = FlagsMixin(PerformanceCounterDescriptionFlagsKHR).merge;
    pub const intersect = FlagsMixin(PerformanceCounterDescriptionFlagsKHR).intersect;
    pub const complement = FlagsMixin(PerformanceCounterDescriptionFlagsKHR).complement;
    pub const subtract = FlagsMixin(PerformanceCounterDescriptionFlagsKHR).subtract;
    pub const contains = FlagsMixin(PerformanceCounterDescriptionFlagsKHR).contains;
    pub const format = FlagFormatMixin(PerformanceCounterDescriptionFlagsKHR).format;
};
pub const AcquireProfilingLockFlagsKHR = packed struct(Flags) {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(AcquireProfilingLockFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(AcquireProfilingLockFlagsKHR).fromInt;
    pub const merge = FlagsMixin(AcquireProfilingLockFlagsKHR).merge;
    pub const intersect = FlagsMixin(AcquireProfilingLockFlagsKHR).intersect;
    pub const complement = FlagsMixin(AcquireProfilingLockFlagsKHR).complement;
    pub const subtract = FlagsMixin(AcquireProfilingLockFlagsKHR).subtract;
    pub const contains = FlagsMixin(AcquireProfilingLockFlagsKHR).contains;
    pub const format = FlagFormatMixin(AcquireProfilingLockFlagsKHR).format;
};
pub const ShaderCorePropertiesFlagsAMD = packed struct(Flags) {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(ShaderCorePropertiesFlagsAMD).toInt;
    pub const fromInt = FlagsMixin(ShaderCorePropertiesFlagsAMD).fromInt;
    pub const merge = FlagsMixin(ShaderCorePropertiesFlagsAMD).merge;
    pub const intersect = FlagsMixin(ShaderCorePropertiesFlagsAMD).intersect;
    pub const complement = FlagsMixin(ShaderCorePropertiesFlagsAMD).complement;
    pub const subtract = FlagsMixin(ShaderCorePropertiesFlagsAMD).subtract;
    pub const contains = FlagsMixin(ShaderCorePropertiesFlagsAMD).contains;
    pub const format = FlagFormatMixin(ShaderCorePropertiesFlagsAMD).format;
};
pub const RefreshObjectFlagsKHR = packed struct(Flags) {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(RefreshObjectFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(RefreshObjectFlagsKHR).fromInt;
    pub const merge = FlagsMixin(RefreshObjectFlagsKHR).merge;
    pub const intersect = FlagsMixin(RefreshObjectFlagsKHR).intersect;
    pub const complement = FlagsMixin(RefreshObjectFlagsKHR).complement;
    pub const subtract = FlagsMixin(RefreshObjectFlagsKHR).subtract;
    pub const contains = FlagsMixin(RefreshObjectFlagsKHR).contains;
    pub const format = FlagFormatMixin(RefreshObjectFlagsKHR).format;
};
pub const PerformanceConfigurationTypeINTEL = enum(i32) {
    command_queue_metrics_discovery_activated_intel = 0,
    _,
};
pub const QueryPoolSamplingModeINTEL = enum(i32) {
    manual_intel = 0,
    _,
};
pub const PerformanceOverrideTypeINTEL = enum(i32) {
    null_hardware_intel = 0,
    flush_gpu_caches_intel = 1,
    _,
};
pub const PerformanceParameterTypeINTEL = enum(i32) {
    hw_counters_supported_intel = 0,
    stream_marker_valid_bits_intel = 1,
    _,
};
pub const PerformanceValueTypeINTEL = enum(i32) {
    uint32_intel = 0,
    uint64_intel = 1,
    float_intel = 2,
    bool_intel = 3,
    string_intel = 4,
    _,
};
pub const ShaderFloatControlsIndependence = enum(i32) {
    @"32_bit_only" = 0,
    all = 1,
    none = 2,
    _,
    pub const @"32_bit_only_khr" = ShaderFloatControlsIndependence.@"32_bit_only";
    pub const all_khr = ShaderFloatControlsIndependence.all;
    pub const none_khr = ShaderFloatControlsIndependence.none;
};
pub const PipelineExecutableStatisticFormatKHR = enum(i32) {
    bool32_khr = 0,
    int64_khr = 1,
    uint64_khr = 2,
    float64_khr = 3,
    _,
};
pub const LineRasterizationMode = enum(i32) {
    default = 0,
    rectangular = 1,
    bresenham = 2,
    rectangular_smooth = 3,
    _,
    pub const default_ext = LineRasterizationMode.default;
    pub const rectangular_ext = LineRasterizationMode.rectangular;
    pub const bresenham_ext = LineRasterizationMode.bresenham;
    pub const rectangular_smooth_ext = LineRasterizationMode.rectangular_smooth;
    pub const default_khr = LineRasterizationMode.default;
    pub const rectangular_khr = LineRasterizationMode.rectangular;
    pub const bresenham_khr = LineRasterizationMode.bresenham;
    pub const rectangular_smooth_khr = LineRasterizationMode.rectangular_smooth;
};
pub const PipelineCompilerControlFlagsAMD = packed struct(Flags) {
    _reserved_bits: Flags = 0,
    pub const toInt = FlagsMixin(PipelineCompilerControlFlagsAMD).toInt;
    pub const fromInt = FlagsMixin(PipelineCompilerControlFlagsAMD).fromInt;
    pub const merge = FlagsMixin(PipelineCompilerControlFlagsAMD).merge;
    pub const intersect = FlagsMixin(PipelineCompilerControlFlagsAMD).intersect;
    pub const complement = FlagsMixin(PipelineCompilerControlFlagsAMD).complement;
    pub const subtract = FlagsMixin(PipelineCompilerControlFlagsAMD).subtract;
    pub const contains = FlagsMixin(PipelineCompilerControlFlagsAMD).contains;
    pub const format = FlagFormatMixin(PipelineCompilerControlFlagsAMD).format;
};
pub const FaultLevel = enum(i32) {
    unassigned = 0,
    critical = 1,
    recoverable = 2,
    warning = 3,
    _,
};
pub const FaultType = enum(i32) {
    invalid = 0,
    unassigned = 1,
    implementation = 2,
    system = 3,
    physical_device = 4,
    command_buffer_full = 5,
    invalid_api_usage = 6,
    _,
};
pub const FaultQueryBehavior = enum(i32) {
    get_and_clear_all_faults = 0,
    _,
};
pub const ToolPurposeFlags = packed struct(Flags) {
    validation_bit: bool = false,
    profiling_bit: bool = false,
    tracing_bit: bool = false,
    additional_features_bit: bool = false,
    modifying_features_bit: bool = false,
    debug_reporting_bit_ext: bool = false,
    debug_markers_bit_ext: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ToolPurposeFlags).toInt;
    pub const fromInt = FlagsMixin(ToolPurposeFlags).fromInt;
    pub const merge = FlagsMixin(ToolPurposeFlags).merge;
    pub const intersect = FlagsMixin(ToolPurposeFlags).intersect;
    pub const complement = FlagsMixin(ToolPurposeFlags).complement;
    pub const subtract = FlagsMixin(ToolPurposeFlags).subtract;
    pub const contains = FlagsMixin(ToolPurposeFlags).contains;
    pub const format = FlagFormatMixin(ToolPurposeFlags).format;
};
pub const PipelineMatchControl = enum(i32) {
    application_uuid_exact_match = 0,
    _,
};
pub const FragmentShadingRateCombinerOpKHR = enum(i32) {
    keep_khr = 0,
    replace_khr = 1,
    min_khr = 2,
    max_khr = 3,
    mul_khr = 4,
    _,
};
pub const FragmentShadingRateNV = enum(i32) {
    @"1_invocation_per_pixel_nv" = 0,
    @"1_invocation_per_1x2_pixels_nv" = 1,
    @"1_invocation_per_2x1_pixels_nv" = 4,
    @"1_invocation_per_2x2_pixels_nv" = 5,
    @"1_invocation_per_2x4_pixels_nv" = 6,
    @"1_invocation_per_4x2_pixels_nv" = 9,
    @"1_invocation_per_4x4_pixels_nv" = 10,
    @"2_invocations_per_pixel_nv" = 11,
    @"4_invocations_per_pixel_nv" = 12,
    @"8_invocations_per_pixel_nv" = 13,
    @"16_invocations_per_pixel_nv" = 14,
    no_invocations_nv = 15,
    _,
};
pub const FragmentShadingRateTypeNV = enum(i32) {
    fragment_size_nv = 0,
    enums_nv = 1,
    _,
};
pub const SubpassMergeStatusEXT = enum(i32) {
    merged_ext = 0,
    disallowed_ext = 1,
    not_merged_side_effects_ext = 2,
    not_merged_samples_mismatch_ext = 3,
    not_merged_views_mismatch_ext = 4,
    not_merged_aliasing_ext = 5,
    not_merged_dependencies_ext = 6,
    not_merged_incompatible_input_attachment_ext = 7,
    not_merged_too_many_attachments_ext = 8,
    not_merged_insufficient_storage_ext = 9,
    not_merged_depth_stencil_count_ext = 10,
    not_merged_resolve_attachment_reuse_ext = 11,
    not_merged_single_subpass_ext = 12,
    not_merged_unspecified_ext = 13,
    _,
};
pub const AccessFlags2 = packed struct(Flags64) {
    indirect_command_read_bit: bool = false,
    index_read_bit: bool = false,
    vertex_attribute_read_bit: bool = false,
    uniform_read_bit: bool = false,
    input_attachment_read_bit: bool = false,
    shader_read_bit: bool = false,
    shader_write_bit: bool = false,
    color_attachment_read_bit: bool = false,
    color_attachment_write_bit: bool = false,
    depth_stencil_attachment_read_bit: bool = false,
    depth_stencil_attachment_write_bit: bool = false,
    transfer_read_bit: bool = false,
    transfer_write_bit: bool = false,
    host_read_bit: bool = false,
    host_write_bit: bool = false,
    memory_read_bit: bool = false,
    memory_write_bit: bool = false,
    command_preprocess_read_bit_ext: bool = false,
    command_preprocess_write_bit_ext: bool = false,
    color_attachment_read_noncoherent_bit_ext: bool = false,
    conditional_rendering_read_bit_ext: bool = false,
    acceleration_structure_read_bit_khr: bool = false,
    acceleration_structure_write_bit_khr: bool = false,
    fragment_shading_rate_attachment_read_bit_khr: bool = false,
    fragment_density_map_read_bit_ext: bool = false,
    transform_feedback_write_bit_ext: bool = false,
    transform_feedback_counter_read_bit_ext: bool = false,
    transform_feedback_counter_write_bit_ext: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    shader_sampled_read_bit: bool = false,
    shader_storage_read_bit: bool = false,
    shader_storage_write_bit: bool = false,
    video_decode_read_bit_khr: bool = false,
    video_decode_write_bit_khr: bool = false,
    video_encode_read_bit_khr: bool = false,
    video_encode_write_bit_khr: bool = false,
    invocation_mask_read_bit_huawei: bool = false,
    shader_binding_table_read_bit_khr: bool = false,
    descriptor_buffer_read_bit_ext: bool = false,
    optical_flow_read_bit_nv: bool = false,
    optical_flow_write_bit_nv: bool = false,
    micromap_read_bit_ext: bool = false,
    micromap_write_bit_ext: bool = false,
    _reserved_bit_46: bool = false,
    data_graph_read_bit_arm: bool = false,
    data_graph_write_bit_arm: bool = false,
    _reserved_bit_49: bool = false,
    _reserved_bit_50: bool = false,
    shader_tile_attachment_read_bit_qcom: bool = false,
    shader_tile_attachment_write_bit_qcom: bool = false,
    _reserved_bit_53: bool = false,
    _reserved_bit_54: bool = false,
    _reserved_bit_55: bool = false,
    _reserved_bit_56: bool = false,
    _reserved_bit_57: bool = false,
    _reserved_bit_58: bool = false,
    _reserved_bit_59: bool = false,
    _reserved_bit_60: bool = false,
    _reserved_bit_61: bool = false,
    _reserved_bit_62: bool = false,
    _reserved_bit_63: bool = false,
    pub const toInt = FlagsMixin(AccessFlags2).toInt;
    pub const fromInt = FlagsMixin(AccessFlags2).fromInt;
    pub const merge = FlagsMixin(AccessFlags2).merge;
    pub const intersect = FlagsMixin(AccessFlags2).intersect;
    pub const complement = FlagsMixin(AccessFlags2).complement;
    pub const subtract = FlagsMixin(AccessFlags2).subtract;
    pub const contains = FlagsMixin(AccessFlags2).contains;
    pub const format = FlagFormatMixin(AccessFlags2).format;
};
pub const PipelineStageFlags2 = packed struct(Flags64) {
    top_of_pipe_bit: bool = false,
    draw_indirect_bit: bool = false,
    vertex_input_bit: bool = false,
    vertex_shader_bit: bool = false,
    tessellation_control_shader_bit: bool = false,
    tessellation_evaluation_shader_bit: bool = false,
    geometry_shader_bit: bool = false,
    fragment_shader_bit: bool = false,
    early_fragment_tests_bit: bool = false,
    late_fragment_tests_bit: bool = false,
    color_attachment_output_bit: bool = false,
    compute_shader_bit: bool = false,
    all_transfer_bit: bool = false,
    bottom_of_pipe_bit: bool = false,
    host_bit: bool = false,
    all_graphics_bit: bool = false,
    all_commands_bit: bool = false,
    command_preprocess_bit_ext: bool = false,
    conditional_rendering_bit_ext: bool = false,
    task_shader_bit_ext: bool = false,
    mesh_shader_bit_ext: bool = false,
    ray_tracing_shader_bit_khr: bool = false,
    fragment_shading_rate_attachment_bit_khr: bool = false,
    fragment_density_process_bit_ext: bool = false,
    transform_feedback_bit_ext: bool = false,
    acceleration_structure_build_bit_khr: bool = false,
    video_decode_bit_khr: bool = false,
    video_encode_bit_khr: bool = false,
    acceleration_structure_copy_bit_khr: bool = false,
    optical_flow_bit_nv: bool = false,
    micromap_build_bit_ext: bool = false,
    _reserved_bit_31: bool = false,
    copy_bit: bool = false,
    resolve_bit: bool = false,
    blit_bit: bool = false,
    clear_bit: bool = false,
    index_input_bit: bool = false,
    vertex_attribute_input_bit: bool = false,
    pre_rasterization_shaders_bit: bool = false,
    subpass_shader_bit_huawei: bool = false,
    invocation_mask_bit_huawei: bool = false,
    cluster_culling_shader_bit_huawei: bool = false,
    data_graph_bit_arm: bool = false,
    _reserved_bit_43: bool = false,
    convert_cooperative_vector_matrix_bit_nv: bool = false,
    _reserved_bit_45: bool = false,
    _reserved_bit_46: bool = false,
    _reserved_bit_47: bool = false,
    _reserved_bit_48: bool = false,
    _reserved_bit_49: bool = false,
    _reserved_bit_50: bool = false,
    _reserved_bit_51: bool = false,
    _reserved_bit_52: bool = false,
    _reserved_bit_53: bool = false,
    _reserved_bit_54: bool = false,
    _reserved_bit_55: bool = false,
    _reserved_bit_56: bool = false,
    _reserved_bit_57: bool = false,
    _reserved_bit_58: bool = false,
    _reserved_bit_59: bool = false,
    _reserved_bit_60: bool = false,
    _reserved_bit_61: bool = false,
    _reserved_bit_62: bool = false,
    _reserved_bit_63: bool = false,
    pub const toInt = FlagsMixin(PipelineStageFlags2).toInt;
    pub const fromInt = FlagsMixin(PipelineStageFlags2).fromInt;
    pub const merge = FlagsMixin(PipelineStageFlags2).merge;
    pub const intersect = FlagsMixin(PipelineStageFlags2).intersect;
    pub const complement = FlagsMixin(PipelineStageFlags2).complement;
    pub const subtract = FlagsMixin(PipelineStageFlags2).subtract;
    pub const contains = FlagsMixin(PipelineStageFlags2).contains;
    pub const format = FlagFormatMixin(PipelineStageFlags2).format;
};
pub const SubmitFlags = packed struct(Flags) {
    protected_bit: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(SubmitFlags).toInt;
    pub const fromInt = FlagsMixin(SubmitFlags).fromInt;
    pub const merge = FlagsMixin(SubmitFlags).merge;
    pub const intersect = FlagsMixin(SubmitFlags).intersect;
    pub const complement = FlagsMixin(SubmitFlags).complement;
    pub const subtract = FlagsMixin(SubmitFlags).subtract;
    pub const contains = FlagsMixin(SubmitFlags).contains;
    pub const format = FlagFormatMixin(SubmitFlags).format;
};
pub const EventCreateFlags = packed struct(Flags) {
    device_only_bit: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(EventCreateFlags).toInt;
    pub const fromInt = FlagsMixin(EventCreateFlags).fromInt;
    pub const merge = FlagsMixin(EventCreateFlags).merge;
    pub const intersect = FlagsMixin(EventCreateFlags).intersect;
    pub const complement = FlagsMixin(EventCreateFlags).complement;
    pub const subtract = FlagsMixin(EventCreateFlags).subtract;
    pub const contains = FlagsMixin(EventCreateFlags).contains;
    pub const format = FlagFormatMixin(EventCreateFlags).format;
};
pub const PipelineLayoutCreateFlags = packed struct(Flags) {
    _reserved_bit_0: bool = false,
    independent_sets_bit_ext: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(PipelineLayoutCreateFlags).toInt;
    pub const fromInt = FlagsMixin(PipelineLayoutCreateFlags).fromInt;
    pub const merge = FlagsMixin(PipelineLayoutCreateFlags).merge;
    pub const intersect = FlagsMixin(PipelineLayoutCreateFlags).intersect;
    pub const complement = FlagsMixin(PipelineLayoutCreateFlags).complement;
    pub const subtract = FlagsMixin(PipelineLayoutCreateFlags).subtract;
    pub const contains = FlagsMixin(PipelineLayoutCreateFlags).contains;
    pub const format = FlagFormatMixin(PipelineLayoutCreateFlags).format;
};
pub const SciSyncClientTypeNV = enum(i32) {
    signaler_nv = 0,
    waiter_nv = 1,
    signaler_waiter_nv = 2,
    _,
};
pub const SciSyncPrimitiveTypeNV = enum(i32) {
    fence_nv = 0,
    semaphore_nv = 1,
    _,
};
pub const ProvokingVertexModeEXT = enum(i32) {
    first_vertex_ext = 0,
    last_vertex_ext = 1,
    _,
};
pub const PipelineCacheValidationVersion = enum(i32) {
    safety_critical_one = 1,
    _,
};
pub const AccelerationStructureMotionInstanceTypeNV = enum(i32) {
    static_nv = 0,
    matrix_motion_nv = 1,
    srt_motion_nv = 2,
    _,
};
pub const PipelineColorBlendStateCreateFlags = packed struct(Flags) {
    rasterization_order_attachment_access_bit_ext: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(PipelineColorBlendStateCreateFlags).toInt;
    pub const fromInt = FlagsMixin(PipelineColorBlendStateCreateFlags).fromInt;
    pub const merge = FlagsMixin(PipelineColorBlendStateCreateFlags).merge;
    pub const intersect = FlagsMixin(PipelineColorBlendStateCreateFlags).intersect;
    pub const complement = FlagsMixin(PipelineColorBlendStateCreateFlags).complement;
    pub const subtract = FlagsMixin(PipelineColorBlendStateCreateFlags).subtract;
    pub const contains = FlagsMixin(PipelineColorBlendStateCreateFlags).contains;
    pub const format = FlagFormatMixin(PipelineColorBlendStateCreateFlags).format;
};
pub const PipelineDepthStencilStateCreateFlags = packed struct(Flags) {
    rasterization_order_attachment_depth_access_bit_ext: bool = false,
    rasterization_order_attachment_stencil_access_bit_ext: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(PipelineDepthStencilStateCreateFlags).toInt;
    pub const fromInt = FlagsMixin(PipelineDepthStencilStateCreateFlags).fromInt;
    pub const merge = FlagsMixin(PipelineDepthStencilStateCreateFlags).merge;
    pub const intersect = FlagsMixin(PipelineDepthStencilStateCreateFlags).intersect;
    pub const complement = FlagsMixin(PipelineDepthStencilStateCreateFlags).complement;
    pub const subtract = FlagsMixin(PipelineDepthStencilStateCreateFlags).subtract;
    pub const contains = FlagsMixin(PipelineDepthStencilStateCreateFlags).contains;
    pub const format = FlagFormatMixin(PipelineDepthStencilStateCreateFlags).format;
};
pub const GraphicsPipelineLibraryFlagsEXT = packed struct(Flags) {
    vertex_input_interface_bit_ext: bool = false,
    pre_rasterization_shaders_bit_ext: bool = false,
    fragment_shader_bit_ext: bool = false,
    fragment_output_interface_bit_ext: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(GraphicsPipelineLibraryFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(GraphicsPipelineLibraryFlagsEXT).fromInt;
    pub const merge = FlagsMixin(GraphicsPipelineLibraryFlagsEXT).merge;
    pub const intersect = FlagsMixin(GraphicsPipelineLibraryFlagsEXT).intersect;
    pub const complement = FlagsMixin(GraphicsPipelineLibraryFlagsEXT).complement;
    pub const subtract = FlagsMixin(GraphicsPipelineLibraryFlagsEXT).subtract;
    pub const contains = FlagsMixin(GraphicsPipelineLibraryFlagsEXT).contains;
    pub const format = FlagFormatMixin(GraphicsPipelineLibraryFlagsEXT).format;
};
pub const DeviceAddressBindingFlagsEXT = packed struct(Flags) {
    internal_object_bit_ext: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(DeviceAddressBindingFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(DeviceAddressBindingFlagsEXT).fromInt;
    pub const merge = FlagsMixin(DeviceAddressBindingFlagsEXT).merge;
    pub const intersect = FlagsMixin(DeviceAddressBindingFlagsEXT).intersect;
    pub const complement = FlagsMixin(DeviceAddressBindingFlagsEXT).complement;
    pub const subtract = FlagsMixin(DeviceAddressBindingFlagsEXT).subtract;
    pub const contains = FlagsMixin(DeviceAddressBindingFlagsEXT).contains;
    pub const format = FlagFormatMixin(DeviceAddressBindingFlagsEXT).format;
};
pub const DeviceAddressBindingTypeEXT = enum(i32) {
    bind_ext = 0,
    unbind_ext = 1,
    _,
};
pub const FrameBoundaryFlagsEXT = packed struct(Flags) {
    frame_end_bit_ext: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(FrameBoundaryFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(FrameBoundaryFlagsEXT).fromInt;
    pub const merge = FlagsMixin(FrameBoundaryFlagsEXT).merge;
    pub const intersect = FlagsMixin(FrameBoundaryFlagsEXT).intersect;
    pub const complement = FlagsMixin(FrameBoundaryFlagsEXT).complement;
    pub const subtract = FlagsMixin(FrameBoundaryFlagsEXT).subtract;
    pub const contains = FlagsMixin(FrameBoundaryFlagsEXT).contains;
    pub const format = FlagFormatMixin(FrameBoundaryFlagsEXT).format;
};
pub const PresentScalingFlagsKHR = packed struct(Flags) {
    one_to_one_bit_khr: bool = false,
    aspect_ratio_stretch_bit_khr: bool = false,
    stretch_bit_khr: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(PresentScalingFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(PresentScalingFlagsKHR).fromInt;
    pub const merge = FlagsMixin(PresentScalingFlagsKHR).merge;
    pub const intersect = FlagsMixin(PresentScalingFlagsKHR).intersect;
    pub const complement = FlagsMixin(PresentScalingFlagsKHR).complement;
    pub const subtract = FlagsMixin(PresentScalingFlagsKHR).subtract;
    pub const contains = FlagsMixin(PresentScalingFlagsKHR).contains;
    pub const format = FlagFormatMixin(PresentScalingFlagsKHR).format;
};
pub const PresentGravityFlagsKHR = packed struct(Flags) {
    min_bit_khr: bool = false,
    max_bit_khr: bool = false,
    centered_bit_khr: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(PresentGravityFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(PresentGravityFlagsKHR).fromInt;
    pub const merge = FlagsMixin(PresentGravityFlagsKHR).merge;
    pub const intersect = FlagsMixin(PresentGravityFlagsKHR).intersect;
    pub const complement = FlagsMixin(PresentGravityFlagsKHR).complement;
    pub const subtract = FlagsMixin(PresentGravityFlagsKHR).subtract;
    pub const contains = FlagsMixin(PresentGravityFlagsKHR).contains;
    pub const format = FlagFormatMixin(PresentGravityFlagsKHR).format;
};
pub const PhysicalDeviceSchedulingControlsFlagsARM = packed struct(Flags64) {
    shader_core_count_arm: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    _reserved_bit_32: bool = false,
    _reserved_bit_33: bool = false,
    _reserved_bit_34: bool = false,
    _reserved_bit_35: bool = false,
    _reserved_bit_36: bool = false,
    _reserved_bit_37: bool = false,
    _reserved_bit_38: bool = false,
    _reserved_bit_39: bool = false,
    _reserved_bit_40: bool = false,
    _reserved_bit_41: bool = false,
    _reserved_bit_42: bool = false,
    _reserved_bit_43: bool = false,
    _reserved_bit_44: bool = false,
    _reserved_bit_45: bool = false,
    _reserved_bit_46: bool = false,
    _reserved_bit_47: bool = false,
    _reserved_bit_48: bool = false,
    _reserved_bit_49: bool = false,
    _reserved_bit_50: bool = false,
    _reserved_bit_51: bool = false,
    _reserved_bit_52: bool = false,
    _reserved_bit_53: bool = false,
    _reserved_bit_54: bool = false,
    _reserved_bit_55: bool = false,
    _reserved_bit_56: bool = false,
    _reserved_bit_57: bool = false,
    _reserved_bit_58: bool = false,
    _reserved_bit_59: bool = false,
    _reserved_bit_60: bool = false,
    _reserved_bit_61: bool = false,
    _reserved_bit_62: bool = false,
    _reserved_bit_63: bool = false,
    pub const toInt = FlagsMixin(PhysicalDeviceSchedulingControlsFlagsARM).toInt;
    pub const fromInt = FlagsMixin(PhysicalDeviceSchedulingControlsFlagsARM).fromInt;
    pub const merge = FlagsMixin(PhysicalDeviceSchedulingControlsFlagsARM).merge;
    pub const intersect = FlagsMixin(PhysicalDeviceSchedulingControlsFlagsARM).intersect;
    pub const complement = FlagsMixin(PhysicalDeviceSchedulingControlsFlagsARM).complement;
    pub const subtract = FlagsMixin(PhysicalDeviceSchedulingControlsFlagsARM).subtract;
    pub const contains = FlagsMixin(PhysicalDeviceSchedulingControlsFlagsARM).contains;
    pub const format = FlagFormatMixin(PhysicalDeviceSchedulingControlsFlagsARM).format;
};
pub const VideoCodecOperationFlagsKHR = packed struct(Flags) {
    decode_h264_bit_khr: bool = false,
    decode_h265_bit_khr: bool = false,
    decode_av1_bit_khr: bool = false,
    decode_vp9_bit_khr: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    encode_h264_bit_khr: bool = false,
    encode_h265_bit_khr: bool = false,
    encode_av1_bit_khr: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoCodecOperationFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoCodecOperationFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoCodecOperationFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoCodecOperationFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoCodecOperationFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoCodecOperationFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoCodecOperationFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoCodecOperationFlagsKHR).format;
};
pub const VideoChromaSubsamplingFlagsKHR = packed struct(Flags) {
    monochrome_bit_khr: bool = false,
    @"420_bit_khr": bool = false,
    @"422_bit_khr": bool = false,
    @"444_bit_khr": bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoChromaSubsamplingFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoChromaSubsamplingFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoChromaSubsamplingFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoChromaSubsamplingFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoChromaSubsamplingFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoChromaSubsamplingFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoChromaSubsamplingFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoChromaSubsamplingFlagsKHR).format;
};
pub const VideoComponentBitDepthFlagsKHR = packed struct(Flags) {
    @"8_bit_khr": bool = false,
    _reserved_bit_1: bool = false,
    @"10_bit_khr": bool = false,
    _reserved_bit_3: bool = false,
    @"12_bit_khr": bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoComponentBitDepthFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoComponentBitDepthFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoComponentBitDepthFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoComponentBitDepthFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoComponentBitDepthFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoComponentBitDepthFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoComponentBitDepthFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoComponentBitDepthFlagsKHR).format;
};
pub const VideoCapabilityFlagsKHR = packed struct(Flags) {
    protected_content_bit_khr: bool = false,
    separate_reference_images_bit_khr: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoCapabilityFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoCapabilityFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoCapabilityFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoCapabilityFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoCapabilityFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoCapabilityFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoCapabilityFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoCapabilityFlagsKHR).format;
};
pub const VideoSessionCreateFlagsKHR = packed struct(Flags) {
    protected_content_bit_khr: bool = false,
    allow_encode_parameter_optimizations_bit_khr: bool = false,
    inline_queries_bit_khr: bool = false,
    allow_encode_quantization_delta_map_bit_khr: bool = false,
    allow_encode_emphasis_map_bit_khr: bool = false,
    inline_session_parameters_bit_khr: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoSessionCreateFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoSessionCreateFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoSessionCreateFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoSessionCreateFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoSessionCreateFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoSessionCreateFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoSessionCreateFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoSessionCreateFlagsKHR).format;
};
pub const VideoSessionParametersCreateFlagsKHR = packed struct(Flags) {
    quantization_map_compatible_bit_khr: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoSessionParametersCreateFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoSessionParametersCreateFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoSessionParametersCreateFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoSessionParametersCreateFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoSessionParametersCreateFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoSessionParametersCreateFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoSessionParametersCreateFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoSessionParametersCreateFlagsKHR).format;
};
pub const VideoDecodeH264PictureLayoutFlagsKHR = packed struct(Flags) {
    interlaced_interleaved_lines_bit_khr: bool = false,
    interlaced_separate_planes_bit_khr: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoDecodeH264PictureLayoutFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoDecodeH264PictureLayoutFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoDecodeH264PictureLayoutFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoDecodeH264PictureLayoutFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoDecodeH264PictureLayoutFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoDecodeH264PictureLayoutFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoDecodeH264PictureLayoutFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoDecodeH264PictureLayoutFlagsKHR).format;
};
pub const VideoCodingControlFlagsKHR = packed struct(Flags) {
    reset_bit_khr: bool = false,
    encode_rate_control_bit_khr: bool = false,
    encode_quality_level_bit_khr: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoCodingControlFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoCodingControlFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoCodingControlFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoCodingControlFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoCodingControlFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoCodingControlFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoCodingControlFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoCodingControlFlagsKHR).format;
};
pub const QueryResultStatusKHR = enum(i32) {
    error_khr = -1,
    not_ready_khr = 0,
    complete_khr = 1,
    insufficient_bitstream_buffer_range_khr = -1000299000,
    _,
};
pub const VideoDecodeUsageFlagsKHR = packed struct(Flags) {
    transcoding_bit_khr: bool = false,
    offline_bit_khr: bool = false,
    streaming_bit_khr: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoDecodeUsageFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoDecodeUsageFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoDecodeUsageFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoDecodeUsageFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoDecodeUsageFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoDecodeUsageFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoDecodeUsageFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoDecodeUsageFlagsKHR).format;
};
pub const VideoDecodeCapabilityFlagsKHR = packed struct(Flags) {
    dpb_and_output_coincide_bit_khr: bool = false,
    dpb_and_output_distinct_bit_khr: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoDecodeCapabilityFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoDecodeCapabilityFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoDecodeCapabilityFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoDecodeCapabilityFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoDecodeCapabilityFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoDecodeCapabilityFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoDecodeCapabilityFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoDecodeCapabilityFlagsKHR).format;
};
pub const VideoEncodeFlagsKHR = packed struct(Flags) {
    with_quantization_delta_map_bit_khr: bool = false,
    with_emphasis_map_bit_khr: bool = false,
    intra_refresh_bit_khr: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeFlagsKHR).format;
};
pub const VideoEncodeUsageFlagsKHR = packed struct(Flags) {
    transcoding_bit_khr: bool = false,
    streaming_bit_khr: bool = false,
    recording_bit_khr: bool = false,
    conferencing_bit_khr: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeUsageFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeUsageFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeUsageFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeUsageFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeUsageFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeUsageFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeUsageFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeUsageFlagsKHR).format;
};
pub const VideoEncodeContentFlagsKHR = packed struct(Flags) {
    camera_bit_khr: bool = false,
    desktop_bit_khr: bool = false,
    rendered_bit_khr: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeContentFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeContentFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeContentFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeContentFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeContentFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeContentFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeContentFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeContentFlagsKHR).format;
};
pub const VideoEncodeTuningModeKHR = enum(i32) {
    default_khr = 0,
    high_quality_khr = 1,
    low_latency_khr = 2,
    ultra_low_latency_khr = 3,
    lossless_khr = 4,
    _,
};
pub const VideoEncodeCapabilityFlagsKHR = packed struct(Flags) {
    preceding_externally_encoded_bytes_bit_khr: bool = false,
    insufficient_bitstream_buffer_range_detection_bit_khr: bool = false,
    quantization_delta_map_bit_khr: bool = false,
    emphasis_map_bit_khr: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeCapabilityFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeCapabilityFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeCapabilityFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeCapabilityFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeCapabilityFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeCapabilityFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeCapabilityFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeCapabilityFlagsKHR).format;
};
pub const VideoEncodeFeedbackFlagsKHR = packed struct(Flags) {
    bitstream_buffer_offset_bit_khr: bool = false,
    bitstream_bytes_written_bit_khr: bool = false,
    bitstream_has_overrides_bit_khr: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeFeedbackFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeFeedbackFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeFeedbackFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeFeedbackFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeFeedbackFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeFeedbackFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeFeedbackFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeFeedbackFlagsKHR).format;
};
pub const VideoEncodeRateControlModeFlagsKHR = packed struct(Flags) {
    disabled_bit_khr: bool = false,
    cbr_bit_khr: bool = false,
    vbr_bit_khr: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeRateControlModeFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeRateControlModeFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeRateControlModeFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeRateControlModeFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeRateControlModeFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeRateControlModeFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeRateControlModeFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeRateControlModeFlagsKHR).format;
};
pub const VideoEncodeIntraRefreshModeFlagsKHR = packed struct(Flags) {
    per_picture_partition_bit_khr: bool = false,
    block_based_bit_khr: bool = false,
    block_row_based_bit_khr: bool = false,
    block_column_based_bit_khr: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeIntraRefreshModeFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeIntraRefreshModeFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeIntraRefreshModeFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeIntraRefreshModeFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeIntraRefreshModeFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeIntraRefreshModeFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeIntraRefreshModeFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeIntraRefreshModeFlagsKHR).format;
};
pub const VideoEncodeH264CapabilityFlagsKHR = packed struct(Flags) {
    hrd_compliance_bit_khr: bool = false,
    prediction_weight_table_generated_bit_khr: bool = false,
    row_unaligned_slice_bit_khr: bool = false,
    different_slice_type_bit_khr: bool = false,
    b_frame_in_l0_list_bit_khr: bool = false,
    b_frame_in_l1_list_bit_khr: bool = false,
    per_picture_type_min_max_qp_bit_khr: bool = false,
    per_slice_constant_qp_bit_khr: bool = false,
    generate_prefix_nalu_bit_khr: bool = false,
    mb_qp_diff_wraparound_bit_khr: bool = false,
    b_picture_intra_refresh_bit_khr: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeH264CapabilityFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeH264CapabilityFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeH264CapabilityFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeH264CapabilityFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeH264CapabilityFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeH264CapabilityFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeH264CapabilityFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeH264CapabilityFlagsKHR).format;
};
pub const VideoEncodeH264StdFlagsKHR = packed struct(Flags) {
    separate_color_plane_flag_set_bit_khr: bool = false,
    qpprime_y_zero_transform_bypass_flag_set_bit_khr: bool = false,
    scaling_matrix_present_flag_set_bit_khr: bool = false,
    chroma_qp_index_offset_bit_khr: bool = false,
    second_chroma_qp_index_offset_bit_khr: bool = false,
    pic_init_qp_minus26_bit_khr: bool = false,
    weighted_pred_flag_set_bit_khr: bool = false,
    weighted_bipred_idc_explicit_bit_khr: bool = false,
    weighted_bipred_idc_implicit_bit_khr: bool = false,
    transform_8x8_mode_flag_set_bit_khr: bool = false,
    direct_spatial_mv_pred_flag_unset_bit_khr: bool = false,
    entropy_coding_mode_flag_unset_bit_khr: bool = false,
    entropy_coding_mode_flag_set_bit_khr: bool = false,
    direct_8x8_inference_flag_unset_bit_khr: bool = false,
    constrained_intra_pred_flag_set_bit_khr: bool = false,
    deblocking_filter_disabled_bit_khr: bool = false,
    deblocking_filter_enabled_bit_khr: bool = false,
    deblocking_filter_partial_bit_khr: bool = false,
    _reserved_bit_18: bool = false,
    slice_qp_delta_bit_khr: bool = false,
    different_slice_qp_delta_bit_khr: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeH264StdFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeH264StdFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeH264StdFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeH264StdFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeH264StdFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeH264StdFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeH264StdFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeH264StdFlagsKHR).format;
};
pub const VideoEncodeH264RateControlFlagsKHR = packed struct(Flags) {
    attempt_hrd_compliance_bit_khr: bool = false,
    regular_gop_bit_khr: bool = false,
    reference_pattern_flat_bit_khr: bool = false,
    reference_pattern_dyadic_bit_khr: bool = false,
    temporal_layer_pattern_dyadic_bit_khr: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeH264RateControlFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeH264RateControlFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeH264RateControlFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeH264RateControlFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeH264RateControlFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeH264RateControlFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeH264RateControlFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeH264RateControlFlagsKHR).format;
};
pub const HostImageCopyFlags = packed struct(Flags) {
    memcpy_bit: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(HostImageCopyFlags).toInt;
    pub const fromInt = FlagsMixin(HostImageCopyFlags).fromInt;
    pub const merge = FlagsMixin(HostImageCopyFlags).merge;
    pub const intersect = FlagsMixin(HostImageCopyFlags).intersect;
    pub const complement = FlagsMixin(HostImageCopyFlags).complement;
    pub const subtract = FlagsMixin(HostImageCopyFlags).subtract;
    pub const contains = FlagsMixin(HostImageCopyFlags).contains;
    pub const format = FlagFormatMixin(HostImageCopyFlags).format;
};
pub const PartitionedAccelerationStructureOpTypeNV = enum(i32) {
    write_instance_nv = 0,
    update_instance_nv = 1,
    write_partition_translation_nv = 2,
    _,
};
pub const PartitionedAccelerationStructureInstanceFlagsNV = packed struct(Flags) {
    flag_triangle_facing_cull_disable_bit_nv: bool = false,
    flag_triangle_flip_facing_bit_nv: bool = false,
    flag_force_opaque_bit_nv: bool = false,
    flag_force_no_opaque_bit_nv: bool = false,
    flag_enable_explicit_bounding_box_nv: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(PartitionedAccelerationStructureInstanceFlagsNV).toInt;
    pub const fromInt = FlagsMixin(PartitionedAccelerationStructureInstanceFlagsNV).fromInt;
    pub const merge = FlagsMixin(PartitionedAccelerationStructureInstanceFlagsNV).merge;
    pub const intersect = FlagsMixin(PartitionedAccelerationStructureInstanceFlagsNV).intersect;
    pub const complement = FlagsMixin(PartitionedAccelerationStructureInstanceFlagsNV).complement;
    pub const subtract = FlagsMixin(PartitionedAccelerationStructureInstanceFlagsNV).subtract;
    pub const contains = FlagsMixin(PartitionedAccelerationStructureInstanceFlagsNV).contains;
    pub const format = FlagFormatMixin(PartitionedAccelerationStructureInstanceFlagsNV).format;
};
pub const ImageConstraintsInfoFlagsFUCHSIA = packed struct(Flags) {
    cpu_read_rarely_fuchsia: bool = false,
    cpu_read_often_fuchsia: bool = false,
    cpu_write_rarely_fuchsia: bool = false,
    cpu_write_often_fuchsia: bool = false,
    protected_optional_fuchsia: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ImageConstraintsInfoFlagsFUCHSIA).toInt;
    pub const fromInt = FlagsMixin(ImageConstraintsInfoFlagsFUCHSIA).fromInt;
    pub const merge = FlagsMixin(ImageConstraintsInfoFlagsFUCHSIA).merge;
    pub const intersect = FlagsMixin(ImageConstraintsInfoFlagsFUCHSIA).intersect;
    pub const complement = FlagsMixin(ImageConstraintsInfoFlagsFUCHSIA).complement;
    pub const subtract = FlagsMixin(ImageConstraintsInfoFlagsFUCHSIA).subtract;
    pub const contains = FlagsMixin(ImageConstraintsInfoFlagsFUCHSIA).contains;
    pub const format = FlagFormatMixin(ImageConstraintsInfoFlagsFUCHSIA).format;
};
pub const FormatFeatureFlags2 = packed struct(Flags64) {
    sampled_image_bit: bool = false,
    storage_image_bit: bool = false,
    storage_image_atomic_bit: bool = false,
    uniform_texel_buffer_bit: bool = false,
    storage_texel_buffer_bit: bool = false,
    storage_texel_buffer_atomic_bit: bool = false,
    vertex_buffer_bit: bool = false,
    color_attachment_bit: bool = false,
    color_attachment_blend_bit: bool = false,
    depth_stencil_attachment_bit: bool = false,
    blit_src_bit: bool = false,
    blit_dst_bit: bool = false,
    sampled_image_filter_linear_bit: bool = false,
    sampled_image_filter_cubic_bit: bool = false,
    transfer_src_bit: bool = false,
    transfer_dst_bit: bool = false,
    sampled_image_filter_minmax_bit: bool = false,
    midpoint_chroma_samples_bit: bool = false,
    sampled_image_ycbcr_conversion_linear_filter_bit: bool = false,
    sampled_image_ycbcr_conversion_separate_reconstruction_filter_bit: bool = false,
    sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_bit: bool = false,
    sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_forceable_bit: bool = false,
    disjoint_bit: bool = false,
    cosited_chroma_samples_bit: bool = false,
    fragment_density_map_bit_ext: bool = false,
    video_decode_output_bit_khr: bool = false,
    video_decode_dpb_bit_khr: bool = false,
    video_encode_input_bit_khr: bool = false,
    video_encode_dpb_bit_khr: bool = false,
    acceleration_structure_vertex_buffer_bit_khr: bool = false,
    fragment_shading_rate_attachment_bit_khr: bool = false,
    storage_read_without_format_bit: bool = false,
    storage_write_without_format_bit: bool = false,
    sampled_image_depth_comparison_bit: bool = false,
    weight_image_bit_qcom: bool = false,
    weight_sampled_image_bit_qcom: bool = false,
    block_matching_bit_qcom: bool = false,
    box_filter_sampled_bit_qcom: bool = false,
    linear_color_attachment_bit_nv: bool = false,
    tensor_shader_bit_arm: bool = false,
    optical_flow_image_bit_nv: bool = false,
    optical_flow_vector_bit_nv: bool = false,
    optical_flow_cost_bit_nv: bool = false,
    tensor_image_aliasing_bit_arm: bool = false,
    _reserved_bit_44: bool = false,
    _reserved_bit_45: bool = false,
    host_image_transfer_bit: bool = false,
    _reserved_bit_47: bool = false,
    tensor_data_graph_bit_arm: bool = false,
    video_encode_quantization_delta_map_bit_khr: bool = false,
    video_encode_emphasis_map_bit_khr: bool = false,
    acceleration_structure_radius_buffer_bit_nv: bool = false,
    _reserved_bit_52: bool = false,
    _reserved_bit_53: bool = false,
    _reserved_bit_54: bool = false,
    _reserved_bit_55: bool = false,
    _reserved_bit_56: bool = false,
    _reserved_bit_57: bool = false,
    _reserved_bit_58: bool = false,
    _reserved_bit_59: bool = false,
    _reserved_bit_60: bool = false,
    _reserved_bit_61: bool = false,
    _reserved_bit_62: bool = false,
    _reserved_bit_63: bool = false,
    pub const toInt = FlagsMixin(FormatFeatureFlags2).toInt;
    pub const fromInt = FlagsMixin(FormatFeatureFlags2).fromInt;
    pub const merge = FlagsMixin(FormatFeatureFlags2).merge;
    pub const intersect = FlagsMixin(FormatFeatureFlags2).intersect;
    pub const complement = FlagsMixin(FormatFeatureFlags2).complement;
    pub const subtract = FlagsMixin(FormatFeatureFlags2).subtract;
    pub const contains = FlagsMixin(FormatFeatureFlags2).contains;
    pub const format = FlagFormatMixin(FormatFeatureFlags2).format;
};
pub const RenderingFlags = packed struct(Flags) {
    contents_secondary_command_buffers_bit: bool = false,
    suspending_bit: bool = false,
    resuming_bit: bool = false,
    enable_legacy_dithering_bit_ext: bool = false,
    contents_inline_bit_khr: bool = false,
    per_layer_fragment_density_bit_valve: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(RenderingFlags).toInt;
    pub const fromInt = FlagsMixin(RenderingFlags).fromInt;
    pub const merge = FlagsMixin(RenderingFlags).merge;
    pub const intersect = FlagsMixin(RenderingFlags).intersect;
    pub const complement = FlagsMixin(RenderingFlags).complement;
    pub const subtract = FlagsMixin(RenderingFlags).subtract;
    pub const contains = FlagsMixin(RenderingFlags).contains;
    pub const format = FlagFormatMixin(RenderingFlags).format;
};
pub const VideoEncodeH265CapabilityFlagsKHR = packed struct(Flags) {
    hrd_compliance_bit_khr: bool = false,
    prediction_weight_table_generated_bit_khr: bool = false,
    row_unaligned_slice_segment_bit_khr: bool = false,
    different_slice_segment_type_bit_khr: bool = false,
    b_frame_in_l0_list_bit_khr: bool = false,
    b_frame_in_l1_list_bit_khr: bool = false,
    per_picture_type_min_max_qp_bit_khr: bool = false,
    per_slice_segment_constant_qp_bit_khr: bool = false,
    multiple_tiles_per_slice_segment_bit_khr: bool = false,
    multiple_slice_segments_per_tile_bit_khr: bool = false,
    cu_qp_diff_wraparound_bit_khr: bool = false,
    b_picture_intra_refresh_bit_khr: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeH265CapabilityFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeH265CapabilityFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeH265CapabilityFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeH265CapabilityFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeH265CapabilityFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeH265CapabilityFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeH265CapabilityFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeH265CapabilityFlagsKHR).format;
};
pub const VideoEncodeH265StdFlagsKHR = packed struct(Flags) {
    separate_color_plane_flag_set_bit_khr: bool = false,
    sample_adaptive_offset_enabled_flag_set_bit_khr: bool = false,
    scaling_list_data_present_flag_set_bit_khr: bool = false,
    pcm_enabled_flag_set_bit_khr: bool = false,
    sps_temporal_mvp_enabled_flag_set_bit_khr: bool = false,
    init_qp_minus26_bit_khr: bool = false,
    weighted_pred_flag_set_bit_khr: bool = false,
    weighted_bipred_flag_set_bit_khr: bool = false,
    log2_parallel_merge_level_minus2_bit_khr: bool = false,
    sign_data_hiding_enabled_flag_set_bit_khr: bool = false,
    transform_skip_enabled_flag_set_bit_khr: bool = false,
    transform_skip_enabled_flag_unset_bit_khr: bool = false,
    pps_slice_chroma_qp_offsets_present_flag_set_bit_khr: bool = false,
    transquant_bypass_enabled_flag_set_bit_khr: bool = false,
    constrained_intra_pred_flag_set_bit_khr: bool = false,
    entropy_coding_sync_enabled_flag_set_bit_khr: bool = false,
    deblocking_filter_override_enabled_flag_set_bit_khr: bool = false,
    dependent_slice_segments_enabled_flag_set_bit_khr: bool = false,
    dependent_slice_segment_flag_set_bit_khr: bool = false,
    slice_qp_delta_bit_khr: bool = false,
    different_slice_qp_delta_bit_khr: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeH265StdFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeH265StdFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeH265StdFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeH265StdFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeH265StdFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeH265StdFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeH265StdFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeH265StdFlagsKHR).format;
};
pub const VideoEncodeH265RateControlFlagsKHR = packed struct(Flags) {
    attempt_hrd_compliance_bit_khr: bool = false,
    regular_gop_bit_khr: bool = false,
    reference_pattern_flat_bit_khr: bool = false,
    reference_pattern_dyadic_bit_khr: bool = false,
    temporal_sub_layer_pattern_dyadic_bit_khr: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeH265RateControlFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeH265RateControlFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeH265RateControlFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeH265RateControlFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeH265RateControlFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeH265RateControlFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeH265RateControlFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeH265RateControlFlagsKHR).format;
};
pub const VideoEncodeH265CtbSizeFlagsKHR = packed struct(Flags) {
    @"16_bit_khr": bool = false,
    @"32_bit_khr": bool = false,
    @"64_bit_khr": bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeH265CtbSizeFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeH265CtbSizeFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeH265CtbSizeFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeH265CtbSizeFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeH265CtbSizeFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeH265CtbSizeFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeH265CtbSizeFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeH265CtbSizeFlagsKHR).format;
};
pub const VideoEncodeH265TransformBlockSizeFlagsKHR = packed struct(Flags) {
    @"4_bit_khr": bool = false,
    @"8_bit_khr": bool = false,
    @"16_bit_khr": bool = false,
    @"32_bit_khr": bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeH265TransformBlockSizeFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeH265TransformBlockSizeFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeH265TransformBlockSizeFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeH265TransformBlockSizeFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeH265TransformBlockSizeFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeH265TransformBlockSizeFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeH265TransformBlockSizeFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeH265TransformBlockSizeFlagsKHR).format;
};
pub const VideoEncodeAV1CapabilityFlagsKHR = packed struct(Flags) {
    per_rate_control_group_min_max_q_index_bit_khr: bool = false,
    generate_obu_extension_header_bit_khr: bool = false,
    primary_reference_cdf_only_bit_khr: bool = false,
    frame_size_override_bit_khr: bool = false,
    motion_vector_scaling_bit_khr: bool = false,
    compound_prediction_intra_refresh_bit_khr: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeAV1CapabilityFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeAV1CapabilityFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeAV1CapabilityFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeAV1CapabilityFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeAV1CapabilityFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeAV1CapabilityFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeAV1CapabilityFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeAV1CapabilityFlagsKHR).format;
};
pub const VideoEncodeAV1StdFlagsKHR = packed struct(Flags) {
    uniform_tile_spacing_flag_set_bit_khr: bool = false,
    skip_mode_present_unset_bit_khr: bool = false,
    primary_ref_frame_bit_khr: bool = false,
    delta_q_bit_khr: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeAV1StdFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeAV1StdFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeAV1StdFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeAV1StdFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeAV1StdFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeAV1StdFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeAV1StdFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeAV1StdFlagsKHR).format;
};
pub const VideoEncodeAV1RateControlFlagsKHR = packed struct(Flags) {
    regular_gop_bit_khr: bool = false,
    temporal_layer_pattern_dyadic_bit_khr: bool = false,
    reference_pattern_flat_bit_khr: bool = false,
    reference_pattern_dyadic_bit_khr: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeAV1RateControlFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeAV1RateControlFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeAV1RateControlFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeAV1RateControlFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeAV1RateControlFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeAV1RateControlFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeAV1RateControlFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeAV1RateControlFlagsKHR).format;
};
pub const VideoEncodeAV1SuperblockSizeFlagsKHR = packed struct(Flags) {
    @"64_bit_khr": bool = false,
    @"128_bit_khr": bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(VideoEncodeAV1SuperblockSizeFlagsKHR).toInt;
    pub const fromInt = FlagsMixin(VideoEncodeAV1SuperblockSizeFlagsKHR).fromInt;
    pub const merge = FlagsMixin(VideoEncodeAV1SuperblockSizeFlagsKHR).merge;
    pub const intersect = FlagsMixin(VideoEncodeAV1SuperblockSizeFlagsKHR).intersect;
    pub const complement = FlagsMixin(VideoEncodeAV1SuperblockSizeFlagsKHR).complement;
    pub const subtract = FlagsMixin(VideoEncodeAV1SuperblockSizeFlagsKHR).subtract;
    pub const contains = FlagsMixin(VideoEncodeAV1SuperblockSizeFlagsKHR).contains;
    pub const format = FlagFormatMixin(VideoEncodeAV1SuperblockSizeFlagsKHR).format;
};
pub const VideoEncodeAV1PredictionModeKHR = enum(i32) {
    intra_only_khr = 0,
    single_reference_khr = 1,
    unidirectional_compound_khr = 2,
    bidirectional_compound_khr = 3,
    _,
};
pub const VideoEncodeAV1RateControlGroupKHR = enum(i32) {
    intra_khr = 0,
    predictive_khr = 1,
    bipredictive_khr = 2,
    _,
};
pub const ExportMetalObjectTypeFlagsEXT = packed struct(Flags) {
    metal_device_bit_ext: bool = false,
    metal_command_queue_bit_ext: bool = false,
    metal_buffer_bit_ext: bool = false,
    metal_texture_bit_ext: bool = false,
    metal_iosurface_bit_ext: bool = false,
    metal_shared_event_bit_ext: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ExportMetalObjectTypeFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(ExportMetalObjectTypeFlagsEXT).fromInt;
    pub const merge = FlagsMixin(ExportMetalObjectTypeFlagsEXT).merge;
    pub const intersect = FlagsMixin(ExportMetalObjectTypeFlagsEXT).intersect;
    pub const complement = FlagsMixin(ExportMetalObjectTypeFlagsEXT).complement;
    pub const subtract = FlagsMixin(ExportMetalObjectTypeFlagsEXT).subtract;
    pub const contains = FlagsMixin(ExportMetalObjectTypeFlagsEXT).contains;
    pub const format = FlagFormatMixin(ExportMetalObjectTypeFlagsEXT).format;
};
pub const InstanceCreateFlags = packed struct(Flags) {
    enumerate_portability_bit_khr: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(InstanceCreateFlags).toInt;
    pub const fromInt = FlagsMixin(InstanceCreateFlags).fromInt;
    pub const merge = FlagsMixin(InstanceCreateFlags).merge;
    pub const intersect = FlagsMixin(InstanceCreateFlags).intersect;
    pub const complement = FlagsMixin(InstanceCreateFlags).complement;
    pub const subtract = FlagsMixin(InstanceCreateFlags).subtract;
    pub const contains = FlagsMixin(InstanceCreateFlags).contains;
    pub const format = FlagFormatMixin(InstanceCreateFlags).format;
};
pub const ImageCompressionFlagsEXT = packed struct(Flags) {
    fixed_rate_default_ext: bool = false,
    fixed_rate_explicit_ext: bool = false,
    disabled_ext: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ImageCompressionFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(ImageCompressionFlagsEXT).fromInt;
    pub const merge = FlagsMixin(ImageCompressionFlagsEXT).merge;
    pub const intersect = FlagsMixin(ImageCompressionFlagsEXT).intersect;
    pub const complement = FlagsMixin(ImageCompressionFlagsEXT).complement;
    pub const subtract = FlagsMixin(ImageCompressionFlagsEXT).subtract;
    pub const contains = FlagsMixin(ImageCompressionFlagsEXT).contains;
    pub const format = FlagFormatMixin(ImageCompressionFlagsEXT).format;
};
pub const ImageCompressionFixedRateFlagsEXT = packed struct(Flags) {
    @"1bpc_bit_ext": bool = false,
    @"2bpc_bit_ext": bool = false,
    @"3bpc_bit_ext": bool = false,
    @"4bpc_bit_ext": bool = false,
    @"5bpc_bit_ext": bool = false,
    @"6bpc_bit_ext": bool = false,
    @"7bpc_bit_ext": bool = false,
    @"8bpc_bit_ext": bool = false,
    @"9bpc_bit_ext": bool = false,
    @"10bpc_bit_ext": bool = false,
    @"11bpc_bit_ext": bool = false,
    @"12bpc_bit_ext": bool = false,
    @"13bpc_bit_ext": bool = false,
    @"14bpc_bit_ext": bool = false,
    @"15bpc_bit_ext": bool = false,
    @"16bpc_bit_ext": bool = false,
    @"17bpc_bit_ext": bool = false,
    @"18bpc_bit_ext": bool = false,
    @"19bpc_bit_ext": bool = false,
    @"20bpc_bit_ext": bool = false,
    @"21bpc_bit_ext": bool = false,
    @"22bpc_bit_ext": bool = false,
    @"23bpc_bit_ext": bool = false,
    @"24bpc_bit_ext": bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ImageCompressionFixedRateFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(ImageCompressionFixedRateFlagsEXT).fromInt;
    pub const merge = FlagsMixin(ImageCompressionFixedRateFlagsEXT).merge;
    pub const intersect = FlagsMixin(ImageCompressionFixedRateFlagsEXT).intersect;
    pub const complement = FlagsMixin(ImageCompressionFixedRateFlagsEXT).complement;
    pub const subtract = FlagsMixin(ImageCompressionFixedRateFlagsEXT).subtract;
    pub const contains = FlagsMixin(ImageCompressionFixedRateFlagsEXT).contains;
    pub const format = FlagFormatMixin(ImageCompressionFixedRateFlagsEXT).format;
};
pub const PipelineRobustnessBufferBehavior = enum(i32) {
    device_default = 0,
    disabled = 1,
    robust_buffer_access = 2,
    robust_buffer_access_2 = 3,
    _,
    pub const device_default_ext = PipelineRobustnessBufferBehavior.device_default;
    pub const disabled_ext = PipelineRobustnessBufferBehavior.disabled;
    pub const robust_buffer_access_ext = PipelineRobustnessBufferBehavior.robust_buffer_access;
    pub const robust_buffer_access_2_ext = PipelineRobustnessBufferBehavior.robust_buffer_access_2;
};
pub const PipelineRobustnessImageBehavior = enum(i32) {
    device_default = 0,
    disabled = 1,
    robust_image_access = 2,
    robust_image_access_2 = 3,
    _,
    pub const device_default_ext = PipelineRobustnessImageBehavior.device_default;
    pub const disabled_ext = PipelineRobustnessImageBehavior.disabled;
    pub const robust_image_access_ext = PipelineRobustnessImageBehavior.robust_image_access;
    pub const robust_image_access_2_ext = PipelineRobustnessImageBehavior.robust_image_access_2;
};
pub const OpticalFlowGridSizeFlagsNV = packed struct(Flags) {
    @"1x1_bit_nv": bool = false,
    @"2x2_bit_nv": bool = false,
    @"4x4_bit_nv": bool = false,
    @"8x8_bit_nv": bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(OpticalFlowGridSizeFlagsNV).toInt;
    pub const fromInt = FlagsMixin(OpticalFlowGridSizeFlagsNV).fromInt;
    pub const merge = FlagsMixin(OpticalFlowGridSizeFlagsNV).merge;
    pub const intersect = FlagsMixin(OpticalFlowGridSizeFlagsNV).intersect;
    pub const complement = FlagsMixin(OpticalFlowGridSizeFlagsNV).complement;
    pub const subtract = FlagsMixin(OpticalFlowGridSizeFlagsNV).subtract;
    pub const contains = FlagsMixin(OpticalFlowGridSizeFlagsNV).contains;
    pub const format = FlagFormatMixin(OpticalFlowGridSizeFlagsNV).format;
};
pub const OpticalFlowUsageFlagsNV = packed struct(Flags) {
    input_bit_nv: bool = false,
    output_bit_nv: bool = false,
    hint_bit_nv: bool = false,
    cost_bit_nv: bool = false,
    global_flow_bit_nv: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(OpticalFlowUsageFlagsNV).toInt;
    pub const fromInt = FlagsMixin(OpticalFlowUsageFlagsNV).fromInt;
    pub const merge = FlagsMixin(OpticalFlowUsageFlagsNV).merge;
    pub const intersect = FlagsMixin(OpticalFlowUsageFlagsNV).intersect;
    pub const complement = FlagsMixin(OpticalFlowUsageFlagsNV).complement;
    pub const subtract = FlagsMixin(OpticalFlowUsageFlagsNV).subtract;
    pub const contains = FlagsMixin(OpticalFlowUsageFlagsNV).contains;
    pub const format = FlagFormatMixin(OpticalFlowUsageFlagsNV).format;
};
pub const OpticalFlowPerformanceLevelNV = enum(i32) {
    unknown_nv = 0,
    slow_nv = 1,
    medium_nv = 2,
    fast_nv = 3,
    _,
};
pub const OpticalFlowSessionBindingPointNV = enum(i32) {
    unknown_nv = 0,
    input_nv = 1,
    reference_nv = 2,
    hint_nv = 3,
    flow_vector_nv = 4,
    backward_flow_vector_nv = 5,
    cost_nv = 6,
    backward_cost_nv = 7,
    global_flow_nv = 8,
    _,
};
pub const OpticalFlowSessionCreateFlagsNV = packed struct(Flags) {
    enable_hint_bit_nv: bool = false,
    enable_cost_bit_nv: bool = false,
    enable_global_flow_bit_nv: bool = false,
    allow_regions_bit_nv: bool = false,
    both_directions_bit_nv: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(OpticalFlowSessionCreateFlagsNV).toInt;
    pub const fromInt = FlagsMixin(OpticalFlowSessionCreateFlagsNV).fromInt;
    pub const merge = FlagsMixin(OpticalFlowSessionCreateFlagsNV).merge;
    pub const intersect = FlagsMixin(OpticalFlowSessionCreateFlagsNV).intersect;
    pub const complement = FlagsMixin(OpticalFlowSessionCreateFlagsNV).complement;
    pub const subtract = FlagsMixin(OpticalFlowSessionCreateFlagsNV).subtract;
    pub const contains = FlagsMixin(OpticalFlowSessionCreateFlagsNV).contains;
    pub const format = FlagFormatMixin(OpticalFlowSessionCreateFlagsNV).format;
};
pub const OpticalFlowExecuteFlagsNV = packed struct(Flags) {
    disable_temporal_hints_bit_nv: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(OpticalFlowExecuteFlagsNV).toInt;
    pub const fromInt = FlagsMixin(OpticalFlowExecuteFlagsNV).fromInt;
    pub const merge = FlagsMixin(OpticalFlowExecuteFlagsNV).merge;
    pub const intersect = FlagsMixin(OpticalFlowExecuteFlagsNV).intersect;
    pub const complement = FlagsMixin(OpticalFlowExecuteFlagsNV).complement;
    pub const subtract = FlagsMixin(OpticalFlowExecuteFlagsNV).subtract;
    pub const contains = FlagsMixin(OpticalFlowExecuteFlagsNV).contains;
    pub const format = FlagFormatMixin(OpticalFlowExecuteFlagsNV).format;
};
pub const MicromapTypeEXT = enum(i32) {
    opacity_micromap_ext = 0,
    displacement_micromap_nv = 1000397000,
    _,
};
pub const BuildMicromapFlagsEXT = packed struct(Flags) {
    prefer_fast_trace_bit_ext: bool = false,
    prefer_fast_build_bit_ext: bool = false,
    allow_compaction_bit_ext: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(BuildMicromapFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(BuildMicromapFlagsEXT).fromInt;
    pub const merge = FlagsMixin(BuildMicromapFlagsEXT).merge;
    pub const intersect = FlagsMixin(BuildMicromapFlagsEXT).intersect;
    pub const complement = FlagsMixin(BuildMicromapFlagsEXT).complement;
    pub const subtract = FlagsMixin(BuildMicromapFlagsEXT).subtract;
    pub const contains = FlagsMixin(BuildMicromapFlagsEXT).contains;
    pub const format = FlagFormatMixin(BuildMicromapFlagsEXT).format;
};
pub const MicromapCreateFlagsEXT = packed struct(Flags) {
    device_address_capture_replay_bit_ext: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(MicromapCreateFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(MicromapCreateFlagsEXT).fromInt;
    pub const merge = FlagsMixin(MicromapCreateFlagsEXT).merge;
    pub const intersect = FlagsMixin(MicromapCreateFlagsEXT).intersect;
    pub const complement = FlagsMixin(MicromapCreateFlagsEXT).complement;
    pub const subtract = FlagsMixin(MicromapCreateFlagsEXT).subtract;
    pub const contains = FlagsMixin(MicromapCreateFlagsEXT).contains;
    pub const format = FlagFormatMixin(MicromapCreateFlagsEXT).format;
};
pub const CopyMicromapModeEXT = enum(i32) {
    clone_ext = 0,
    serialize_ext = 1,
    deserialize_ext = 2,
    compact_ext = 3,
    _,
};
pub const BuildMicromapModeEXT = enum(i32) {
    build_ext = 0,
    _,
};
pub const OpacityMicromapFormatEXT = enum(i32) {
    @"2_state_ext" = 1,
    @"4_state_ext" = 2,
    _,
};
pub const OpacityMicromapSpecialIndexEXT = enum(i32) {
    fully_transparent_ext = -1,
    fully_opaque_ext = -2,
    fully_unknown_transparent_ext = -3,
    fully_unknown_opaque_ext = -4,
    cluster_geometry_disable_opacity_micromap_nv = -5,
    _,
};
pub const DepthBiasRepresentationEXT = enum(i32) {
    least_representable_value_format_ext = 0,
    least_representable_value_force_unorm_ext = 1,
    float_ext = 2,
    _,
};
pub const DeviceFaultAddressTypeEXT = enum(i32) {
    none_ext = 0,
    read_invalid_ext = 1,
    write_invalid_ext = 2,
    execute_invalid_ext = 3,
    instruction_pointer_unknown_ext = 4,
    instruction_pointer_invalid_ext = 5,
    instruction_pointer_fault_ext = 6,
    _,
};
pub const DeviceFaultVendorBinaryHeaderVersionEXT = enum(i32) {
    one_ext = 1,
    _,
};
pub const IndirectCommandsLayoutUsageFlagsEXT = packed struct(Flags) {
    explicit_preprocess_bit_ext: bool = false,
    unordered_sequences_bit_ext: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(IndirectCommandsLayoutUsageFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(IndirectCommandsLayoutUsageFlagsEXT).fromInt;
    pub const merge = FlagsMixin(IndirectCommandsLayoutUsageFlagsEXT).merge;
    pub const intersect = FlagsMixin(IndirectCommandsLayoutUsageFlagsEXT).intersect;
    pub const complement = FlagsMixin(IndirectCommandsLayoutUsageFlagsEXT).complement;
    pub const subtract = FlagsMixin(IndirectCommandsLayoutUsageFlagsEXT).subtract;
    pub const contains = FlagsMixin(IndirectCommandsLayoutUsageFlagsEXT).contains;
    pub const format = FlagFormatMixin(IndirectCommandsLayoutUsageFlagsEXT).format;
};
pub const IndirectExecutionSetInfoTypeEXT = enum(i32) {
    pipelines_ext = 0,
    shader_objects_ext = 1,
    _,
};
pub const IndirectCommandsInputModeFlagsEXT = packed struct(Flags) {
    vulkan_index_buffer_ext: bool = false,
    dxgi_index_buffer_ext: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(IndirectCommandsInputModeFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(IndirectCommandsInputModeFlagsEXT).fromInt;
    pub const merge = FlagsMixin(IndirectCommandsInputModeFlagsEXT).merge;
    pub const intersect = FlagsMixin(IndirectCommandsInputModeFlagsEXT).intersect;
    pub const complement = FlagsMixin(IndirectCommandsInputModeFlagsEXT).complement;
    pub const subtract = FlagsMixin(IndirectCommandsInputModeFlagsEXT).subtract;
    pub const contains = FlagsMixin(IndirectCommandsInputModeFlagsEXT).contains;
    pub const format = FlagFormatMixin(IndirectCommandsInputModeFlagsEXT).format;
};
pub const IndirectCommandsTokenTypeEXT = enum(i32) {
    execution_set_ext = 0,
    push_constant_ext = 1,
    sequence_index_ext = 2,
    index_buffer_ext = 3,
    vertex_buffer_ext = 4,
    draw_indexed_ext = 5,
    draw_ext = 6,
    draw_indexed_count_ext = 7,
    draw_count_ext = 8,
    dispatch_ext = 9,
    draw_mesh_tasks_nv_ext = 1000202002,
    draw_mesh_tasks_count_nv_ext = 1000202003,
    draw_mesh_tasks_ext = 1000328000,
    draw_mesh_tasks_count_ext = 1000328001,
    trace_rays2_ext = 1000386004,
    _,
};
pub const DisplacementMicromapFormatNV = enum(i32) {
    @"64_triangles_64_bytes_nv" = 1,
    @"256_triangles_128_bytes_nv" = 2,
    @"1024_triangles_128_bytes_nv" = 3,
    _,
};
pub const ShaderCreateFlagsEXT = packed struct(Flags) {
    link_stage_bit_ext: bool = false,
    allow_varying_subgroup_size_bit_ext: bool = false,
    require_full_subgroups_bit_ext: bool = false,
    no_task_shader_bit_ext: bool = false,
    dispatch_base_bit_ext: bool = false,
    fragment_shading_rate_attachment_bit_ext: bool = false,
    fragment_density_map_attachment_bit_ext: bool = false,
    indirect_bindable_bit_ext: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(ShaderCreateFlagsEXT).toInt;
    pub const fromInt = FlagsMixin(ShaderCreateFlagsEXT).fromInt;
    pub const merge = FlagsMixin(ShaderCreateFlagsEXT).merge;
    pub const intersect = FlagsMixin(ShaderCreateFlagsEXT).intersect;
    pub const complement = FlagsMixin(ShaderCreateFlagsEXT).complement;
    pub const subtract = FlagsMixin(ShaderCreateFlagsEXT).subtract;
    pub const contains = FlagsMixin(ShaderCreateFlagsEXT).contains;
    pub const format = FlagFormatMixin(ShaderCreateFlagsEXT).format;
};
pub const ShaderCodeTypeEXT = enum(i32) {
    binary_ext = 0,
    spirv_ext = 1,
    _,
};
pub const ScopeKHR = enum(i32) {
    device_khr = 1,
    workgroup_khr = 2,
    subgroup_khr = 3,
    queue_family_khr = 5,
    _,
    pub const device_nv = ScopeKHR.device_khr;
    pub const workgroup_nv = ScopeKHR.workgroup_khr;
    pub const subgroup_nv = ScopeKHR.subgroup_khr;
    pub const queue_family_nv = ScopeKHR.queue_family_khr;
};
pub const ComponentTypeKHR = enum(i32) {
    float16_khr = 0,
    float32_khr = 1,
    float64_khr = 2,
    sint8_khr = 3,
    sint16_khr = 4,
    sint32_khr = 5,
    sint64_khr = 6,
    uint8_khr = 7,
    uint16_khr = 8,
    uint32_khr = 9,
    uint64_khr = 10,
    bfloat16_khr = 1000141000,
    sint8_packed_nv = 1000491000,
    uint8_packed_nv = 1000491001,
    float8_e4m3_ext = 1000491002,
    float8_e5m2_ext = 1000491003,
    _,
    pub const float16_nv = ComponentTypeKHR.float16_khr;
    pub const float32_nv = ComponentTypeKHR.float32_khr;
    pub const float64_nv = ComponentTypeKHR.float64_khr;
    pub const sint8_nv = ComponentTypeKHR.sint8_khr;
    pub const sint16_nv = ComponentTypeKHR.sint16_khr;
    pub const sint32_nv = ComponentTypeKHR.sint32_khr;
    pub const sint64_nv = ComponentTypeKHR.sint64_khr;
    pub const uint8_nv = ComponentTypeKHR.uint8_khr;
    pub const uint16_nv = ComponentTypeKHR.uint16_khr;
    pub const uint32_nv = ComponentTypeKHR.uint32_khr;
    pub const uint64_nv = ComponentTypeKHR.uint64_khr;
    pub const float_e4m3_nv = ComponentTypeKHR.float8_e4m3_ext;
    pub const float_e5m2_nv = ComponentTypeKHR.float8_e5m2_ext;
};
pub const CubicFilterWeightsQCOM = enum(i32) {
    catmull_rom_qcom = 0,
    zero_tangent_cardinal_qcom = 1,
    b_spline_qcom = 2,
    mitchell_netravali_qcom = 3,
    _,
};
pub const BlockMatchWindowCompareModeQCOM = enum(i32) {
    min_qcom = 0,
    max_qcom = 1,
    _,
};
pub const PhysicalDeviceLayeredApiKHR = enum(i32) {
    vulkan_khr = 0,
    d3d12_khr = 1,
    metal_khr = 2,
    opengl_khr = 3,
    opengles_khr = 4,
    _,
};
pub const LayeredDriverUnderlyingApiMSFT = enum(i32) {
    none_msft = 0,
    d3d12_msft = 1,
    _,
};
pub const LatencyMarkerNV = enum(i32) {
    simulation_start_nv = 0,
    simulation_end_nv = 1,
    rendersubmit_start_nv = 2,
    rendersubmit_end_nv = 3,
    present_start_nv = 4,
    present_end_nv = 5,
    input_sample_nv = 6,
    trigger_flash_nv = 7,
    out_of_band_rendersubmit_start_nv = 8,
    out_of_band_rendersubmit_end_nv = 9,
    out_of_band_present_start_nv = 10,
    out_of_band_present_end_nv = 11,
    _,
};
pub const OutOfBandQueueTypeNV = enum(i32) {
    render_nv = 0,
    present_nv = 1,
    _,
};
pub const MemoryUnmapFlags = packed struct(Flags) {
    reserve_bit_ext: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(MemoryUnmapFlags).toInt;
    pub const fromInt = FlagsMixin(MemoryUnmapFlags).fromInt;
    pub const merge = FlagsMixin(MemoryUnmapFlags).merge;
    pub const intersect = FlagsMixin(MemoryUnmapFlags).intersect;
    pub const complement = FlagsMixin(MemoryUnmapFlags).complement;
    pub const subtract = FlagsMixin(MemoryUnmapFlags).subtract;
    pub const contains = FlagsMixin(MemoryUnmapFlags).contains;
    pub const format = FlagFormatMixin(MemoryUnmapFlags).format;
};
pub const DepthClampModeEXT = enum(i32) {
    viewport_range_ext = 0,
    user_defined_range_ext = 1,
    _,
};
pub const AccessFlags3KHR = packed struct(Flags64) {
    _reserved_bit_0: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    _reserved_bit_32: bool = false,
    _reserved_bit_33: bool = false,
    _reserved_bit_34: bool = false,
    _reserved_bit_35: bool = false,
    _reserved_bit_36: bool = false,
    _reserved_bit_37: bool = false,
    _reserved_bit_38: bool = false,
    _reserved_bit_39: bool = false,
    _reserved_bit_40: bool = false,
    _reserved_bit_41: bool = false,
    _reserved_bit_42: bool = false,
    _reserved_bit_43: bool = false,
    _reserved_bit_44: bool = false,
    _reserved_bit_45: bool = false,
    _reserved_bit_46: bool = false,
    _reserved_bit_47: bool = false,
    _reserved_bit_48: bool = false,
    _reserved_bit_49: bool = false,
    _reserved_bit_50: bool = false,
    _reserved_bit_51: bool = false,
    _reserved_bit_52: bool = false,
    _reserved_bit_53: bool = false,
    _reserved_bit_54: bool = false,
    _reserved_bit_55: bool = false,
    _reserved_bit_56: bool = false,
    _reserved_bit_57: bool = false,
    _reserved_bit_58: bool = false,
    _reserved_bit_59: bool = false,
    _reserved_bit_60: bool = false,
    _reserved_bit_61: bool = false,
    _reserved_bit_62: bool = false,
    _reserved_bit_63: bool = false,
    pub const toInt = FlagsMixin(AccessFlags3KHR).toInt;
    pub const fromInt = FlagsMixin(AccessFlags3KHR).fromInt;
    pub const merge = FlagsMixin(AccessFlags3KHR).merge;
    pub const intersect = FlagsMixin(AccessFlags3KHR).intersect;
    pub const complement = FlagsMixin(AccessFlags3KHR).complement;
    pub const subtract = FlagsMixin(AccessFlags3KHR).subtract;
    pub const contains = FlagsMixin(AccessFlags3KHR).contains;
    pub const format = FlagFormatMixin(AccessFlags3KHR).format;
};
pub const TileShadingRenderPassFlagsQCOM = packed struct(Flags) {
    enable_bit_qcom: bool = false,
    per_tile_execution_bit_qcom: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    pub const toInt = FlagsMixin(TileShadingRenderPassFlagsQCOM).toInt;
    pub const fromInt = FlagsMixin(TileShadingRenderPassFlagsQCOM).fromInt;
    pub const merge = FlagsMixin(TileShadingRenderPassFlagsQCOM).merge;
    pub const intersect = FlagsMixin(TileShadingRenderPassFlagsQCOM).intersect;
    pub const complement = FlagsMixin(TileShadingRenderPassFlagsQCOM).complement;
    pub const subtract = FlagsMixin(TileShadingRenderPassFlagsQCOM).subtract;
    pub const contains = FlagsMixin(TileShadingRenderPassFlagsQCOM).contains;
    pub const format = FlagFormatMixin(TileShadingRenderPassFlagsQCOM).format;
};
pub const CooperativeVectorMatrixLayoutNV = enum(i32) {
    row_major_nv = 0,
    column_major_nv = 1,
    inferencing_optimal_nv = 2,
    training_optimal_nv = 3,
    _,
};
pub const TensorCreateFlagsARM = packed struct(Flags64) {
    mutable_format_bit_arm: bool = false,
    protected_bit_arm: bool = false,
    descriptor_buffer_capture_replay_bit_arm: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    _reserved_bit_32: bool = false,
    _reserved_bit_33: bool = false,
    _reserved_bit_34: bool = false,
    _reserved_bit_35: bool = false,
    _reserved_bit_36: bool = false,
    _reserved_bit_37: bool = false,
    _reserved_bit_38: bool = false,
    _reserved_bit_39: bool = false,
    _reserved_bit_40: bool = false,
    _reserved_bit_41: bool = false,
    _reserved_bit_42: bool = false,
    _reserved_bit_43: bool = false,
    _reserved_bit_44: bool = false,
    _reserved_bit_45: bool = false,
    _reserved_bit_46: bool = false,
    _reserved_bit_47: bool = false,
    _reserved_bit_48: bool = false,
    _reserved_bit_49: bool = false,
    _reserved_bit_50: bool = false,
    _reserved_bit_51: bool = false,
    _reserved_bit_52: bool = false,
    _reserved_bit_53: bool = false,
    _reserved_bit_54: bool = false,
    _reserved_bit_55: bool = false,
    _reserved_bit_56: bool = false,
    _reserved_bit_57: bool = false,
    _reserved_bit_58: bool = false,
    _reserved_bit_59: bool = false,
    _reserved_bit_60: bool = false,
    _reserved_bit_61: bool = false,
    _reserved_bit_62: bool = false,
    _reserved_bit_63: bool = false,
    pub const toInt = FlagsMixin(TensorCreateFlagsARM).toInt;
    pub const fromInt = FlagsMixin(TensorCreateFlagsARM).fromInt;
    pub const merge = FlagsMixin(TensorCreateFlagsARM).merge;
    pub const intersect = FlagsMixin(TensorCreateFlagsARM).intersect;
    pub const complement = FlagsMixin(TensorCreateFlagsARM).complement;
    pub const subtract = FlagsMixin(TensorCreateFlagsARM).subtract;
    pub const contains = FlagsMixin(TensorCreateFlagsARM).contains;
    pub const format = FlagFormatMixin(TensorCreateFlagsARM).format;
};
pub const TensorUsageFlagsARM = packed struct(Flags64) {
    _reserved_bit_0: bool = false,
    shader_bit_arm: bool = false,
    transfer_src_bit_arm: bool = false,
    transfer_dst_bit_arm: bool = false,
    image_aliasing_bit_arm: bool = false,
    data_graph_bit_arm: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    _reserved_bit_32: bool = false,
    _reserved_bit_33: bool = false,
    _reserved_bit_34: bool = false,
    _reserved_bit_35: bool = false,
    _reserved_bit_36: bool = false,
    _reserved_bit_37: bool = false,
    _reserved_bit_38: bool = false,
    _reserved_bit_39: bool = false,
    _reserved_bit_40: bool = false,
    _reserved_bit_41: bool = false,
    _reserved_bit_42: bool = false,
    _reserved_bit_43: bool = false,
    _reserved_bit_44: bool = false,
    _reserved_bit_45: bool = false,
    _reserved_bit_46: bool = false,
    _reserved_bit_47: bool = false,
    _reserved_bit_48: bool = false,
    _reserved_bit_49: bool = false,
    _reserved_bit_50: bool = false,
    _reserved_bit_51: bool = false,
    _reserved_bit_52: bool = false,
    _reserved_bit_53: bool = false,
    _reserved_bit_54: bool = false,
    _reserved_bit_55: bool = false,
    _reserved_bit_56: bool = false,
    _reserved_bit_57: bool = false,
    _reserved_bit_58: bool = false,
    _reserved_bit_59: bool = false,
    _reserved_bit_60: bool = false,
    _reserved_bit_61: bool = false,
    _reserved_bit_62: bool = false,
    _reserved_bit_63: bool = false,
    pub const toInt = FlagsMixin(TensorUsageFlagsARM).toInt;
    pub const fromInt = FlagsMixin(TensorUsageFlagsARM).fromInt;
    pub const merge = FlagsMixin(TensorUsageFlagsARM).merge;
    pub const intersect = FlagsMixin(TensorUsageFlagsARM).intersect;
    pub const complement = FlagsMixin(TensorUsageFlagsARM).complement;
    pub const subtract = FlagsMixin(TensorUsageFlagsARM).subtract;
    pub const contains = FlagsMixin(TensorUsageFlagsARM).contains;
    pub const format = FlagFormatMixin(TensorUsageFlagsARM).format;
};
pub const TensorTilingARM = enum(i32) {
    optimal_arm = 0,
    linear_arm = 1,
    _,
};
pub const TensorViewCreateFlagsARM = packed struct(Flags64) {
    descriptor_buffer_capture_replay_bit_arm: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    _reserved_bit_32: bool = false,
    _reserved_bit_33: bool = false,
    _reserved_bit_34: bool = false,
    _reserved_bit_35: bool = false,
    _reserved_bit_36: bool = false,
    _reserved_bit_37: bool = false,
    _reserved_bit_38: bool = false,
    _reserved_bit_39: bool = false,
    _reserved_bit_40: bool = false,
    _reserved_bit_41: bool = false,
    _reserved_bit_42: bool = false,
    _reserved_bit_43: bool = false,
    _reserved_bit_44: bool = false,
    _reserved_bit_45: bool = false,
    _reserved_bit_46: bool = false,
    _reserved_bit_47: bool = false,
    _reserved_bit_48: bool = false,
    _reserved_bit_49: bool = false,
    _reserved_bit_50: bool = false,
    _reserved_bit_51: bool = false,
    _reserved_bit_52: bool = false,
    _reserved_bit_53: bool = false,
    _reserved_bit_54: bool = false,
    _reserved_bit_55: bool = false,
    _reserved_bit_56: bool = false,
    _reserved_bit_57: bool = false,
    _reserved_bit_58: bool = false,
    _reserved_bit_59: bool = false,
    _reserved_bit_60: bool = false,
    _reserved_bit_61: bool = false,
    _reserved_bit_62: bool = false,
    _reserved_bit_63: bool = false,
    pub const toInt = FlagsMixin(TensorViewCreateFlagsARM).toInt;
    pub const fromInt = FlagsMixin(TensorViewCreateFlagsARM).fromInt;
    pub const merge = FlagsMixin(TensorViewCreateFlagsARM).merge;
    pub const intersect = FlagsMixin(TensorViewCreateFlagsARM).intersect;
    pub const complement = FlagsMixin(TensorViewCreateFlagsARM).complement;
    pub const subtract = FlagsMixin(TensorViewCreateFlagsARM).subtract;
    pub const contains = FlagsMixin(TensorViewCreateFlagsARM).contains;
    pub const format = FlagFormatMixin(TensorViewCreateFlagsARM).format;
};
pub const DefaultVertexAttributeValueKHR = enum(i32) {
    zero_zero_zero_zero_khr = 0,
    zero_zero_zero_one_khr = 1,
    _,
};
pub const DataGraphPipelineSessionCreateFlagsARM = packed struct(Flags64) {
    protected_bit_arm: bool = false,
    _reserved_bit_1: bool = false,
    _reserved_bit_2: bool = false,
    _reserved_bit_3: bool = false,
    _reserved_bit_4: bool = false,
    _reserved_bit_5: bool = false,
    _reserved_bit_6: bool = false,
    _reserved_bit_7: bool = false,
    _reserved_bit_8: bool = false,
    _reserved_bit_9: bool = false,
    _reserved_bit_10: bool = false,
    _reserved_bit_11: bool = false,
    _reserved_bit_12: bool = false,
    _reserved_bit_13: bool = false,
    _reserved_bit_14: bool = false,
    _reserved_bit_15: bool = false,
    _reserved_bit_16: bool = false,
    _reserved_bit_17: bool = false,
    _reserved_bit_18: bool = false,
    _reserved_bit_19: bool = false,
    _reserved_bit_20: bool = false,
    _reserved_bit_21: bool = false,
    _reserved_bit_22: bool = false,
    _reserved_bit_23: bool = false,
    _reserved_bit_24: bool = false,
    _reserved_bit_25: bool = false,
    _reserved_bit_26: bool = false,
    _reserved_bit_27: bool = false,
    _reserved_bit_28: bool = false,
    _reserved_bit_29: bool = false,
    _reserved_bit_30: bool = false,
    _reserved_bit_31: bool = false,
    _reserved_bit_32: bool = false,
    _reserved_bit_33: bool = false,
    _reserved_bit_34: bool = false,
    _reserved_bit_35: bool = false,
    _reserved_bit_36: bool = false,
    _reserved_bit_37: bool = false,
    _reserved_bit_38: bool = false,
    _reserved_bit_39: bool = false,
    _reserved_bit_40: bool = false,
    _reserved_bit_41: bool = false,
    _reserved_bit_42: bool = false,
    _reserved_bit_43: bool = false,
    _reserved_bit_44: bool = false,
    _reserved_bit_45: bool = false,
    _reserved_bit_46: bool = false,
    _reserved_bit_47: bool = false,
    _reserved_bit_48: bool = false,
    _reserved_bit_49: bool = false,
    _reserved_bit_50: bool = false,
    _reserved_bit_51: bool = false,
    _reserved_bit_52: bool = false,
    _reserved_bit_53: bool = false,
    _reserved_bit_54: bool = false,
    _reserved_bit_55: bool = false,
    _reserved_bit_56: bool = false,
    _reserved_bit_57: bool = false,
    _reserved_bit_58: bool = false,
    _reserved_bit_59: bool = false,
    _reserved_bit_60: bool = false,
    _reserved_bit_61: bool = false,
    _reserved_bit_62: bool = false,
    _reserved_bit_63: bool = false,
    pub const toInt = FlagsMixin(DataGraphPipelineSessionCreateFlagsARM).toInt;
    pub const fromInt = FlagsMixin(DataGraphPipelineSessionCreateFlagsARM).fromInt;
    pub const merge = FlagsMixin(DataGraphPipelineSessionCreateFlagsARM).merge;
    pub const intersect = FlagsMixin(DataGraphPipelineSessionCreateFlagsARM).intersect;
    pub const complement = FlagsMixin(DataGraphPipelineSessionCreateFlagsARM).complement;
    pub const subtract = FlagsMixin(DataGraphPipelineSessionCreateFlagsARM).subtract;
    pub const contains = FlagsMixin(DataGraphPipelineSessionCreateFlagsARM).contains;
    pub const format = FlagFormatMixin(DataGraphPipelineSessionCreateFlagsARM).format;
};
pub const DataGraphPipelineSessionBindPointARM = enum(i32) {
    transient_arm = 0,
    _,
};
pub const DataGraphPipelineSessionBindPointTypeARM = enum(i32) {
    memory_arm = 0,
    _,
};
pub const DataGraphPipelinePropertyARM = enum(i32) {
    creation_log_arm = 0,
    identifier_arm = 1,
    _,
};
pub const DataGraphPipelineDispatchFlagsARM = packed struct(Flags64) {
    _reserved_bits: Flags64 = 0,
    pub const toInt = FlagsMixin(DataGraphPipelineDispatchFlagsARM).toInt;
    pub const fromInt = FlagsMixin(DataGraphPipelineDispatchFlagsARM).fromInt;
    pub const merge = FlagsMixin(DataGraphPipelineDispatchFlagsARM).merge;
    pub const intersect = FlagsMixin(DataGraphPipelineDispatchFlagsARM).intersect;
    pub const complement = FlagsMixin(DataGraphPipelineDispatchFlagsARM).complement;
    pub const subtract = FlagsMixin(DataGraphPipelineDispatchFlagsARM).subtract;
    pub const contains = FlagsMixin(DataGraphPipelineDispatchFlagsARM).contains;
    pub const format = FlagFormatMixin(DataGraphPipelineDispatchFlagsARM).format;
};
pub const PhysicalDeviceDataGraphProcessingEngineTypeARM = enum(i32) {
    default_arm = 0,
    _,
};
pub const PhysicalDeviceDataGraphOperationTypeARM = enum(i32) {
    spirv_extended_instruction_set_arm = 0,
    _,
};
pub const PfnCreateInstance = *const fn (
    p_create_info: *const InstanceCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_instance: *Instance,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyInstance = *const fn (
    instance: Instance,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnEnumeratePhysicalDevices = *const fn (
    instance: Instance,
    p_physical_device_count: *u32,
    p_physical_devices: ?[*]PhysicalDevice,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDeviceProcAddr = *const fn (
    device: Device,
    p_name: [*:0]const u8,
) callconv(vulkan_call_conv) PfnVoidFunction;
pub const PfnGetInstanceProcAddr = *const fn (
    instance: Instance,
    p_name: [*:0]const u8,
) callconv(vulkan_call_conv) PfnVoidFunction;
pub const PfnGetPhysicalDeviceProperties = *const fn (
    physical_device: PhysicalDevice,
    p_properties: *PhysicalDeviceProperties,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceQueueFamilyProperties = *const fn (
    physical_device: PhysicalDevice,
    p_queue_family_property_count: *u32,
    p_queue_family_properties: ?[*]QueueFamilyProperties,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceMemoryProperties = *const fn (
    physical_device: PhysicalDevice,
    p_memory_properties: *PhysicalDeviceMemoryProperties,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceFeatures = *const fn (
    physical_device: PhysicalDevice,
    p_features: *PhysicalDeviceFeatures,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceFormatProperties = *const fn (
    physical_device: PhysicalDevice,
    format: Format,
    p_format_properties: *FormatProperties,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceImageFormatProperties = *const fn (
    physical_device: PhysicalDevice,
    format: Format,
    @"type": ImageType,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    flags: ImageCreateFlags,
    p_image_format_properties: *ImageFormatProperties,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateDevice = *const fn (
    physical_device: PhysicalDevice,
    p_create_info: *const DeviceCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_device: *Device,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyDevice = *const fn (
    device: Device,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnEnumerateInstanceVersion = *const fn (
    p_api_version: *u32,
) callconv(vulkan_call_conv) Result;
pub const PfnEnumerateInstanceLayerProperties = *const fn (
    p_property_count: *u32,
    p_properties: ?[*]LayerProperties,
) callconv(vulkan_call_conv) Result;
pub const PfnEnumerateInstanceExtensionProperties = *const fn (
    p_layer_name: ?[*:0]const u8,
    p_property_count: *u32,
    p_properties: ?[*]ExtensionProperties,
) callconv(vulkan_call_conv) Result;
pub const PfnEnumerateDeviceLayerProperties = *const fn (
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]LayerProperties,
) callconv(vulkan_call_conv) Result;
pub const PfnEnumerateDeviceExtensionProperties = *const fn (
    physical_device: PhysicalDevice,
    p_layer_name: ?[*:0]const u8,
    p_property_count: *u32,
    p_properties: ?[*]ExtensionProperties,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDeviceQueue = *const fn (
    device: Device,
    queue_family_index: u32,
    queue_index: u32,
    p_queue: *Queue,
) callconv(vulkan_call_conv) void;
pub const PfnQueueSubmit = *const fn (
    queue: Queue,
    submit_count: u32,
    p_submits: ?[*]const SubmitInfo,
    fence: Fence,
) callconv(vulkan_call_conv) Result;
pub const PfnQueueWaitIdle = *const fn (
    queue: Queue,
) callconv(vulkan_call_conv) Result;
pub const PfnDeviceWaitIdle = *const fn (
    device: Device,
) callconv(vulkan_call_conv) Result;
pub const PfnAllocateMemory = *const fn (
    device: Device,
    p_allocate_info: *const MemoryAllocateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_memory: *DeviceMemory,
) callconv(vulkan_call_conv) Result;
pub const PfnFreeMemory = *const fn (
    device: Device,
    memory: DeviceMemory,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnMapMemory = *const fn (
    device: Device,
    memory: DeviceMemory,
    offset: DeviceSize,
    size: DeviceSize,
    flags: MemoryMapFlags,
    pp_data: *?*anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnUnmapMemory = *const fn (
    device: Device,
    memory: DeviceMemory,
) callconv(vulkan_call_conv) void;
pub const PfnFlushMappedMemoryRanges = *const fn (
    device: Device,
    memory_range_count: u32,
    p_memory_ranges: [*]const MappedMemoryRange,
) callconv(vulkan_call_conv) Result;
pub const PfnInvalidateMappedMemoryRanges = *const fn (
    device: Device,
    memory_range_count: u32,
    p_memory_ranges: [*]const MappedMemoryRange,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDeviceMemoryCommitment = *const fn (
    device: Device,
    memory: DeviceMemory,
    p_committed_memory_in_bytes: *DeviceSize,
) callconv(vulkan_call_conv) void;
pub const PfnGetBufferMemoryRequirements = *const fn (
    device: Device,
    buffer: Buffer,
    p_memory_requirements: *MemoryRequirements,
) callconv(vulkan_call_conv) void;
pub const PfnBindBufferMemory = *const fn (
    device: Device,
    buffer: Buffer,
    memory: DeviceMemory,
    memory_offset: DeviceSize,
) callconv(vulkan_call_conv) Result;
pub const PfnGetImageMemoryRequirements = *const fn (
    device: Device,
    image: Image,
    p_memory_requirements: *MemoryRequirements,
) callconv(vulkan_call_conv) void;
pub const PfnBindImageMemory = *const fn (
    device: Device,
    image: Image,
    memory: DeviceMemory,
    memory_offset: DeviceSize,
) callconv(vulkan_call_conv) Result;
pub const PfnGetImageSparseMemoryRequirements = *const fn (
    device: Device,
    image: Image,
    p_sparse_memory_requirement_count: *u32,
    p_sparse_memory_requirements: ?[*]SparseImageMemoryRequirements,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceSparseImageFormatProperties = *const fn (
    physical_device: PhysicalDevice,
    format: Format,
    @"type": ImageType,
    samples: SampleCountFlags,
    usage: ImageUsageFlags,
    tiling: ImageTiling,
    p_property_count: *u32,
    p_properties: ?[*]SparseImageFormatProperties,
) callconv(vulkan_call_conv) void;
pub const PfnQueueBindSparse = *const fn (
    queue: Queue,
    bind_info_count: u32,
    p_bind_info: ?[*]const BindSparseInfo,
    fence: Fence,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateFence = *const fn (
    device: Device,
    p_create_info: *const FenceCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_fence: *Fence,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyFence = *const fn (
    device: Device,
    fence: Fence,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnResetFences = *const fn (
    device: Device,
    fence_count: u32,
    p_fences: [*]const Fence,
) callconv(vulkan_call_conv) Result;
pub const PfnGetFenceStatus = *const fn (
    device: Device,
    fence: Fence,
) callconv(vulkan_call_conv) Result;
pub const PfnWaitForFences = *const fn (
    device: Device,
    fence_count: u32,
    p_fences: [*]const Fence,
    wait_all: Bool32,
    timeout: u64,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateSemaphore = *const fn (
    device: Device,
    p_create_info: *const SemaphoreCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_semaphore: *Semaphore,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroySemaphore = *const fn (
    device: Device,
    semaphore: Semaphore,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCreateEvent = *const fn (
    device: Device,
    p_create_info: *const EventCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_event: *Event,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyEvent = *const fn (
    device: Device,
    event: Event,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnGetEventStatus = *const fn (
    device: Device,
    event: Event,
) callconv(vulkan_call_conv) Result;
pub const PfnSetEvent = *const fn (
    device: Device,
    event: Event,
) callconv(vulkan_call_conv) Result;
pub const PfnResetEvent = *const fn (
    device: Device,
    event: Event,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateQueryPool = *const fn (
    device: Device,
    p_create_info: *const QueryPoolCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_query_pool: *QueryPool,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyQueryPool = *const fn (
    device: Device,
    query_pool: QueryPool,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnGetQueryPoolResults = *const fn (
    device: Device,
    query_pool: QueryPool,
    first_query: u32,
    query_count: u32,
    data_size: usize,
    p_data: *anyopaque,
    stride: DeviceSize,
    flags: QueryResultFlags,
) callconv(vulkan_call_conv) Result;
pub const PfnResetQueryPool = *const fn (
    device: Device,
    query_pool: QueryPool,
    first_query: u32,
    query_count: u32,
) callconv(vulkan_call_conv) void;
pub const PfnResetQueryPoolEXT = PfnResetQueryPool;
pub const PfnCreateBuffer = *const fn (
    device: Device,
    p_create_info: *const BufferCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_buffer: *Buffer,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyBuffer = *const fn (
    device: Device,
    buffer: Buffer,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCreateBufferView = *const fn (
    device: Device,
    p_create_info: *const BufferViewCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_view: *BufferView,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyBufferView = *const fn (
    device: Device,
    buffer_view: BufferView,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCreateImage = *const fn (
    device: Device,
    p_create_info: *const ImageCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_image: *Image,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyImage = *const fn (
    device: Device,
    image: Image,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnGetImageSubresourceLayout = *const fn (
    device: Device,
    image: Image,
    p_subresource: *const ImageSubresource,
    p_layout: *SubresourceLayout,
) callconv(vulkan_call_conv) void;
pub const PfnCreateImageView = *const fn (
    device: Device,
    p_create_info: *const ImageViewCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_view: *ImageView,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyImageView = *const fn (
    device: Device,
    image_view: ImageView,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCreateShaderModule = *const fn (
    device: Device,
    p_create_info: *const ShaderModuleCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_shader_module: *ShaderModule,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyShaderModule = *const fn (
    device: Device,
    shader_module: ShaderModule,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCreatePipelineCache = *const fn (
    device: Device,
    p_create_info: *const PipelineCacheCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_pipeline_cache: *PipelineCache,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyPipelineCache = *const fn (
    device: Device,
    pipeline_cache: PipelineCache,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnGetPipelineCacheData = *const fn (
    device: Device,
    pipeline_cache: PipelineCache,
    p_data_size: *usize,
    p_data: ?*anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnMergePipelineCaches = *const fn (
    device: Device,
    dst_cache: PipelineCache,
    src_cache_count: u32,
    p_src_caches: [*]const PipelineCache,
) callconv(vulkan_call_conv) Result;
pub const PfnCreatePipelineBinariesKHR = *const fn (
    device: Device,
    p_create_info: *const PipelineBinaryCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_binaries: *PipelineBinaryHandlesInfoKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyPipelineBinaryKHR = *const fn (
    device: Device,
    pipeline_binary: PipelineBinaryKHR,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnGetPipelineKeyKHR = *const fn (
    device: Device,
    p_pipeline_create_info: ?*const PipelineCreateInfoKHR,
    p_pipeline_key: *PipelineBinaryKeyKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPipelineBinaryDataKHR = *const fn (
    device: Device,
    p_info: *const PipelineBinaryDataInfoKHR,
    p_pipeline_binary_key: *PipelineBinaryKeyKHR,
    p_pipeline_binary_data_size: *usize,
    p_pipeline_binary_data: ?*anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnReleaseCapturedPipelineDataKHR = *const fn (
    device: Device,
    p_info: *const ReleaseCapturedPipelineDataInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateGraphicsPipelines = *const fn (
    device: Device,
    pipeline_cache: PipelineCache,
    create_info_count: u32,
    p_create_infos: [*]const GraphicsPipelineCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_pipelines: [*]Pipeline,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateComputePipelines = *const fn (
    device: Device,
    pipeline_cache: PipelineCache,
    create_info_count: u32,
    p_create_infos: [*]const ComputePipelineCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_pipelines: [*]Pipeline,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = *const fn (
    device: Device,
    renderpass: RenderPass,
    p_max_workgroup_size: [*]Extent2D,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyPipeline = *const fn (
    device: Device,
    pipeline: Pipeline,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCreatePipelineLayout = *const fn (
    device: Device,
    p_create_info: *const PipelineLayoutCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_pipeline_layout: *PipelineLayout,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyPipelineLayout = *const fn (
    device: Device,
    pipeline_layout: PipelineLayout,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCreateSampler = *const fn (
    device: Device,
    p_create_info: *const SamplerCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_sampler: *Sampler,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroySampler = *const fn (
    device: Device,
    sampler: Sampler,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCreateDescriptorSetLayout = *const fn (
    device: Device,
    p_create_info: *const DescriptorSetLayoutCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_set_layout: *DescriptorSetLayout,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyDescriptorSetLayout = *const fn (
    device: Device,
    descriptor_set_layout: DescriptorSetLayout,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCreateDescriptorPool = *const fn (
    device: Device,
    p_create_info: *const DescriptorPoolCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_descriptor_pool: *DescriptorPool,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyDescriptorPool = *const fn (
    device: Device,
    descriptor_pool: DescriptorPool,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnResetDescriptorPool = *const fn (
    device: Device,
    descriptor_pool: DescriptorPool,
    flags: DescriptorPoolResetFlags,
) callconv(vulkan_call_conv) Result;
pub const PfnAllocateDescriptorSets = *const fn (
    device: Device,
    p_allocate_info: *const DescriptorSetAllocateInfo,
    p_descriptor_sets: [*]DescriptorSet,
) callconv(vulkan_call_conv) Result;
pub const PfnFreeDescriptorSets = *const fn (
    device: Device,
    descriptor_pool: DescriptorPool,
    descriptor_set_count: u32,
    p_descriptor_sets: [*]const DescriptorSet,
) callconv(vulkan_call_conv) Result;
pub const PfnUpdateDescriptorSets = *const fn (
    device: Device,
    descriptor_write_count: u32,
    p_descriptor_writes: ?[*]const WriteDescriptorSet,
    descriptor_copy_count: u32,
    p_descriptor_copies: ?[*]const CopyDescriptorSet,
) callconv(vulkan_call_conv) void;
pub const PfnCreateFramebuffer = *const fn (
    device: Device,
    p_create_info: *const FramebufferCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_framebuffer: *Framebuffer,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyFramebuffer = *const fn (
    device: Device,
    framebuffer: Framebuffer,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCreateRenderPass = *const fn (
    device: Device,
    p_create_info: *const RenderPassCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_render_pass: *RenderPass,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyRenderPass = *const fn (
    device: Device,
    render_pass: RenderPass,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnGetRenderAreaGranularity = *const fn (
    device: Device,
    render_pass: RenderPass,
    p_granularity: *Extent2D,
) callconv(vulkan_call_conv) void;
pub const PfnGetRenderingAreaGranularity = *const fn (
    device: Device,
    p_rendering_area_info: *const RenderingAreaInfo,
    p_granularity: *Extent2D,
) callconv(vulkan_call_conv) void;
pub const PfnGetRenderingAreaGranularityKHR = PfnGetRenderingAreaGranularity;
pub const PfnCreateCommandPool = *const fn (
    device: Device,
    p_create_info: *const CommandPoolCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_command_pool: *CommandPool,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyCommandPool = *const fn (
    device: Device,
    command_pool: CommandPool,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnResetCommandPool = *const fn (
    device: Device,
    command_pool: CommandPool,
    flags: CommandPoolResetFlags,
) callconv(vulkan_call_conv) Result;
pub const PfnAllocateCommandBuffers = *const fn (
    device: Device,
    p_allocate_info: *const CommandBufferAllocateInfo,
    p_command_buffers: [*]CommandBuffer,
) callconv(vulkan_call_conv) Result;
pub const PfnFreeCommandBuffers = *const fn (
    device: Device,
    command_pool: CommandPool,
    command_buffer_count: u32,
    p_command_buffers: [*]const CommandBuffer,
) callconv(vulkan_call_conv) void;
pub const PfnBeginCommandBuffer = *const fn (
    command_buffer: CommandBuffer,
    p_begin_info: *const CommandBufferBeginInfo,
) callconv(vulkan_call_conv) Result;
pub const PfnEndCommandBuffer = *const fn (
    command_buffer: CommandBuffer,
) callconv(vulkan_call_conv) Result;
pub const PfnResetCommandBuffer = *const fn (
    command_buffer: CommandBuffer,
    flags: CommandBufferResetFlags,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdBindPipeline = *const fn (
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    pipeline: Pipeline,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetAttachmentFeedbackLoopEnableEXT = *const fn (
    command_buffer: CommandBuffer,
    aspect_mask: ImageAspectFlags,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetViewport = *const fn (
    command_buffer: CommandBuffer,
    first_viewport: u32,
    viewport_count: u32,
    p_viewports: [*]const Viewport,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetScissor = *const fn (
    command_buffer: CommandBuffer,
    first_scissor: u32,
    scissor_count: u32,
    p_scissors: [*]const Rect2D,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetLineWidth = *const fn (
    command_buffer: CommandBuffer,
    line_width: f32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetDepthBias = *const fn (
    command_buffer: CommandBuffer,
    depth_bias_constant_factor: f32,
    depth_bias_clamp: f32,
    depth_bias_slope_factor: f32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetBlendConstants = *const fn (
    command_buffer: CommandBuffer,
    blend_constants: *const [4]f32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetDepthBounds = *const fn (
    command_buffer: CommandBuffer,
    min_depth_bounds: f32,
    max_depth_bounds: f32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetStencilCompareMask = *const fn (
    command_buffer: CommandBuffer,
    face_mask: StencilFaceFlags,
    compare_mask: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetStencilWriteMask = *const fn (
    command_buffer: CommandBuffer,
    face_mask: StencilFaceFlags,
    write_mask: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetStencilReference = *const fn (
    command_buffer: CommandBuffer,
    face_mask: StencilFaceFlags,
    reference: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBindDescriptorSets = *const fn (
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    layout: PipelineLayout,
    first_set: u32,
    descriptor_set_count: u32,
    p_descriptor_sets: [*]const DescriptorSet,
    dynamic_offset_count: u32,
    p_dynamic_offsets: ?[*]const u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBindIndexBuffer = *const fn (
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    index_type: IndexType,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBindVertexBuffers = *const fn (
    command_buffer: CommandBuffer,
    first_binding: u32,
    binding_count: u32,
    p_buffers: [*]const Buffer,
    p_offsets: [*]const DeviceSize,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDraw = *const fn (
    command_buffer: CommandBuffer,
    vertex_count: u32,
    instance_count: u32,
    first_vertex: u32,
    first_instance: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDrawIndexed = *const fn (
    command_buffer: CommandBuffer,
    index_count: u32,
    instance_count: u32,
    first_index: u32,
    vertex_offset: i32,
    first_instance: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDrawMultiEXT = *const fn (
    command_buffer: CommandBuffer,
    draw_count: u32,
    p_vertex_info: ?[*]const MultiDrawInfoEXT,
    instance_count: u32,
    first_instance: u32,
    stride: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDrawMultiIndexedEXT = *const fn (
    command_buffer: CommandBuffer,
    draw_count: u32,
    p_index_info: ?[*]const MultiDrawIndexedInfoEXT,
    instance_count: u32,
    first_instance: u32,
    stride: u32,
    p_vertex_offset: ?*const i32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDrawIndirect = *const fn (
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    draw_count: u32,
    stride: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDrawIndexedIndirect = *const fn (
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    draw_count: u32,
    stride: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDispatch = *const fn (
    command_buffer: CommandBuffer,
    group_count_x: u32,
    group_count_y: u32,
    group_count_z: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDispatchIndirect = *const fn (
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSubpassShadingHUAWEI = *const fn (
    command_buffer: CommandBuffer,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDrawClusterHUAWEI = *const fn (
    command_buffer: CommandBuffer,
    group_count_x: u32,
    group_count_y: u32,
    group_count_z: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDrawClusterIndirectHUAWEI = *const fn (
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
) callconv(vulkan_call_conv) void;
pub const PfnCmdUpdatePipelineIndirectBufferNV = *const fn (
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    pipeline: Pipeline,
) callconv(vulkan_call_conv) void;
pub const PfnCmdCopyBuffer = *const fn (
    command_buffer: CommandBuffer,
    src_buffer: Buffer,
    dst_buffer: Buffer,
    region_count: u32,
    p_regions: [*]const BufferCopy,
) callconv(vulkan_call_conv) void;
pub const PfnCmdCopyImage = *const fn (
    command_buffer: CommandBuffer,
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: [*]const ImageCopy,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBlitImage = *const fn (
    command_buffer: CommandBuffer,
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: [*]const ImageBlit,
    filter: Filter,
) callconv(vulkan_call_conv) void;
pub const PfnCmdCopyBufferToImage = *const fn (
    command_buffer: CommandBuffer,
    src_buffer: Buffer,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: [*]const BufferImageCopy,
) callconv(vulkan_call_conv) void;
pub const PfnCmdCopyImageToBuffer = *const fn (
    command_buffer: CommandBuffer,
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_buffer: Buffer,
    region_count: u32,
    p_regions: [*]const BufferImageCopy,
) callconv(vulkan_call_conv) void;
pub const PfnCmdCopyMemoryIndirectNV = *const fn (
    command_buffer: CommandBuffer,
    copy_buffer_address: DeviceAddress,
    copy_count: u32,
    stride: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdCopyMemoryToImageIndirectNV = *const fn (
    command_buffer: CommandBuffer,
    copy_buffer_address: DeviceAddress,
    copy_count: u32,
    stride: u32,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    p_image_subresources: [*]const ImageSubresourceLayers,
) callconv(vulkan_call_conv) void;
pub const PfnCmdUpdateBuffer = *const fn (
    command_buffer: CommandBuffer,
    dst_buffer: Buffer,
    dst_offset: DeviceSize,
    data_size: DeviceSize,
    p_data: *const anyopaque,
) callconv(vulkan_call_conv) void;
pub const PfnCmdFillBuffer = *const fn (
    command_buffer: CommandBuffer,
    dst_buffer: Buffer,
    dst_offset: DeviceSize,
    size: DeviceSize,
    data: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdClearColorImage = *const fn (
    command_buffer: CommandBuffer,
    image: Image,
    image_layout: ImageLayout,
    p_color: *const ClearColorValue,
    range_count: u32,
    p_ranges: [*]const ImageSubresourceRange,
) callconv(vulkan_call_conv) void;
pub const PfnCmdClearDepthStencilImage = *const fn (
    command_buffer: CommandBuffer,
    image: Image,
    image_layout: ImageLayout,
    p_depth_stencil: *const ClearDepthStencilValue,
    range_count: u32,
    p_ranges: [*]const ImageSubresourceRange,
) callconv(vulkan_call_conv) void;
pub const PfnCmdClearAttachments = *const fn (
    command_buffer: CommandBuffer,
    attachment_count: u32,
    p_attachments: [*]const ClearAttachment,
    rect_count: u32,
    p_rects: [*]const ClearRect,
) callconv(vulkan_call_conv) void;
pub const PfnCmdResolveImage = *const fn (
    command_buffer: CommandBuffer,
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: [*]const ImageResolve,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetEvent = *const fn (
    command_buffer: CommandBuffer,
    event: Event,
    stage_mask: PipelineStageFlags,
) callconv(vulkan_call_conv) void;
pub const PfnCmdResetEvent = *const fn (
    command_buffer: CommandBuffer,
    event: Event,
    stage_mask: PipelineStageFlags,
) callconv(vulkan_call_conv) void;
pub const PfnCmdWaitEvents = *const fn (
    command_buffer: CommandBuffer,
    event_count: u32,
    p_events: [*]const Event,
    src_stage_mask: PipelineStageFlags,
    dst_stage_mask: PipelineStageFlags,
    memory_barrier_count: u32,
    p_memory_barriers: ?[*]const MemoryBarrier,
    buffer_memory_barrier_count: u32,
    p_buffer_memory_barriers: ?[*]const BufferMemoryBarrier,
    image_memory_barrier_count: u32,
    p_image_memory_barriers: ?[*]const ImageMemoryBarrier,
) callconv(vulkan_call_conv) void;
pub const PfnCmdPipelineBarrier = *const fn (
    command_buffer: CommandBuffer,
    src_stage_mask: PipelineStageFlags,
    dst_stage_mask: PipelineStageFlags,
    dependency_flags: DependencyFlags,
    memory_barrier_count: u32,
    p_memory_barriers: ?[*]const MemoryBarrier,
    buffer_memory_barrier_count: u32,
    p_buffer_memory_barriers: ?[*]const BufferMemoryBarrier,
    image_memory_barrier_count: u32,
    p_image_memory_barriers: ?[*]const ImageMemoryBarrier,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBeginQuery = *const fn (
    command_buffer: CommandBuffer,
    query_pool: QueryPool,
    query: u32,
    flags: QueryControlFlags,
) callconv(vulkan_call_conv) void;
pub const PfnCmdEndQuery = *const fn (
    command_buffer: CommandBuffer,
    query_pool: QueryPool,
    query: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBeginConditionalRenderingEXT = *const fn (
    command_buffer: CommandBuffer,
    p_conditional_rendering_begin: *const ConditionalRenderingBeginInfoEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCmdEndConditionalRenderingEXT = *const fn (
    command_buffer: CommandBuffer,
) callconv(vulkan_call_conv) void;
pub const PfnCmdResetQueryPool = *const fn (
    command_buffer: CommandBuffer,
    query_pool: QueryPool,
    first_query: u32,
    query_count: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdWriteTimestamp = *const fn (
    command_buffer: CommandBuffer,
    pipeline_stage: PipelineStageFlags,
    query_pool: QueryPool,
    query: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdCopyQueryPoolResults = *const fn (
    command_buffer: CommandBuffer,
    query_pool: QueryPool,
    first_query: u32,
    query_count: u32,
    dst_buffer: Buffer,
    dst_offset: DeviceSize,
    stride: DeviceSize,
    flags: QueryResultFlags,
) callconv(vulkan_call_conv) void;
pub const PfnCmdPushConstants = *const fn (
    command_buffer: CommandBuffer,
    layout: PipelineLayout,
    stage_flags: ShaderStageFlags,
    offset: u32,
    size: u32,
    p_values: *const anyopaque,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBeginRenderPass = *const fn (
    command_buffer: CommandBuffer,
    p_render_pass_begin: *const RenderPassBeginInfo,
    contents: SubpassContents,
) callconv(vulkan_call_conv) void;
pub const PfnCmdNextSubpass = *const fn (
    command_buffer: CommandBuffer,
    contents: SubpassContents,
) callconv(vulkan_call_conv) void;
pub const PfnCmdEndRenderPass = *const fn (
    command_buffer: CommandBuffer,
) callconv(vulkan_call_conv) void;
pub const PfnCmdExecuteCommands = *const fn (
    command_buffer: CommandBuffer,
    command_buffer_count: u32,
    p_command_buffers: [*]const CommandBuffer,
) callconv(vulkan_call_conv) void;
pub const PfnCreateAndroidSurfaceKHR = *const fn (
    instance: Instance,
    p_create_info: *const AndroidSurfaceCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_surface: *SurfaceKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateSurfaceOHOS = *const fn (
    instance: Instance,
    p_create_info: *const SurfaceCreateInfoOHOS,
    p_allocator: ?*const AllocationCallbacks,
    p_surface: *SurfaceKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceDisplayPropertiesKHR = *const fn (
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]DisplayPropertiesKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceDisplayPlanePropertiesKHR = *const fn (
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]DisplayPlanePropertiesKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDisplayPlaneSupportedDisplaysKHR = *const fn (
    physical_device: PhysicalDevice,
    plane_index: u32,
    p_display_count: *u32,
    p_displays: ?[*]DisplayKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDisplayModePropertiesKHR = *const fn (
    physical_device: PhysicalDevice,
    display: DisplayKHR,
    p_property_count: *u32,
    p_properties: ?[*]DisplayModePropertiesKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateDisplayModeKHR = *const fn (
    physical_device: PhysicalDevice,
    display: DisplayKHR,
    p_create_info: *const DisplayModeCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_mode: *DisplayModeKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDisplayPlaneCapabilitiesKHR = *const fn (
    physical_device: PhysicalDevice,
    mode: DisplayModeKHR,
    plane_index: u32,
    p_capabilities: *DisplayPlaneCapabilitiesKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateDisplayPlaneSurfaceKHR = *const fn (
    instance: Instance,
    p_create_info: *const DisplaySurfaceCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_surface: *SurfaceKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateSharedSwapchainsKHR = *const fn (
    device: Device,
    swapchain_count: u32,
    p_create_infos: [*]const SwapchainCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_swapchains: [*]SwapchainKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroySurfaceKHR = *const fn (
    instance: Instance,
    surface: SurfaceKHR,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceSurfaceSupportKHR = *const fn (
    physical_device: PhysicalDevice,
    queue_family_index: u32,
    surface: SurfaceKHR,
    p_supported: *Bool32,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceSurfaceCapabilitiesKHR = *const fn (
    physical_device: PhysicalDevice,
    surface: SurfaceKHR,
    p_surface_capabilities: *SurfaceCapabilitiesKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceSurfaceFormatsKHR = *const fn (
    physical_device: PhysicalDevice,
    surface: SurfaceKHR,
    p_surface_format_count: *u32,
    p_surface_formats: ?[*]SurfaceFormatKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceSurfacePresentModesKHR = *const fn (
    physical_device: PhysicalDevice,
    surface: SurfaceKHR,
    p_present_mode_count: *u32,
    p_present_modes: ?[*]PresentModeKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateSwapchainKHR = *const fn (
    device: Device,
    p_create_info: *const SwapchainCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_swapchain: *SwapchainKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroySwapchainKHR = *const fn (
    device: Device,
    swapchain: SwapchainKHR,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnGetSwapchainImagesKHR = *const fn (
    device: Device,
    swapchain: SwapchainKHR,
    p_swapchain_image_count: *u32,
    p_swapchain_images: ?[*]Image,
) callconv(vulkan_call_conv) Result;
pub const PfnAcquireNextImageKHR = *const fn (
    device: Device,
    swapchain: SwapchainKHR,
    timeout: u64,
    semaphore: Semaphore,
    fence: Fence,
    p_image_index: *u32,
) callconv(vulkan_call_conv) Result;
pub const PfnQueuePresentKHR = *const fn (
    queue: Queue,
    p_present_info: *const PresentInfoKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateViSurfaceNN = *const fn (
    instance: Instance,
    p_create_info: *const ViSurfaceCreateInfoNN,
    p_allocator: ?*const AllocationCallbacks,
    p_surface: *SurfaceKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateWaylandSurfaceKHR = *const fn (
    instance: Instance,
    p_create_info: *const WaylandSurfaceCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_surface: *SurfaceKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceWaylandPresentationSupportKHR = *const fn (
    physical_device: PhysicalDevice,
    queue_family_index: u32,
    display: *wl_display,
) callconv(vulkan_call_conv) Bool32;
pub const PfnCreateWin32SurfaceKHR = *const fn (
    instance: Instance,
    p_create_info: *const Win32SurfaceCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_surface: *SurfaceKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceWin32PresentationSupportKHR = *const fn (
    physical_device: PhysicalDevice,
    queue_family_index: u32,
) callconv(vulkan_call_conv) Bool32;
pub const PfnCreateXlibSurfaceKHR = *const fn (
    instance: Instance,
    p_create_info: *const XlibSurfaceCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_surface: *SurfaceKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceXlibPresentationSupportKHR = *const fn (
    physical_device: PhysicalDevice,
    queue_family_index: u32,
    dpy: *Display,
    visual_id: VisualID,
) callconv(vulkan_call_conv) Bool32;
pub const PfnCreateXcbSurfaceKHR = *const fn (
    instance: Instance,
    p_create_info: *const XcbSurfaceCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_surface: *SurfaceKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceXcbPresentationSupportKHR = *const fn (
    physical_device: PhysicalDevice,
    queue_family_index: u32,
    connection: *xcb_connection_t,
    visual_id: xcb_visualid_t,
) callconv(vulkan_call_conv) Bool32;
pub const PfnCreateDirectFBSurfaceEXT = *const fn (
    instance: Instance,
    p_create_info: *const DirectFBSurfaceCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
    p_surface: *SurfaceKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceDirectFBPresentationSupportEXT = *const fn (
    physical_device: PhysicalDevice,
    queue_family_index: u32,
    dfb: *IDirectFB,
) callconv(vulkan_call_conv) Bool32;
pub const PfnCreateImagePipeSurfaceFUCHSIA = *const fn (
    instance: Instance,
    p_create_info: *const ImagePipeSurfaceCreateInfoFUCHSIA,
    p_allocator: ?*const AllocationCallbacks,
    p_surface: *SurfaceKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateStreamDescriptorSurfaceGGP = *const fn (
    instance: Instance,
    p_create_info: *const StreamDescriptorSurfaceCreateInfoGGP,
    p_allocator: ?*const AllocationCallbacks,
    p_surface: *SurfaceKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateScreenSurfaceQNX = *const fn (
    instance: Instance,
    p_create_info: *const ScreenSurfaceCreateInfoQNX,
    p_allocator: ?*const AllocationCallbacks,
    p_surface: *SurfaceKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceScreenPresentationSupportQNX = *const fn (
    physical_device: PhysicalDevice,
    queue_family_index: u32,
    window: *_screen_window,
) callconv(vulkan_call_conv) Bool32;
pub const PfnCreateDebugReportCallbackEXT = *const fn (
    instance: Instance,
    p_create_info: *const DebugReportCallbackCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
    p_callback: *DebugReportCallbackEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyDebugReportCallbackEXT = *const fn (
    instance: Instance,
    callback: DebugReportCallbackEXT,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnDebugReportMessageEXT = *const fn (
    instance: Instance,
    flags: DebugReportFlagsEXT,
    object_type: DebugReportObjectTypeEXT,
    object: u64,
    location: usize,
    message_code: i32,
    p_layer_prefix: [*:0]const u8,
    p_message: [*:0]const u8,
) callconv(vulkan_call_conv) void;
pub const PfnDebugMarkerSetObjectNameEXT = *const fn (
    device: Device,
    p_name_info: *const DebugMarkerObjectNameInfoEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnDebugMarkerSetObjectTagEXT = *const fn (
    device: Device,
    p_tag_info: *const DebugMarkerObjectTagInfoEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdDebugMarkerBeginEXT = *const fn (
    command_buffer: CommandBuffer,
    p_marker_info: *const DebugMarkerMarkerInfoEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDebugMarkerEndEXT = *const fn (
    command_buffer: CommandBuffer,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDebugMarkerInsertEXT = *const fn (
    command_buffer: CommandBuffer,
    p_marker_info: *const DebugMarkerMarkerInfoEXT,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceExternalImageFormatPropertiesNV = *const fn (
    physical_device: PhysicalDevice,
    format: Format,
    @"type": ImageType,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    flags: ImageCreateFlags,
    external_handle_type: ExternalMemoryHandleTypeFlagsNV,
    p_external_image_format_properties: *ExternalImageFormatPropertiesNV,
) callconv(vulkan_call_conv) Result;
pub const PfnGetMemoryWin32HandleNV = *const fn (
    device: Device,
    memory: DeviceMemory,
    handle_type: ExternalMemoryHandleTypeFlagsNV,
    p_handle: *HANDLE,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdExecuteGeneratedCommandsNV = *const fn (
    command_buffer: CommandBuffer,
    is_preprocessed: Bool32,
    p_generated_commands_info: *const GeneratedCommandsInfoNV,
) callconv(vulkan_call_conv) void;
pub const PfnCmdPreprocessGeneratedCommandsNV = *const fn (
    command_buffer: CommandBuffer,
    p_generated_commands_info: *const GeneratedCommandsInfoNV,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBindPipelineShaderGroupNV = *const fn (
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    pipeline: Pipeline,
    group_index: u32,
) callconv(vulkan_call_conv) void;
pub const PfnGetGeneratedCommandsMemoryRequirementsNV = *const fn (
    device: Device,
    p_info: *const GeneratedCommandsMemoryRequirementsInfoNV,
    p_memory_requirements: *MemoryRequirements2,
) callconv(vulkan_call_conv) void;
pub const PfnCreateIndirectCommandsLayoutNV = *const fn (
    device: Device,
    p_create_info: *const IndirectCommandsLayoutCreateInfoNV,
    p_allocator: ?*const AllocationCallbacks,
    p_indirect_commands_layout: *IndirectCommandsLayoutNV,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyIndirectCommandsLayoutNV = *const fn (
    device: Device,
    indirect_commands_layout: IndirectCommandsLayoutNV,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCmdExecuteGeneratedCommandsEXT = *const fn (
    command_buffer: CommandBuffer,
    is_preprocessed: Bool32,
    p_generated_commands_info: *const GeneratedCommandsInfoEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCmdPreprocessGeneratedCommandsEXT = *const fn (
    command_buffer: CommandBuffer,
    p_generated_commands_info: *const GeneratedCommandsInfoEXT,
    state_command_buffer: CommandBuffer,
) callconv(vulkan_call_conv) void;
pub const PfnGetGeneratedCommandsMemoryRequirementsEXT = *const fn (
    device: Device,
    p_info: *const GeneratedCommandsMemoryRequirementsInfoEXT,
    p_memory_requirements: *MemoryRequirements2,
) callconv(vulkan_call_conv) void;
pub const PfnCreateIndirectCommandsLayoutEXT = *const fn (
    device: Device,
    p_create_info: *const IndirectCommandsLayoutCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
    p_indirect_commands_layout: *IndirectCommandsLayoutEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyIndirectCommandsLayoutEXT = *const fn (
    device: Device,
    indirect_commands_layout: IndirectCommandsLayoutEXT,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCreateIndirectExecutionSetEXT = *const fn (
    device: Device,
    p_create_info: *const IndirectExecutionSetCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
    p_indirect_execution_set: *IndirectExecutionSetEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyIndirectExecutionSetEXT = *const fn (
    device: Device,
    indirect_execution_set: IndirectExecutionSetEXT,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnUpdateIndirectExecutionSetPipelineEXT = *const fn (
    device: Device,
    indirect_execution_set: IndirectExecutionSetEXT,
    execution_set_write_count: u32,
    p_execution_set_writes: [*]const WriteIndirectExecutionSetPipelineEXT,
) callconv(vulkan_call_conv) void;
pub const PfnUpdateIndirectExecutionSetShaderEXT = *const fn (
    device: Device,
    indirect_execution_set: IndirectExecutionSetEXT,
    execution_set_write_count: u32,
    p_execution_set_writes: [*]const WriteIndirectExecutionSetShaderEXT,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceFeatures2 = *const fn (
    physical_device: PhysicalDevice,
    p_features: *PhysicalDeviceFeatures2,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceFeatures2KHR = PfnGetPhysicalDeviceFeatures2;
pub const PfnGetPhysicalDeviceProperties2 = *const fn (
    physical_device: PhysicalDevice,
    p_properties: *PhysicalDeviceProperties2,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceProperties2KHR = PfnGetPhysicalDeviceProperties2;
pub const PfnGetPhysicalDeviceFormatProperties2 = *const fn (
    physical_device: PhysicalDevice,
    format: Format,
    p_format_properties: *FormatProperties2,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceFormatProperties2KHR = PfnGetPhysicalDeviceFormatProperties2;
pub const PfnGetPhysicalDeviceImageFormatProperties2 = *const fn (
    physical_device: PhysicalDevice,
    p_image_format_info: *const PhysicalDeviceImageFormatInfo2,
    p_image_format_properties: *ImageFormatProperties2,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceImageFormatProperties2KHR = PfnGetPhysicalDeviceImageFormatProperties2;
pub const PfnGetPhysicalDeviceQueueFamilyProperties2 = *const fn (
    physical_device: PhysicalDevice,
    p_queue_family_property_count: *u32,
    p_queue_family_properties: ?[*]QueueFamilyProperties2,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceQueueFamilyProperties2KHR = PfnGetPhysicalDeviceQueueFamilyProperties2;
pub const PfnGetPhysicalDeviceMemoryProperties2 = *const fn (
    physical_device: PhysicalDevice,
    p_memory_properties: *PhysicalDeviceMemoryProperties2,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceMemoryProperties2KHR = PfnGetPhysicalDeviceMemoryProperties2;
pub const PfnGetPhysicalDeviceSparseImageFormatProperties2 = *const fn (
    physical_device: PhysicalDevice,
    p_format_info: *const PhysicalDeviceSparseImageFormatInfo2,
    p_property_count: *u32,
    p_properties: ?[*]SparseImageFormatProperties2,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceSparseImageFormatProperties2KHR = PfnGetPhysicalDeviceSparseImageFormatProperties2;
pub const PfnCmdPushDescriptorSet = *const fn (
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    layout: PipelineLayout,
    set: u32,
    descriptor_write_count: u32,
    p_descriptor_writes: [*]const WriteDescriptorSet,
) callconv(vulkan_call_conv) void;
pub const PfnCmdPushDescriptorSetKHR = PfnCmdPushDescriptorSet;
pub const PfnTrimCommandPool = *const fn (
    device: Device,
    command_pool: CommandPool,
    flags: CommandPoolTrimFlags,
) callconv(vulkan_call_conv) void;
pub const PfnTrimCommandPoolKHR = PfnTrimCommandPool;
pub const PfnGetPhysicalDeviceExternalBufferProperties = *const fn (
    physical_device: PhysicalDevice,
    p_external_buffer_info: *const PhysicalDeviceExternalBufferInfo,
    p_external_buffer_properties: *ExternalBufferProperties,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceExternalBufferPropertiesKHR = PfnGetPhysicalDeviceExternalBufferProperties;
pub const PfnGetMemoryWin32HandleKHR = *const fn (
    device: Device,
    p_get_win_32_handle_info: *const MemoryGetWin32HandleInfoKHR,
    p_handle: *HANDLE,
) callconv(vulkan_call_conv) Result;
pub const PfnGetMemoryWin32HandlePropertiesKHR = *const fn (
    device: Device,
    handle_type: ExternalMemoryHandleTypeFlags,
    handle: HANDLE,
    p_memory_win_32_handle_properties: *MemoryWin32HandlePropertiesKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetMemoryFdKHR = *const fn (
    device: Device,
    p_get_fd_info: *const MemoryGetFdInfoKHR,
    p_fd: *c_int,
) callconv(vulkan_call_conv) Result;
pub const PfnGetMemoryFdPropertiesKHR = *const fn (
    device: Device,
    handle_type: ExternalMemoryHandleTypeFlags,
    fd: c_int,
    p_memory_fd_properties: *MemoryFdPropertiesKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetMemoryZirconHandleFUCHSIA = *const fn (
    device: Device,
    p_get_zircon_handle_info: *const MemoryGetZirconHandleInfoFUCHSIA,
    p_zircon_handle: *zx_handle_t,
) callconv(vulkan_call_conv) Result;
pub const PfnGetMemoryZirconHandlePropertiesFUCHSIA = *const fn (
    device: Device,
    handle_type: ExternalMemoryHandleTypeFlags,
    zircon_handle: zx_handle_t,
    p_memory_zircon_handle_properties: *MemoryZirconHandlePropertiesFUCHSIA,
) callconv(vulkan_call_conv) Result;
pub const PfnGetMemoryRemoteAddressNV = *const fn (
    device: Device,
    p_memory_get_remote_address_info: *const MemoryGetRemoteAddressInfoNV,
    p_address: *RemoteAddressNV,
) callconv(vulkan_call_conv) Result;
pub const PfnGetMemorySciBufNV = *const fn (
    device: Device,
    p_get_sci_buf_info: *const MemoryGetSciBufInfoNV,
    p_handle: *NvSciBufObj,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceExternalMemorySciBufPropertiesNV = *const fn (
    physical_device: PhysicalDevice,
    handle_type: ExternalMemoryHandleTypeFlags,
    handle: NvSciBufObj,
    p_memory_sci_buf_properties: *MemorySciBufPropertiesNV,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceSciBufAttributesNV = *const fn (
    physical_device: PhysicalDevice,
    p_attributes: NvSciBufAttrList,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceExternalSemaphoreProperties = *const fn (
    physical_device: PhysicalDevice,
    p_external_semaphore_info: *const PhysicalDeviceExternalSemaphoreInfo,
    p_external_semaphore_properties: *ExternalSemaphoreProperties,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceExternalSemaphorePropertiesKHR = PfnGetPhysicalDeviceExternalSemaphoreProperties;
pub const PfnGetSemaphoreWin32HandleKHR = *const fn (
    device: Device,
    p_get_win_32_handle_info: *const SemaphoreGetWin32HandleInfoKHR,
    p_handle: *HANDLE,
) callconv(vulkan_call_conv) Result;
pub const PfnImportSemaphoreWin32HandleKHR = *const fn (
    device: Device,
    p_import_semaphore_win_32_handle_info: *const ImportSemaphoreWin32HandleInfoKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetSemaphoreFdKHR = *const fn (
    device: Device,
    p_get_fd_info: *const SemaphoreGetFdInfoKHR,
    p_fd: *c_int,
) callconv(vulkan_call_conv) Result;
pub const PfnImportSemaphoreFdKHR = *const fn (
    device: Device,
    p_import_semaphore_fd_info: *const ImportSemaphoreFdInfoKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetSemaphoreZirconHandleFUCHSIA = *const fn (
    device: Device,
    p_get_zircon_handle_info: *const SemaphoreGetZirconHandleInfoFUCHSIA,
    p_zircon_handle: *zx_handle_t,
) callconv(vulkan_call_conv) Result;
pub const PfnImportSemaphoreZirconHandleFUCHSIA = *const fn (
    device: Device,
    p_import_semaphore_zircon_handle_info: *const ImportSemaphoreZirconHandleInfoFUCHSIA,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceExternalFenceProperties = *const fn (
    physical_device: PhysicalDevice,
    p_external_fence_info: *const PhysicalDeviceExternalFenceInfo,
    p_external_fence_properties: *ExternalFenceProperties,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceExternalFencePropertiesKHR = PfnGetPhysicalDeviceExternalFenceProperties;
pub const PfnGetFenceWin32HandleKHR = *const fn (
    device: Device,
    p_get_win_32_handle_info: *const FenceGetWin32HandleInfoKHR,
    p_handle: *HANDLE,
) callconv(vulkan_call_conv) Result;
pub const PfnImportFenceWin32HandleKHR = *const fn (
    device: Device,
    p_import_fence_win_32_handle_info: *const ImportFenceWin32HandleInfoKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetFenceFdKHR = *const fn (
    device: Device,
    p_get_fd_info: *const FenceGetFdInfoKHR,
    p_fd: *c_int,
) callconv(vulkan_call_conv) Result;
pub const PfnImportFenceFdKHR = *const fn (
    device: Device,
    p_import_fence_fd_info: *const ImportFenceFdInfoKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetFenceSciSyncFenceNV = *const fn (
    device: Device,
    p_get_sci_sync_handle_info: *const FenceGetSciSyncInfoNV,
    p_handle: *anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnGetFenceSciSyncObjNV = *const fn (
    device: Device,
    p_get_sci_sync_handle_info: *const FenceGetSciSyncInfoNV,
    p_handle: *anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnImportFenceSciSyncFenceNV = *const fn (
    device: Device,
    p_import_fence_sci_sync_info: *const ImportFenceSciSyncInfoNV,
) callconv(vulkan_call_conv) Result;
pub const PfnImportFenceSciSyncObjNV = *const fn (
    device: Device,
    p_import_fence_sci_sync_info: *const ImportFenceSciSyncInfoNV,
) callconv(vulkan_call_conv) Result;
pub const PfnGetSemaphoreSciSyncObjNV = *const fn (
    device: Device,
    p_get_sci_sync_info: *const SemaphoreGetSciSyncInfoNV,
    p_handle: *anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnImportSemaphoreSciSyncObjNV = *const fn (
    device: Device,
    p_import_semaphore_sci_sync_info: *const ImportSemaphoreSciSyncInfoNV,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceSciSyncAttributesNV = *const fn (
    physical_device: PhysicalDevice,
    p_sci_sync_attributes_info: *const SciSyncAttributesInfoNV,
    p_attributes: NvSciSyncAttrList,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateSemaphoreSciSyncPoolNV = *const fn (
    device: Device,
    p_create_info: *const SemaphoreSciSyncPoolCreateInfoNV,
    p_allocator: ?*const AllocationCallbacks,
    p_semaphore_pool: *SemaphoreSciSyncPoolNV,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroySemaphoreSciSyncPoolNV = *const fn (
    device: Device,
    semaphore_pool: SemaphoreSciSyncPoolNV,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnReleaseDisplayEXT = *const fn (
    physical_device: PhysicalDevice,
    display: DisplayKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnAcquireXlibDisplayEXT = *const fn (
    physical_device: PhysicalDevice,
    dpy: *Display,
    display: DisplayKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetRandROutputDisplayEXT = *const fn (
    physical_device: PhysicalDevice,
    dpy: *Display,
    rr_output: RROutput,
    p_display: *DisplayKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnAcquireWinrtDisplayNV = *const fn (
    physical_device: PhysicalDevice,
    display: DisplayKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetWinrtDisplayNV = *const fn (
    physical_device: PhysicalDevice,
    device_relative_id: u32,
    p_display: *DisplayKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnDisplayPowerControlEXT = *const fn (
    device: Device,
    display: DisplayKHR,
    p_display_power_info: *const DisplayPowerInfoEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnRegisterDeviceEventEXT = *const fn (
    device: Device,
    p_device_event_info: *const DeviceEventInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
    p_fence: *Fence,
) callconv(vulkan_call_conv) Result;
pub const PfnRegisterDisplayEventEXT = *const fn (
    device: Device,
    display: DisplayKHR,
    p_display_event_info: *const DisplayEventInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
    p_fence: *Fence,
) callconv(vulkan_call_conv) Result;
pub const PfnGetSwapchainCounterEXT = *const fn (
    device: Device,
    swapchain: SwapchainKHR,
    counter: SurfaceCounterFlagsEXT,
    p_counter_value: *u64,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceSurfaceCapabilities2EXT = *const fn (
    physical_device: PhysicalDevice,
    surface: SurfaceKHR,
    p_surface_capabilities: *SurfaceCapabilities2EXT,
) callconv(vulkan_call_conv) Result;
pub const PfnEnumeratePhysicalDeviceGroups = *const fn (
    instance: Instance,
    p_physical_device_group_count: *u32,
    p_physical_device_group_properties: ?[*]PhysicalDeviceGroupProperties,
) callconv(vulkan_call_conv) Result;
pub const PfnEnumeratePhysicalDeviceGroupsKHR = PfnEnumeratePhysicalDeviceGroups;
pub const PfnGetDeviceGroupPeerMemoryFeatures = *const fn (
    device: Device,
    heap_index: u32,
    local_device_index: u32,
    remote_device_index: u32,
    p_peer_memory_features: *PeerMemoryFeatureFlags,
) callconv(vulkan_call_conv) void;
pub const PfnGetDeviceGroupPeerMemoryFeaturesKHR = PfnGetDeviceGroupPeerMemoryFeatures;
pub const PfnBindBufferMemory2 = *const fn (
    device: Device,
    bind_info_count: u32,
    p_bind_infos: [*]const BindBufferMemoryInfo,
) callconv(vulkan_call_conv) Result;
pub const PfnBindBufferMemory2KHR = PfnBindBufferMemory2;
pub const PfnBindImageMemory2 = *const fn (
    device: Device,
    bind_info_count: u32,
    p_bind_infos: [*]const BindImageMemoryInfo,
) callconv(vulkan_call_conv) Result;
pub const PfnBindImageMemory2KHR = PfnBindImageMemory2;
pub const PfnCmdSetDeviceMask = *const fn (
    command_buffer: CommandBuffer,
    device_mask: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetDeviceMaskKHR = PfnCmdSetDeviceMask;
pub const PfnGetDeviceGroupPresentCapabilitiesKHR = *const fn (
    device: Device,
    p_device_group_present_capabilities: *DeviceGroupPresentCapabilitiesKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDeviceGroupSurfacePresentModesKHR = *const fn (
    device: Device,
    surface: SurfaceKHR,
    p_modes: *DeviceGroupPresentModeFlagsKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnAcquireNextImage2KHR = *const fn (
    device: Device,
    p_acquire_info: *const AcquireNextImageInfoKHR,
    p_image_index: *u32,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdDispatchBase = *const fn (
    command_buffer: CommandBuffer,
    base_group_x: u32,
    base_group_y: u32,
    base_group_z: u32,
    group_count_x: u32,
    group_count_y: u32,
    group_count_z: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDispatchBaseKHR = PfnCmdDispatchBase;
pub const PfnGetPhysicalDevicePresentRectanglesKHR = *const fn (
    physical_device: PhysicalDevice,
    surface: SurfaceKHR,
    p_rect_count: *u32,
    p_rects: ?[*]Rect2D,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateDescriptorUpdateTemplate = *const fn (
    device: Device,
    p_create_info: *const DescriptorUpdateTemplateCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_descriptor_update_template: *DescriptorUpdateTemplate,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateDescriptorUpdateTemplateKHR = PfnCreateDescriptorUpdateTemplate;
pub const PfnDestroyDescriptorUpdateTemplate = *const fn (
    device: Device,
    descriptor_update_template: DescriptorUpdateTemplate,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnDestroyDescriptorUpdateTemplateKHR = PfnDestroyDescriptorUpdateTemplate;
pub const PfnUpdateDescriptorSetWithTemplate = *const fn (
    device: Device,
    descriptor_set: DescriptorSet,
    descriptor_update_template: DescriptorUpdateTemplate,
    p_data: *const anyopaque,
) callconv(vulkan_call_conv) void;
pub const PfnUpdateDescriptorSetWithTemplateKHR = PfnUpdateDescriptorSetWithTemplate;
pub const PfnCmdPushDescriptorSetWithTemplate = *const fn (
    command_buffer: CommandBuffer,
    descriptor_update_template: DescriptorUpdateTemplate,
    layout: PipelineLayout,
    set: u32,
    p_data: *const anyopaque,
) callconv(vulkan_call_conv) void;
pub const PfnCmdPushDescriptorSetWithTemplateKHR = PfnCmdPushDescriptorSetWithTemplate;
pub const PfnSetHdrMetadataEXT = *const fn (
    device: Device,
    swapchain_count: u32,
    p_swapchains: [*]const SwapchainKHR,
    p_metadata: [*]const HdrMetadataEXT,
) callconv(vulkan_call_conv) void;
pub const PfnGetSwapchainStatusKHR = *const fn (
    device: Device,
    swapchain: SwapchainKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetRefreshCycleDurationGOOGLE = *const fn (
    device: Device,
    swapchain: SwapchainKHR,
    p_display_timing_properties: *RefreshCycleDurationGOOGLE,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPastPresentationTimingGOOGLE = *const fn (
    device: Device,
    swapchain: SwapchainKHR,
    p_presentation_timing_count: *u32,
    p_presentation_timings: ?[*]PastPresentationTimingGOOGLE,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateIOSSurfaceMVK = *const fn (
    instance: Instance,
    p_create_info: *const IOSSurfaceCreateInfoMVK,
    p_allocator: ?*const AllocationCallbacks,
    p_surface: *SurfaceKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateMacOSSurfaceMVK = *const fn (
    instance: Instance,
    p_create_info: *const MacOSSurfaceCreateInfoMVK,
    p_allocator: ?*const AllocationCallbacks,
    p_surface: *SurfaceKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateMetalSurfaceEXT = *const fn (
    instance: Instance,
    p_create_info: *const MetalSurfaceCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
    p_surface: *SurfaceKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdSetViewportWScalingNV = *const fn (
    command_buffer: CommandBuffer,
    first_viewport: u32,
    viewport_count: u32,
    p_viewport_w_scalings: [*]const ViewportWScalingNV,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetDiscardRectangleEXT = *const fn (
    command_buffer: CommandBuffer,
    first_discard_rectangle: u32,
    discard_rectangle_count: u32,
    p_discard_rectangles: [*]const Rect2D,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetDiscardRectangleEnableEXT = *const fn (
    command_buffer: CommandBuffer,
    discard_rectangle_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetDiscardRectangleModeEXT = *const fn (
    command_buffer: CommandBuffer,
    discard_rectangle_mode: DiscardRectangleModeEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetSampleLocationsEXT = *const fn (
    command_buffer: CommandBuffer,
    p_sample_locations_info: *const SampleLocationsInfoEXT,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceMultisamplePropertiesEXT = *const fn (
    physical_device: PhysicalDevice,
    samples: SampleCountFlags,
    p_multisample_properties: *MultisamplePropertiesEXT,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceSurfaceCapabilities2KHR = *const fn (
    physical_device: PhysicalDevice,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    p_surface_capabilities: *SurfaceCapabilities2KHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceSurfaceFormats2KHR = *const fn (
    physical_device: PhysicalDevice,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    p_surface_format_count: *u32,
    p_surface_formats: ?[*]SurfaceFormat2KHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceDisplayProperties2KHR = *const fn (
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]DisplayProperties2KHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceDisplayPlaneProperties2KHR = *const fn (
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]DisplayPlaneProperties2KHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDisplayModeProperties2KHR = *const fn (
    physical_device: PhysicalDevice,
    display: DisplayKHR,
    p_property_count: *u32,
    p_properties: ?[*]DisplayModeProperties2KHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDisplayPlaneCapabilities2KHR = *const fn (
    physical_device: PhysicalDevice,
    p_display_plane_info: *const DisplayPlaneInfo2KHR,
    p_capabilities: *DisplayPlaneCapabilities2KHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetBufferMemoryRequirements2 = *const fn (
    device: Device,
    p_info: *const BufferMemoryRequirementsInfo2,
    p_memory_requirements: *MemoryRequirements2,
) callconv(vulkan_call_conv) void;
pub const PfnGetBufferMemoryRequirements2KHR = PfnGetBufferMemoryRequirements2;
pub const PfnGetImageMemoryRequirements2 = *const fn (
    device: Device,
    p_info: *const ImageMemoryRequirementsInfo2,
    p_memory_requirements: *MemoryRequirements2,
) callconv(vulkan_call_conv) void;
pub const PfnGetImageMemoryRequirements2KHR = PfnGetImageMemoryRequirements2;
pub const PfnGetImageSparseMemoryRequirements2 = *const fn (
    device: Device,
    p_info: *const ImageSparseMemoryRequirementsInfo2,
    p_sparse_memory_requirement_count: *u32,
    p_sparse_memory_requirements: ?[*]SparseImageMemoryRequirements2,
) callconv(vulkan_call_conv) void;
pub const PfnGetImageSparseMemoryRequirements2KHR = PfnGetImageSparseMemoryRequirements2;
pub const PfnGetDeviceBufferMemoryRequirements = *const fn (
    device: Device,
    p_info: *const DeviceBufferMemoryRequirements,
    p_memory_requirements: *MemoryRequirements2,
) callconv(vulkan_call_conv) void;
pub const PfnGetDeviceBufferMemoryRequirementsKHR = PfnGetDeviceBufferMemoryRequirements;
pub const PfnGetDeviceImageMemoryRequirements = *const fn (
    device: Device,
    p_info: *const DeviceImageMemoryRequirements,
    p_memory_requirements: *MemoryRequirements2,
) callconv(vulkan_call_conv) void;
pub const PfnGetDeviceImageMemoryRequirementsKHR = PfnGetDeviceImageMemoryRequirements;
pub const PfnGetDeviceImageSparseMemoryRequirements = *const fn (
    device: Device,
    p_info: *const DeviceImageMemoryRequirements,
    p_sparse_memory_requirement_count: *u32,
    p_sparse_memory_requirements: ?[*]SparseImageMemoryRequirements2,
) callconv(vulkan_call_conv) void;
pub const PfnGetDeviceImageSparseMemoryRequirementsKHR = PfnGetDeviceImageSparseMemoryRequirements;
pub const PfnCreateSamplerYcbcrConversion = *const fn (
    device: Device,
    p_create_info: *const SamplerYcbcrConversionCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_ycbcr_conversion: *SamplerYcbcrConversion,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateSamplerYcbcrConversionKHR = PfnCreateSamplerYcbcrConversion;
pub const PfnDestroySamplerYcbcrConversion = *const fn (
    device: Device,
    ycbcr_conversion: SamplerYcbcrConversion,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnDestroySamplerYcbcrConversionKHR = PfnDestroySamplerYcbcrConversion;
pub const PfnGetDeviceQueue2 = *const fn (
    device: Device,
    p_queue_info: *const DeviceQueueInfo2,
    p_queue: *Queue,
) callconv(vulkan_call_conv) void;
pub const PfnCreateValidationCacheEXT = *const fn (
    device: Device,
    p_create_info: *const ValidationCacheCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
    p_validation_cache: *ValidationCacheEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyValidationCacheEXT = *const fn (
    device: Device,
    validation_cache: ValidationCacheEXT,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnGetValidationCacheDataEXT = *const fn (
    device: Device,
    validation_cache: ValidationCacheEXT,
    p_data_size: *usize,
    p_data: ?*anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnMergeValidationCachesEXT = *const fn (
    device: Device,
    dst_cache: ValidationCacheEXT,
    src_cache_count: u32,
    p_src_caches: [*]const ValidationCacheEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDescriptorSetLayoutSupport = *const fn (
    device: Device,
    p_create_info: *const DescriptorSetLayoutCreateInfo,
    p_support: *DescriptorSetLayoutSupport,
) callconv(vulkan_call_conv) void;
pub const PfnGetDescriptorSetLayoutSupportKHR = PfnGetDescriptorSetLayoutSupport;
pub const PfnGetSwapchainGrallocUsageANDROID = *const fn (
    device: Device,
    format: Format,
    image_usage: ImageUsageFlags,
    gralloc_usage: *c_int,
) callconv(vulkan_call_conv) Result;
pub const PfnGetSwapchainGrallocUsage2ANDROID = *const fn (
    device: Device,
    format: Format,
    image_usage: ImageUsageFlags,
    swapchain_image_usage: SwapchainImageUsageFlagsANDROID,
    gralloc_consumer_usage: *u64,
    gralloc_producer_usage: *u64,
) callconv(vulkan_call_conv) Result;
pub const PfnAcquireImageANDROID = *const fn (
    device: Device,
    image: Image,
    native_fence_fd: c_int,
    semaphore: Semaphore,
    fence: Fence,
) callconv(vulkan_call_conv) Result;
pub const PfnQueueSignalReleaseImageANDROID = *const fn (
    queue: Queue,
    wait_semaphore_count: u32,
    p_wait_semaphores: [*]const Semaphore,
    image: Image,
    p_native_fence_fd: *c_int,
) callconv(vulkan_call_conv) Result;
pub const PfnGetShaderInfoAMD = *const fn (
    device: Device,
    pipeline: Pipeline,
    shader_stage: ShaderStageFlags,
    info_type: ShaderInfoTypeAMD,
    p_info_size: *usize,
    p_info: ?*anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnSetLocalDimmingAMD = *const fn (
    device: Device,
    swap_chain: SwapchainKHR,
    local_dimming_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceCalibrateableTimeDomainsKHR = *const fn (
    physical_device: PhysicalDevice,
    p_time_domain_count: *u32,
    p_time_domains: ?[*]TimeDomainKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceCalibrateableTimeDomainsEXT = PfnGetPhysicalDeviceCalibrateableTimeDomainsKHR;
pub const PfnGetCalibratedTimestampsKHR = *const fn (
    device: Device,
    timestamp_count: u32,
    p_timestamp_infos: [*]const CalibratedTimestampInfoKHR,
    p_timestamps: [*]u64,
    p_max_deviation: *u64,
) callconv(vulkan_call_conv) Result;
pub const PfnGetCalibratedTimestampsEXT = PfnGetCalibratedTimestampsKHR;
pub const PfnSetDebugUtilsObjectNameEXT = *const fn (
    device: Device,
    p_name_info: *const DebugUtilsObjectNameInfoEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnSetDebugUtilsObjectTagEXT = *const fn (
    device: Device,
    p_tag_info: *const DebugUtilsObjectTagInfoEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnQueueBeginDebugUtilsLabelEXT = *const fn (
    queue: Queue,
    p_label_info: *const DebugUtilsLabelEXT,
) callconv(vulkan_call_conv) void;
pub const PfnQueueEndDebugUtilsLabelEXT = *const fn (
    queue: Queue,
) callconv(vulkan_call_conv) void;
pub const PfnQueueInsertDebugUtilsLabelEXT = *const fn (
    queue: Queue,
    p_label_info: *const DebugUtilsLabelEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBeginDebugUtilsLabelEXT = *const fn (
    command_buffer: CommandBuffer,
    p_label_info: *const DebugUtilsLabelEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCmdEndDebugUtilsLabelEXT = *const fn (
    command_buffer: CommandBuffer,
) callconv(vulkan_call_conv) void;
pub const PfnCmdInsertDebugUtilsLabelEXT = *const fn (
    command_buffer: CommandBuffer,
    p_label_info: *const DebugUtilsLabelEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCreateDebugUtilsMessengerEXT = *const fn (
    instance: Instance,
    p_create_info: *const DebugUtilsMessengerCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
    p_messenger: *DebugUtilsMessengerEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyDebugUtilsMessengerEXT = *const fn (
    instance: Instance,
    messenger: DebugUtilsMessengerEXT,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnSubmitDebugUtilsMessageEXT = *const fn (
    instance: Instance,
    message_severity: DebugUtilsMessageSeverityFlagsEXT,
    message_types: DebugUtilsMessageTypeFlagsEXT,
    p_callback_data: *const DebugUtilsMessengerCallbackDataEXT,
) callconv(vulkan_call_conv) void;
pub const PfnGetMemoryHostPointerPropertiesEXT = *const fn (
    device: Device,
    handle_type: ExternalMemoryHandleTypeFlags,
    p_host_pointer: *const anyopaque,
    p_memory_host_pointer_properties: *MemoryHostPointerPropertiesEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdWriteBufferMarkerAMD = *const fn (
    command_buffer: CommandBuffer,
    pipeline_stage: PipelineStageFlags,
    dst_buffer: Buffer,
    dst_offset: DeviceSize,
    marker: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCreateRenderPass2 = *const fn (
    device: Device,
    p_create_info: *const RenderPassCreateInfo2,
    p_allocator: ?*const AllocationCallbacks,
    p_render_pass: *RenderPass,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateRenderPass2KHR = PfnCreateRenderPass2;
pub const PfnCmdBeginRenderPass2 = *const fn (
    command_buffer: CommandBuffer,
    p_render_pass_begin: *const RenderPassBeginInfo,
    p_subpass_begin_info: *const SubpassBeginInfo,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBeginRenderPass2KHR = PfnCmdBeginRenderPass2;
pub const PfnCmdNextSubpass2 = *const fn (
    command_buffer: CommandBuffer,
    p_subpass_begin_info: *const SubpassBeginInfo,
    p_subpass_end_info: *const SubpassEndInfo,
) callconv(vulkan_call_conv) void;
pub const PfnCmdNextSubpass2KHR = PfnCmdNextSubpass2;
pub const PfnCmdEndRenderPass2 = *const fn (
    command_buffer: CommandBuffer,
    p_subpass_end_info: *const SubpassEndInfo,
) callconv(vulkan_call_conv) void;
pub const PfnCmdEndRenderPass2KHR = PfnCmdEndRenderPass2;
pub const PfnGetSemaphoreCounterValue = *const fn (
    device: Device,
    semaphore: Semaphore,
    p_value: *u64,
) callconv(vulkan_call_conv) Result;
pub const PfnGetSemaphoreCounterValueKHR = PfnGetSemaphoreCounterValue;
pub const PfnWaitSemaphores = *const fn (
    device: Device,
    p_wait_info: *const SemaphoreWaitInfo,
    timeout: u64,
) callconv(vulkan_call_conv) Result;
pub const PfnWaitSemaphoresKHR = PfnWaitSemaphores;
pub const PfnSignalSemaphore = *const fn (
    device: Device,
    p_signal_info: *const SemaphoreSignalInfo,
) callconv(vulkan_call_conv) Result;
pub const PfnSignalSemaphoreKHR = PfnSignalSemaphore;
pub const PfnGetAndroidHardwareBufferPropertiesANDROID = *const fn (
    device: Device,
    buffer: *const AHardwareBuffer,
    p_properties: *AndroidHardwareBufferPropertiesANDROID,
) callconv(vulkan_call_conv) Result;
pub const PfnGetMemoryAndroidHardwareBufferANDROID = *const fn (
    device: Device,
    p_info: *const MemoryGetAndroidHardwareBufferInfoANDROID,
    p_buffer: **AHardwareBuffer,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdDrawIndirectCount = *const fn (
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    count_buffer: Buffer,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDrawIndirectCountKHR = PfnCmdDrawIndirectCount;
pub const PfnCmdDrawIndirectCountAMD = PfnCmdDrawIndirectCount;
pub const PfnCmdDrawIndexedIndirectCount = *const fn (
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    count_buffer: Buffer,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDrawIndexedIndirectCountKHR = PfnCmdDrawIndexedIndirectCount;
pub const PfnCmdDrawIndexedIndirectCountAMD = PfnCmdDrawIndexedIndirectCount;
pub const PfnCmdSetCheckpointNV = *const fn (
    command_buffer: CommandBuffer,
    p_checkpoint_marker: *const anyopaque,
) callconv(vulkan_call_conv) void;
pub const PfnGetQueueCheckpointDataNV = *const fn (
    queue: Queue,
    p_checkpoint_data_count: *u32,
    p_checkpoint_data: ?[*]CheckpointDataNV,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBindTransformFeedbackBuffersEXT = *const fn (
    command_buffer: CommandBuffer,
    first_binding: u32,
    binding_count: u32,
    p_buffers: [*]const Buffer,
    p_offsets: [*]const DeviceSize,
    p_sizes: ?[*]const DeviceSize,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBeginTransformFeedbackEXT = *const fn (
    command_buffer: CommandBuffer,
    first_counter_buffer: u32,
    counter_buffer_count: u32,
    p_counter_buffers: ?[*]const Buffer,
    p_counter_buffer_offsets: ?[*]const DeviceSize,
) callconv(vulkan_call_conv) void;
pub const PfnCmdEndTransformFeedbackEXT = *const fn (
    command_buffer: CommandBuffer,
    first_counter_buffer: u32,
    counter_buffer_count: u32,
    p_counter_buffers: ?[*]const Buffer,
    p_counter_buffer_offsets: ?[*]const DeviceSize,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBeginQueryIndexedEXT = *const fn (
    command_buffer: CommandBuffer,
    query_pool: QueryPool,
    query: u32,
    flags: QueryControlFlags,
    index: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdEndQueryIndexedEXT = *const fn (
    command_buffer: CommandBuffer,
    query_pool: QueryPool,
    query: u32,
    index: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDrawIndirectByteCountEXT = *const fn (
    command_buffer: CommandBuffer,
    instance_count: u32,
    first_instance: u32,
    counter_buffer: Buffer,
    counter_buffer_offset: DeviceSize,
    counter_offset: u32,
    vertex_stride: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetExclusiveScissorNV = *const fn (
    command_buffer: CommandBuffer,
    first_exclusive_scissor: u32,
    exclusive_scissor_count: u32,
    p_exclusive_scissors: [*]const Rect2D,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetExclusiveScissorEnableNV = *const fn (
    command_buffer: CommandBuffer,
    first_exclusive_scissor: u32,
    exclusive_scissor_count: u32,
    p_exclusive_scissor_enables: [*]const Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBindShadingRateImageNV = *const fn (
    command_buffer: CommandBuffer,
    image_view: ImageView,
    image_layout: ImageLayout,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetViewportShadingRatePaletteNV = *const fn (
    command_buffer: CommandBuffer,
    first_viewport: u32,
    viewport_count: u32,
    p_shading_rate_palettes: [*]const ShadingRatePaletteNV,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetCoarseSampleOrderNV = *const fn (
    command_buffer: CommandBuffer,
    sample_order_type: CoarseSampleOrderTypeNV,
    custom_sample_order_count: u32,
    p_custom_sample_orders: ?[*]const CoarseSampleOrderCustomNV,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDrawMeshTasksNV = *const fn (
    command_buffer: CommandBuffer,
    task_count: u32,
    first_task: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDrawMeshTasksIndirectNV = *const fn (
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    draw_count: u32,
    stride: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDrawMeshTasksIndirectCountNV = *const fn (
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    count_buffer: Buffer,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDrawMeshTasksEXT = *const fn (
    command_buffer: CommandBuffer,
    group_count_x: u32,
    group_count_y: u32,
    group_count_z: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDrawMeshTasksIndirectEXT = *const fn (
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    draw_count: u32,
    stride: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDrawMeshTasksIndirectCountEXT = *const fn (
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    count_buffer: Buffer,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCompileDeferredNV = *const fn (
    device: Device,
    pipeline: Pipeline,
    shader: u32,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateAccelerationStructureNV = *const fn (
    device: Device,
    p_create_info: *const AccelerationStructureCreateInfoNV,
    p_allocator: ?*const AllocationCallbacks,
    p_acceleration_structure: *AccelerationStructureNV,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdBindInvocationMaskHUAWEI = *const fn (
    command_buffer: CommandBuffer,
    image_view: ImageView,
    image_layout: ImageLayout,
) callconv(vulkan_call_conv) void;
pub const PfnDestroyAccelerationStructureKHR = *const fn (
    device: Device,
    acceleration_structure: AccelerationStructureKHR,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnDestroyAccelerationStructureNV = *const fn (
    device: Device,
    acceleration_structure: AccelerationStructureNV,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnGetAccelerationStructureMemoryRequirementsNV = *const fn (
    device: Device,
    p_info: *const AccelerationStructureMemoryRequirementsInfoNV,
    p_memory_requirements: *MemoryRequirements2KHR,
) callconv(vulkan_call_conv) void;
pub const PfnBindAccelerationStructureMemoryNV = *const fn (
    device: Device,
    bind_info_count: u32,
    p_bind_infos: [*]const BindAccelerationStructureMemoryInfoNV,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdCopyAccelerationStructureNV = *const fn (
    command_buffer: CommandBuffer,
    dst: AccelerationStructureNV,
    src: AccelerationStructureNV,
    mode: CopyAccelerationStructureModeKHR,
) callconv(vulkan_call_conv) void;
pub const PfnCmdCopyAccelerationStructureKHR = *const fn (
    command_buffer: CommandBuffer,
    p_info: *const CopyAccelerationStructureInfoKHR,
) callconv(vulkan_call_conv) void;
pub const PfnCopyAccelerationStructureKHR = *const fn (
    device: Device,
    deferred_operation: DeferredOperationKHR,
    p_info: *const CopyAccelerationStructureInfoKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdCopyAccelerationStructureToMemoryKHR = *const fn (
    command_buffer: CommandBuffer,
    p_info: *const CopyAccelerationStructureToMemoryInfoKHR,
) callconv(vulkan_call_conv) void;
pub const PfnCopyAccelerationStructureToMemoryKHR = *const fn (
    device: Device,
    deferred_operation: DeferredOperationKHR,
    p_info: *const CopyAccelerationStructureToMemoryInfoKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdCopyMemoryToAccelerationStructureKHR = *const fn (
    command_buffer: CommandBuffer,
    p_info: *const CopyMemoryToAccelerationStructureInfoKHR,
) callconv(vulkan_call_conv) void;
pub const PfnCopyMemoryToAccelerationStructureKHR = *const fn (
    device: Device,
    deferred_operation: DeferredOperationKHR,
    p_info: *const CopyMemoryToAccelerationStructureInfoKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdWriteAccelerationStructuresPropertiesKHR = *const fn (
    command_buffer: CommandBuffer,
    acceleration_structure_count: u32,
    p_acceleration_structures: [*]const AccelerationStructureKHR,
    query_type: QueryType,
    query_pool: QueryPool,
    first_query: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdWriteAccelerationStructuresPropertiesNV = *const fn (
    command_buffer: CommandBuffer,
    acceleration_structure_count: u32,
    p_acceleration_structures: [*]const AccelerationStructureNV,
    query_type: QueryType,
    query_pool: QueryPool,
    first_query: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBuildAccelerationStructureNV = *const fn (
    command_buffer: CommandBuffer,
    p_info: *const AccelerationStructureInfoNV,
    instance_data: Buffer,
    instance_offset: DeviceSize,
    update: Bool32,
    dst: AccelerationStructureNV,
    src: AccelerationStructureNV,
    scratch: Buffer,
    scratch_offset: DeviceSize,
) callconv(vulkan_call_conv) void;
pub const PfnWriteAccelerationStructuresPropertiesKHR = *const fn (
    device: Device,
    acceleration_structure_count: u32,
    p_acceleration_structures: [*]const AccelerationStructureKHR,
    query_type: QueryType,
    data_size: usize,
    p_data: *anyopaque,
    stride: usize,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdTraceRaysKHR = *const fn (
    command_buffer: CommandBuffer,
    p_raygen_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_miss_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_hit_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_callable_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    width: u32,
    height: u32,
    depth: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdTraceRaysNV = *const fn (
    command_buffer: CommandBuffer,
    raygen_shader_binding_table_buffer: Buffer,
    raygen_shader_binding_offset: DeviceSize,
    miss_shader_binding_table_buffer: Buffer,
    miss_shader_binding_offset: DeviceSize,
    miss_shader_binding_stride: DeviceSize,
    hit_shader_binding_table_buffer: Buffer,
    hit_shader_binding_offset: DeviceSize,
    hit_shader_binding_stride: DeviceSize,
    callable_shader_binding_table_buffer: Buffer,
    callable_shader_binding_offset: DeviceSize,
    callable_shader_binding_stride: DeviceSize,
    width: u32,
    height: u32,
    depth: u32,
) callconv(vulkan_call_conv) void;
pub const PfnGetRayTracingShaderGroupHandlesKHR = *const fn (
    device: Device,
    pipeline: Pipeline,
    first_group: u32,
    group_count: u32,
    data_size: usize,
    p_data: *anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnGetRayTracingShaderGroupHandlesNV = PfnGetRayTracingShaderGroupHandlesKHR;
pub const PfnGetRayTracingCaptureReplayShaderGroupHandlesKHR = *const fn (
    device: Device,
    pipeline: Pipeline,
    first_group: u32,
    group_count: u32,
    data_size: usize,
    p_data: *anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnGetAccelerationStructureHandleNV = *const fn (
    device: Device,
    acceleration_structure: AccelerationStructureNV,
    data_size: usize,
    p_data: *anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateRayTracingPipelinesNV = *const fn (
    device: Device,
    pipeline_cache: PipelineCache,
    create_info_count: u32,
    p_create_infos: [*]const RayTracingPipelineCreateInfoNV,
    p_allocator: ?*const AllocationCallbacks,
    p_pipelines: [*]Pipeline,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateRayTracingPipelinesKHR = *const fn (
    device: Device,
    deferred_operation: DeferredOperationKHR,
    pipeline_cache: PipelineCache,
    create_info_count: u32,
    p_create_infos: [*]const RayTracingPipelineCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_pipelines: [*]Pipeline,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceCooperativeMatrixPropertiesNV = *const fn (
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]CooperativeMatrixPropertiesNV,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdTraceRaysIndirectKHR = *const fn (
    command_buffer: CommandBuffer,
    p_raygen_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_miss_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_hit_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_callable_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    indirect_device_address: DeviceAddress,
) callconv(vulkan_call_conv) void;
pub const PfnCmdTraceRaysIndirect2KHR = *const fn (
    command_buffer: CommandBuffer,
    indirect_device_address: DeviceAddress,
) callconv(vulkan_call_conv) void;
pub const PfnGetClusterAccelerationStructureBuildSizesNV = *const fn (
    device: Device,
    p_info: *const ClusterAccelerationStructureInputInfoNV,
    p_size_info: *AccelerationStructureBuildSizesInfoKHR,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBuildClusterAccelerationStructureIndirectNV = *const fn (
    command_buffer: CommandBuffer,
    p_command_infos: *const ClusterAccelerationStructureCommandsInfoNV,
) callconv(vulkan_call_conv) void;
pub const PfnGetDeviceAccelerationStructureCompatibilityKHR = *const fn (
    device: Device,
    p_version_info: *const AccelerationStructureVersionInfoKHR,
    p_compatibility: *AccelerationStructureCompatibilityKHR,
) callconv(vulkan_call_conv) void;
pub const PfnGetRayTracingShaderGroupStackSizeKHR = *const fn (
    device: Device,
    pipeline: Pipeline,
    group: u32,
    group_shader: ShaderGroupShaderKHR,
) callconv(vulkan_call_conv) DeviceSize;
pub const PfnCmdSetRayTracingPipelineStackSizeKHR = *const fn (
    command_buffer: CommandBuffer,
    pipeline_stack_size: u32,
) callconv(vulkan_call_conv) void;
pub const PfnGetImageViewHandleNVX = *const fn (
    device: Device,
    p_info: *const ImageViewHandleInfoNVX,
) callconv(vulkan_call_conv) u32;
pub const PfnGetImageViewHandle64NVX = *const fn (
    device: Device,
    p_info: *const ImageViewHandleInfoNVX,
) callconv(vulkan_call_conv) u64;
pub const PfnGetImageViewAddressNVX = *const fn (
    device: Device,
    image_view: ImageView,
    p_properties: *ImageViewAddressPropertiesNVX,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceSurfacePresentModes2EXT = *const fn (
    physical_device: PhysicalDevice,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    p_present_mode_count: *u32,
    p_present_modes: ?[*]PresentModeKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDeviceGroupSurfacePresentModes2EXT = *const fn (
    device: Device,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    p_modes: *DeviceGroupPresentModeFlagsKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnAcquireFullScreenExclusiveModeEXT = *const fn (
    device: Device,
    swapchain: SwapchainKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnReleaseFullScreenExclusiveModeEXT = *const fn (
    device: Device,
    swapchain: SwapchainKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = *const fn (
    physical_device: PhysicalDevice,
    queue_family_index: u32,
    p_counter_count: *u32,
    p_counters: ?[*]PerformanceCounterKHR,
    p_counter_descriptions: ?[*]PerformanceCounterDescriptionKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = *const fn (
    physical_device: PhysicalDevice,
    p_performance_query_create_info: *const QueryPoolPerformanceCreateInfoKHR,
    p_num_passes: *u32,
) callconv(vulkan_call_conv) void;
pub const PfnAcquireProfilingLockKHR = *const fn (
    device: Device,
    p_info: *const AcquireProfilingLockInfoKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnReleaseProfilingLockKHR = *const fn (
    device: Device,
) callconv(vulkan_call_conv) void;
pub const PfnGetImageDrmFormatModifierPropertiesEXT = *const fn (
    device: Device,
    image: Image,
    p_properties: *ImageDrmFormatModifierPropertiesEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnGetBufferOpaqueCaptureAddress = *const fn (
    device: Device,
    p_info: *const BufferDeviceAddressInfo,
) callconv(vulkan_call_conv) u64;
pub const PfnGetBufferOpaqueCaptureAddressKHR = PfnGetBufferOpaqueCaptureAddress;
pub const PfnGetBufferDeviceAddress = *const fn (
    device: Device,
    p_info: *const BufferDeviceAddressInfo,
) callconv(vulkan_call_conv) DeviceAddress;
pub const PfnGetBufferDeviceAddressKHR = PfnGetBufferDeviceAddress;
pub const PfnGetBufferDeviceAddressEXT = PfnGetBufferDeviceAddress;
pub const PfnCreateHeadlessSurfaceEXT = *const fn (
    instance: Instance,
    p_create_info: *const HeadlessSurfaceCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
    p_surface: *SurfaceKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = *const fn (
    physical_device: PhysicalDevice,
    p_combination_count: *u32,
    p_combinations: ?[*]FramebufferMixedSamplesCombinationNV,
) callconv(vulkan_call_conv) Result;
pub const PfnInitializePerformanceApiINTEL = *const fn (
    device: Device,
    p_initialize_info: *const InitializePerformanceApiInfoINTEL,
) callconv(vulkan_call_conv) Result;
pub const PfnUninitializePerformanceApiINTEL = *const fn (
    device: Device,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetPerformanceMarkerINTEL = *const fn (
    command_buffer: CommandBuffer,
    p_marker_info: *const PerformanceMarkerInfoINTEL,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdSetPerformanceStreamMarkerINTEL = *const fn (
    command_buffer: CommandBuffer,
    p_marker_info: *const PerformanceStreamMarkerInfoINTEL,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdSetPerformanceOverrideINTEL = *const fn (
    command_buffer: CommandBuffer,
    p_override_info: *const PerformanceOverrideInfoINTEL,
) callconv(vulkan_call_conv) Result;
pub const PfnAcquirePerformanceConfigurationINTEL = *const fn (
    device: Device,
    p_acquire_info: *const PerformanceConfigurationAcquireInfoINTEL,
    p_configuration: *PerformanceConfigurationINTEL,
) callconv(vulkan_call_conv) Result;
pub const PfnReleasePerformanceConfigurationINTEL = *const fn (
    device: Device,
    configuration: PerformanceConfigurationINTEL,
) callconv(vulkan_call_conv) Result;
pub const PfnQueueSetPerformanceConfigurationINTEL = *const fn (
    queue: Queue,
    configuration: PerformanceConfigurationINTEL,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPerformanceParameterINTEL = *const fn (
    device: Device,
    parameter: PerformanceParameterTypeINTEL,
    p_value: *PerformanceValueINTEL,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDeviceMemoryOpaqueCaptureAddress = *const fn (
    device: Device,
    p_info: *const DeviceMemoryOpaqueCaptureAddressInfo,
) callconv(vulkan_call_conv) u64;
pub const PfnGetDeviceMemoryOpaqueCaptureAddressKHR = PfnGetDeviceMemoryOpaqueCaptureAddress;
pub const PfnGetPipelineExecutablePropertiesKHR = *const fn (
    device: Device,
    p_pipeline_info: *const PipelineInfoKHR,
    p_executable_count: *u32,
    p_properties: ?[*]PipelineExecutablePropertiesKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPipelineExecutableStatisticsKHR = *const fn (
    device: Device,
    p_executable_info: *const PipelineExecutableInfoKHR,
    p_statistic_count: *u32,
    p_statistics: ?[*]PipelineExecutableStatisticKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPipelineExecutableInternalRepresentationsKHR = *const fn (
    device: Device,
    p_executable_info: *const PipelineExecutableInfoKHR,
    p_internal_representation_count: *u32,
    p_internal_representations: ?[*]PipelineExecutableInternalRepresentationKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdSetLineStipple = *const fn (
    command_buffer: CommandBuffer,
    line_stipple_factor: u32,
    line_stipple_pattern: u16,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetLineStippleKHR = PfnCmdSetLineStipple;
pub const PfnCmdSetLineStippleEXT = PfnCmdSetLineStipple;
pub const PfnGetFaultData = *const fn (
    device: Device,
    fault_query_behavior: FaultQueryBehavior,
    p_unrecorded_faults: *Bool32,
    p_fault_count: *u32,
    p_faults: ?[*]FaultData,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceToolProperties = *const fn (
    physical_device: PhysicalDevice,
    p_tool_count: *u32,
    p_tool_properties: ?[*]PhysicalDeviceToolProperties,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceToolPropertiesEXT = PfnGetPhysicalDeviceToolProperties;
pub const PfnCreateAccelerationStructureKHR = *const fn (
    device: Device,
    p_create_info: *const AccelerationStructureCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_acceleration_structure: *AccelerationStructureKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdBuildAccelerationStructuresKHR = *const fn (
    command_buffer: CommandBuffer,
    info_count: u32,
    p_infos: [*]const AccelerationStructureBuildGeometryInfoKHR,
    pp_build_range_infos: [*]const [*]const AccelerationStructureBuildRangeInfoKHR,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBuildAccelerationStructuresIndirectKHR = *const fn (
    command_buffer: CommandBuffer,
    info_count: u32,
    p_infos: [*]const AccelerationStructureBuildGeometryInfoKHR,
    p_indirect_device_addresses: [*]const DeviceAddress,
    p_indirect_strides: [*]const u32,
    pp_max_primitive_counts: [*]const [*]const u32,
) callconv(vulkan_call_conv) void;
pub const PfnBuildAccelerationStructuresKHR = *const fn (
    device: Device,
    deferred_operation: DeferredOperationKHR,
    info_count: u32,
    p_infos: [*]const AccelerationStructureBuildGeometryInfoKHR,
    pp_build_range_infos: [*]const [*]const AccelerationStructureBuildRangeInfoKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetAccelerationStructureDeviceAddressKHR = *const fn (
    device: Device,
    p_info: *const AccelerationStructureDeviceAddressInfoKHR,
) callconv(vulkan_call_conv) DeviceAddress;
pub const PfnCreateDeferredOperationKHR = *const fn (
    device: Device,
    p_allocator: ?*const AllocationCallbacks,
    p_deferred_operation: *DeferredOperationKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyDeferredOperationKHR = *const fn (
    device: Device,
    operation: DeferredOperationKHR,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnGetDeferredOperationMaxConcurrencyKHR = *const fn (
    device: Device,
    operation: DeferredOperationKHR,
) callconv(vulkan_call_conv) u32;
pub const PfnGetDeferredOperationResultKHR = *const fn (
    device: Device,
    operation: DeferredOperationKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnDeferredOperationJoinKHR = *const fn (
    device: Device,
    operation: DeferredOperationKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPipelineIndirectMemoryRequirementsNV = *const fn (
    device: Device,
    p_create_info: *const ComputePipelineCreateInfo,
    p_memory_requirements: *MemoryRequirements2,
) callconv(vulkan_call_conv) void;
pub const PfnGetPipelineIndirectDeviceAddressNV = *const fn (
    device: Device,
    p_info: *const PipelineIndirectDeviceAddressInfoNV,
) callconv(vulkan_call_conv) DeviceAddress;
pub const PfnAntiLagUpdateAMD = *const fn (
    device: Device,
    p_data: *const AntiLagDataAMD,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetCullMode = *const fn (
    command_buffer: CommandBuffer,
    cull_mode: CullModeFlags,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetCullModeEXT = PfnCmdSetCullMode;
pub const PfnCmdSetFrontFace = *const fn (
    command_buffer: CommandBuffer,
    front_face: FrontFace,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetFrontFaceEXT = PfnCmdSetFrontFace;
pub const PfnCmdSetPrimitiveTopology = *const fn (
    command_buffer: CommandBuffer,
    primitive_topology: PrimitiveTopology,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetPrimitiveTopologyEXT = PfnCmdSetPrimitiveTopology;
pub const PfnCmdSetViewportWithCount = *const fn (
    command_buffer: CommandBuffer,
    viewport_count: u32,
    p_viewports: [*]const Viewport,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetViewportWithCountEXT = PfnCmdSetViewportWithCount;
pub const PfnCmdSetScissorWithCount = *const fn (
    command_buffer: CommandBuffer,
    scissor_count: u32,
    p_scissors: [*]const Rect2D,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetScissorWithCountEXT = PfnCmdSetScissorWithCount;
pub const PfnCmdBindIndexBuffer2 = *const fn (
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    size: DeviceSize,
    index_type: IndexType,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBindIndexBuffer2KHR = PfnCmdBindIndexBuffer2;
pub const PfnCmdBindVertexBuffers2 = *const fn (
    command_buffer: CommandBuffer,
    first_binding: u32,
    binding_count: u32,
    p_buffers: [*]const Buffer,
    p_offsets: [*]const DeviceSize,
    p_sizes: ?[*]const DeviceSize,
    p_strides: ?[*]const DeviceSize,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBindVertexBuffers2EXT = PfnCmdBindVertexBuffers2;
pub const PfnCmdSetDepthTestEnable = *const fn (
    command_buffer: CommandBuffer,
    depth_test_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetDepthTestEnableEXT = PfnCmdSetDepthTestEnable;
pub const PfnCmdSetDepthWriteEnable = *const fn (
    command_buffer: CommandBuffer,
    depth_write_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetDepthWriteEnableEXT = PfnCmdSetDepthWriteEnable;
pub const PfnCmdSetDepthCompareOp = *const fn (
    command_buffer: CommandBuffer,
    depth_compare_op: CompareOp,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetDepthCompareOpEXT = PfnCmdSetDepthCompareOp;
pub const PfnCmdSetDepthBoundsTestEnable = *const fn (
    command_buffer: CommandBuffer,
    depth_bounds_test_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetDepthBoundsTestEnableEXT = PfnCmdSetDepthBoundsTestEnable;
pub const PfnCmdSetStencilTestEnable = *const fn (
    command_buffer: CommandBuffer,
    stencil_test_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetStencilTestEnableEXT = PfnCmdSetStencilTestEnable;
pub const PfnCmdSetStencilOp = *const fn (
    command_buffer: CommandBuffer,
    face_mask: StencilFaceFlags,
    fail_op: StencilOp,
    pass_op: StencilOp,
    depth_fail_op: StencilOp,
    compare_op: CompareOp,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetStencilOpEXT = PfnCmdSetStencilOp;
pub const PfnCmdSetPatchControlPointsEXT = *const fn (
    command_buffer: CommandBuffer,
    patch_control_points: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetRasterizerDiscardEnable = *const fn (
    command_buffer: CommandBuffer,
    rasterizer_discard_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetRasterizerDiscardEnableEXT = PfnCmdSetRasterizerDiscardEnable;
pub const PfnCmdSetDepthBiasEnable = *const fn (
    command_buffer: CommandBuffer,
    depth_bias_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetDepthBiasEnableEXT = PfnCmdSetDepthBiasEnable;
pub const PfnCmdSetLogicOpEXT = *const fn (
    command_buffer: CommandBuffer,
    logic_op: LogicOp,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetPrimitiveRestartEnable = *const fn (
    command_buffer: CommandBuffer,
    primitive_restart_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetPrimitiveRestartEnableEXT = PfnCmdSetPrimitiveRestartEnable;
pub const PfnCmdSetTessellationDomainOriginEXT = *const fn (
    command_buffer: CommandBuffer,
    domain_origin: TessellationDomainOrigin,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetDepthClampEnableEXT = *const fn (
    command_buffer: CommandBuffer,
    depth_clamp_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetPolygonModeEXT = *const fn (
    command_buffer: CommandBuffer,
    polygon_mode: PolygonMode,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetRasterizationSamplesEXT = *const fn (
    command_buffer: CommandBuffer,
    rasterization_samples: SampleCountFlags,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetSampleMaskEXT = *const fn (
    command_buffer: CommandBuffer,
    samples: SampleCountFlags,
    p_sample_mask: [*]const SampleMask,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetAlphaToCoverageEnableEXT = *const fn (
    command_buffer: CommandBuffer,
    alpha_to_coverage_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetAlphaToOneEnableEXT = *const fn (
    command_buffer: CommandBuffer,
    alpha_to_one_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetLogicOpEnableEXT = *const fn (
    command_buffer: CommandBuffer,
    logic_op_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetColorBlendEnableEXT = *const fn (
    command_buffer: CommandBuffer,
    first_attachment: u32,
    attachment_count: u32,
    p_color_blend_enables: [*]const Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetColorBlendEquationEXT = *const fn (
    command_buffer: CommandBuffer,
    first_attachment: u32,
    attachment_count: u32,
    p_color_blend_equations: [*]const ColorBlendEquationEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetColorWriteMaskEXT = *const fn (
    command_buffer: CommandBuffer,
    first_attachment: u32,
    attachment_count: u32,
    p_color_write_masks: [*]const ColorComponentFlags,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetRasterizationStreamEXT = *const fn (
    command_buffer: CommandBuffer,
    rasterization_stream: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetConservativeRasterizationModeEXT = *const fn (
    command_buffer: CommandBuffer,
    conservative_rasterization_mode: ConservativeRasterizationModeEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetExtraPrimitiveOverestimationSizeEXT = *const fn (
    command_buffer: CommandBuffer,
    extra_primitive_overestimation_size: f32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetDepthClipEnableEXT = *const fn (
    command_buffer: CommandBuffer,
    depth_clip_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetSampleLocationsEnableEXT = *const fn (
    command_buffer: CommandBuffer,
    sample_locations_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetColorBlendAdvancedEXT = *const fn (
    command_buffer: CommandBuffer,
    first_attachment: u32,
    attachment_count: u32,
    p_color_blend_advanced: [*]const ColorBlendAdvancedEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetProvokingVertexModeEXT = *const fn (
    command_buffer: CommandBuffer,
    provoking_vertex_mode: ProvokingVertexModeEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetLineRasterizationModeEXT = *const fn (
    command_buffer: CommandBuffer,
    line_rasterization_mode: LineRasterizationModeEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetLineStippleEnableEXT = *const fn (
    command_buffer: CommandBuffer,
    stippled_line_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetDepthClipNegativeOneToOneEXT = *const fn (
    command_buffer: CommandBuffer,
    negative_one_to_one: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetViewportWScalingEnableNV = *const fn (
    command_buffer: CommandBuffer,
    viewport_w_scaling_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetViewportSwizzleNV = *const fn (
    command_buffer: CommandBuffer,
    first_viewport: u32,
    viewport_count: u32,
    p_viewport_swizzles: [*]const ViewportSwizzleNV,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetCoverageToColorEnableNV = *const fn (
    command_buffer: CommandBuffer,
    coverage_to_color_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetCoverageToColorLocationNV = *const fn (
    command_buffer: CommandBuffer,
    coverage_to_color_location: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetCoverageModulationModeNV = *const fn (
    command_buffer: CommandBuffer,
    coverage_modulation_mode: CoverageModulationModeNV,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetCoverageModulationTableEnableNV = *const fn (
    command_buffer: CommandBuffer,
    coverage_modulation_table_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetCoverageModulationTableNV = *const fn (
    command_buffer: CommandBuffer,
    coverage_modulation_table_count: u32,
    p_coverage_modulation_table: [*]const f32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetShadingRateImageEnableNV = *const fn (
    command_buffer: CommandBuffer,
    shading_rate_image_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetCoverageReductionModeNV = *const fn (
    command_buffer: CommandBuffer,
    coverage_reduction_mode: CoverageReductionModeNV,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetRepresentativeFragmentTestEnableNV = *const fn (
    command_buffer: CommandBuffer,
    representative_fragment_test_enable: Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCreatePrivateDataSlot = *const fn (
    device: Device,
    p_create_info: *const PrivateDataSlotCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_private_data_slot: *PrivateDataSlot,
) callconv(vulkan_call_conv) Result;
pub const PfnCreatePrivateDataSlotEXT = PfnCreatePrivateDataSlot;
pub const PfnDestroyPrivateDataSlot = *const fn (
    device: Device,
    private_data_slot: PrivateDataSlot,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnDestroyPrivateDataSlotEXT = PfnDestroyPrivateDataSlot;
pub const PfnSetPrivateData = *const fn (
    device: Device,
    object_type: ObjectType,
    object_handle: u64,
    private_data_slot: PrivateDataSlot,
    data: u64,
) callconv(vulkan_call_conv) Result;
pub const PfnSetPrivateDataEXT = PfnSetPrivateData;
pub const PfnGetPrivateData = *const fn (
    device: Device,
    object_type: ObjectType,
    object_handle: u64,
    private_data_slot: PrivateDataSlot,
    p_data: *u64,
) callconv(vulkan_call_conv) void;
pub const PfnGetPrivateDataEXT = PfnGetPrivateData;
pub const PfnCmdCopyBuffer2 = *const fn (
    command_buffer: CommandBuffer,
    p_copy_buffer_info: *const CopyBufferInfo2,
) callconv(vulkan_call_conv) void;
pub const PfnCmdCopyBuffer2KHR = PfnCmdCopyBuffer2;
pub const PfnCmdCopyImage2 = *const fn (
    command_buffer: CommandBuffer,
    p_copy_image_info: *const CopyImageInfo2,
) callconv(vulkan_call_conv) void;
pub const PfnCmdCopyImage2KHR = PfnCmdCopyImage2;
pub const PfnCmdBlitImage2 = *const fn (
    command_buffer: CommandBuffer,
    p_blit_image_info: *const BlitImageInfo2,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBlitImage2KHR = PfnCmdBlitImage2;
pub const PfnCmdCopyBufferToImage2 = *const fn (
    command_buffer: CommandBuffer,
    p_copy_buffer_to_image_info: *const CopyBufferToImageInfo2,
) callconv(vulkan_call_conv) void;
pub const PfnCmdCopyBufferToImage2KHR = PfnCmdCopyBufferToImage2;
pub const PfnCmdCopyImageToBuffer2 = *const fn (
    command_buffer: CommandBuffer,
    p_copy_image_to_buffer_info: *const CopyImageToBufferInfo2,
) callconv(vulkan_call_conv) void;
pub const PfnCmdCopyImageToBuffer2KHR = PfnCmdCopyImageToBuffer2;
pub const PfnCmdResolveImage2 = *const fn (
    command_buffer: CommandBuffer,
    p_resolve_image_info: *const ResolveImageInfo2,
) callconv(vulkan_call_conv) void;
pub const PfnCmdResolveImage2KHR = PfnCmdResolveImage2;
pub const PfnCmdRefreshObjectsKHR = *const fn (
    command_buffer: CommandBuffer,
    p_refresh_objects: *const RefreshObjectListKHR,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceRefreshableObjectTypesKHR = *const fn (
    physical_device: PhysicalDevice,
    p_refreshable_object_type_count: *u32,
    p_refreshable_object_types: ?[*]ObjectType,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdSetFragmentShadingRateKHR = *const fn (
    command_buffer: CommandBuffer,
    p_fragment_size: *const Extent2D,
    combiner_ops: *const [2]FragmentShadingRateCombinerOpKHR,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceFragmentShadingRatesKHR = *const fn (
    physical_device: PhysicalDevice,
    p_fragment_shading_rate_count: *u32,
    p_fragment_shading_rates: ?[*]PhysicalDeviceFragmentShadingRateKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdSetFragmentShadingRateEnumNV = *const fn (
    command_buffer: CommandBuffer,
    shading_rate: FragmentShadingRateNV,
    combiner_ops: *const [2]FragmentShadingRateCombinerOpKHR,
) callconv(vulkan_call_conv) void;
pub const PfnGetAccelerationStructureBuildSizesKHR = *const fn (
    device: Device,
    build_type: AccelerationStructureBuildTypeKHR,
    p_build_info: *const AccelerationStructureBuildGeometryInfoKHR,
    p_max_primitive_counts: ?[*]const u32,
    p_size_info: *AccelerationStructureBuildSizesInfoKHR,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetVertexInputEXT = *const fn (
    command_buffer: CommandBuffer,
    vertex_binding_description_count: u32,
    p_vertex_binding_descriptions: ?[*]const VertexInputBindingDescription2EXT,
    vertex_attribute_description_count: u32,
    p_vertex_attribute_descriptions: ?[*]const VertexInputAttributeDescription2EXT,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetColorWriteEnableEXT = *const fn (
    command_buffer: CommandBuffer,
    attachment_count: u32,
    p_color_write_enables: [*]const Bool32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetEvent2 = *const fn (
    command_buffer: CommandBuffer,
    event: Event,
    p_dependency_info: *const DependencyInfo,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetEvent2KHR = PfnCmdSetEvent2;
pub const PfnCmdResetEvent2 = *const fn (
    command_buffer: CommandBuffer,
    event: Event,
    stage_mask: PipelineStageFlags2,
) callconv(vulkan_call_conv) void;
pub const PfnCmdResetEvent2KHR = PfnCmdResetEvent2;
pub const PfnCmdWaitEvents2 = *const fn (
    command_buffer: CommandBuffer,
    event_count: u32,
    p_events: [*]const Event,
    p_dependency_infos: [*]const DependencyInfo,
) callconv(vulkan_call_conv) void;
pub const PfnCmdWaitEvents2KHR = PfnCmdWaitEvents2;
pub const PfnCmdPipelineBarrier2 = *const fn (
    command_buffer: CommandBuffer,
    p_dependency_info: *const DependencyInfo,
) callconv(vulkan_call_conv) void;
pub const PfnCmdPipelineBarrier2KHR = PfnCmdPipelineBarrier2;
pub const PfnQueueSubmit2 = *const fn (
    queue: Queue,
    submit_count: u32,
    p_submits: ?[*]const SubmitInfo2,
    fence: Fence,
) callconv(vulkan_call_conv) Result;
pub const PfnQueueSubmit2KHR = PfnQueueSubmit2;
pub const PfnCmdWriteTimestamp2 = *const fn (
    command_buffer: CommandBuffer,
    stage: PipelineStageFlags2,
    query_pool: QueryPool,
    query: u32,
) callconv(vulkan_call_conv) void;
pub const PfnCmdWriteTimestamp2KHR = PfnCmdWriteTimestamp2;
pub const PfnCmdWriteBufferMarker2AMD = *const fn (
    command_buffer: CommandBuffer,
    stage: PipelineStageFlags2,
    dst_buffer: Buffer,
    dst_offset: DeviceSize,
    marker: u32,
) callconv(vulkan_call_conv) void;
pub const PfnGetQueueCheckpointData2NV = *const fn (
    queue: Queue,
    p_checkpoint_data_count: *u32,
    p_checkpoint_data: ?[*]CheckpointData2NV,
) callconv(vulkan_call_conv) void;
pub const PfnCopyMemoryToImage = *const fn (
    device: Device,
    p_copy_memory_to_image_info: *const CopyMemoryToImageInfo,
) callconv(vulkan_call_conv) Result;
pub const PfnCopyMemoryToImageEXT = PfnCopyMemoryToImage;
pub const PfnCopyImageToMemory = *const fn (
    device: Device,
    p_copy_image_to_memory_info: *const CopyImageToMemoryInfo,
) callconv(vulkan_call_conv) Result;
pub const PfnCopyImageToMemoryEXT = PfnCopyImageToMemory;
pub const PfnCopyImageToImage = *const fn (
    device: Device,
    p_copy_image_to_image_info: *const CopyImageToImageInfo,
) callconv(vulkan_call_conv) Result;
pub const PfnCopyImageToImageEXT = PfnCopyImageToImage;
pub const PfnTransitionImageLayout = *const fn (
    device: Device,
    transition_count: u32,
    p_transitions: [*]const HostImageLayoutTransitionInfo,
) callconv(vulkan_call_conv) Result;
pub const PfnTransitionImageLayoutEXT = PfnTransitionImageLayout;
pub const PfnGetCommandPoolMemoryConsumption = *const fn (
    device: Device,
    command_pool: CommandPool,
    command_buffer: CommandBuffer,
    p_consumption: *CommandPoolMemoryConsumption,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceVideoCapabilitiesKHR = *const fn (
    physical_device: PhysicalDevice,
    p_video_profile: *const VideoProfileInfoKHR,
    p_capabilities: *VideoCapabilitiesKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceVideoFormatPropertiesKHR = *const fn (
    physical_device: PhysicalDevice,
    p_video_format_info: *const PhysicalDeviceVideoFormatInfoKHR,
    p_video_format_property_count: *u32,
    p_video_format_properties: ?[*]VideoFormatPropertiesKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = *const fn (
    physical_device: PhysicalDevice,
    p_quality_level_info: *const PhysicalDeviceVideoEncodeQualityLevelInfoKHR,
    p_quality_level_properties: *VideoEncodeQualityLevelPropertiesKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateVideoSessionKHR = *const fn (
    device: Device,
    p_create_info: *const VideoSessionCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_video_session: *VideoSessionKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyVideoSessionKHR = *const fn (
    device: Device,
    video_session: VideoSessionKHR,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCreateVideoSessionParametersKHR = *const fn (
    device: Device,
    p_create_info: *const VideoSessionParametersCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_video_session_parameters: *VideoSessionParametersKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnUpdateVideoSessionParametersKHR = *const fn (
    device: Device,
    video_session_parameters: VideoSessionParametersKHR,
    p_update_info: *const VideoSessionParametersUpdateInfoKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetEncodedVideoSessionParametersKHR = *const fn (
    device: Device,
    p_video_session_parameters_info: *const VideoEncodeSessionParametersGetInfoKHR,
    p_feedback_info: ?*VideoEncodeSessionParametersFeedbackInfoKHR,
    p_data_size: *usize,
    p_data: ?*anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyVideoSessionParametersKHR = *const fn (
    device: Device,
    video_session_parameters: VideoSessionParametersKHR,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnGetVideoSessionMemoryRequirementsKHR = *const fn (
    device: Device,
    video_session: VideoSessionKHR,
    p_memory_requirements_count: *u32,
    p_memory_requirements: ?[*]VideoSessionMemoryRequirementsKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnBindVideoSessionMemoryKHR = *const fn (
    device: Device,
    video_session: VideoSessionKHR,
    bind_session_memory_info_count: u32,
    p_bind_session_memory_infos: [*]const BindVideoSessionMemoryInfoKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdDecodeVideoKHR = *const fn (
    command_buffer: CommandBuffer,
    p_decode_info: *const VideoDecodeInfoKHR,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBeginVideoCodingKHR = *const fn (
    command_buffer: CommandBuffer,
    p_begin_info: *const VideoBeginCodingInfoKHR,
) callconv(vulkan_call_conv) void;
pub const PfnCmdControlVideoCodingKHR = *const fn (
    command_buffer: CommandBuffer,
    p_coding_control_info: *const VideoCodingControlInfoKHR,
) callconv(vulkan_call_conv) void;
pub const PfnCmdEndVideoCodingKHR = *const fn (
    command_buffer: CommandBuffer,
    p_end_coding_info: *const VideoEndCodingInfoKHR,
) callconv(vulkan_call_conv) void;
pub const PfnCmdEncodeVideoKHR = *const fn (
    command_buffer: CommandBuffer,
    p_encode_info: *const VideoEncodeInfoKHR,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDecompressMemoryNV = *const fn (
    command_buffer: CommandBuffer,
    decompress_region_count: u32,
    p_decompress_memory_regions: [*]const DecompressMemoryRegionNV,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDecompressMemoryIndirectCountNV = *const fn (
    command_buffer: CommandBuffer,
    indirect_commands_address: DeviceAddress,
    indirect_commands_count_address: DeviceAddress,
    stride: u32,
) callconv(vulkan_call_conv) void;
pub const PfnGetPartitionedAccelerationStructuresBuildSizesNV = *const fn (
    device: Device,
    p_info: *const PartitionedAccelerationStructureInstancesInputNV,
    p_size_info: *AccelerationStructureBuildSizesInfoKHR,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBuildPartitionedAccelerationStructuresNV = *const fn (
    command_buffer: CommandBuffer,
    p_build_info: *const BuildPartitionedAccelerationStructureInfoNV,
) callconv(vulkan_call_conv) void;
pub const PfnCreateCuModuleNVX = *const fn (
    device: Device,
    p_create_info: *const CuModuleCreateInfoNVX,
    p_allocator: ?*const AllocationCallbacks,
    p_module: *CuModuleNVX,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateCuFunctionNVX = *const fn (
    device: Device,
    p_create_info: *const CuFunctionCreateInfoNVX,
    p_allocator: ?*const AllocationCallbacks,
    p_function: *CuFunctionNVX,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyCuModuleNVX = *const fn (
    device: Device,
    module: CuModuleNVX,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnDestroyCuFunctionNVX = *const fn (
    device: Device,
    function: CuFunctionNVX,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCmdCuLaunchKernelNVX = *const fn (
    command_buffer: CommandBuffer,
    p_launch_info: *const CuLaunchInfoNVX,
) callconv(vulkan_call_conv) void;
pub const PfnGetDescriptorSetLayoutSizeEXT = *const fn (
    device: Device,
    layout: DescriptorSetLayout,
    p_layout_size_in_bytes: *DeviceSize,
) callconv(vulkan_call_conv) void;
pub const PfnGetDescriptorSetLayoutBindingOffsetEXT = *const fn (
    device: Device,
    layout: DescriptorSetLayout,
    binding: u32,
    p_offset: *DeviceSize,
) callconv(vulkan_call_conv) void;
pub const PfnGetDescriptorEXT = *const fn (
    device: Device,
    p_descriptor_info: *const DescriptorGetInfoEXT,
    data_size: usize,
    p_descriptor: *anyopaque,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBindDescriptorBuffersEXT = *const fn (
    command_buffer: CommandBuffer,
    buffer_count: u32,
    p_binding_infos: [*]const DescriptorBufferBindingInfoEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetDescriptorBufferOffsetsEXT = *const fn (
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    layout: PipelineLayout,
    first_set: u32,
    set_count: u32,
    p_buffer_indices: [*]const u32,
    p_offsets: [*]const DeviceSize,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBindDescriptorBufferEmbeddedSamplersEXT = *const fn (
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    layout: PipelineLayout,
    set: u32,
) callconv(vulkan_call_conv) void;
pub const PfnGetBufferOpaqueCaptureDescriptorDataEXT = *const fn (
    device: Device,
    p_info: *const BufferCaptureDescriptorDataInfoEXT,
    p_data: *anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnGetImageOpaqueCaptureDescriptorDataEXT = *const fn (
    device: Device,
    p_info: *const ImageCaptureDescriptorDataInfoEXT,
    p_data: *anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnGetImageViewOpaqueCaptureDescriptorDataEXT = *const fn (
    device: Device,
    p_info: *const ImageViewCaptureDescriptorDataInfoEXT,
    p_data: *anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnGetSamplerOpaqueCaptureDescriptorDataEXT = *const fn (
    device: Device,
    p_info: *const SamplerCaptureDescriptorDataInfoEXT,
    p_data: *anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = *const fn (
    device: Device,
    p_info: *const AccelerationStructureCaptureDescriptorDataInfoEXT,
    p_data: *anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnSetDeviceMemoryPriorityEXT = *const fn (
    device: Device,
    memory: DeviceMemory,
    priority: f32,
) callconv(vulkan_call_conv) void;
pub const PfnAcquireDrmDisplayEXT = *const fn (
    physical_device: PhysicalDevice,
    drm_fd: i32,
    display: DisplayKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDrmDisplayEXT = *const fn (
    physical_device: PhysicalDevice,
    drm_fd: i32,
    connector_id: u32,
    display: *DisplayKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnWaitForPresent2KHR = *const fn (
    device: Device,
    swapchain: SwapchainKHR,
    p_present_wait_2_info: *const PresentWait2InfoKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnWaitForPresentKHR = *const fn (
    device: Device,
    swapchain: SwapchainKHR,
    present_id: u64,
    timeout: u64,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateBufferCollectionFUCHSIA = *const fn (
    device: Device,
    p_create_info: *const BufferCollectionCreateInfoFUCHSIA,
    p_allocator: ?*const AllocationCallbacks,
    p_collection: *BufferCollectionFUCHSIA,
) callconv(vulkan_call_conv) Result;
pub const PfnSetBufferCollectionBufferConstraintsFUCHSIA = *const fn (
    device: Device,
    collection: BufferCollectionFUCHSIA,
    p_buffer_constraints_info: *const BufferConstraintsInfoFUCHSIA,
) callconv(vulkan_call_conv) Result;
pub const PfnSetBufferCollectionImageConstraintsFUCHSIA = *const fn (
    device: Device,
    collection: BufferCollectionFUCHSIA,
    p_image_constraints_info: *const ImageConstraintsInfoFUCHSIA,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyBufferCollectionFUCHSIA = *const fn (
    device: Device,
    collection: BufferCollectionFUCHSIA,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnGetBufferCollectionPropertiesFUCHSIA = *const fn (
    device: Device,
    collection: BufferCollectionFUCHSIA,
    p_properties: *BufferCollectionPropertiesFUCHSIA,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateCudaModuleNV = *const fn (
    device: Device,
    p_create_info: *const CudaModuleCreateInfoNV,
    p_allocator: ?*const AllocationCallbacks,
    p_module: *CudaModuleNV,
) callconv(vulkan_call_conv) Result;
pub const PfnGetCudaModuleCacheNV = *const fn (
    device: Device,
    module: CudaModuleNV,
    p_cache_size: *usize,
    p_cache_data: ?*anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateCudaFunctionNV = *const fn (
    device: Device,
    p_create_info: *const CudaFunctionCreateInfoNV,
    p_allocator: ?*const AllocationCallbacks,
    p_function: *CudaFunctionNV,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyCudaModuleNV = *const fn (
    device: Device,
    module: CudaModuleNV,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnDestroyCudaFunctionNV = *const fn (
    device: Device,
    function: CudaFunctionNV,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCmdCudaLaunchKernelNV = *const fn (
    command_buffer: CommandBuffer,
    p_launch_info: *const CudaLaunchInfoNV,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBeginRendering = *const fn (
    command_buffer: CommandBuffer,
    p_rendering_info: *const RenderingInfo,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBeginRenderingKHR = PfnCmdBeginRendering;
pub const PfnCmdEndRendering = *const fn (
    command_buffer: CommandBuffer,
) callconv(vulkan_call_conv) void;
pub const PfnCmdEndRendering2EXT = *const fn (
    command_buffer: CommandBuffer,
    p_rendering_end_info: ?*const RenderingEndInfoEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCmdEndRenderingKHR = PfnCmdEndRendering;
pub const PfnGetDescriptorSetLayoutHostMappingInfoVALVE = *const fn (
    device: Device,
    p_binding_reference: *const DescriptorSetBindingReferenceVALVE,
    p_host_mapping: *DescriptorSetLayoutHostMappingInfoVALVE,
) callconv(vulkan_call_conv) void;
pub const PfnGetDescriptorSetHostMappingVALVE = *const fn (
    device: Device,
    descriptor_set: DescriptorSet,
    pp_data: **anyopaque,
) callconv(vulkan_call_conv) void;
pub const PfnCreateMicromapEXT = *const fn (
    device: Device,
    p_create_info: *const MicromapCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
    p_micromap: *MicromapEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdBuildMicromapsEXT = *const fn (
    command_buffer: CommandBuffer,
    info_count: u32,
    p_infos: [*]const MicromapBuildInfoEXT,
) callconv(vulkan_call_conv) void;
pub const PfnBuildMicromapsEXT = *const fn (
    device: Device,
    deferred_operation: DeferredOperationKHR,
    info_count: u32,
    p_infos: [*]const MicromapBuildInfoEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyMicromapEXT = *const fn (
    device: Device,
    micromap: MicromapEXT,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCmdCopyMicromapEXT = *const fn (
    command_buffer: CommandBuffer,
    p_info: *const CopyMicromapInfoEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCopyMicromapEXT = *const fn (
    device: Device,
    deferred_operation: DeferredOperationKHR,
    p_info: *const CopyMicromapInfoEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdCopyMicromapToMemoryEXT = *const fn (
    command_buffer: CommandBuffer,
    p_info: *const CopyMicromapToMemoryInfoEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCopyMicromapToMemoryEXT = *const fn (
    device: Device,
    deferred_operation: DeferredOperationKHR,
    p_info: *const CopyMicromapToMemoryInfoEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdCopyMemoryToMicromapEXT = *const fn (
    command_buffer: CommandBuffer,
    p_info: *const CopyMemoryToMicromapInfoEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCopyMemoryToMicromapEXT = *const fn (
    device: Device,
    deferred_operation: DeferredOperationKHR,
    p_info: *const CopyMemoryToMicromapInfoEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdWriteMicromapsPropertiesEXT = *const fn (
    command_buffer: CommandBuffer,
    micromap_count: u32,
    p_micromaps: [*]const MicromapEXT,
    query_type: QueryType,
    query_pool: QueryPool,
    first_query: u32,
) callconv(vulkan_call_conv) void;
pub const PfnWriteMicromapsPropertiesEXT = *const fn (
    device: Device,
    micromap_count: u32,
    p_micromaps: [*]const MicromapEXT,
    query_type: QueryType,
    data_size: usize,
    p_data: *anyopaque,
    stride: usize,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDeviceMicromapCompatibilityEXT = *const fn (
    device: Device,
    p_version_info: *const MicromapVersionInfoEXT,
    p_compatibility: *AccelerationStructureCompatibilityKHR,
) callconv(vulkan_call_conv) void;
pub const PfnGetMicromapBuildSizesEXT = *const fn (
    device: Device,
    build_type: AccelerationStructureBuildTypeKHR,
    p_build_info: *const MicromapBuildInfoEXT,
    p_size_info: *MicromapBuildSizesInfoEXT,
) callconv(vulkan_call_conv) void;
pub const PfnGetShaderModuleIdentifierEXT = *const fn (
    device: Device,
    shader_module: ShaderModule,
    p_identifier: *ShaderModuleIdentifierEXT,
) callconv(vulkan_call_conv) void;
pub const PfnGetShaderModuleCreateInfoIdentifierEXT = *const fn (
    device: Device,
    p_create_info: *const ShaderModuleCreateInfo,
    p_identifier: *ShaderModuleIdentifierEXT,
) callconv(vulkan_call_conv) void;
pub const PfnGetImageSubresourceLayout2 = *const fn (
    device: Device,
    image: Image,
    p_subresource: *const ImageSubresource2,
    p_layout: *SubresourceLayout2,
) callconv(vulkan_call_conv) void;
pub const PfnGetImageSubresourceLayout2KHR = PfnGetImageSubresourceLayout2;
pub const PfnGetImageSubresourceLayout2EXT = PfnGetImageSubresourceLayout2;
pub const PfnGetPipelinePropertiesEXT = *const fn (
    device: Device,
    p_pipeline_info: *const PipelineInfoEXT,
    p_pipeline_properties: *BaseOutStructure,
) callconv(vulkan_call_conv) Result;
pub const PfnExportMetalObjectsEXT = *const fn (
    device: Device,
    p_metal_objects_info: *ExportMetalObjectsInfoEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBindTileMemoryQCOM = *const fn (
    command_buffer: CommandBuffer,
    p_tile_memory_bind_info: ?*const TileMemoryBindInfoQCOM,
) callconv(vulkan_call_conv) void;
pub const PfnGetFramebufferTilePropertiesQCOM = *const fn (
    device: Device,
    framebuffer: Framebuffer,
    p_properties_count: *u32,
    p_properties: ?[*]TilePropertiesQCOM,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDynamicRenderingTilePropertiesQCOM = *const fn (
    device: Device,
    p_rendering_info: *const RenderingInfo,
    p_properties: *TilePropertiesQCOM,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceOpticalFlowImageFormatsNV = *const fn (
    physical_device: PhysicalDevice,
    p_optical_flow_image_format_info: *const OpticalFlowImageFormatInfoNV,
    p_format_count: *u32,
    p_image_format_properties: ?[*]OpticalFlowImageFormatPropertiesNV,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateOpticalFlowSessionNV = *const fn (
    device: Device,
    p_create_info: *const OpticalFlowSessionCreateInfoNV,
    p_allocator: ?*const AllocationCallbacks,
    p_session: *OpticalFlowSessionNV,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyOpticalFlowSessionNV = *const fn (
    device: Device,
    session: OpticalFlowSessionNV,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnBindOpticalFlowSessionImageNV = *const fn (
    device: Device,
    session: OpticalFlowSessionNV,
    binding_point: OpticalFlowSessionBindingPointNV,
    view: ImageView,
    layout: ImageLayout,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdOpticalFlowExecuteNV = *const fn (
    command_buffer: CommandBuffer,
    session: OpticalFlowSessionNV,
    p_execute_info: *const OpticalFlowExecuteInfoNV,
) callconv(vulkan_call_conv) void;
pub const PfnGetDeviceFaultInfoEXT = *const fn (
    device: Device,
    p_fault_counts: *DeviceFaultCountsEXT,
    p_fault_info: ?*DeviceFaultInfoEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdSetDepthBias2EXT = *const fn (
    command_buffer: CommandBuffer,
    p_depth_bias_info: *const DepthBiasInfoEXT,
) callconv(vulkan_call_conv) void;
pub const PfnReleaseSwapchainImagesKHR = *const fn (
    device: Device,
    p_release_info: *const ReleaseSwapchainImagesInfoKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnReleaseSwapchainImagesEXT = PfnReleaseSwapchainImagesKHR;
pub const PfnGetDeviceImageSubresourceLayout = *const fn (
    device: Device,
    p_info: *const DeviceImageSubresourceInfo,
    p_layout: *SubresourceLayout2,
) callconv(vulkan_call_conv) void;
pub const PfnGetDeviceImageSubresourceLayoutKHR = PfnGetDeviceImageSubresourceLayout;
pub const PfnMapMemory2 = *const fn (
    device: Device,
    p_memory_map_info: *const MemoryMapInfo,
    pp_data: *?*anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnMapMemory2KHR = PfnMapMemory2;
pub const PfnUnmapMemory2 = *const fn (
    device: Device,
    p_memory_unmap_info: *const MemoryUnmapInfo,
) callconv(vulkan_call_conv) Result;
pub const PfnUnmapMemory2KHR = PfnUnmapMemory2;
pub const PfnCreateShadersEXT = *const fn (
    device: Device,
    create_info_count: u32,
    p_create_infos: [*]const ShaderCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
    p_shaders: [*]ShaderEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyShaderEXT = *const fn (
    device: Device,
    shader: ShaderEXT,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnGetShaderBinaryDataEXT = *const fn (
    device: Device,
    shader: ShaderEXT,
    p_data_size: *usize,
    p_data: ?*anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdBindShadersEXT = *const fn (
    command_buffer: CommandBuffer,
    stage_count: u32,
    p_stages: [*]const ShaderStageFlags,
    p_shaders: ?[*]const ShaderEXT,
) callconv(vulkan_call_conv) void;
pub const PfnGetScreenBufferPropertiesQNX = *const fn (
    device: Device,
    buffer: *const _screen_buffer,
    p_properties: *ScreenBufferPropertiesQNX,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceCooperativeMatrixPropertiesKHR = *const fn (
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]CooperativeMatrixPropertiesKHR,
) callconv(vulkan_call_conv) Result;
pub const PfnGetExecutionGraphPipelineScratchSizeAMDX = *const fn (
    device: Device,
    execution_graph: Pipeline,
    p_size_info: *ExecutionGraphPipelineScratchSizeAMDX,
) callconv(vulkan_call_conv) Result;
pub const PfnGetExecutionGraphPipelineNodeIndexAMDX = *const fn (
    device: Device,
    execution_graph: Pipeline,
    p_node_info: *const PipelineShaderStageNodeCreateInfoAMDX,
    p_node_index: *u32,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateExecutionGraphPipelinesAMDX = *const fn (
    device: Device,
    pipeline_cache: PipelineCache,
    create_info_count: u32,
    p_create_infos: [*]const ExecutionGraphPipelineCreateInfoAMDX,
    p_allocator: ?*const AllocationCallbacks,
    p_pipelines: [*]Pipeline,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdInitializeGraphScratchMemoryAMDX = *const fn (
    command_buffer: CommandBuffer,
    execution_graph: Pipeline,
    scratch: DeviceAddress,
    scratch_size: DeviceSize,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDispatchGraphAMDX = *const fn (
    command_buffer: CommandBuffer,
    scratch: DeviceAddress,
    scratch_size: DeviceSize,
    p_count_info: *const DispatchGraphCountInfoAMDX,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDispatchGraphIndirectAMDX = *const fn (
    command_buffer: CommandBuffer,
    scratch: DeviceAddress,
    scratch_size: DeviceSize,
    p_count_info: *const DispatchGraphCountInfoAMDX,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDispatchGraphIndirectCountAMDX = *const fn (
    command_buffer: CommandBuffer,
    scratch: DeviceAddress,
    scratch_size: DeviceSize,
    count_info: DeviceAddress,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBindDescriptorSets2 = *const fn (
    command_buffer: CommandBuffer,
    p_bind_descriptor_sets_info: *const BindDescriptorSetsInfo,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBindDescriptorSets2KHR = PfnCmdBindDescriptorSets2;
pub const PfnCmdPushConstants2 = *const fn (
    command_buffer: CommandBuffer,
    p_push_constants_info: *const PushConstantsInfo,
) callconv(vulkan_call_conv) void;
pub const PfnCmdPushConstants2KHR = PfnCmdPushConstants2;
pub const PfnCmdPushDescriptorSet2 = *const fn (
    command_buffer: CommandBuffer,
    p_push_descriptor_set_info: *const PushDescriptorSetInfo,
) callconv(vulkan_call_conv) void;
pub const PfnCmdPushDescriptorSet2KHR = PfnCmdPushDescriptorSet2;
pub const PfnCmdPushDescriptorSetWithTemplate2 = *const fn (
    command_buffer: CommandBuffer,
    p_push_descriptor_set_with_template_info: *const PushDescriptorSetWithTemplateInfo,
) callconv(vulkan_call_conv) void;
pub const PfnCmdPushDescriptorSetWithTemplate2KHR = PfnCmdPushDescriptorSetWithTemplate2;
pub const PfnCmdSetDescriptorBufferOffsets2EXT = *const fn (
    command_buffer: CommandBuffer,
    p_set_descriptor_buffer_offsets_info: *const SetDescriptorBufferOffsetsInfoEXT,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBindDescriptorBufferEmbeddedSamplers2EXT = *const fn (
    command_buffer: CommandBuffer,
    p_bind_descriptor_buffer_embedded_samplers_info: *const BindDescriptorBufferEmbeddedSamplersInfoEXT,
) callconv(vulkan_call_conv) void;
pub const PfnSetLatencySleepModeNV = *const fn (
    device: Device,
    swapchain: SwapchainKHR,
    p_sleep_mode_info: *const LatencySleepModeInfoNV,
) callconv(vulkan_call_conv) Result;
pub const PfnLatencySleepNV = *const fn (
    device: Device,
    swapchain: SwapchainKHR,
    p_sleep_info: *const LatencySleepInfoNV,
) callconv(vulkan_call_conv) Result;
pub const PfnSetLatencyMarkerNV = *const fn (
    device: Device,
    swapchain: SwapchainKHR,
    p_latency_marker_info: *const SetLatencyMarkerInfoNV,
) callconv(vulkan_call_conv) void;
pub const PfnGetLatencyTimingsNV = *const fn (
    device: Device,
    swapchain: SwapchainKHR,
    p_latency_marker_info: *GetLatencyMarkerInfoNV,
) callconv(vulkan_call_conv) void;
pub const PfnQueueNotifyOutOfBandNV = *const fn (
    queue: Queue,
    p_queue_type_info: *const OutOfBandQueueTypeInfoNV,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetRenderingAttachmentLocations = *const fn (
    command_buffer: CommandBuffer,
    p_location_info: *const RenderingAttachmentLocationInfo,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetRenderingAttachmentLocationsKHR = PfnCmdSetRenderingAttachmentLocations;
pub const PfnCmdSetRenderingInputAttachmentIndices = *const fn (
    command_buffer: CommandBuffer,
    p_input_attachment_index_info: *const RenderingInputAttachmentIndexInfo,
) callconv(vulkan_call_conv) void;
pub const PfnCmdSetRenderingInputAttachmentIndicesKHR = PfnCmdSetRenderingInputAttachmentIndices;
pub const PfnCmdSetDepthClampRangeEXT = *const fn (
    command_buffer: CommandBuffer,
    depth_clamp_mode: DepthClampModeEXT,
    p_depth_clamp_range: ?*const DepthClampRangeEXT,
) callconv(vulkan_call_conv) void;
pub const PfnGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV = *const fn (
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]CooperativeMatrixFlexibleDimensionsPropertiesNV,
) callconv(vulkan_call_conv) Result;
pub const PfnGetMemoryMetalHandleEXT = *const fn (
    device: Device,
    p_get_metal_handle_info: *const MemoryGetMetalHandleInfoEXT,
    p_handle: **anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnGetMemoryMetalHandlePropertiesEXT = *const fn (
    device: Device,
    handle_type: ExternalMemoryHandleTypeFlags,
    p_handle: *const anyopaque,
    p_memory_metal_handle_properties: *MemoryMetalHandlePropertiesEXT,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceCooperativeVectorPropertiesNV = *const fn (
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]CooperativeVectorPropertiesNV,
) callconv(vulkan_call_conv) Result;
pub const PfnConvertCooperativeVectorMatrixNV = *const fn (
    device: Device,
    p_info: *const ConvertCooperativeVectorMatrixInfoNV,
) callconv(vulkan_call_conv) Result;
pub const PfnCmdConvertCooperativeVectorMatrixNV = *const fn (
    command_buffer: CommandBuffer,
    info_count: u32,
    p_infos: [*]const ConvertCooperativeVectorMatrixInfoNV,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDispatchTileQCOM = *const fn (
    command_buffer: CommandBuffer,
    p_dispatch_tile_info: *const DispatchTileInfoQCOM,
) callconv(vulkan_call_conv) void;
pub const PfnCmdBeginPerTileExecutionQCOM = *const fn (
    command_buffer: CommandBuffer,
    p_per_tile_begin_info: *const PerTileBeginInfoQCOM,
) callconv(vulkan_call_conv) void;
pub const PfnCmdEndPerTileExecutionQCOM = *const fn (
    command_buffer: CommandBuffer,
    p_per_tile_end_info: *const PerTileEndInfoQCOM,
) callconv(vulkan_call_conv) void;
pub const PfnCreateExternalComputeQueueNV = *const fn (
    device: Device,
    p_create_info: *const ExternalComputeQueueCreateInfoNV,
    p_allocator: ?*const AllocationCallbacks,
    p_external_queue: *ExternalComputeQueueNV,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyExternalComputeQueueNV = *const fn (
    device: Device,
    external_queue: ExternalComputeQueueNV,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnGetExternalComputeQueueDataNV = *const fn (
    external_queue: ExternalComputeQueueNV,
    params: *ExternalComputeQueueDataParamsNV,
    p_data: *anyopaque,
) callconv(vulkan_call_conv) void;
pub const PfnCreateTensorARM = *const fn (
    device: Device,
    p_create_info: *const TensorCreateInfoARM,
    p_allocator: ?*const AllocationCallbacks,
    p_tensor: *TensorARM,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyTensorARM = *const fn (
    device: Device,
    tensor: TensorARM,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCreateTensorViewARM = *const fn (
    device: Device,
    p_create_info: *const TensorViewCreateInfoARM,
    p_allocator: ?*const AllocationCallbacks,
    p_view: *TensorViewARM,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyTensorViewARM = *const fn (
    device: Device,
    tensor_view: TensorViewARM,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnGetTensorMemoryRequirementsARM = *const fn (
    device: Device,
    p_info: *const TensorMemoryRequirementsInfoARM,
    p_memory_requirements: *MemoryRequirements2,
) callconv(vulkan_call_conv) void;
pub const PfnBindTensorMemoryARM = *const fn (
    device: Device,
    bind_info_count: u32,
    p_bind_infos: [*]const BindTensorMemoryInfoARM,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDeviceTensorMemoryRequirementsARM = *const fn (
    device: Device,
    p_info: *const DeviceTensorMemoryRequirementsARM,
    p_memory_requirements: *MemoryRequirements2,
) callconv(vulkan_call_conv) void;
pub const PfnCmdCopyTensorARM = *const fn (
    command_buffer: CommandBuffer,
    p_copy_tensor_info: *const CopyTensorInfoARM,
) callconv(vulkan_call_conv) void;
pub const PfnGetTensorOpaqueCaptureDescriptorDataARM = *const fn (
    device: Device,
    p_info: *const TensorCaptureDescriptorDataInfoARM,
    p_data: *anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnGetTensorViewOpaqueCaptureDescriptorDataARM = *const fn (
    device: Device,
    p_info: *const TensorViewCaptureDescriptorDataInfoARM,
    p_data: *anyopaque,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceExternalTensorPropertiesARM = *const fn (
    physical_device: PhysicalDevice,
    p_external_tensor_info: *const PhysicalDeviceExternalTensorInfoARM,
    p_external_tensor_properties: *ExternalTensorPropertiesARM,
) callconv(vulkan_call_conv) void;
pub const PfnCreateDataGraphPipelinesARM = *const fn (
    device: Device,
    deferred_operation: DeferredOperationKHR,
    pipeline_cache: PipelineCache,
    create_info_count: u32,
    p_create_infos: [*]const DataGraphPipelineCreateInfoARM,
    p_allocator: ?*const AllocationCallbacks,
    p_pipelines: [*]Pipeline,
) callconv(vulkan_call_conv) Result;
pub const PfnCreateDataGraphPipelineSessionARM = *const fn (
    device: Device,
    p_create_info: *const DataGraphPipelineSessionCreateInfoARM,
    p_allocator: ?*const AllocationCallbacks,
    p_session: *DataGraphPipelineSessionARM,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDataGraphPipelineSessionBindPointRequirementsARM = *const fn (
    device: Device,
    p_info: *const DataGraphPipelineSessionBindPointRequirementsInfoARM,
    p_bind_point_requirement_count: *u32,
    p_bind_point_requirements: ?[*]DataGraphPipelineSessionBindPointRequirementARM,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDataGraphPipelineSessionMemoryRequirementsARM = *const fn (
    device: Device,
    p_info: *const DataGraphPipelineSessionMemoryRequirementsInfoARM,
    p_memory_requirements: *MemoryRequirements2,
) callconv(vulkan_call_conv) void;
pub const PfnBindDataGraphPipelineSessionMemoryARM = *const fn (
    device: Device,
    bind_info_count: u32,
    p_bind_infos: [*]const BindDataGraphPipelineSessionMemoryInfoARM,
) callconv(vulkan_call_conv) Result;
pub const PfnDestroyDataGraphPipelineSessionARM = *const fn (
    device: Device,
    session: DataGraphPipelineSessionARM,
    p_allocator: ?*const AllocationCallbacks,
) callconv(vulkan_call_conv) void;
pub const PfnCmdDispatchDataGraphARM = *const fn (
    command_buffer: CommandBuffer,
    session: DataGraphPipelineSessionARM,
    p_info: ?*const DataGraphPipelineDispatchInfoARM,
) callconv(vulkan_call_conv) void;
pub const PfnGetDataGraphPipelineAvailablePropertiesARM = *const fn (
    device: Device,
    p_pipeline_info: *const DataGraphPipelineInfoARM,
    p_properties_count: *u32,
    p_properties: ?[*]DataGraphPipelinePropertyARM,
) callconv(vulkan_call_conv) Result;
pub const PfnGetDataGraphPipelinePropertiesARM = *const fn (
    device: Device,
    p_pipeline_info: *const DataGraphPipelineInfoARM,
    properties_count: u32,
    p_properties: [*]DataGraphPipelinePropertyQueryResultARM,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM = *const fn (
    physical_device: PhysicalDevice,
    queue_family_index: u32,
    p_queue_family_data_graph_property_count: *u32,
    p_queue_family_data_graph_properties: ?[*]QueueFamilyDataGraphPropertiesARM,
) callconv(vulkan_call_conv) Result;
pub const PfnGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM = *const fn (
    physical_device: PhysicalDevice,
    p_queue_family_data_graph_processing_engine_info: *const PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM,
    p_queue_family_data_graph_processing_engine_properties: *QueueFamilyDataGraphProcessingEnginePropertiesARM,
) callconv(vulkan_call_conv) void;
pub const features = struct {
    pub const version_1_0 = ApiInfo{
        .name = "VERSION_1_0",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const version_1_1 = ApiInfo{
        .name = "VERSION_1_1",
        .version = makeApiVersion(0, 1, 1, 0),
    };
    pub const version_1_2 = ApiInfo{
        .name = "VERSION_1_2",
        .version = makeApiVersion(0, 1, 2, 0),
    };
    pub const version_1_3 = ApiInfo{
        .name = "VERSION_1_3",
        .version = makeApiVersion(0, 1, 3, 0),
    };
    pub const version_1_4 = ApiInfo{
        .name = "VERSION_1_4",
        .version = makeApiVersion(0, 1, 4, 0),
    };
};
pub const extensions = struct {
    pub const khr_surface = ApiInfo{
        .name = "VK_KHR_surface",
        .version = makeApiVersion(0, 25, 0, 0),
    };
    pub const khr_swapchain = ApiInfo{
        .name = "VK_KHR_swapchain",
        .version = makeApiVersion(0, 70, 0, 0),
    };
    pub const khr_display = ApiInfo{
        .name = "VK_KHR_display",
        .version = makeApiVersion(0, 23, 0, 0),
    };
    pub const khr_display_swapchain = ApiInfo{
        .name = "VK_KHR_display_swapchain",
        .version = makeApiVersion(0, 10, 0, 0),
    };
    pub const khr_xlib_surface = ApiInfo{
        .name = "VK_KHR_xlib_surface",
        .version = makeApiVersion(0, 6, 0, 0),
    };
    pub const khr_xcb_surface = ApiInfo{
        .name = "VK_KHR_xcb_surface",
        .version = makeApiVersion(0, 6, 0, 0),
    };
    pub const khr_wayland_surface = ApiInfo{
        .name = "VK_KHR_wayland_surface",
        .version = makeApiVersion(0, 6, 0, 0),
    };
    pub const khr_android_surface = ApiInfo{
        .name = "VK_KHR_android_surface",
        .version = makeApiVersion(0, 6, 0, 0),
    };
    pub const khr_win_32_surface = ApiInfo{
        .name = "VK_KHR_win32_surface",
        .version = makeApiVersion(0, 6, 0, 0),
    };
    pub const ext_debug_report = ApiInfo{
        .name = "VK_EXT_debug_report",
        .version = makeApiVersion(0, 10, 0, 0),
    };
    pub const nv_glsl_shader = ApiInfo{
        .name = "VK_NV_glsl_shader",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_depth_range_unrestricted = ApiInfo{
        .name = "VK_EXT_depth_range_unrestricted",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_sampler_mirror_clamp_to_edge = ApiInfo{
        .name = "VK_KHR_sampler_mirror_clamp_to_edge",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const img_filter_cubic = ApiInfo{
        .name = "VK_IMG_filter_cubic",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const amd_rasterization_order = ApiInfo{
        .name = "VK_AMD_rasterization_order",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const amd_shader_trinary_minmax = ApiInfo{
        .name = "VK_AMD_shader_trinary_minmax",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const amd_shader_explicit_vertex_parameter = ApiInfo{
        .name = "VK_AMD_shader_explicit_vertex_parameter",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_debug_marker = ApiInfo{
        .name = "VK_EXT_debug_marker",
        .version = makeApiVersion(0, 4, 0, 0),
    };
    pub const khr_video_queue = ApiInfo{
        .name = "VK_KHR_video_queue",
        .version = makeApiVersion(0, 8, 0, 0),
    };
    pub const khr_video_decode_queue = ApiInfo{
        .name = "VK_KHR_video_decode_queue",
        .version = makeApiVersion(0, 8, 0, 0),
    };
    pub const amd_gcn_shader = ApiInfo{
        .name = "VK_AMD_gcn_shader",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_dedicated_allocation = ApiInfo{
        .name = "VK_NV_dedicated_allocation",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_transform_feedback = ApiInfo{
        .name = "VK_EXT_transform_feedback",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nvx_binary_import = ApiInfo{
        .name = "VK_NVX_binary_import",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const nvx_image_view_handle = ApiInfo{
        .name = "VK_NVX_image_view_handle",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const amd_draw_indirect_count = ApiInfo{
        .name = "VK_AMD_draw_indirect_count",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const amd_negative_viewport_height = ApiInfo{
        .name = "VK_AMD_negative_viewport_height",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const amd_gpu_shader_half_float = ApiInfo{
        .name = "VK_AMD_gpu_shader_half_float",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const amd_shader_ballot = ApiInfo{
        .name = "VK_AMD_shader_ballot",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_video_encode_h_264 = ApiInfo{
        .name = "VK_KHR_video_encode_h264",
        .version = makeApiVersion(0, 14, 0, 0),
    };
    pub const khr_video_encode_h_265 = ApiInfo{
        .name = "VK_KHR_video_encode_h265",
        .version = makeApiVersion(0, 14, 0, 0),
    };
    pub const khr_video_decode_h_264 = ApiInfo{
        .name = "VK_KHR_video_decode_h264",
        .version = makeApiVersion(0, 9, 0, 0),
    };
    pub const amd_texture_gather_bias_lod = ApiInfo{
        .name = "VK_AMD_texture_gather_bias_lod",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const amd_shader_info = ApiInfo{
        .name = "VK_AMD_shader_info",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_dynamic_rendering = ApiInfo{
        .name = "VK_KHR_dynamic_rendering",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const amd_shader_image_load_store_lod = ApiInfo{
        .name = "VK_AMD_shader_image_load_store_lod",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ggp_stream_descriptor_surface = ApiInfo{
        .name = "VK_GGP_stream_descriptor_surface",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_corner_sampled_image = ApiInfo{
        .name = "VK_NV_corner_sampled_image",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const nv_private_vendor_info = ApiInfo{
        .name = "VK_NV_private_vendor_info",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_multiview = ApiInfo{
        .name = "VK_KHR_multiview",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const img_format_pvrtc = ApiInfo{
        .name = "VK_IMG_format_pvrtc",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_external_memory_capabilities = ApiInfo{
        .name = "VK_NV_external_memory_capabilities",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_external_memory = ApiInfo{
        .name = "VK_NV_external_memory",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_external_memory_win_32 = ApiInfo{
        .name = "VK_NV_external_memory_win32",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_win_32_keyed_mutex = ApiInfo{
        .name = "VK_NV_win32_keyed_mutex",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_get_physical_device_properties_2 = ApiInfo{
        .name = "VK_KHR_get_physical_device_properties2",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_device_group = ApiInfo{
        .name = "VK_KHR_device_group",
        .version = makeApiVersion(0, 4, 0, 0),
    };
    pub const ext_validation_flags = ApiInfo{
        .name = "VK_EXT_validation_flags",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const nn_vi_surface = ApiInfo{
        .name = "VK_NN_vi_surface",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_shader_draw_parameters = ApiInfo{
        .name = "VK_KHR_shader_draw_parameters",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_shader_subgroup_ballot = ApiInfo{
        .name = "VK_EXT_shader_subgroup_ballot",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_shader_subgroup_vote = ApiInfo{
        .name = "VK_EXT_shader_subgroup_vote",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_texture_compression_astc_hdr = ApiInfo{
        .name = "VK_EXT_texture_compression_astc_hdr",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_astc_decode_mode = ApiInfo{
        .name = "VK_EXT_astc_decode_mode",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_pipeline_robustness = ApiInfo{
        .name = "VK_EXT_pipeline_robustness",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_maintenance_1 = ApiInfo{
        .name = "VK_KHR_maintenance1",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_device_group_creation = ApiInfo{
        .name = "VK_KHR_device_group_creation",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_external_memory_capabilities = ApiInfo{
        .name = "VK_KHR_external_memory_capabilities",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_external_memory = ApiInfo{
        .name = "VK_KHR_external_memory",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_external_memory_win_32 = ApiInfo{
        .name = "VK_KHR_external_memory_win32",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_external_memory_fd = ApiInfo{
        .name = "VK_KHR_external_memory_fd",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_win_32_keyed_mutex = ApiInfo{
        .name = "VK_KHR_win32_keyed_mutex",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_external_semaphore_capabilities = ApiInfo{
        .name = "VK_KHR_external_semaphore_capabilities",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_external_semaphore = ApiInfo{
        .name = "VK_KHR_external_semaphore",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_external_semaphore_win_32 = ApiInfo{
        .name = "VK_KHR_external_semaphore_win32",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_external_semaphore_fd = ApiInfo{
        .name = "VK_KHR_external_semaphore_fd",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_push_descriptor = ApiInfo{
        .name = "VK_KHR_push_descriptor",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const ext_conditional_rendering = ApiInfo{
        .name = "VK_EXT_conditional_rendering",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_shader_float_16_int_8 = ApiInfo{
        .name = "VK_KHR_shader_float16_int8",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_1_6bit_storage = ApiInfo{
        .name = "VK_KHR_16bit_storage",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_incremental_present = ApiInfo{
        .name = "VK_KHR_incremental_present",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_descriptor_update_template = ApiInfo{
        .name = "VK_KHR_descriptor_update_template",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_clip_space_w_scaling = ApiInfo{
        .name = "VK_NV_clip_space_w_scaling",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_direct_mode_display = ApiInfo{
        .name = "VK_EXT_direct_mode_display",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_acquire_xlib_display = ApiInfo{
        .name = "VK_EXT_acquire_xlib_display",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_display_surface_counter = ApiInfo{
        .name = "VK_EXT_display_surface_counter",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_display_control = ApiInfo{
        .name = "VK_EXT_display_control",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const google_display_timing = ApiInfo{
        .name = "VK_GOOGLE_display_timing",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_sample_mask_override_coverage = ApiInfo{
        .name = "VK_NV_sample_mask_override_coverage",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_geometry_shader_passthrough = ApiInfo{
        .name = "VK_NV_geometry_shader_passthrough",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_viewport_array_2 = ApiInfo{
        .name = "VK_NV_viewport_array2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nvx_multiview_per_view_attributes = ApiInfo{
        .name = "VK_NVX_multiview_per_view_attributes",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_viewport_swizzle = ApiInfo{
        .name = "VK_NV_viewport_swizzle",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_discard_rectangles = ApiInfo{
        .name = "VK_EXT_discard_rectangles",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const ext_conservative_rasterization = ApiInfo{
        .name = "VK_EXT_conservative_rasterization",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_depth_clip_enable = ApiInfo{
        .name = "VK_EXT_depth_clip_enable",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_swapchain_colorspace = ApiInfo{
        .name = "VK_EXT_swapchain_colorspace",
        .version = makeApiVersion(0, 5, 0, 0),
    };
    pub const ext_hdr_metadata = ApiInfo{
        .name = "VK_EXT_hdr_metadata",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const khr_imageless_framebuffer = ApiInfo{
        .name = "VK_KHR_imageless_framebuffer",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_create_renderpass_2 = ApiInfo{
        .name = "VK_KHR_create_renderpass2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const img_relaxed_line_rasterization = ApiInfo{
        .name = "VK_IMG_relaxed_line_rasterization",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_shared_presentable_image = ApiInfo{
        .name = "VK_KHR_shared_presentable_image",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_external_fence_capabilities = ApiInfo{
        .name = "VK_KHR_external_fence_capabilities",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_external_fence = ApiInfo{
        .name = "VK_KHR_external_fence",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_external_fence_win_32 = ApiInfo{
        .name = "VK_KHR_external_fence_win32",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_external_fence_fd = ApiInfo{
        .name = "VK_KHR_external_fence_fd",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_performance_query = ApiInfo{
        .name = "VK_KHR_performance_query",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_maintenance_2 = ApiInfo{
        .name = "VK_KHR_maintenance2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_get_surface_capabilities_2 = ApiInfo{
        .name = "VK_KHR_get_surface_capabilities2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_variable_pointers = ApiInfo{
        .name = "VK_KHR_variable_pointers",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_get_display_properties_2 = ApiInfo{
        .name = "VK_KHR_get_display_properties2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const mvk_ios_surface = ApiInfo{
        .name = "VK_MVK_ios_surface",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const mvk_macos_surface = ApiInfo{
        .name = "VK_MVK_macos_surface",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const ext_external_memory_dma_buf = ApiInfo{
        .name = "VK_EXT_external_memory_dma_buf",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_queue_family_foreign = ApiInfo{
        .name = "VK_EXT_queue_family_foreign",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_dedicated_allocation = ApiInfo{
        .name = "VK_KHR_dedicated_allocation",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const ext_debug_utils = ApiInfo{
        .name = "VK_EXT_debug_utils",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const android_external_memory_android_hardware_buffer = ApiInfo{
        .name = "VK_ANDROID_external_memory_android_hardware_buffer",
        .version = makeApiVersion(0, 5, 0, 0),
    };
    pub const ext_sampler_filter_minmax = ApiInfo{
        .name = "VK_EXT_sampler_filter_minmax",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_storage_buffer_storage_class = ApiInfo{
        .name = "VK_KHR_storage_buffer_storage_class",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const amd_gpu_shader_int_16 = ApiInfo{
        .name = "VK_AMD_gpu_shader_int16",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const amdx_shader_enqueue = ApiInfo{
        .name = "VK_AMDX_shader_enqueue",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const amd_mixed_attachment_samples = ApiInfo{
        .name = "VK_AMD_mixed_attachment_samples",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const amd_shader_fragment_mask = ApiInfo{
        .name = "VK_AMD_shader_fragment_mask",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_inline_uniform_block = ApiInfo{
        .name = "VK_EXT_inline_uniform_block",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_shader_stencil_export = ApiInfo{
        .name = "VK_EXT_shader_stencil_export",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_shader_bfloat_16 = ApiInfo{
        .name = "VK_KHR_shader_bfloat16",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_sample_locations = ApiInfo{
        .name = "VK_EXT_sample_locations",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_relaxed_block_layout = ApiInfo{
        .name = "VK_KHR_relaxed_block_layout",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_get_memory_requirements_2 = ApiInfo{
        .name = "VK_KHR_get_memory_requirements2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_image_format_list = ApiInfo{
        .name = "VK_KHR_image_format_list",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_blend_operation_advanced = ApiInfo{
        .name = "VK_EXT_blend_operation_advanced",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const nv_fragment_coverage_to_color = ApiInfo{
        .name = "VK_NV_fragment_coverage_to_color",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_acceleration_structure = ApiInfo{
        .name = "VK_KHR_acceleration_structure",
        .version = makeApiVersion(0, 13, 0, 0),
    };
    pub const khr_ray_tracing_pipeline = ApiInfo{
        .name = "VK_KHR_ray_tracing_pipeline",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_ray_query = ApiInfo{
        .name = "VK_KHR_ray_query",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_framebuffer_mixed_samples = ApiInfo{
        .name = "VK_NV_framebuffer_mixed_samples",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_fill_rectangle = ApiInfo{
        .name = "VK_NV_fill_rectangle",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_shader_sm_builtins = ApiInfo{
        .name = "VK_NV_shader_sm_builtins",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_post_depth_coverage = ApiInfo{
        .name = "VK_EXT_post_depth_coverage",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_sampler_ycbcr_conversion = ApiInfo{
        .name = "VK_KHR_sampler_ycbcr_conversion",
        .version = makeApiVersion(0, 14, 0, 0),
    };
    pub const khr_bind_memory_2 = ApiInfo{
        .name = "VK_KHR_bind_memory2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_image_drm_format_modifier = ApiInfo{
        .name = "VK_EXT_image_drm_format_modifier",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const ext_validation_cache = ApiInfo{
        .name = "VK_EXT_validation_cache",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_descriptor_indexing = ApiInfo{
        .name = "VK_EXT_descriptor_indexing",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const ext_shader_viewport_index_layer = ApiInfo{
        .name = "VK_EXT_shader_viewport_index_layer",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_portability_subset = ApiInfo{
        .name = "VK_KHR_portability_subset",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_shading_rate_image = ApiInfo{
        .name = "VK_NV_shading_rate_image",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const nv_ray_tracing = ApiInfo{
        .name = "VK_NV_ray_tracing",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const nv_representative_fragment_test = ApiInfo{
        .name = "VK_NV_representative_fragment_test",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_maintenance_3 = ApiInfo{
        .name = "VK_KHR_maintenance3",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_draw_indirect_count = ApiInfo{
        .name = "VK_KHR_draw_indirect_count",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_filter_cubic = ApiInfo{
        .name = "VK_EXT_filter_cubic",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const qcom_render_pass_shader_resolve = ApiInfo{
        .name = "VK_QCOM_render_pass_shader_resolve",
        .version = makeApiVersion(0, 4, 0, 0),
    };
    pub const ext_global_priority = ApiInfo{
        .name = "VK_EXT_global_priority",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_shader_subgroup_extended_types = ApiInfo{
        .name = "VK_KHR_shader_subgroup_extended_types",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_8bit_storage = ApiInfo{
        .name = "VK_KHR_8bit_storage",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_external_memory_host = ApiInfo{
        .name = "VK_EXT_external_memory_host",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const amd_buffer_marker = ApiInfo{
        .name = "VK_AMD_buffer_marker",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_shader_atomic_int_64 = ApiInfo{
        .name = "VK_KHR_shader_atomic_int64",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_shader_clock = ApiInfo{
        .name = "VK_KHR_shader_clock",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const amd_pipeline_compiler_control = ApiInfo{
        .name = "VK_AMD_pipeline_compiler_control",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_calibrated_timestamps = ApiInfo{
        .name = "VK_EXT_calibrated_timestamps",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const amd_shader_core_properties = ApiInfo{
        .name = "VK_AMD_shader_core_properties",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_video_decode_h_265 = ApiInfo{
        .name = "VK_KHR_video_decode_h265",
        .version = makeApiVersion(0, 8, 0, 0),
    };
    pub const khr_global_priority = ApiInfo{
        .name = "VK_KHR_global_priority",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const amd_memory_overallocation_behavior = ApiInfo{
        .name = "VK_AMD_memory_overallocation_behavior",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_vertex_attribute_divisor = ApiInfo{
        .name = "VK_EXT_vertex_attribute_divisor",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const ggp_frame_token = ApiInfo{
        .name = "VK_GGP_frame_token",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_pipeline_creation_feedback = ApiInfo{
        .name = "VK_EXT_pipeline_creation_feedback",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_driver_properties = ApiInfo{
        .name = "VK_KHR_driver_properties",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_shader_float_controls = ApiInfo{
        .name = "VK_KHR_shader_float_controls",
        .version = makeApiVersion(0, 4, 0, 0),
    };
    pub const nv_shader_subgroup_partitioned = ApiInfo{
        .name = "VK_NV_shader_subgroup_partitioned",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_depth_stencil_resolve = ApiInfo{
        .name = "VK_KHR_depth_stencil_resolve",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_swapchain_mutable_format = ApiInfo{
        .name = "VK_KHR_swapchain_mutable_format",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_compute_shader_derivatives = ApiInfo{
        .name = "VK_NV_compute_shader_derivatives",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_mesh_shader = ApiInfo{
        .name = "VK_NV_mesh_shader",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_fragment_shader_barycentric = ApiInfo{
        .name = "VK_NV_fragment_shader_barycentric",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_shader_image_footprint = ApiInfo{
        .name = "VK_NV_shader_image_footprint",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const nv_scissor_exclusive = ApiInfo{
        .name = "VK_NV_scissor_exclusive",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const nv_device_diagnostic_checkpoints = ApiInfo{
        .name = "VK_NV_device_diagnostic_checkpoints",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_timeline_semaphore = ApiInfo{
        .name = "VK_KHR_timeline_semaphore",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const intel_shader_integer_functions_2 = ApiInfo{
        .name = "VK_INTEL_shader_integer_functions2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const intel_performance_query = ApiInfo{
        .name = "VK_INTEL_performance_query",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_vulkan_memory_model = ApiInfo{
        .name = "VK_KHR_vulkan_memory_model",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const ext_pci_bus_info = ApiInfo{
        .name = "VK_EXT_pci_bus_info",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const amd_display_native_hdr = ApiInfo{
        .name = "VK_AMD_display_native_hdr",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const fuchsia_imagepipe_surface = ApiInfo{
        .name = "VK_FUCHSIA_imagepipe_surface",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_shader_terminate_invocation = ApiInfo{
        .name = "VK_KHR_shader_terminate_invocation",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_metal_surface = ApiInfo{
        .name = "VK_EXT_metal_surface",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_fragment_density_map = ApiInfo{
        .name = "VK_EXT_fragment_density_map",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const ext_scalar_block_layout = ApiInfo{
        .name = "VK_EXT_scalar_block_layout",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const google_hlsl_functionality_1 = ApiInfo{
        .name = "VK_GOOGLE_hlsl_functionality1",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const google_decorate_string = ApiInfo{
        .name = "VK_GOOGLE_decorate_string",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_subgroup_size_control = ApiInfo{
        .name = "VK_EXT_subgroup_size_control",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_fragment_shading_rate = ApiInfo{
        .name = "VK_KHR_fragment_shading_rate",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const amd_shader_core_properties_2 = ApiInfo{
        .name = "VK_AMD_shader_core_properties2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const amd_device_coherent_memory = ApiInfo{
        .name = "VK_AMD_device_coherent_memory",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_dynamic_rendering_local_read = ApiInfo{
        .name = "VK_KHR_dynamic_rendering_local_read",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_shader_image_atomic_int_64 = ApiInfo{
        .name = "VK_EXT_shader_image_atomic_int64",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_shader_quad_control = ApiInfo{
        .name = "VK_KHR_shader_quad_control",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_spirv_1_4 = ApiInfo{
        .name = "VK_KHR_spirv_1_4",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_memory_budget = ApiInfo{
        .name = "VK_EXT_memory_budget",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_memory_priority = ApiInfo{
        .name = "VK_EXT_memory_priority",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_surface_protected_capabilities = ApiInfo{
        .name = "VK_KHR_surface_protected_capabilities",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_dedicated_allocation_image_aliasing = ApiInfo{
        .name = "VK_NV_dedicated_allocation_image_aliasing",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_separate_depth_stencil_layouts = ApiInfo{
        .name = "VK_KHR_separate_depth_stencil_layouts",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_buffer_device_address = ApiInfo{
        .name = "VK_EXT_buffer_device_address",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const ext_tooling_info = ApiInfo{
        .name = "VK_EXT_tooling_info",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_separate_stencil_usage = ApiInfo{
        .name = "VK_EXT_separate_stencil_usage",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_validation_features = ApiInfo{
        .name = "VK_EXT_validation_features",
        .version = makeApiVersion(0, 6, 0, 0),
    };
    pub const khr_present_wait = ApiInfo{
        .name = "VK_KHR_present_wait",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_cooperative_matrix = ApiInfo{
        .name = "VK_NV_cooperative_matrix",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_coverage_reduction_mode = ApiInfo{
        .name = "VK_NV_coverage_reduction_mode",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_fragment_shader_interlock = ApiInfo{
        .name = "VK_EXT_fragment_shader_interlock",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_ycbcr_image_arrays = ApiInfo{
        .name = "VK_EXT_ycbcr_image_arrays",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_uniform_buffer_standard_layout = ApiInfo{
        .name = "VK_KHR_uniform_buffer_standard_layout",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_provoking_vertex = ApiInfo{
        .name = "VK_EXT_provoking_vertex",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_full_screen_exclusive = ApiInfo{
        .name = "VK_EXT_full_screen_exclusive",
        .version = makeApiVersion(0, 4, 0, 0),
    };
    pub const ext_headless_surface = ApiInfo{
        .name = "VK_EXT_headless_surface",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_buffer_device_address = ApiInfo{
        .name = "VK_KHR_buffer_device_address",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_line_rasterization = ApiInfo{
        .name = "VK_EXT_line_rasterization",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_shader_atomic_float = ApiInfo{
        .name = "VK_EXT_shader_atomic_float",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_host_query_reset = ApiInfo{
        .name = "VK_EXT_host_query_reset",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_index_type_uint_8 = ApiInfo{
        .name = "VK_EXT_index_type_uint8",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_extended_dynamic_state = ApiInfo{
        .name = "VK_EXT_extended_dynamic_state",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_deferred_host_operations = ApiInfo{
        .name = "VK_KHR_deferred_host_operations",
        .version = makeApiVersion(0, 4, 0, 0),
    };
    pub const khr_pipeline_executable_properties = ApiInfo{
        .name = "VK_KHR_pipeline_executable_properties",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_host_image_copy = ApiInfo{
        .name = "VK_EXT_host_image_copy",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_map_memory_2 = ApiInfo{
        .name = "VK_KHR_map_memory2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_map_memory_placed = ApiInfo{
        .name = "VK_EXT_map_memory_placed",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_shader_atomic_float_2 = ApiInfo{
        .name = "VK_EXT_shader_atomic_float2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_surface_maintenance_1 = ApiInfo{
        .name = "VK_EXT_surface_maintenance1",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_swapchain_maintenance_1 = ApiInfo{
        .name = "VK_EXT_swapchain_maintenance1",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_shader_demote_to_helper_invocation = ApiInfo{
        .name = "VK_EXT_shader_demote_to_helper_invocation",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_device_generated_commands = ApiInfo{
        .name = "VK_NV_device_generated_commands",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const nv_inherited_viewport_scissor = ApiInfo{
        .name = "VK_NV_inherited_viewport_scissor",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_shader_integer_dot_product = ApiInfo{
        .name = "VK_KHR_shader_integer_dot_product",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_texel_buffer_alignment = ApiInfo{
        .name = "VK_EXT_texel_buffer_alignment",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const qcom_render_pass_transform = ApiInfo{
        .name = "VK_QCOM_render_pass_transform",
        .version = makeApiVersion(0, 5, 0, 0),
    };
    pub const ext_depth_bias_control = ApiInfo{
        .name = "VK_EXT_depth_bias_control",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_device_memory_report = ApiInfo{
        .name = "VK_EXT_device_memory_report",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const ext_acquire_drm_display = ApiInfo{
        .name = "VK_EXT_acquire_drm_display",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_robustness_2 = ApiInfo{
        .name = "VK_EXT_robustness2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_custom_border_color = ApiInfo{
        .name = "VK_EXT_custom_border_color",
        .version = makeApiVersion(0, 12, 0, 0),
    };
    pub const google_user_type = ApiInfo{
        .name = "VK_GOOGLE_user_type",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_pipeline_library = ApiInfo{
        .name = "VK_KHR_pipeline_library",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_present_barrier = ApiInfo{
        .name = "VK_NV_present_barrier",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_shader_non_semantic_info = ApiInfo{
        .name = "VK_KHR_shader_non_semantic_info",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_present_id = ApiInfo{
        .name = "VK_KHR_present_id",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_private_data = ApiInfo{
        .name = "VK_EXT_private_data",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_pipeline_creation_cache_control = ApiInfo{
        .name = "VK_EXT_pipeline_creation_cache_control",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const khr_video_encode_queue = ApiInfo{
        .name = "VK_KHR_video_encode_queue",
        .version = makeApiVersion(0, 12, 0, 0),
    };
    pub const nv_device_diagnostics_config = ApiInfo{
        .name = "VK_NV_device_diagnostics_config",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const qcom_render_pass_store_ops = ApiInfo{
        .name = "VK_QCOM_render_pass_store_ops",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const nv_cuda_kernel_launch = ApiInfo{
        .name = "VK_NV_cuda_kernel_launch",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_object_refresh = ApiInfo{
        .name = "VK_KHR_object_refresh",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const qcom_tile_shading = ApiInfo{
        .name = "VK_QCOM_tile_shading",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_low_latency = ApiInfo{
        .name = "VK_NV_low_latency",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_metal_objects = ApiInfo{
        .name = "VK_EXT_metal_objects",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_synchronization_2 = ApiInfo{
        .name = "VK_KHR_synchronization2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_descriptor_buffer = ApiInfo{
        .name = "VK_EXT_descriptor_buffer",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_graphics_pipeline_library = ApiInfo{
        .name = "VK_EXT_graphics_pipeline_library",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const amd_shader_early_and_late_fragment_tests = ApiInfo{
        .name = "VK_AMD_shader_early_and_late_fragment_tests",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_fragment_shader_barycentric = ApiInfo{
        .name = "VK_KHR_fragment_shader_barycentric",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_shader_subgroup_uniform_control_flow = ApiInfo{
        .name = "VK_KHR_shader_subgroup_uniform_control_flow",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_zero_initialize_workgroup_memory = ApiInfo{
        .name = "VK_KHR_zero_initialize_workgroup_memory",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_fragment_shading_rate_enums = ApiInfo{
        .name = "VK_NV_fragment_shading_rate_enums",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_ray_tracing_motion_blur = ApiInfo{
        .name = "VK_NV_ray_tracing_motion_blur",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_mesh_shader = ApiInfo{
        .name = "VK_EXT_mesh_shader",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_ycbcr_2plane_444_formats = ApiInfo{
        .name = "VK_EXT_ycbcr_2plane_444_formats",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_fragment_density_map_2 = ApiInfo{
        .name = "VK_EXT_fragment_density_map2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const qcom_rotated_copy_commands = ApiInfo{
        .name = "VK_QCOM_rotated_copy_commands",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const ext_image_robustness = ApiInfo{
        .name = "VK_EXT_image_robustness",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_workgroup_memory_explicit_layout = ApiInfo{
        .name = "VK_KHR_workgroup_memory_explicit_layout",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_copy_commands_2 = ApiInfo{
        .name = "VK_KHR_copy_commands2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_image_compression_control = ApiInfo{
        .name = "VK_EXT_image_compression_control",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_attachment_feedback_loop_layout = ApiInfo{
        .name = "VK_EXT_attachment_feedback_loop_layout",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const ext_4444_formats = ApiInfo{
        .name = "VK_EXT_4444_formats",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_device_fault = ApiInfo{
        .name = "VK_EXT_device_fault",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const arm_rasterization_order_attachment_access = ApiInfo{
        .name = "VK_ARM_rasterization_order_attachment_access",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_rgba_1_0x_6_formats = ApiInfo{
        .name = "VK_EXT_rgba10x6_formats",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_acquire_winrt_display = ApiInfo{
        .name = "VK_NV_acquire_winrt_display",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_directfb_surface = ApiInfo{
        .name = "VK_EXT_directfb_surface",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const valve_mutable_descriptor_type = ApiInfo{
        .name = "VK_VALVE_mutable_descriptor_type",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_vertex_input_dynamic_state = ApiInfo{
        .name = "VK_EXT_vertex_input_dynamic_state",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const ext_physical_device_drm = ApiInfo{
        .name = "VK_EXT_physical_device_drm",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_device_address_binding_report = ApiInfo{
        .name = "VK_EXT_device_address_binding_report",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_depth_clip_control = ApiInfo{
        .name = "VK_EXT_depth_clip_control",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_primitive_topology_list_restart = ApiInfo{
        .name = "VK_EXT_primitive_topology_list_restart",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_format_feature_flags_2 = ApiInfo{
        .name = "VK_KHR_format_feature_flags2",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const ext_present_mode_fifo_latest_ready = ApiInfo{
        .name = "VK_EXT_present_mode_fifo_latest_ready",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const fuchsia_external_memory = ApiInfo{
        .name = "VK_FUCHSIA_external_memory",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const fuchsia_external_semaphore = ApiInfo{
        .name = "VK_FUCHSIA_external_semaphore",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const fuchsia_buffer_collection = ApiInfo{
        .name = "VK_FUCHSIA_buffer_collection",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const huawei_subpass_shading = ApiInfo{
        .name = "VK_HUAWEI_subpass_shading",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const huawei_invocation_mask = ApiInfo{
        .name = "VK_HUAWEI_invocation_mask",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_external_memory_rdma = ApiInfo{
        .name = "VK_NV_external_memory_rdma",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_pipeline_properties = ApiInfo{
        .name = "VK_EXT_pipeline_properties",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_external_sci_sync = ApiInfo{
        .name = "VK_NV_external_sci_sync",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const nv_external_memory_sci_buf = ApiInfo{
        .name = "VK_NV_external_memory_sci_buf",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const ext_frame_boundary = ApiInfo{
        .name = "VK_EXT_frame_boundary",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_multisampled_render_to_single_sampled = ApiInfo{
        .name = "VK_EXT_multisampled_render_to_single_sampled",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_extended_dynamic_state_2 = ApiInfo{
        .name = "VK_EXT_extended_dynamic_state2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const qnx_screen_surface = ApiInfo{
        .name = "VK_QNX_screen_surface",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_color_write_enable = ApiInfo{
        .name = "VK_EXT_color_write_enable",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_primitives_generated_query = ApiInfo{
        .name = "VK_EXT_primitives_generated_query",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_ray_tracing_maintenance_1 = ApiInfo{
        .name = "VK_KHR_ray_tracing_maintenance1",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_global_priority_query = ApiInfo{
        .name = "VK_EXT_global_priority_query",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_image_view_min_lod = ApiInfo{
        .name = "VK_EXT_image_view_min_lod",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_multi_draw = ApiInfo{
        .name = "VK_EXT_multi_draw",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_image_2d_view_of_3d = ApiInfo{
        .name = "VK_EXT_image_2d_view_of_3d",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_portability_enumeration = ApiInfo{
        .name = "VK_KHR_portability_enumeration",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_shader_tile_image = ApiInfo{
        .name = "VK_EXT_shader_tile_image",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_opacity_micromap = ApiInfo{
        .name = "VK_EXT_opacity_micromap",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const nv_displacement_micromap = ApiInfo{
        .name = "VK_NV_displacement_micromap",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const ext_load_store_op_none = ApiInfo{
        .name = "VK_EXT_load_store_op_none",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const huawei_cluster_culling_shader = ApiInfo{
        .name = "VK_HUAWEI_cluster_culling_shader",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const ext_border_color_swizzle = ApiInfo{
        .name = "VK_EXT_border_color_swizzle",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_pageable_device_local_memory = ApiInfo{
        .name = "VK_EXT_pageable_device_local_memory",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_maintenance_4 = ApiInfo{
        .name = "VK_KHR_maintenance4",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const arm_shader_core_properties = ApiInfo{
        .name = "VK_ARM_shader_core_properties",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_shader_subgroup_rotate = ApiInfo{
        .name = "VK_KHR_shader_subgroup_rotate",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const arm_scheduling_controls = ApiInfo{
        .name = "VK_ARM_scheduling_controls",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_image_sliced_view_of_3d = ApiInfo{
        .name = "VK_EXT_image_sliced_view_of_3d",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const valve_descriptor_set_host_mapping = ApiInfo{
        .name = "VK_VALVE_descriptor_set_host_mapping",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_depth_clamp_zero_one = ApiInfo{
        .name = "VK_EXT_depth_clamp_zero_one",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_non_seamless_cube_map = ApiInfo{
        .name = "VK_EXT_non_seamless_cube_map",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const arm_render_pass_striped = ApiInfo{
        .name = "VK_ARM_render_pass_striped",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const qcom_fragment_density_map_offset = ApiInfo{
        .name = "VK_QCOM_fragment_density_map_offset",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const nv_copy_memory_indirect = ApiInfo{
        .name = "VK_NV_copy_memory_indirect",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_memory_decompression = ApiInfo{
        .name = "VK_NV_memory_decompression",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_device_generated_commands_compute = ApiInfo{
        .name = "VK_NV_device_generated_commands_compute",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const nv_ray_tracing_linear_swept_spheres = ApiInfo{
        .name = "VK_NV_ray_tracing_linear_swept_spheres",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_linear_color_attachment = ApiInfo{
        .name = "VK_NV_linear_color_attachment",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const google_surfaceless_query = ApiInfo{
        .name = "VK_GOOGLE_surfaceless_query",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_shader_maximal_reconvergence = ApiInfo{
        .name = "VK_KHR_shader_maximal_reconvergence",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_application_parameters = ApiInfo{
        .name = "VK_EXT_application_parameters",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_image_compression_control_swapchain = ApiInfo{
        .name = "VK_EXT_image_compression_control_swapchain",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const qcom_image_processing = ApiInfo{
        .name = "VK_QCOM_image_processing",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_nested_command_buffer = ApiInfo{
        .name = "VK_EXT_nested_command_buffer",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_external_memory_acquire_unmodified = ApiInfo{
        .name = "VK_EXT_external_memory_acquire_unmodified",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_extended_dynamic_state_3 = ApiInfo{
        .name = "VK_EXT_extended_dynamic_state3",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const ext_subpass_merge_feedback = ApiInfo{
        .name = "VK_EXT_subpass_merge_feedback",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const lunarg_direct_driver_loading = ApiInfo{
        .name = "VK_LUNARG_direct_driver_loading",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const arm_tensors = ApiInfo{
        .name = "VK_ARM_tensors",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_shader_module_identifier = ApiInfo{
        .name = "VK_EXT_shader_module_identifier",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_rasterization_order_attachment_access = ApiInfo{
        .name = "VK_EXT_rasterization_order_attachment_access",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_optical_flow = ApiInfo{
        .name = "VK_NV_optical_flow",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_legacy_dithering = ApiInfo{
        .name = "VK_EXT_legacy_dithering",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const ext_pipeline_protected_access = ApiInfo{
        .name = "VK_EXT_pipeline_protected_access",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const android_external_format_resolve = ApiInfo{
        .name = "VK_ANDROID_external_format_resolve",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_maintenance_5 = ApiInfo{
        .name = "VK_KHR_maintenance5",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const amd_anti_lag = ApiInfo{
        .name = "VK_AMD_anti_lag",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_present_id_2 = ApiInfo{
        .name = "VK_KHR_present_id2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_present_wait_2 = ApiInfo{
        .name = "VK_KHR_present_wait2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_ray_tracing_position_fetch = ApiInfo{
        .name = "VK_KHR_ray_tracing_position_fetch",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_shader_object = ApiInfo{
        .name = "VK_EXT_shader_object",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_pipeline_binary = ApiInfo{
        .name = "VK_KHR_pipeline_binary",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const qcom_tile_properties = ApiInfo{
        .name = "VK_QCOM_tile_properties",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const sec_amigo_profiling = ApiInfo{
        .name = "VK_SEC_amigo_profiling",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_surface_maintenance_1 = ApiInfo{
        .name = "VK_KHR_surface_maintenance1",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_swapchain_maintenance_1 = ApiInfo{
        .name = "VK_KHR_swapchain_maintenance1",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const qcom_multiview_per_view_viewports = ApiInfo{
        .name = "VK_QCOM_multiview_per_view_viewports",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_external_sci_sync_2 = ApiInfo{
        .name = "VK_NV_external_sci_sync2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_ray_tracing_invocation_reorder = ApiInfo{
        .name = "VK_NV_ray_tracing_invocation_reorder",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_cooperative_vector = ApiInfo{
        .name = "VK_NV_cooperative_vector",
        .version = makeApiVersion(0, 4, 0, 0),
    };
    pub const nv_extended_sparse_address_space = ApiInfo{
        .name = "VK_NV_extended_sparse_address_space",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_mutable_descriptor_type = ApiInfo{
        .name = "VK_EXT_mutable_descriptor_type",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_legacy_vertex_attributes = ApiInfo{
        .name = "VK_EXT_legacy_vertex_attributes",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_layer_settings = ApiInfo{
        .name = "VK_EXT_layer_settings",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const arm_shader_core_builtins = ApiInfo{
        .name = "VK_ARM_shader_core_builtins",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const ext_pipeline_library_group_handles = ApiInfo{
        .name = "VK_EXT_pipeline_library_group_handles",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_dynamic_rendering_unused_attachments = ApiInfo{
        .name = "VK_EXT_dynamic_rendering_unused_attachments",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_low_latency_2 = ApiInfo{
        .name = "VK_NV_low_latency2",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const khr_cooperative_matrix = ApiInfo{
        .name = "VK_KHR_cooperative_matrix",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const arm_data_graph = ApiInfo{
        .name = "VK_ARM_data_graph",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const qcom_multiview_per_view_render_areas = ApiInfo{
        .name = "VK_QCOM_multiview_per_view_render_areas",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_compute_shader_derivatives = ApiInfo{
        .name = "VK_KHR_compute_shader_derivatives",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_video_decode_av_1 = ApiInfo{
        .name = "VK_KHR_video_decode_av1",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_video_encode_av_1 = ApiInfo{
        .name = "VK_KHR_video_encode_av1",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_video_decode_vp_9 = ApiInfo{
        .name = "VK_KHR_video_decode_vp9",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_video_maintenance_1 = ApiInfo{
        .name = "VK_KHR_video_maintenance1",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_per_stage_descriptor_set = ApiInfo{
        .name = "VK_NV_per_stage_descriptor_set",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const qcom_image_processing_2 = ApiInfo{
        .name = "VK_QCOM_image_processing2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const qcom_filter_cubic_weights = ApiInfo{
        .name = "VK_QCOM_filter_cubic_weights",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const qcom_ycbcr_degamma = ApiInfo{
        .name = "VK_QCOM_ycbcr_degamma",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const qcom_filter_cubic_clamp = ApiInfo{
        .name = "VK_QCOM_filter_cubic_clamp",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_attachment_feedback_loop_dynamic_state = ApiInfo{
        .name = "VK_EXT_attachment_feedback_loop_dynamic_state",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_vertex_attribute_divisor = ApiInfo{
        .name = "VK_KHR_vertex_attribute_divisor",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_load_store_op_none = ApiInfo{
        .name = "VK_KHR_load_store_op_none",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_unified_image_layouts = ApiInfo{
        .name = "VK_KHR_unified_image_layouts",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_shader_float_controls_2 = ApiInfo{
        .name = "VK_KHR_shader_float_controls2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const qnx_external_memory_screen_buffer = ApiInfo{
        .name = "VK_QNX_external_memory_screen_buffer",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const msft_layered_driver = ApiInfo{
        .name = "VK_MSFT_layered_driver",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_index_type_uint_8 = ApiInfo{
        .name = "VK_KHR_index_type_uint8",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_line_rasterization = ApiInfo{
        .name = "VK_KHR_line_rasterization",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_calibrated_timestamps = ApiInfo{
        .name = "VK_KHR_calibrated_timestamps",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_shader_expect_assume = ApiInfo{
        .name = "VK_KHR_shader_expect_assume",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_maintenance_6 = ApiInfo{
        .name = "VK_KHR_maintenance6",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_descriptor_pool_overallocation = ApiInfo{
        .name = "VK_NV_descriptor_pool_overallocation",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const qcom_tile_memory_heap = ApiInfo{
        .name = "VK_QCOM_tile_memory_heap",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_display_stereo = ApiInfo{
        .name = "VK_NV_display_stereo",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_video_encode_intra_refresh = ApiInfo{
        .name = "VK_KHR_video_encode_intra_refresh",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_video_encode_quantization_map = ApiInfo{
        .name = "VK_KHR_video_encode_quantization_map",
        .version = makeApiVersion(0, 2, 0, 0),
    };
    pub const nv_raw_access_chains = ApiInfo{
        .name = "VK_NV_raw_access_chains",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_external_compute_queue = ApiInfo{
        .name = "VK_NV_external_compute_queue",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_shader_relaxed_extended_instruction = ApiInfo{
        .name = "VK_KHR_shader_relaxed_extended_instruction",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_command_buffer_inheritance = ApiInfo{
        .name = "VK_NV_command_buffer_inheritance",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_maintenance_7 = ApiInfo{
        .name = "VK_KHR_maintenance7",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_shader_atomic_float_16_vector = ApiInfo{
        .name = "VK_NV_shader_atomic_float16_vector",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_shader_replicated_composites = ApiInfo{
        .name = "VK_EXT_shader_replicated_composites",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_shader_float_8 = ApiInfo{
        .name = "VK_EXT_shader_float8",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_ray_tracing_validation = ApiInfo{
        .name = "VK_NV_ray_tracing_validation",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_cluster_acceleration_structure = ApiInfo{
        .name = "VK_NV_cluster_acceleration_structure",
        .version = makeApiVersion(0, 3, 0, 0),
    };
    pub const nv_partitioned_acceleration_structure = ApiInfo{
        .name = "VK_NV_partitioned_acceleration_structure",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_device_generated_commands = ApiInfo{
        .name = "VK_EXT_device_generated_commands",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_maintenance_8 = ApiInfo{
        .name = "VK_KHR_maintenance8",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const mesa_image_alignment_control = ApiInfo{
        .name = "VK_MESA_image_alignment_control",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_depth_clamp_control = ApiInfo{
        .name = "VK_EXT_depth_clamp_control",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_maintenance_9 = ApiInfo{
        .name = "VK_KHR_maintenance9",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_video_maintenance_2 = ApiInfo{
        .name = "VK_KHR_video_maintenance2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ohos_surface = ApiInfo{
        .name = "VK_OHOS_surface",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const huawei_hdr_vivid = ApiInfo{
        .name = "VK_HUAWEI_hdr_vivid",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_cooperative_matrix_2 = ApiInfo{
        .name = "VK_NV_cooperative_matrix2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const arm_pipeline_opacity_micromap = ApiInfo{
        .name = "VK_ARM_pipeline_opacity_micromap",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_external_memory_metal = ApiInfo{
        .name = "VK_EXT_external_memory_metal",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_depth_clamp_zero_one = ApiInfo{
        .name = "VK_KHR_depth_clamp_zero_one",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_vertex_attribute_robustness = ApiInfo{
        .name = "VK_EXT_vertex_attribute_robustness",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const arm_format_pack = ApiInfo{
        .name = "VK_ARM_format_pack",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const valve_fragment_density_map_layered = ApiInfo{
        .name = "VK_VALVE_fragment_density_map_layered",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_robustness_2 = ApiInfo{
        .name = "VK_KHR_robustness2",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const nv_present_metering = ApiInfo{
        .name = "VK_NV_present_metering",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_fragment_density_map_offset = ApiInfo{
        .name = "VK_EXT_fragment_density_map_offset",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const ext_zero_initialize_device_memory = ApiInfo{
        .name = "VK_EXT_zero_initialize_device_memory",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const khr_present_mode_fifo_latest_ready = ApiInfo{
        .name = "VK_KHR_present_mode_fifo_latest_ready",
        .version = makeApiVersion(0, 1, 0, 0),
    };
    pub const sec_pipeline_cache_incremental_mode = ApiInfo{
        .name = "VK_SEC_pipeline_cache_incremental_mode",
        .version = makeApiVersion(0, 1, 0, 0),
    };
};
const BaseDispatch = struct {
    vkCreateInstance: ?PfnCreateInstance = null,
    vkGetInstanceProcAddr: ?PfnGetInstanceProcAddr = null,
    vkEnumerateInstanceVersion: ?PfnEnumerateInstanceVersion = null,
    vkEnumerateInstanceLayerProperties: ?PfnEnumerateInstanceLayerProperties = null,
    vkEnumerateInstanceExtensionProperties: ?PfnEnumerateInstanceExtensionProperties = null,
};
const InstanceDispatch = struct {
    vkDestroyInstance: ?PfnDestroyInstance = null,
    vkEnumeratePhysicalDevices: ?PfnEnumeratePhysicalDevices = null,
    vkGetDeviceProcAddr: ?PfnGetDeviceProcAddr = null,
    vkGetPhysicalDeviceProperties: ?PfnGetPhysicalDeviceProperties = null,
    vkGetPhysicalDeviceQueueFamilyProperties: ?PfnGetPhysicalDeviceQueueFamilyProperties = null,
    vkGetPhysicalDeviceMemoryProperties: ?PfnGetPhysicalDeviceMemoryProperties = null,
    vkGetPhysicalDeviceFeatures: ?PfnGetPhysicalDeviceFeatures = null,
    vkGetPhysicalDeviceFormatProperties: ?PfnGetPhysicalDeviceFormatProperties = null,
    vkGetPhysicalDeviceImageFormatProperties: ?PfnGetPhysicalDeviceImageFormatProperties = null,
    vkCreateDevice: ?PfnCreateDevice = null,
    vkEnumerateDeviceLayerProperties: ?PfnEnumerateDeviceLayerProperties = null,
    vkEnumerateDeviceExtensionProperties: ?PfnEnumerateDeviceExtensionProperties = null,
    vkGetPhysicalDeviceSparseImageFormatProperties: ?PfnGetPhysicalDeviceSparseImageFormatProperties = null,
    vkCreateAndroidSurfaceKHR: ?PfnCreateAndroidSurfaceKHR = null,
    vkCreateSurfaceOHOS: ?PfnCreateSurfaceOHOS = null,
    vkGetPhysicalDeviceDisplayPropertiesKHR: ?PfnGetPhysicalDeviceDisplayPropertiesKHR = null,
    vkGetPhysicalDeviceDisplayPlanePropertiesKHR: ?PfnGetPhysicalDeviceDisplayPlanePropertiesKHR = null,
    vkGetDisplayPlaneSupportedDisplaysKHR: ?PfnGetDisplayPlaneSupportedDisplaysKHR = null,
    vkGetDisplayModePropertiesKHR: ?PfnGetDisplayModePropertiesKHR = null,
    vkCreateDisplayModeKHR: ?PfnCreateDisplayModeKHR = null,
    vkGetDisplayPlaneCapabilitiesKHR: ?PfnGetDisplayPlaneCapabilitiesKHR = null,
    vkCreateDisplayPlaneSurfaceKHR: ?PfnCreateDisplayPlaneSurfaceKHR = null,
    vkDestroySurfaceKHR: ?PfnDestroySurfaceKHR = null,
    vkGetPhysicalDeviceSurfaceSupportKHR: ?PfnGetPhysicalDeviceSurfaceSupportKHR = null,
    vkGetPhysicalDeviceSurfaceCapabilitiesKHR: ?PfnGetPhysicalDeviceSurfaceCapabilitiesKHR = null,
    vkGetPhysicalDeviceSurfaceFormatsKHR: ?PfnGetPhysicalDeviceSurfaceFormatsKHR = null,
    vkGetPhysicalDeviceSurfacePresentModesKHR: ?PfnGetPhysicalDeviceSurfacePresentModesKHR = null,
    vkCreateViSurfaceNN: ?PfnCreateViSurfaceNN = null,
    vkCreateWaylandSurfaceKHR: ?PfnCreateWaylandSurfaceKHR = null,
    vkGetPhysicalDeviceWaylandPresentationSupportKHR: ?PfnGetPhysicalDeviceWaylandPresentationSupportKHR = null,
    vkCreateWin32SurfaceKHR: ?PfnCreateWin32SurfaceKHR = null,
    vkGetPhysicalDeviceWin32PresentationSupportKHR: ?PfnGetPhysicalDeviceWin32PresentationSupportKHR = null,
    vkCreateXlibSurfaceKHR: ?PfnCreateXlibSurfaceKHR = null,
    vkGetPhysicalDeviceXlibPresentationSupportKHR: ?PfnGetPhysicalDeviceXlibPresentationSupportKHR = null,
    vkCreateXcbSurfaceKHR: ?PfnCreateXcbSurfaceKHR = null,
    vkGetPhysicalDeviceXcbPresentationSupportKHR: ?PfnGetPhysicalDeviceXcbPresentationSupportKHR = null,
    vkCreateDirectFBSurfaceEXT: ?PfnCreateDirectFBSurfaceEXT = null,
    vkGetPhysicalDeviceDirectFBPresentationSupportEXT: ?PfnGetPhysicalDeviceDirectFBPresentationSupportEXT = null,
    vkCreateImagePipeSurfaceFUCHSIA: ?PfnCreateImagePipeSurfaceFUCHSIA = null,
    vkCreateStreamDescriptorSurfaceGGP: ?PfnCreateStreamDescriptorSurfaceGGP = null,
    vkCreateScreenSurfaceQNX: ?PfnCreateScreenSurfaceQNX = null,
    vkGetPhysicalDeviceScreenPresentationSupportQNX: ?PfnGetPhysicalDeviceScreenPresentationSupportQNX = null,
    vkCreateDebugReportCallbackEXT: ?PfnCreateDebugReportCallbackEXT = null,
    vkDestroyDebugReportCallbackEXT: ?PfnDestroyDebugReportCallbackEXT = null,
    vkDebugReportMessageEXT: ?PfnDebugReportMessageEXT = null,
    vkGetPhysicalDeviceExternalImageFormatPropertiesNV: ?PfnGetPhysicalDeviceExternalImageFormatPropertiesNV = null,
    vkGetPhysicalDeviceFeatures2: ?PfnGetPhysicalDeviceFeatures2 = null,
    vkGetPhysicalDeviceFeatures2KHR: ?PfnGetPhysicalDeviceFeatures2KHR = null,
    vkGetPhysicalDeviceProperties2: ?PfnGetPhysicalDeviceProperties2 = null,
    vkGetPhysicalDeviceProperties2KHR: ?PfnGetPhysicalDeviceProperties2KHR = null,
    vkGetPhysicalDeviceFormatProperties2: ?PfnGetPhysicalDeviceFormatProperties2 = null,
    vkGetPhysicalDeviceFormatProperties2KHR: ?PfnGetPhysicalDeviceFormatProperties2KHR = null,
    vkGetPhysicalDeviceImageFormatProperties2: ?PfnGetPhysicalDeviceImageFormatProperties2 = null,
    vkGetPhysicalDeviceImageFormatProperties2KHR: ?PfnGetPhysicalDeviceImageFormatProperties2KHR = null,
    vkGetPhysicalDeviceQueueFamilyProperties2: ?PfnGetPhysicalDeviceQueueFamilyProperties2 = null,
    vkGetPhysicalDeviceQueueFamilyProperties2KHR: ?PfnGetPhysicalDeviceQueueFamilyProperties2KHR = null,
    vkGetPhysicalDeviceMemoryProperties2: ?PfnGetPhysicalDeviceMemoryProperties2 = null,
    vkGetPhysicalDeviceMemoryProperties2KHR: ?PfnGetPhysicalDeviceMemoryProperties2KHR = null,
    vkGetPhysicalDeviceSparseImageFormatProperties2: ?PfnGetPhysicalDeviceSparseImageFormatProperties2 = null,
    vkGetPhysicalDeviceSparseImageFormatProperties2KHR: ?PfnGetPhysicalDeviceSparseImageFormatProperties2KHR = null,
    vkGetPhysicalDeviceExternalBufferProperties: ?PfnGetPhysicalDeviceExternalBufferProperties = null,
    vkGetPhysicalDeviceExternalBufferPropertiesKHR: ?PfnGetPhysicalDeviceExternalBufferPropertiesKHR = null,
    vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV: ?PfnGetPhysicalDeviceExternalMemorySciBufPropertiesNV = null,
    vkGetPhysicalDeviceSciBufAttributesNV: ?PfnGetPhysicalDeviceSciBufAttributesNV = null,
    vkGetPhysicalDeviceExternalSemaphoreProperties: ?PfnGetPhysicalDeviceExternalSemaphoreProperties = null,
    vkGetPhysicalDeviceExternalSemaphorePropertiesKHR: ?PfnGetPhysicalDeviceExternalSemaphorePropertiesKHR = null,
    vkGetPhysicalDeviceExternalFenceProperties: ?PfnGetPhysicalDeviceExternalFenceProperties = null,
    vkGetPhysicalDeviceExternalFencePropertiesKHR: ?PfnGetPhysicalDeviceExternalFencePropertiesKHR = null,
    vkGetPhysicalDeviceSciSyncAttributesNV: ?PfnGetPhysicalDeviceSciSyncAttributesNV = null,
    vkReleaseDisplayEXT: ?PfnReleaseDisplayEXT = null,
    vkAcquireXlibDisplayEXT: ?PfnAcquireXlibDisplayEXT = null,
    vkGetRandROutputDisplayEXT: ?PfnGetRandROutputDisplayEXT = null,
    vkAcquireWinrtDisplayNV: ?PfnAcquireWinrtDisplayNV = null,
    vkGetWinrtDisplayNV: ?PfnGetWinrtDisplayNV = null,
    vkGetPhysicalDeviceSurfaceCapabilities2EXT: ?PfnGetPhysicalDeviceSurfaceCapabilities2EXT = null,
    vkEnumeratePhysicalDeviceGroups: ?PfnEnumeratePhysicalDeviceGroups = null,
    vkEnumeratePhysicalDeviceGroupsKHR: ?PfnEnumeratePhysicalDeviceGroupsKHR = null,
    vkGetPhysicalDevicePresentRectanglesKHR: ?PfnGetPhysicalDevicePresentRectanglesKHR = null,
    vkCreateIOSSurfaceMVK: ?PfnCreateIOSSurfaceMVK = null,
    vkCreateMacOSSurfaceMVK: ?PfnCreateMacOSSurfaceMVK = null,
    vkCreateMetalSurfaceEXT: ?PfnCreateMetalSurfaceEXT = null,
    vkGetPhysicalDeviceMultisamplePropertiesEXT: ?PfnGetPhysicalDeviceMultisamplePropertiesEXT = null,
    vkGetPhysicalDeviceSurfaceCapabilities2KHR: ?PfnGetPhysicalDeviceSurfaceCapabilities2KHR = null,
    vkGetPhysicalDeviceSurfaceFormats2KHR: ?PfnGetPhysicalDeviceSurfaceFormats2KHR = null,
    vkGetPhysicalDeviceDisplayProperties2KHR: ?PfnGetPhysicalDeviceDisplayProperties2KHR = null,
    vkGetPhysicalDeviceDisplayPlaneProperties2KHR: ?PfnGetPhysicalDeviceDisplayPlaneProperties2KHR = null,
    vkGetDisplayModeProperties2KHR: ?PfnGetDisplayModeProperties2KHR = null,
    vkGetDisplayPlaneCapabilities2KHR: ?PfnGetDisplayPlaneCapabilities2KHR = null,
    vkGetPhysicalDeviceCalibrateableTimeDomainsKHR: ?PfnGetPhysicalDeviceCalibrateableTimeDomainsKHR = null,
    vkGetPhysicalDeviceCalibrateableTimeDomainsEXT: ?PfnGetPhysicalDeviceCalibrateableTimeDomainsEXT = null,
    vkCreateDebugUtilsMessengerEXT: ?PfnCreateDebugUtilsMessengerEXT = null,
    vkDestroyDebugUtilsMessengerEXT: ?PfnDestroyDebugUtilsMessengerEXT = null,
    vkSubmitDebugUtilsMessageEXT: ?PfnSubmitDebugUtilsMessageEXT = null,
    vkGetPhysicalDeviceCooperativeMatrixPropertiesNV: ?PfnGetPhysicalDeviceCooperativeMatrixPropertiesNV = null,
    vkGetPhysicalDeviceSurfacePresentModes2EXT: ?PfnGetPhysicalDeviceSurfacePresentModes2EXT = null,
    vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR: ?PfnEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = null,
    vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR: ?PfnGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = null,
    vkCreateHeadlessSurfaceEXT: ?PfnCreateHeadlessSurfaceEXT = null,
    vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV: ?PfnGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = null,
    vkGetPhysicalDeviceToolProperties: ?PfnGetPhysicalDeviceToolProperties = null,
    vkGetPhysicalDeviceToolPropertiesEXT: ?PfnGetPhysicalDeviceToolPropertiesEXT = null,
    vkGetPhysicalDeviceRefreshableObjectTypesKHR: ?PfnGetPhysicalDeviceRefreshableObjectTypesKHR = null,
    vkGetPhysicalDeviceFragmentShadingRatesKHR: ?PfnGetPhysicalDeviceFragmentShadingRatesKHR = null,
    vkGetPhysicalDeviceVideoCapabilitiesKHR: ?PfnGetPhysicalDeviceVideoCapabilitiesKHR = null,
    vkGetPhysicalDeviceVideoFormatPropertiesKHR: ?PfnGetPhysicalDeviceVideoFormatPropertiesKHR = null,
    vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR: ?PfnGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = null,
    vkAcquireDrmDisplayEXT: ?PfnAcquireDrmDisplayEXT = null,
    vkGetDrmDisplayEXT: ?PfnGetDrmDisplayEXT = null,
    vkGetPhysicalDeviceOpticalFlowImageFormatsNV: ?PfnGetPhysicalDeviceOpticalFlowImageFormatsNV = null,
    vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR: ?PfnGetPhysicalDeviceCooperativeMatrixPropertiesKHR = null,
    vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV: ?PfnGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV = null,
    vkGetPhysicalDeviceCooperativeVectorPropertiesNV: ?PfnGetPhysicalDeviceCooperativeVectorPropertiesNV = null,
    vkGetExternalComputeQueueDataNV: ?PfnGetExternalComputeQueueDataNV = null,
    vkGetPhysicalDeviceExternalTensorPropertiesARM: ?PfnGetPhysicalDeviceExternalTensorPropertiesARM = null,
    vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM: ?PfnGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM = null,
    vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM: ?PfnGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM = null,
};
const DeviceDispatch = struct {
    vkDestroyDevice: ?PfnDestroyDevice = null,
    vkGetDeviceQueue: ?PfnGetDeviceQueue = null,
    vkQueueSubmit: ?PfnQueueSubmit = null,
    vkQueueWaitIdle: ?PfnQueueWaitIdle = null,
    vkDeviceWaitIdle: ?PfnDeviceWaitIdle = null,
    vkAllocateMemory: ?PfnAllocateMemory = null,
    vkFreeMemory: ?PfnFreeMemory = null,
    vkMapMemory: ?PfnMapMemory = null,
    vkUnmapMemory: ?PfnUnmapMemory = null,
    vkFlushMappedMemoryRanges: ?PfnFlushMappedMemoryRanges = null,
    vkInvalidateMappedMemoryRanges: ?PfnInvalidateMappedMemoryRanges = null,
    vkGetDeviceMemoryCommitment: ?PfnGetDeviceMemoryCommitment = null,
    vkGetBufferMemoryRequirements: ?PfnGetBufferMemoryRequirements = null,
    vkBindBufferMemory: ?PfnBindBufferMemory = null,
    vkGetImageMemoryRequirements: ?PfnGetImageMemoryRequirements = null,
    vkBindImageMemory: ?PfnBindImageMemory = null,
    vkGetImageSparseMemoryRequirements: ?PfnGetImageSparseMemoryRequirements = null,
    vkQueueBindSparse: ?PfnQueueBindSparse = null,
    vkCreateFence: ?PfnCreateFence = null,
    vkDestroyFence: ?PfnDestroyFence = null,
    vkResetFences: ?PfnResetFences = null,
    vkGetFenceStatus: ?PfnGetFenceStatus = null,
    vkWaitForFences: ?PfnWaitForFences = null,
    vkCreateSemaphore: ?PfnCreateSemaphore = null,
    vkDestroySemaphore: ?PfnDestroySemaphore = null,
    vkCreateEvent: ?PfnCreateEvent = null,
    vkDestroyEvent: ?PfnDestroyEvent = null,
    vkGetEventStatus: ?PfnGetEventStatus = null,
    vkSetEvent: ?PfnSetEvent = null,
    vkResetEvent: ?PfnResetEvent = null,
    vkCreateQueryPool: ?PfnCreateQueryPool = null,
    vkDestroyQueryPool: ?PfnDestroyQueryPool = null,
    vkGetQueryPoolResults: ?PfnGetQueryPoolResults = null,
    vkResetQueryPool: ?PfnResetQueryPool = null,
    vkResetQueryPoolEXT: ?PfnResetQueryPoolEXT = null,
    vkCreateBuffer: ?PfnCreateBuffer = null,
    vkDestroyBuffer: ?PfnDestroyBuffer = null,
    vkCreateBufferView: ?PfnCreateBufferView = null,
    vkDestroyBufferView: ?PfnDestroyBufferView = null,
    vkCreateImage: ?PfnCreateImage = null,
    vkDestroyImage: ?PfnDestroyImage = null,
    vkGetImageSubresourceLayout: ?PfnGetImageSubresourceLayout = null,
    vkCreateImageView: ?PfnCreateImageView = null,
    vkDestroyImageView: ?PfnDestroyImageView = null,
    vkCreateShaderModule: ?PfnCreateShaderModule = null,
    vkDestroyShaderModule: ?PfnDestroyShaderModule = null,
    vkCreatePipelineCache: ?PfnCreatePipelineCache = null,
    vkDestroyPipelineCache: ?PfnDestroyPipelineCache = null,
    vkGetPipelineCacheData: ?PfnGetPipelineCacheData = null,
    vkMergePipelineCaches: ?PfnMergePipelineCaches = null,
    vkCreatePipelineBinariesKHR: ?PfnCreatePipelineBinariesKHR = null,
    vkDestroyPipelineBinaryKHR: ?PfnDestroyPipelineBinaryKHR = null,
    vkGetPipelineKeyKHR: ?PfnGetPipelineKeyKHR = null,
    vkGetPipelineBinaryDataKHR: ?PfnGetPipelineBinaryDataKHR = null,
    vkReleaseCapturedPipelineDataKHR: ?PfnReleaseCapturedPipelineDataKHR = null,
    vkCreateGraphicsPipelines: ?PfnCreateGraphicsPipelines = null,
    vkCreateComputePipelines: ?PfnCreateComputePipelines = null,
    vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI: ?PfnGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = null,
    vkDestroyPipeline: ?PfnDestroyPipeline = null,
    vkCreatePipelineLayout: ?PfnCreatePipelineLayout = null,
    vkDestroyPipelineLayout: ?PfnDestroyPipelineLayout = null,
    vkCreateSampler: ?PfnCreateSampler = null,
    vkDestroySampler: ?PfnDestroySampler = null,
    vkCreateDescriptorSetLayout: ?PfnCreateDescriptorSetLayout = null,
    vkDestroyDescriptorSetLayout: ?PfnDestroyDescriptorSetLayout = null,
    vkCreateDescriptorPool: ?PfnCreateDescriptorPool = null,
    vkDestroyDescriptorPool: ?PfnDestroyDescriptorPool = null,
    vkResetDescriptorPool: ?PfnResetDescriptorPool = null,
    vkAllocateDescriptorSets: ?PfnAllocateDescriptorSets = null,
    vkFreeDescriptorSets: ?PfnFreeDescriptorSets = null,
    vkUpdateDescriptorSets: ?PfnUpdateDescriptorSets = null,
    vkCreateFramebuffer: ?PfnCreateFramebuffer = null,
    vkDestroyFramebuffer: ?PfnDestroyFramebuffer = null,
    vkCreateRenderPass: ?PfnCreateRenderPass = null,
    vkDestroyRenderPass: ?PfnDestroyRenderPass = null,
    vkGetRenderAreaGranularity: ?PfnGetRenderAreaGranularity = null,
    vkGetRenderingAreaGranularity: ?PfnGetRenderingAreaGranularity = null,
    vkGetRenderingAreaGranularityKHR: ?PfnGetRenderingAreaGranularityKHR = null,
    vkCreateCommandPool: ?PfnCreateCommandPool = null,
    vkDestroyCommandPool: ?PfnDestroyCommandPool = null,
    vkResetCommandPool: ?PfnResetCommandPool = null,
    vkAllocateCommandBuffers: ?PfnAllocateCommandBuffers = null,
    vkFreeCommandBuffers: ?PfnFreeCommandBuffers = null,
    vkBeginCommandBuffer: ?PfnBeginCommandBuffer = null,
    vkEndCommandBuffer: ?PfnEndCommandBuffer = null,
    vkResetCommandBuffer: ?PfnResetCommandBuffer = null,
    vkCmdBindPipeline: ?PfnCmdBindPipeline = null,
    vkCmdSetAttachmentFeedbackLoopEnableEXT: ?PfnCmdSetAttachmentFeedbackLoopEnableEXT = null,
    vkCmdSetViewport: ?PfnCmdSetViewport = null,
    vkCmdSetScissor: ?PfnCmdSetScissor = null,
    vkCmdSetLineWidth: ?PfnCmdSetLineWidth = null,
    vkCmdSetDepthBias: ?PfnCmdSetDepthBias = null,
    vkCmdSetBlendConstants: ?PfnCmdSetBlendConstants = null,
    vkCmdSetDepthBounds: ?PfnCmdSetDepthBounds = null,
    vkCmdSetStencilCompareMask: ?PfnCmdSetStencilCompareMask = null,
    vkCmdSetStencilWriteMask: ?PfnCmdSetStencilWriteMask = null,
    vkCmdSetStencilReference: ?PfnCmdSetStencilReference = null,
    vkCmdBindDescriptorSets: ?PfnCmdBindDescriptorSets = null,
    vkCmdBindIndexBuffer: ?PfnCmdBindIndexBuffer = null,
    vkCmdBindVertexBuffers: ?PfnCmdBindVertexBuffers = null,
    vkCmdDraw: ?PfnCmdDraw = null,
    vkCmdDrawIndexed: ?PfnCmdDrawIndexed = null,
    vkCmdDrawMultiEXT: ?PfnCmdDrawMultiEXT = null,
    vkCmdDrawMultiIndexedEXT: ?PfnCmdDrawMultiIndexedEXT = null,
    vkCmdDrawIndirect: ?PfnCmdDrawIndirect = null,
    vkCmdDrawIndexedIndirect: ?PfnCmdDrawIndexedIndirect = null,
    vkCmdDispatch: ?PfnCmdDispatch = null,
    vkCmdDispatchIndirect: ?PfnCmdDispatchIndirect = null,
    vkCmdSubpassShadingHUAWEI: ?PfnCmdSubpassShadingHUAWEI = null,
    vkCmdDrawClusterHUAWEI: ?PfnCmdDrawClusterHUAWEI = null,
    vkCmdDrawClusterIndirectHUAWEI: ?PfnCmdDrawClusterIndirectHUAWEI = null,
    vkCmdUpdatePipelineIndirectBufferNV: ?PfnCmdUpdatePipelineIndirectBufferNV = null,
    vkCmdCopyBuffer: ?PfnCmdCopyBuffer = null,
    vkCmdCopyImage: ?PfnCmdCopyImage = null,
    vkCmdBlitImage: ?PfnCmdBlitImage = null,
    vkCmdCopyBufferToImage: ?PfnCmdCopyBufferToImage = null,
    vkCmdCopyImageToBuffer: ?PfnCmdCopyImageToBuffer = null,
    vkCmdCopyMemoryIndirectNV: ?PfnCmdCopyMemoryIndirectNV = null,
    vkCmdCopyMemoryToImageIndirectNV: ?PfnCmdCopyMemoryToImageIndirectNV = null,
    vkCmdUpdateBuffer: ?PfnCmdUpdateBuffer = null,
    vkCmdFillBuffer: ?PfnCmdFillBuffer = null,
    vkCmdClearColorImage: ?PfnCmdClearColorImage = null,
    vkCmdClearDepthStencilImage: ?PfnCmdClearDepthStencilImage = null,
    vkCmdClearAttachments: ?PfnCmdClearAttachments = null,
    vkCmdResolveImage: ?PfnCmdResolveImage = null,
    vkCmdSetEvent: ?PfnCmdSetEvent = null,
    vkCmdResetEvent: ?PfnCmdResetEvent = null,
    vkCmdWaitEvents: ?PfnCmdWaitEvents = null,
    vkCmdPipelineBarrier: ?PfnCmdPipelineBarrier = null,
    vkCmdBeginQuery: ?PfnCmdBeginQuery = null,
    vkCmdEndQuery: ?PfnCmdEndQuery = null,
    vkCmdBeginConditionalRenderingEXT: ?PfnCmdBeginConditionalRenderingEXT = null,
    vkCmdEndConditionalRenderingEXT: ?PfnCmdEndConditionalRenderingEXT = null,
    vkCmdResetQueryPool: ?PfnCmdResetQueryPool = null,
    vkCmdWriteTimestamp: ?PfnCmdWriteTimestamp = null,
    vkCmdCopyQueryPoolResults: ?PfnCmdCopyQueryPoolResults = null,
    vkCmdPushConstants: ?PfnCmdPushConstants = null,
    vkCmdBeginRenderPass: ?PfnCmdBeginRenderPass = null,
    vkCmdNextSubpass: ?PfnCmdNextSubpass = null,
    vkCmdEndRenderPass: ?PfnCmdEndRenderPass = null,
    vkCmdExecuteCommands: ?PfnCmdExecuteCommands = null,
    vkCreateSharedSwapchainsKHR: ?PfnCreateSharedSwapchainsKHR = null,
    vkCreateSwapchainKHR: ?PfnCreateSwapchainKHR = null,
    vkDestroySwapchainKHR: ?PfnDestroySwapchainKHR = null,
    vkGetSwapchainImagesKHR: ?PfnGetSwapchainImagesKHR = null,
    vkAcquireNextImageKHR: ?PfnAcquireNextImageKHR = null,
    vkQueuePresentKHR: ?PfnQueuePresentKHR = null,
    vkDebugMarkerSetObjectNameEXT: ?PfnDebugMarkerSetObjectNameEXT = null,
    vkDebugMarkerSetObjectTagEXT: ?PfnDebugMarkerSetObjectTagEXT = null,
    vkCmdDebugMarkerBeginEXT: ?PfnCmdDebugMarkerBeginEXT = null,
    vkCmdDebugMarkerEndEXT: ?PfnCmdDebugMarkerEndEXT = null,
    vkCmdDebugMarkerInsertEXT: ?PfnCmdDebugMarkerInsertEXT = null,
    vkGetMemoryWin32HandleNV: ?PfnGetMemoryWin32HandleNV = null,
    vkCmdExecuteGeneratedCommandsNV: ?PfnCmdExecuteGeneratedCommandsNV = null,
    vkCmdPreprocessGeneratedCommandsNV: ?PfnCmdPreprocessGeneratedCommandsNV = null,
    vkCmdBindPipelineShaderGroupNV: ?PfnCmdBindPipelineShaderGroupNV = null,
    vkGetGeneratedCommandsMemoryRequirementsNV: ?PfnGetGeneratedCommandsMemoryRequirementsNV = null,
    vkCreateIndirectCommandsLayoutNV: ?PfnCreateIndirectCommandsLayoutNV = null,
    vkDestroyIndirectCommandsLayoutNV: ?PfnDestroyIndirectCommandsLayoutNV = null,
    vkCmdExecuteGeneratedCommandsEXT: ?PfnCmdExecuteGeneratedCommandsEXT = null,
    vkCmdPreprocessGeneratedCommandsEXT: ?PfnCmdPreprocessGeneratedCommandsEXT = null,
    vkGetGeneratedCommandsMemoryRequirementsEXT: ?PfnGetGeneratedCommandsMemoryRequirementsEXT = null,
    vkCreateIndirectCommandsLayoutEXT: ?PfnCreateIndirectCommandsLayoutEXT = null,
    vkDestroyIndirectCommandsLayoutEXT: ?PfnDestroyIndirectCommandsLayoutEXT = null,
    vkCreateIndirectExecutionSetEXT: ?PfnCreateIndirectExecutionSetEXT = null,
    vkDestroyIndirectExecutionSetEXT: ?PfnDestroyIndirectExecutionSetEXT = null,
    vkUpdateIndirectExecutionSetPipelineEXT: ?PfnUpdateIndirectExecutionSetPipelineEXT = null,
    vkUpdateIndirectExecutionSetShaderEXT: ?PfnUpdateIndirectExecutionSetShaderEXT = null,
    vkCmdPushDescriptorSet: ?PfnCmdPushDescriptorSet = null,
    vkCmdPushDescriptorSetKHR: ?PfnCmdPushDescriptorSetKHR = null,
    vkTrimCommandPool: ?PfnTrimCommandPool = null,
    vkTrimCommandPoolKHR: ?PfnTrimCommandPoolKHR = null,
    vkGetMemoryWin32HandleKHR: ?PfnGetMemoryWin32HandleKHR = null,
    vkGetMemoryWin32HandlePropertiesKHR: ?PfnGetMemoryWin32HandlePropertiesKHR = null,
    vkGetMemoryFdKHR: ?PfnGetMemoryFdKHR = null,
    vkGetMemoryFdPropertiesKHR: ?PfnGetMemoryFdPropertiesKHR = null,
    vkGetMemoryZirconHandleFUCHSIA: ?PfnGetMemoryZirconHandleFUCHSIA = null,
    vkGetMemoryZirconHandlePropertiesFUCHSIA: ?PfnGetMemoryZirconHandlePropertiesFUCHSIA = null,
    vkGetMemoryRemoteAddressNV: ?PfnGetMemoryRemoteAddressNV = null,
    vkGetMemorySciBufNV: ?PfnGetMemorySciBufNV = null,
    vkGetSemaphoreWin32HandleKHR: ?PfnGetSemaphoreWin32HandleKHR = null,
    vkImportSemaphoreWin32HandleKHR: ?PfnImportSemaphoreWin32HandleKHR = null,
    vkGetSemaphoreFdKHR: ?PfnGetSemaphoreFdKHR = null,
    vkImportSemaphoreFdKHR: ?PfnImportSemaphoreFdKHR = null,
    vkGetSemaphoreZirconHandleFUCHSIA: ?PfnGetSemaphoreZirconHandleFUCHSIA = null,
    vkImportSemaphoreZirconHandleFUCHSIA: ?PfnImportSemaphoreZirconHandleFUCHSIA = null,
    vkGetFenceWin32HandleKHR: ?PfnGetFenceWin32HandleKHR = null,
    vkImportFenceWin32HandleKHR: ?PfnImportFenceWin32HandleKHR = null,
    vkGetFenceFdKHR: ?PfnGetFenceFdKHR = null,
    vkImportFenceFdKHR: ?PfnImportFenceFdKHR = null,
    vkGetFenceSciSyncFenceNV: ?PfnGetFenceSciSyncFenceNV = null,
    vkGetFenceSciSyncObjNV: ?PfnGetFenceSciSyncObjNV = null,
    vkImportFenceSciSyncFenceNV: ?PfnImportFenceSciSyncFenceNV = null,
    vkImportFenceSciSyncObjNV: ?PfnImportFenceSciSyncObjNV = null,
    vkGetSemaphoreSciSyncObjNV: ?PfnGetSemaphoreSciSyncObjNV = null,
    vkImportSemaphoreSciSyncObjNV: ?PfnImportSemaphoreSciSyncObjNV = null,
    vkCreateSemaphoreSciSyncPoolNV: ?PfnCreateSemaphoreSciSyncPoolNV = null,
    vkDestroySemaphoreSciSyncPoolNV: ?PfnDestroySemaphoreSciSyncPoolNV = null,
    vkDisplayPowerControlEXT: ?PfnDisplayPowerControlEXT = null,
    vkRegisterDeviceEventEXT: ?PfnRegisterDeviceEventEXT = null,
    vkRegisterDisplayEventEXT: ?PfnRegisterDisplayEventEXT = null,
    vkGetSwapchainCounterEXT: ?PfnGetSwapchainCounterEXT = null,
    vkGetDeviceGroupPeerMemoryFeatures: ?PfnGetDeviceGroupPeerMemoryFeatures = null,
    vkGetDeviceGroupPeerMemoryFeaturesKHR: ?PfnGetDeviceGroupPeerMemoryFeaturesKHR = null,
    vkBindBufferMemory2: ?PfnBindBufferMemory2 = null,
    vkBindBufferMemory2KHR: ?PfnBindBufferMemory2KHR = null,
    vkBindImageMemory2: ?PfnBindImageMemory2 = null,
    vkBindImageMemory2KHR: ?PfnBindImageMemory2KHR = null,
    vkCmdSetDeviceMask: ?PfnCmdSetDeviceMask = null,
    vkCmdSetDeviceMaskKHR: ?PfnCmdSetDeviceMaskKHR = null,
    vkGetDeviceGroupPresentCapabilitiesKHR: ?PfnGetDeviceGroupPresentCapabilitiesKHR = null,
    vkGetDeviceGroupSurfacePresentModesKHR: ?PfnGetDeviceGroupSurfacePresentModesKHR = null,
    vkAcquireNextImage2KHR: ?PfnAcquireNextImage2KHR = null,
    vkCmdDispatchBase: ?PfnCmdDispatchBase = null,
    vkCmdDispatchBaseKHR: ?PfnCmdDispatchBaseKHR = null,
    vkCreateDescriptorUpdateTemplate: ?PfnCreateDescriptorUpdateTemplate = null,
    vkCreateDescriptorUpdateTemplateKHR: ?PfnCreateDescriptorUpdateTemplateKHR = null,
    vkDestroyDescriptorUpdateTemplate: ?PfnDestroyDescriptorUpdateTemplate = null,
    vkDestroyDescriptorUpdateTemplateKHR: ?PfnDestroyDescriptorUpdateTemplateKHR = null,
    vkUpdateDescriptorSetWithTemplate: ?PfnUpdateDescriptorSetWithTemplate = null,
    vkUpdateDescriptorSetWithTemplateKHR: ?PfnUpdateDescriptorSetWithTemplateKHR = null,
    vkCmdPushDescriptorSetWithTemplate: ?PfnCmdPushDescriptorSetWithTemplate = null,
    vkCmdPushDescriptorSetWithTemplateKHR: ?PfnCmdPushDescriptorSetWithTemplateKHR = null,
    vkSetHdrMetadataEXT: ?PfnSetHdrMetadataEXT = null,
    vkGetSwapchainStatusKHR: ?PfnGetSwapchainStatusKHR = null,
    vkGetRefreshCycleDurationGOOGLE: ?PfnGetRefreshCycleDurationGOOGLE = null,
    vkGetPastPresentationTimingGOOGLE: ?PfnGetPastPresentationTimingGOOGLE = null,
    vkCmdSetViewportWScalingNV: ?PfnCmdSetViewportWScalingNV = null,
    vkCmdSetDiscardRectangleEXT: ?PfnCmdSetDiscardRectangleEXT = null,
    vkCmdSetDiscardRectangleEnableEXT: ?PfnCmdSetDiscardRectangleEnableEXT = null,
    vkCmdSetDiscardRectangleModeEXT: ?PfnCmdSetDiscardRectangleModeEXT = null,
    vkCmdSetSampleLocationsEXT: ?PfnCmdSetSampleLocationsEXT = null,
    vkGetBufferMemoryRequirements2: ?PfnGetBufferMemoryRequirements2 = null,
    vkGetBufferMemoryRequirements2KHR: ?PfnGetBufferMemoryRequirements2KHR = null,
    vkGetImageMemoryRequirements2: ?PfnGetImageMemoryRequirements2 = null,
    vkGetImageMemoryRequirements2KHR: ?PfnGetImageMemoryRequirements2KHR = null,
    vkGetImageSparseMemoryRequirements2: ?PfnGetImageSparseMemoryRequirements2 = null,
    vkGetImageSparseMemoryRequirements2KHR: ?PfnGetImageSparseMemoryRequirements2KHR = null,
    vkGetDeviceBufferMemoryRequirements: ?PfnGetDeviceBufferMemoryRequirements = null,
    vkGetDeviceBufferMemoryRequirementsKHR: ?PfnGetDeviceBufferMemoryRequirementsKHR = null,
    vkGetDeviceImageMemoryRequirements: ?PfnGetDeviceImageMemoryRequirements = null,
    vkGetDeviceImageMemoryRequirementsKHR: ?PfnGetDeviceImageMemoryRequirementsKHR = null,
    vkGetDeviceImageSparseMemoryRequirements: ?PfnGetDeviceImageSparseMemoryRequirements = null,
    vkGetDeviceImageSparseMemoryRequirementsKHR: ?PfnGetDeviceImageSparseMemoryRequirementsKHR = null,
    vkCreateSamplerYcbcrConversion: ?PfnCreateSamplerYcbcrConversion = null,
    vkCreateSamplerYcbcrConversionKHR: ?PfnCreateSamplerYcbcrConversionKHR = null,
    vkDestroySamplerYcbcrConversion: ?PfnDestroySamplerYcbcrConversion = null,
    vkDestroySamplerYcbcrConversionKHR: ?PfnDestroySamplerYcbcrConversionKHR = null,
    vkGetDeviceQueue2: ?PfnGetDeviceQueue2 = null,
    vkCreateValidationCacheEXT: ?PfnCreateValidationCacheEXT = null,
    vkDestroyValidationCacheEXT: ?PfnDestroyValidationCacheEXT = null,
    vkGetValidationCacheDataEXT: ?PfnGetValidationCacheDataEXT = null,
    vkMergeValidationCachesEXT: ?PfnMergeValidationCachesEXT = null,
    vkGetDescriptorSetLayoutSupport: ?PfnGetDescriptorSetLayoutSupport = null,
    vkGetDescriptorSetLayoutSupportKHR: ?PfnGetDescriptorSetLayoutSupportKHR = null,
    vkGetSwapchainGrallocUsageANDROID: ?PfnGetSwapchainGrallocUsageANDROID = null,
    vkGetSwapchainGrallocUsage2ANDROID: ?PfnGetSwapchainGrallocUsage2ANDROID = null,
    vkAcquireImageANDROID: ?PfnAcquireImageANDROID = null,
    vkQueueSignalReleaseImageANDROID: ?PfnQueueSignalReleaseImageANDROID = null,
    vkGetShaderInfoAMD: ?PfnGetShaderInfoAMD = null,
    vkSetLocalDimmingAMD: ?PfnSetLocalDimmingAMD = null,
    vkGetCalibratedTimestampsKHR: ?PfnGetCalibratedTimestampsKHR = null,
    vkGetCalibratedTimestampsEXT: ?PfnGetCalibratedTimestampsEXT = null,
    vkSetDebugUtilsObjectNameEXT: ?PfnSetDebugUtilsObjectNameEXT = null,
    vkSetDebugUtilsObjectTagEXT: ?PfnSetDebugUtilsObjectTagEXT = null,
    vkQueueBeginDebugUtilsLabelEXT: ?PfnQueueBeginDebugUtilsLabelEXT = null,
    vkQueueEndDebugUtilsLabelEXT: ?PfnQueueEndDebugUtilsLabelEXT = null,
    vkQueueInsertDebugUtilsLabelEXT: ?PfnQueueInsertDebugUtilsLabelEXT = null,
    vkCmdBeginDebugUtilsLabelEXT: ?PfnCmdBeginDebugUtilsLabelEXT = null,
    vkCmdEndDebugUtilsLabelEXT: ?PfnCmdEndDebugUtilsLabelEXT = null,
    vkCmdInsertDebugUtilsLabelEXT: ?PfnCmdInsertDebugUtilsLabelEXT = null,
    vkGetMemoryHostPointerPropertiesEXT: ?PfnGetMemoryHostPointerPropertiesEXT = null,
    vkCmdWriteBufferMarkerAMD: ?PfnCmdWriteBufferMarkerAMD = null,
    vkCreateRenderPass2: ?PfnCreateRenderPass2 = null,
    vkCreateRenderPass2KHR: ?PfnCreateRenderPass2KHR = null,
    vkCmdBeginRenderPass2: ?PfnCmdBeginRenderPass2 = null,
    vkCmdBeginRenderPass2KHR: ?PfnCmdBeginRenderPass2KHR = null,
    vkCmdNextSubpass2: ?PfnCmdNextSubpass2 = null,
    vkCmdNextSubpass2KHR: ?PfnCmdNextSubpass2KHR = null,
    vkCmdEndRenderPass2: ?PfnCmdEndRenderPass2 = null,
    vkCmdEndRenderPass2KHR: ?PfnCmdEndRenderPass2KHR = null,
    vkGetSemaphoreCounterValue: ?PfnGetSemaphoreCounterValue = null,
    vkGetSemaphoreCounterValueKHR: ?PfnGetSemaphoreCounterValueKHR = null,
    vkWaitSemaphores: ?PfnWaitSemaphores = null,
    vkWaitSemaphoresKHR: ?PfnWaitSemaphoresKHR = null,
    vkSignalSemaphore: ?PfnSignalSemaphore = null,
    vkSignalSemaphoreKHR: ?PfnSignalSemaphoreKHR = null,
    vkGetAndroidHardwareBufferPropertiesANDROID: ?PfnGetAndroidHardwareBufferPropertiesANDROID = null,
    vkGetMemoryAndroidHardwareBufferANDROID: ?PfnGetMemoryAndroidHardwareBufferANDROID = null,
    vkCmdDrawIndirectCount: ?PfnCmdDrawIndirectCount = null,
    vkCmdDrawIndirectCountKHR: ?PfnCmdDrawIndirectCountKHR = null,
    vkCmdDrawIndirectCountAMD: ?PfnCmdDrawIndirectCountAMD = null,
    vkCmdDrawIndexedIndirectCount: ?PfnCmdDrawIndexedIndirectCount = null,
    vkCmdDrawIndexedIndirectCountKHR: ?PfnCmdDrawIndexedIndirectCountKHR = null,
    vkCmdDrawIndexedIndirectCountAMD: ?PfnCmdDrawIndexedIndirectCountAMD = null,
    vkCmdSetCheckpointNV: ?PfnCmdSetCheckpointNV = null,
    vkGetQueueCheckpointDataNV: ?PfnGetQueueCheckpointDataNV = null,
    vkCmdBindTransformFeedbackBuffersEXT: ?PfnCmdBindTransformFeedbackBuffersEXT = null,
    vkCmdBeginTransformFeedbackEXT: ?PfnCmdBeginTransformFeedbackEXT = null,
    vkCmdEndTransformFeedbackEXT: ?PfnCmdEndTransformFeedbackEXT = null,
    vkCmdBeginQueryIndexedEXT: ?PfnCmdBeginQueryIndexedEXT = null,
    vkCmdEndQueryIndexedEXT: ?PfnCmdEndQueryIndexedEXT = null,
    vkCmdDrawIndirectByteCountEXT: ?PfnCmdDrawIndirectByteCountEXT = null,
    vkCmdSetExclusiveScissorNV: ?PfnCmdSetExclusiveScissorNV = null,
    vkCmdSetExclusiveScissorEnableNV: ?PfnCmdSetExclusiveScissorEnableNV = null,
    vkCmdBindShadingRateImageNV: ?PfnCmdBindShadingRateImageNV = null,
    vkCmdSetViewportShadingRatePaletteNV: ?PfnCmdSetViewportShadingRatePaletteNV = null,
    vkCmdSetCoarseSampleOrderNV: ?PfnCmdSetCoarseSampleOrderNV = null,
    vkCmdDrawMeshTasksNV: ?PfnCmdDrawMeshTasksNV = null,
    vkCmdDrawMeshTasksIndirectNV: ?PfnCmdDrawMeshTasksIndirectNV = null,
    vkCmdDrawMeshTasksIndirectCountNV: ?PfnCmdDrawMeshTasksIndirectCountNV = null,
    vkCmdDrawMeshTasksEXT: ?PfnCmdDrawMeshTasksEXT = null,
    vkCmdDrawMeshTasksIndirectEXT: ?PfnCmdDrawMeshTasksIndirectEXT = null,
    vkCmdDrawMeshTasksIndirectCountEXT: ?PfnCmdDrawMeshTasksIndirectCountEXT = null,
    vkCompileDeferredNV: ?PfnCompileDeferredNV = null,
    vkCreateAccelerationStructureNV: ?PfnCreateAccelerationStructureNV = null,
    vkCmdBindInvocationMaskHUAWEI: ?PfnCmdBindInvocationMaskHUAWEI = null,
    vkDestroyAccelerationStructureKHR: ?PfnDestroyAccelerationStructureKHR = null,
    vkDestroyAccelerationStructureNV: ?PfnDestroyAccelerationStructureNV = null,
    vkGetAccelerationStructureMemoryRequirementsNV: ?PfnGetAccelerationStructureMemoryRequirementsNV = null,
    vkBindAccelerationStructureMemoryNV: ?PfnBindAccelerationStructureMemoryNV = null,
    vkCmdCopyAccelerationStructureNV: ?PfnCmdCopyAccelerationStructureNV = null,
    vkCmdCopyAccelerationStructureKHR: ?PfnCmdCopyAccelerationStructureKHR = null,
    vkCopyAccelerationStructureKHR: ?PfnCopyAccelerationStructureKHR = null,
    vkCmdCopyAccelerationStructureToMemoryKHR: ?PfnCmdCopyAccelerationStructureToMemoryKHR = null,
    vkCopyAccelerationStructureToMemoryKHR: ?PfnCopyAccelerationStructureToMemoryKHR = null,
    vkCmdCopyMemoryToAccelerationStructureKHR: ?PfnCmdCopyMemoryToAccelerationStructureKHR = null,
    vkCopyMemoryToAccelerationStructureKHR: ?PfnCopyMemoryToAccelerationStructureKHR = null,
    vkCmdWriteAccelerationStructuresPropertiesKHR: ?PfnCmdWriteAccelerationStructuresPropertiesKHR = null,
    vkCmdWriteAccelerationStructuresPropertiesNV: ?PfnCmdWriteAccelerationStructuresPropertiesNV = null,
    vkCmdBuildAccelerationStructureNV: ?PfnCmdBuildAccelerationStructureNV = null,
    vkWriteAccelerationStructuresPropertiesKHR: ?PfnWriteAccelerationStructuresPropertiesKHR = null,
    vkCmdTraceRaysKHR: ?PfnCmdTraceRaysKHR = null,
    vkCmdTraceRaysNV: ?PfnCmdTraceRaysNV = null,
    vkGetRayTracingShaderGroupHandlesKHR: ?PfnGetRayTracingShaderGroupHandlesKHR = null,
    vkGetRayTracingShaderGroupHandlesNV: ?PfnGetRayTracingShaderGroupHandlesNV = null,
    vkGetRayTracingCaptureReplayShaderGroupHandlesKHR: ?PfnGetRayTracingCaptureReplayShaderGroupHandlesKHR = null,
    vkGetAccelerationStructureHandleNV: ?PfnGetAccelerationStructureHandleNV = null,
    vkCreateRayTracingPipelinesNV: ?PfnCreateRayTracingPipelinesNV = null,
    vkCreateRayTracingPipelinesKHR: ?PfnCreateRayTracingPipelinesKHR = null,
    vkCmdTraceRaysIndirectKHR: ?PfnCmdTraceRaysIndirectKHR = null,
    vkCmdTraceRaysIndirect2KHR: ?PfnCmdTraceRaysIndirect2KHR = null,
    vkGetClusterAccelerationStructureBuildSizesNV: ?PfnGetClusterAccelerationStructureBuildSizesNV = null,
    vkCmdBuildClusterAccelerationStructureIndirectNV: ?PfnCmdBuildClusterAccelerationStructureIndirectNV = null,
    vkGetDeviceAccelerationStructureCompatibilityKHR: ?PfnGetDeviceAccelerationStructureCompatibilityKHR = null,
    vkGetRayTracingShaderGroupStackSizeKHR: ?PfnGetRayTracingShaderGroupStackSizeKHR = null,
    vkCmdSetRayTracingPipelineStackSizeKHR: ?PfnCmdSetRayTracingPipelineStackSizeKHR = null,
    vkGetImageViewHandleNVX: ?PfnGetImageViewHandleNVX = null,
    vkGetImageViewHandle64NVX: ?PfnGetImageViewHandle64NVX = null,
    vkGetImageViewAddressNVX: ?PfnGetImageViewAddressNVX = null,
    vkGetDeviceGroupSurfacePresentModes2EXT: ?PfnGetDeviceGroupSurfacePresentModes2EXT = null,
    vkAcquireFullScreenExclusiveModeEXT: ?PfnAcquireFullScreenExclusiveModeEXT = null,
    vkReleaseFullScreenExclusiveModeEXT: ?PfnReleaseFullScreenExclusiveModeEXT = null,
    vkAcquireProfilingLockKHR: ?PfnAcquireProfilingLockKHR = null,
    vkReleaseProfilingLockKHR: ?PfnReleaseProfilingLockKHR = null,
    vkGetImageDrmFormatModifierPropertiesEXT: ?PfnGetImageDrmFormatModifierPropertiesEXT = null,
    vkGetBufferOpaqueCaptureAddress: ?PfnGetBufferOpaqueCaptureAddress = null,
    vkGetBufferOpaqueCaptureAddressKHR: ?PfnGetBufferOpaqueCaptureAddressKHR = null,
    vkGetBufferDeviceAddress: ?PfnGetBufferDeviceAddress = null,
    vkGetBufferDeviceAddressKHR: ?PfnGetBufferDeviceAddressKHR = null,
    vkGetBufferDeviceAddressEXT: ?PfnGetBufferDeviceAddressEXT = null,
    vkInitializePerformanceApiINTEL: ?PfnInitializePerformanceApiINTEL = null,
    vkUninitializePerformanceApiINTEL: ?PfnUninitializePerformanceApiINTEL = null,
    vkCmdSetPerformanceMarkerINTEL: ?PfnCmdSetPerformanceMarkerINTEL = null,
    vkCmdSetPerformanceStreamMarkerINTEL: ?PfnCmdSetPerformanceStreamMarkerINTEL = null,
    vkCmdSetPerformanceOverrideINTEL: ?PfnCmdSetPerformanceOverrideINTEL = null,
    vkAcquirePerformanceConfigurationINTEL: ?PfnAcquirePerformanceConfigurationINTEL = null,
    vkReleasePerformanceConfigurationINTEL: ?PfnReleasePerformanceConfigurationINTEL = null,
    vkQueueSetPerformanceConfigurationINTEL: ?PfnQueueSetPerformanceConfigurationINTEL = null,
    vkGetPerformanceParameterINTEL: ?PfnGetPerformanceParameterINTEL = null,
    vkGetDeviceMemoryOpaqueCaptureAddress: ?PfnGetDeviceMemoryOpaqueCaptureAddress = null,
    vkGetDeviceMemoryOpaqueCaptureAddressKHR: ?PfnGetDeviceMemoryOpaqueCaptureAddressKHR = null,
    vkGetPipelineExecutablePropertiesKHR: ?PfnGetPipelineExecutablePropertiesKHR = null,
    vkGetPipelineExecutableStatisticsKHR: ?PfnGetPipelineExecutableStatisticsKHR = null,
    vkGetPipelineExecutableInternalRepresentationsKHR: ?PfnGetPipelineExecutableInternalRepresentationsKHR = null,
    vkCmdSetLineStipple: ?PfnCmdSetLineStipple = null,
    vkCmdSetLineStippleKHR: ?PfnCmdSetLineStippleKHR = null,
    vkCmdSetLineStippleEXT: ?PfnCmdSetLineStippleEXT = null,
    vkGetFaultData: ?PfnGetFaultData = null,
    vkCreateAccelerationStructureKHR: ?PfnCreateAccelerationStructureKHR = null,
    vkCmdBuildAccelerationStructuresKHR: ?PfnCmdBuildAccelerationStructuresKHR = null,
    vkCmdBuildAccelerationStructuresIndirectKHR: ?PfnCmdBuildAccelerationStructuresIndirectKHR = null,
    vkBuildAccelerationStructuresKHR: ?PfnBuildAccelerationStructuresKHR = null,
    vkGetAccelerationStructureDeviceAddressKHR: ?PfnGetAccelerationStructureDeviceAddressKHR = null,
    vkCreateDeferredOperationKHR: ?PfnCreateDeferredOperationKHR = null,
    vkDestroyDeferredOperationKHR: ?PfnDestroyDeferredOperationKHR = null,
    vkGetDeferredOperationMaxConcurrencyKHR: ?PfnGetDeferredOperationMaxConcurrencyKHR = null,
    vkGetDeferredOperationResultKHR: ?PfnGetDeferredOperationResultKHR = null,
    vkDeferredOperationJoinKHR: ?PfnDeferredOperationJoinKHR = null,
    vkGetPipelineIndirectMemoryRequirementsNV: ?PfnGetPipelineIndirectMemoryRequirementsNV = null,
    vkGetPipelineIndirectDeviceAddressNV: ?PfnGetPipelineIndirectDeviceAddressNV = null,
    vkAntiLagUpdateAMD: ?PfnAntiLagUpdateAMD = null,
    vkCmdSetCullMode: ?PfnCmdSetCullMode = null,
    vkCmdSetCullModeEXT: ?PfnCmdSetCullModeEXT = null,
    vkCmdSetFrontFace: ?PfnCmdSetFrontFace = null,
    vkCmdSetFrontFaceEXT: ?PfnCmdSetFrontFaceEXT = null,
    vkCmdSetPrimitiveTopology: ?PfnCmdSetPrimitiveTopology = null,
    vkCmdSetPrimitiveTopologyEXT: ?PfnCmdSetPrimitiveTopologyEXT = null,
    vkCmdSetViewportWithCount: ?PfnCmdSetViewportWithCount = null,
    vkCmdSetViewportWithCountEXT: ?PfnCmdSetViewportWithCountEXT = null,
    vkCmdSetScissorWithCount: ?PfnCmdSetScissorWithCount = null,
    vkCmdSetScissorWithCountEXT: ?PfnCmdSetScissorWithCountEXT = null,
    vkCmdBindIndexBuffer2: ?PfnCmdBindIndexBuffer2 = null,
    vkCmdBindIndexBuffer2KHR: ?PfnCmdBindIndexBuffer2KHR = null,
    vkCmdBindVertexBuffers2: ?PfnCmdBindVertexBuffers2 = null,
    vkCmdBindVertexBuffers2EXT: ?PfnCmdBindVertexBuffers2EXT = null,
    vkCmdSetDepthTestEnable: ?PfnCmdSetDepthTestEnable = null,
    vkCmdSetDepthTestEnableEXT: ?PfnCmdSetDepthTestEnableEXT = null,
    vkCmdSetDepthWriteEnable: ?PfnCmdSetDepthWriteEnable = null,
    vkCmdSetDepthWriteEnableEXT: ?PfnCmdSetDepthWriteEnableEXT = null,
    vkCmdSetDepthCompareOp: ?PfnCmdSetDepthCompareOp = null,
    vkCmdSetDepthCompareOpEXT: ?PfnCmdSetDepthCompareOpEXT = null,
    vkCmdSetDepthBoundsTestEnable: ?PfnCmdSetDepthBoundsTestEnable = null,
    vkCmdSetDepthBoundsTestEnableEXT: ?PfnCmdSetDepthBoundsTestEnableEXT = null,
    vkCmdSetStencilTestEnable: ?PfnCmdSetStencilTestEnable = null,
    vkCmdSetStencilTestEnableEXT: ?PfnCmdSetStencilTestEnableEXT = null,
    vkCmdSetStencilOp: ?PfnCmdSetStencilOp = null,
    vkCmdSetStencilOpEXT: ?PfnCmdSetStencilOpEXT = null,
    vkCmdSetPatchControlPointsEXT: ?PfnCmdSetPatchControlPointsEXT = null,
    vkCmdSetRasterizerDiscardEnable: ?PfnCmdSetRasterizerDiscardEnable = null,
    vkCmdSetRasterizerDiscardEnableEXT: ?PfnCmdSetRasterizerDiscardEnableEXT = null,
    vkCmdSetDepthBiasEnable: ?PfnCmdSetDepthBiasEnable = null,
    vkCmdSetDepthBiasEnableEXT: ?PfnCmdSetDepthBiasEnableEXT = null,
    vkCmdSetLogicOpEXT: ?PfnCmdSetLogicOpEXT = null,
    vkCmdSetPrimitiveRestartEnable: ?PfnCmdSetPrimitiveRestartEnable = null,
    vkCmdSetPrimitiveRestartEnableEXT: ?PfnCmdSetPrimitiveRestartEnableEXT = null,
    vkCmdSetTessellationDomainOriginEXT: ?PfnCmdSetTessellationDomainOriginEXT = null,
    vkCmdSetDepthClampEnableEXT: ?PfnCmdSetDepthClampEnableEXT = null,
    vkCmdSetPolygonModeEXT: ?PfnCmdSetPolygonModeEXT = null,
    vkCmdSetRasterizationSamplesEXT: ?PfnCmdSetRasterizationSamplesEXT = null,
    vkCmdSetSampleMaskEXT: ?PfnCmdSetSampleMaskEXT = null,
    vkCmdSetAlphaToCoverageEnableEXT: ?PfnCmdSetAlphaToCoverageEnableEXT = null,
    vkCmdSetAlphaToOneEnableEXT: ?PfnCmdSetAlphaToOneEnableEXT = null,
    vkCmdSetLogicOpEnableEXT: ?PfnCmdSetLogicOpEnableEXT = null,
    vkCmdSetColorBlendEnableEXT: ?PfnCmdSetColorBlendEnableEXT = null,
    vkCmdSetColorBlendEquationEXT: ?PfnCmdSetColorBlendEquationEXT = null,
    vkCmdSetColorWriteMaskEXT: ?PfnCmdSetColorWriteMaskEXT = null,
    vkCmdSetRasterizationStreamEXT: ?PfnCmdSetRasterizationStreamEXT = null,
    vkCmdSetConservativeRasterizationModeEXT: ?PfnCmdSetConservativeRasterizationModeEXT = null,
    vkCmdSetExtraPrimitiveOverestimationSizeEXT: ?PfnCmdSetExtraPrimitiveOverestimationSizeEXT = null,
    vkCmdSetDepthClipEnableEXT: ?PfnCmdSetDepthClipEnableEXT = null,
    vkCmdSetSampleLocationsEnableEXT: ?PfnCmdSetSampleLocationsEnableEXT = null,
    vkCmdSetColorBlendAdvancedEXT: ?PfnCmdSetColorBlendAdvancedEXT = null,
    vkCmdSetProvokingVertexModeEXT: ?PfnCmdSetProvokingVertexModeEXT = null,
    vkCmdSetLineRasterizationModeEXT: ?PfnCmdSetLineRasterizationModeEXT = null,
    vkCmdSetLineStippleEnableEXT: ?PfnCmdSetLineStippleEnableEXT = null,
    vkCmdSetDepthClipNegativeOneToOneEXT: ?PfnCmdSetDepthClipNegativeOneToOneEXT = null,
    vkCmdSetViewportWScalingEnableNV: ?PfnCmdSetViewportWScalingEnableNV = null,
    vkCmdSetViewportSwizzleNV: ?PfnCmdSetViewportSwizzleNV = null,
    vkCmdSetCoverageToColorEnableNV: ?PfnCmdSetCoverageToColorEnableNV = null,
    vkCmdSetCoverageToColorLocationNV: ?PfnCmdSetCoverageToColorLocationNV = null,
    vkCmdSetCoverageModulationModeNV: ?PfnCmdSetCoverageModulationModeNV = null,
    vkCmdSetCoverageModulationTableEnableNV: ?PfnCmdSetCoverageModulationTableEnableNV = null,
    vkCmdSetCoverageModulationTableNV: ?PfnCmdSetCoverageModulationTableNV = null,
    vkCmdSetShadingRateImageEnableNV: ?PfnCmdSetShadingRateImageEnableNV = null,
    vkCmdSetCoverageReductionModeNV: ?PfnCmdSetCoverageReductionModeNV = null,
    vkCmdSetRepresentativeFragmentTestEnableNV: ?PfnCmdSetRepresentativeFragmentTestEnableNV = null,
    vkCreatePrivateDataSlot: ?PfnCreatePrivateDataSlot = null,
    vkCreatePrivateDataSlotEXT: ?PfnCreatePrivateDataSlotEXT = null,
    vkDestroyPrivateDataSlot: ?PfnDestroyPrivateDataSlot = null,
    vkDestroyPrivateDataSlotEXT: ?PfnDestroyPrivateDataSlotEXT = null,
    vkSetPrivateData: ?PfnSetPrivateData = null,
    vkSetPrivateDataEXT: ?PfnSetPrivateDataEXT = null,
    vkGetPrivateData: ?PfnGetPrivateData = null,
    vkGetPrivateDataEXT: ?PfnGetPrivateDataEXT = null,
    vkCmdCopyBuffer2: ?PfnCmdCopyBuffer2 = null,
    vkCmdCopyBuffer2KHR: ?PfnCmdCopyBuffer2KHR = null,
    vkCmdCopyImage2: ?PfnCmdCopyImage2 = null,
    vkCmdCopyImage2KHR: ?PfnCmdCopyImage2KHR = null,
    vkCmdBlitImage2: ?PfnCmdBlitImage2 = null,
    vkCmdBlitImage2KHR: ?PfnCmdBlitImage2KHR = null,
    vkCmdCopyBufferToImage2: ?PfnCmdCopyBufferToImage2 = null,
    vkCmdCopyBufferToImage2KHR: ?PfnCmdCopyBufferToImage2KHR = null,
    vkCmdCopyImageToBuffer2: ?PfnCmdCopyImageToBuffer2 = null,
    vkCmdCopyImageToBuffer2KHR: ?PfnCmdCopyImageToBuffer2KHR = null,
    vkCmdResolveImage2: ?PfnCmdResolveImage2 = null,
    vkCmdResolveImage2KHR: ?PfnCmdResolveImage2KHR = null,
    vkCmdRefreshObjectsKHR: ?PfnCmdRefreshObjectsKHR = null,
    vkCmdSetFragmentShadingRateKHR: ?PfnCmdSetFragmentShadingRateKHR = null,
    vkCmdSetFragmentShadingRateEnumNV: ?PfnCmdSetFragmentShadingRateEnumNV = null,
    vkGetAccelerationStructureBuildSizesKHR: ?PfnGetAccelerationStructureBuildSizesKHR = null,
    vkCmdSetVertexInputEXT: ?PfnCmdSetVertexInputEXT = null,
    vkCmdSetColorWriteEnableEXT: ?PfnCmdSetColorWriteEnableEXT = null,
    vkCmdSetEvent2: ?PfnCmdSetEvent2 = null,
    vkCmdSetEvent2KHR: ?PfnCmdSetEvent2KHR = null,
    vkCmdResetEvent2: ?PfnCmdResetEvent2 = null,
    vkCmdResetEvent2KHR: ?PfnCmdResetEvent2KHR = null,
    vkCmdWaitEvents2: ?PfnCmdWaitEvents2 = null,
    vkCmdWaitEvents2KHR: ?PfnCmdWaitEvents2KHR = null,
    vkCmdPipelineBarrier2: ?PfnCmdPipelineBarrier2 = null,
    vkCmdPipelineBarrier2KHR: ?PfnCmdPipelineBarrier2KHR = null,
    vkQueueSubmit2: ?PfnQueueSubmit2 = null,
    vkQueueSubmit2KHR: ?PfnQueueSubmit2KHR = null,
    vkCmdWriteTimestamp2: ?PfnCmdWriteTimestamp2 = null,
    vkCmdWriteTimestamp2KHR: ?PfnCmdWriteTimestamp2KHR = null,
    vkCmdWriteBufferMarker2AMD: ?PfnCmdWriteBufferMarker2AMD = null,
    vkGetQueueCheckpointData2NV: ?PfnGetQueueCheckpointData2NV = null,
    vkCopyMemoryToImage: ?PfnCopyMemoryToImage = null,
    vkCopyMemoryToImageEXT: ?PfnCopyMemoryToImageEXT = null,
    vkCopyImageToMemory: ?PfnCopyImageToMemory = null,
    vkCopyImageToMemoryEXT: ?PfnCopyImageToMemoryEXT = null,
    vkCopyImageToImage: ?PfnCopyImageToImage = null,
    vkCopyImageToImageEXT: ?PfnCopyImageToImageEXT = null,
    vkTransitionImageLayout: ?PfnTransitionImageLayout = null,
    vkTransitionImageLayoutEXT: ?PfnTransitionImageLayoutEXT = null,
    vkGetCommandPoolMemoryConsumption: ?PfnGetCommandPoolMemoryConsumption = null,
    vkCreateVideoSessionKHR: ?PfnCreateVideoSessionKHR = null,
    vkDestroyVideoSessionKHR: ?PfnDestroyVideoSessionKHR = null,
    vkCreateVideoSessionParametersKHR: ?PfnCreateVideoSessionParametersKHR = null,
    vkUpdateVideoSessionParametersKHR: ?PfnUpdateVideoSessionParametersKHR = null,
    vkGetEncodedVideoSessionParametersKHR: ?PfnGetEncodedVideoSessionParametersKHR = null,
    vkDestroyVideoSessionParametersKHR: ?PfnDestroyVideoSessionParametersKHR = null,
    vkGetVideoSessionMemoryRequirementsKHR: ?PfnGetVideoSessionMemoryRequirementsKHR = null,
    vkBindVideoSessionMemoryKHR: ?PfnBindVideoSessionMemoryKHR = null,
    vkCmdDecodeVideoKHR: ?PfnCmdDecodeVideoKHR = null,
    vkCmdBeginVideoCodingKHR: ?PfnCmdBeginVideoCodingKHR = null,
    vkCmdControlVideoCodingKHR: ?PfnCmdControlVideoCodingKHR = null,
    vkCmdEndVideoCodingKHR: ?PfnCmdEndVideoCodingKHR = null,
    vkCmdEncodeVideoKHR: ?PfnCmdEncodeVideoKHR = null,
    vkCmdDecompressMemoryNV: ?PfnCmdDecompressMemoryNV = null,
    vkCmdDecompressMemoryIndirectCountNV: ?PfnCmdDecompressMemoryIndirectCountNV = null,
    vkGetPartitionedAccelerationStructuresBuildSizesNV: ?PfnGetPartitionedAccelerationStructuresBuildSizesNV = null,
    vkCmdBuildPartitionedAccelerationStructuresNV: ?PfnCmdBuildPartitionedAccelerationStructuresNV = null,
    vkCreateCuModuleNVX: ?PfnCreateCuModuleNVX = null,
    vkCreateCuFunctionNVX: ?PfnCreateCuFunctionNVX = null,
    vkDestroyCuModuleNVX: ?PfnDestroyCuModuleNVX = null,
    vkDestroyCuFunctionNVX: ?PfnDestroyCuFunctionNVX = null,
    vkCmdCuLaunchKernelNVX: ?PfnCmdCuLaunchKernelNVX = null,
    vkGetDescriptorSetLayoutSizeEXT: ?PfnGetDescriptorSetLayoutSizeEXT = null,
    vkGetDescriptorSetLayoutBindingOffsetEXT: ?PfnGetDescriptorSetLayoutBindingOffsetEXT = null,
    vkGetDescriptorEXT: ?PfnGetDescriptorEXT = null,
    vkCmdBindDescriptorBuffersEXT: ?PfnCmdBindDescriptorBuffersEXT = null,
    vkCmdSetDescriptorBufferOffsetsEXT: ?PfnCmdSetDescriptorBufferOffsetsEXT = null,
    vkCmdBindDescriptorBufferEmbeddedSamplersEXT: ?PfnCmdBindDescriptorBufferEmbeddedSamplersEXT = null,
    vkGetBufferOpaqueCaptureDescriptorDataEXT: ?PfnGetBufferOpaqueCaptureDescriptorDataEXT = null,
    vkGetImageOpaqueCaptureDescriptorDataEXT: ?PfnGetImageOpaqueCaptureDescriptorDataEXT = null,
    vkGetImageViewOpaqueCaptureDescriptorDataEXT: ?PfnGetImageViewOpaqueCaptureDescriptorDataEXT = null,
    vkGetSamplerOpaqueCaptureDescriptorDataEXT: ?PfnGetSamplerOpaqueCaptureDescriptorDataEXT = null,
    vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT: ?PfnGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = null,
    vkSetDeviceMemoryPriorityEXT: ?PfnSetDeviceMemoryPriorityEXT = null,
    vkWaitForPresent2KHR: ?PfnWaitForPresent2KHR = null,
    vkWaitForPresentKHR: ?PfnWaitForPresentKHR = null,
    vkCreateBufferCollectionFUCHSIA: ?PfnCreateBufferCollectionFUCHSIA = null,
    vkSetBufferCollectionBufferConstraintsFUCHSIA: ?PfnSetBufferCollectionBufferConstraintsFUCHSIA = null,
    vkSetBufferCollectionImageConstraintsFUCHSIA: ?PfnSetBufferCollectionImageConstraintsFUCHSIA = null,
    vkDestroyBufferCollectionFUCHSIA: ?PfnDestroyBufferCollectionFUCHSIA = null,
    vkGetBufferCollectionPropertiesFUCHSIA: ?PfnGetBufferCollectionPropertiesFUCHSIA = null,
    vkCreateCudaModuleNV: ?PfnCreateCudaModuleNV = null,
    vkGetCudaModuleCacheNV: ?PfnGetCudaModuleCacheNV = null,
    vkCreateCudaFunctionNV: ?PfnCreateCudaFunctionNV = null,
    vkDestroyCudaModuleNV: ?PfnDestroyCudaModuleNV = null,
    vkDestroyCudaFunctionNV: ?PfnDestroyCudaFunctionNV = null,
    vkCmdCudaLaunchKernelNV: ?PfnCmdCudaLaunchKernelNV = null,
    vkCmdBeginRendering: ?PfnCmdBeginRendering = null,
    vkCmdBeginRenderingKHR: ?PfnCmdBeginRenderingKHR = null,
    vkCmdEndRendering: ?PfnCmdEndRendering = null,
    vkCmdEndRendering2EXT: ?PfnCmdEndRendering2EXT = null,
    vkCmdEndRenderingKHR: ?PfnCmdEndRenderingKHR = null,
    vkGetDescriptorSetLayoutHostMappingInfoVALVE: ?PfnGetDescriptorSetLayoutHostMappingInfoVALVE = null,
    vkGetDescriptorSetHostMappingVALVE: ?PfnGetDescriptorSetHostMappingVALVE = null,
    vkCreateMicromapEXT: ?PfnCreateMicromapEXT = null,
    vkCmdBuildMicromapsEXT: ?PfnCmdBuildMicromapsEXT = null,
    vkBuildMicromapsEXT: ?PfnBuildMicromapsEXT = null,
    vkDestroyMicromapEXT: ?PfnDestroyMicromapEXT = null,
    vkCmdCopyMicromapEXT: ?PfnCmdCopyMicromapEXT = null,
    vkCopyMicromapEXT: ?PfnCopyMicromapEXT = null,
    vkCmdCopyMicromapToMemoryEXT: ?PfnCmdCopyMicromapToMemoryEXT = null,
    vkCopyMicromapToMemoryEXT: ?PfnCopyMicromapToMemoryEXT = null,
    vkCmdCopyMemoryToMicromapEXT: ?PfnCmdCopyMemoryToMicromapEXT = null,
    vkCopyMemoryToMicromapEXT: ?PfnCopyMemoryToMicromapEXT = null,
    vkCmdWriteMicromapsPropertiesEXT: ?PfnCmdWriteMicromapsPropertiesEXT = null,
    vkWriteMicromapsPropertiesEXT: ?PfnWriteMicromapsPropertiesEXT = null,
    vkGetDeviceMicromapCompatibilityEXT: ?PfnGetDeviceMicromapCompatibilityEXT = null,
    vkGetMicromapBuildSizesEXT: ?PfnGetMicromapBuildSizesEXT = null,
    vkGetShaderModuleIdentifierEXT: ?PfnGetShaderModuleIdentifierEXT = null,
    vkGetShaderModuleCreateInfoIdentifierEXT: ?PfnGetShaderModuleCreateInfoIdentifierEXT = null,
    vkGetImageSubresourceLayout2: ?PfnGetImageSubresourceLayout2 = null,
    vkGetImageSubresourceLayout2KHR: ?PfnGetImageSubresourceLayout2KHR = null,
    vkGetImageSubresourceLayout2EXT: ?PfnGetImageSubresourceLayout2EXT = null,
    vkGetPipelinePropertiesEXT: ?PfnGetPipelinePropertiesEXT = null,
    vkExportMetalObjectsEXT: ?PfnExportMetalObjectsEXT = null,
    vkCmdBindTileMemoryQCOM: ?PfnCmdBindTileMemoryQCOM = null,
    vkGetFramebufferTilePropertiesQCOM: ?PfnGetFramebufferTilePropertiesQCOM = null,
    vkGetDynamicRenderingTilePropertiesQCOM: ?PfnGetDynamicRenderingTilePropertiesQCOM = null,
    vkCreateOpticalFlowSessionNV: ?PfnCreateOpticalFlowSessionNV = null,
    vkDestroyOpticalFlowSessionNV: ?PfnDestroyOpticalFlowSessionNV = null,
    vkBindOpticalFlowSessionImageNV: ?PfnBindOpticalFlowSessionImageNV = null,
    vkCmdOpticalFlowExecuteNV: ?PfnCmdOpticalFlowExecuteNV = null,
    vkGetDeviceFaultInfoEXT: ?PfnGetDeviceFaultInfoEXT = null,
    vkCmdSetDepthBias2EXT: ?PfnCmdSetDepthBias2EXT = null,
    vkReleaseSwapchainImagesKHR: ?PfnReleaseSwapchainImagesKHR = null,
    vkReleaseSwapchainImagesEXT: ?PfnReleaseSwapchainImagesEXT = null,
    vkGetDeviceImageSubresourceLayout: ?PfnGetDeviceImageSubresourceLayout = null,
    vkGetDeviceImageSubresourceLayoutKHR: ?PfnGetDeviceImageSubresourceLayoutKHR = null,
    vkMapMemory2: ?PfnMapMemory2 = null,
    vkMapMemory2KHR: ?PfnMapMemory2KHR = null,
    vkUnmapMemory2: ?PfnUnmapMemory2 = null,
    vkUnmapMemory2KHR: ?PfnUnmapMemory2KHR = null,
    vkCreateShadersEXT: ?PfnCreateShadersEXT = null,
    vkDestroyShaderEXT: ?PfnDestroyShaderEXT = null,
    vkGetShaderBinaryDataEXT: ?PfnGetShaderBinaryDataEXT = null,
    vkCmdBindShadersEXT: ?PfnCmdBindShadersEXT = null,
    vkGetScreenBufferPropertiesQNX: ?PfnGetScreenBufferPropertiesQNX = null,
    vkGetExecutionGraphPipelineScratchSizeAMDX: ?PfnGetExecutionGraphPipelineScratchSizeAMDX = null,
    vkGetExecutionGraphPipelineNodeIndexAMDX: ?PfnGetExecutionGraphPipelineNodeIndexAMDX = null,
    vkCreateExecutionGraphPipelinesAMDX: ?PfnCreateExecutionGraphPipelinesAMDX = null,
    vkCmdInitializeGraphScratchMemoryAMDX: ?PfnCmdInitializeGraphScratchMemoryAMDX = null,
    vkCmdDispatchGraphAMDX: ?PfnCmdDispatchGraphAMDX = null,
    vkCmdDispatchGraphIndirectAMDX: ?PfnCmdDispatchGraphIndirectAMDX = null,
    vkCmdDispatchGraphIndirectCountAMDX: ?PfnCmdDispatchGraphIndirectCountAMDX = null,
    vkCmdBindDescriptorSets2: ?PfnCmdBindDescriptorSets2 = null,
    vkCmdBindDescriptorSets2KHR: ?PfnCmdBindDescriptorSets2KHR = null,
    vkCmdPushConstants2: ?PfnCmdPushConstants2 = null,
    vkCmdPushConstants2KHR: ?PfnCmdPushConstants2KHR = null,
    vkCmdPushDescriptorSet2: ?PfnCmdPushDescriptorSet2 = null,
    vkCmdPushDescriptorSet2KHR: ?PfnCmdPushDescriptorSet2KHR = null,
    vkCmdPushDescriptorSetWithTemplate2: ?PfnCmdPushDescriptorSetWithTemplate2 = null,
    vkCmdPushDescriptorSetWithTemplate2KHR: ?PfnCmdPushDescriptorSetWithTemplate2KHR = null,
    vkCmdSetDescriptorBufferOffsets2EXT: ?PfnCmdSetDescriptorBufferOffsets2EXT = null,
    vkCmdBindDescriptorBufferEmbeddedSamplers2EXT: ?PfnCmdBindDescriptorBufferEmbeddedSamplers2EXT = null,
    vkSetLatencySleepModeNV: ?PfnSetLatencySleepModeNV = null,
    vkLatencySleepNV: ?PfnLatencySleepNV = null,
    vkSetLatencyMarkerNV: ?PfnSetLatencyMarkerNV = null,
    vkGetLatencyTimingsNV: ?PfnGetLatencyTimingsNV = null,
    vkQueueNotifyOutOfBandNV: ?PfnQueueNotifyOutOfBandNV = null,
    vkCmdSetRenderingAttachmentLocations: ?PfnCmdSetRenderingAttachmentLocations = null,
    vkCmdSetRenderingAttachmentLocationsKHR: ?PfnCmdSetRenderingAttachmentLocationsKHR = null,
    vkCmdSetRenderingInputAttachmentIndices: ?PfnCmdSetRenderingInputAttachmentIndices = null,
    vkCmdSetRenderingInputAttachmentIndicesKHR: ?PfnCmdSetRenderingInputAttachmentIndicesKHR = null,
    vkCmdSetDepthClampRangeEXT: ?PfnCmdSetDepthClampRangeEXT = null,
    vkGetMemoryMetalHandleEXT: ?PfnGetMemoryMetalHandleEXT = null,
    vkGetMemoryMetalHandlePropertiesEXT: ?PfnGetMemoryMetalHandlePropertiesEXT = null,
    vkConvertCooperativeVectorMatrixNV: ?PfnConvertCooperativeVectorMatrixNV = null,
    vkCmdConvertCooperativeVectorMatrixNV: ?PfnCmdConvertCooperativeVectorMatrixNV = null,
    vkCmdDispatchTileQCOM: ?PfnCmdDispatchTileQCOM = null,
    vkCmdBeginPerTileExecutionQCOM: ?PfnCmdBeginPerTileExecutionQCOM = null,
    vkCmdEndPerTileExecutionQCOM: ?PfnCmdEndPerTileExecutionQCOM = null,
    vkCreateExternalComputeQueueNV: ?PfnCreateExternalComputeQueueNV = null,
    vkDestroyExternalComputeQueueNV: ?PfnDestroyExternalComputeQueueNV = null,
    vkCreateTensorARM: ?PfnCreateTensorARM = null,
    vkDestroyTensorARM: ?PfnDestroyTensorARM = null,
    vkCreateTensorViewARM: ?PfnCreateTensorViewARM = null,
    vkDestroyTensorViewARM: ?PfnDestroyTensorViewARM = null,
    vkGetTensorMemoryRequirementsARM: ?PfnGetTensorMemoryRequirementsARM = null,
    vkBindTensorMemoryARM: ?PfnBindTensorMemoryARM = null,
    vkGetDeviceTensorMemoryRequirementsARM: ?PfnGetDeviceTensorMemoryRequirementsARM = null,
    vkCmdCopyTensorARM: ?PfnCmdCopyTensorARM = null,
    vkGetTensorOpaqueCaptureDescriptorDataARM: ?PfnGetTensorOpaqueCaptureDescriptorDataARM = null,
    vkGetTensorViewOpaqueCaptureDescriptorDataARM: ?PfnGetTensorViewOpaqueCaptureDescriptorDataARM = null,
    vkCreateDataGraphPipelinesARM: ?PfnCreateDataGraphPipelinesARM = null,
    vkCreateDataGraphPipelineSessionARM: ?PfnCreateDataGraphPipelineSessionARM = null,
    vkGetDataGraphPipelineSessionBindPointRequirementsARM: ?PfnGetDataGraphPipelineSessionBindPointRequirementsARM = null,
    vkGetDataGraphPipelineSessionMemoryRequirementsARM: ?PfnGetDataGraphPipelineSessionMemoryRequirementsARM = null,
    vkBindDataGraphPipelineSessionMemoryARM: ?PfnBindDataGraphPipelineSessionMemoryARM = null,
    vkDestroyDataGraphPipelineSessionARM: ?PfnDestroyDataGraphPipelineSessionARM = null,
    vkCmdDispatchDataGraphARM: ?PfnCmdDispatchDataGraphARM = null,
    vkGetDataGraphPipelineAvailablePropertiesARM: ?PfnGetDataGraphPipelineAvailablePropertiesARM = null,
    vkGetDataGraphPipelinePropertiesARM: ?PfnGetDataGraphPipelinePropertiesARM = null,
};
pub fn CommandFlagsMixin(comptime CommandFlags: type) type {
    return struct {
        pub fn merge(lhs: CommandFlags, rhs: CommandFlags) CommandFlags {
            var result: CommandFlags = .{};
            @setEvalBranchQuota(10_000);
            inline for (@typeInfo(CommandFlags).@"struct".fields) |field| {
                @field(result, field.name) = @field(lhs, field.name) or @field(rhs, field.name);
            }
            return result;
        }
        pub fn intersect(lhs: CommandFlags, rhs: CommandFlags) CommandFlags {
            var result: CommandFlags = .{};
            @setEvalBranchQuota(10_000);
            inline for (@typeInfo(CommandFlags).@"struct".fields) |field| {
                @field(result, field.name) = @field(lhs, field.name) and @field(rhs, field.name);
            }
            return result;
        }
        pub fn complement(self: CommandFlags) CommandFlags {
            var result: CommandFlags = .{};
            @setEvalBranchQuota(10_000);
            inline for (@typeInfo(CommandFlags).@"struct".fields) |field| {
                @field(result, field.name) = !@field(self, field.name);
            }
            return result;
        }
        pub fn subtract(lhs: CommandFlags, rhs: CommandFlags) CommandFlags {
            var result: CommandFlags = .{};
            @setEvalBranchQuota(10_000);
            inline for (@typeInfo(CommandFlags).@"struct".fields) |field| {
                @field(result, field.name) = @field(lhs, field.name) and !@field(rhs, field.name);
            }
            return result;
        }
        pub fn contains(lhs: CommandFlags, rhs: CommandFlags) bool {
            @setEvalBranchQuota(10_000);
            inline for (@typeInfo(CommandFlags).@"struct".fields) |field| {
                if (!@field(lhs, field.name) and @field(rhs, field.name)) {
                    return false;
                }
            }
            return true;
        }
    };
}
var base_dispatch: BaseDispatch = undefined;
var base_wrapper: BaseWrapper = .{};
const BaseWrapper = BaseWrapperWithCustomDispatch(BaseDispatch);
fn BaseWrapperWithCustomDispatch(DispatchType: type) type {
    return struct {
        const Self = @This();
        pub const Dispatch = DispatchType;

        dispatch: *BaseDispatch = &base_dispatch,
        pub fn load(self: *Self, loader: anytype) void {
            inline for (std.meta.fields(Dispatch)) |field| {
                const cmd_ptr = loader(Instance.null_handle, field.name.ptr) orelse undefined;
                @field(self.dispatch, field.name) = @ptrCast(cmd_ptr);
            }
        }
    };
}
pub const CreateInstanceError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InitializationFailed,
    LayerNotPresent,
    ExtensionNotPresent,
    IncompatibleDriver,
    Unknown,
};
pub fn createInstance(
    p_create_info: *const InstanceCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateInstanceError!Instance {
    var out_instance: Instance = undefined;
    const result = base_dispatch.vkCreateInstance.?(
        p_create_info,
        p_allocator,
        &out_instance,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_layer_not_present => return error.LayerNotPresent,
        Result.error_extension_not_present => return error.ExtensionNotPresent,
        Result.error_incompatible_driver => return error.IncompatibleDriver,
        else => return error.Unknown,
    }
    instance_wrapper.load(out_instance, getInstanceProcAddr);
    return out_instance;
}
pub fn getInstanceProcAddr(
    instance: Instance,
    p_name: [*:0]const u8,
) PfnVoidFunction {
    return base_dispatch.vkGetInstanceProcAddr.?(
        instance,
        p_name,
    );
}
pub const EnumerateInstanceVersionError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn enumerateInstanceVersion() EnumerateInstanceVersionError!u32 {
    var out_api_version: u32 = undefined;
    const result = base_dispatch.vkEnumerateInstanceVersion.?(
        &out_api_version,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_api_version;
}
pub const EnumerateInstanceLayerPropertiesError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn enumerateInstanceLayerProperties(
    p_property_count: *u32,
    p_properties: ?[*]LayerProperties,
) EnumerateInstanceLayerPropertiesError!Result {
    const result = base_dispatch.vkEnumerateInstanceLayerProperties.?(
        p_property_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const EnumerateInstanceLayerPropertiesAllocError =
    EnumerateInstanceLayerPropertiesError || Allocator.Error;
pub fn enumerateInstanceLayerPropertiesAlloc(
    allocator: Allocator,
) EnumerateInstanceLayerPropertiesAllocError![]LayerProperties {
    var count: u32 = undefined;
    var data: []LayerProperties = &.{};
    errdefer allocator.free(data);
    var result = Result.incomplete;
    while (result == .incomplete) {
        _ = try enumerateInstanceLayerProperties(&count, null);
        data = try allocator.realloc(data, count);
        result = try enumerateInstanceLayerProperties(&count, data.ptr);
    }
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub const EnumerateInstanceExtensionPropertiesError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    LayerNotPresent,
    Unknown,
};
pub fn enumerateInstanceExtensionProperties(
    p_layer_name: ?[*:0]const u8,
    p_property_count: *u32,
    p_properties: ?[*]ExtensionProperties,
) EnumerateInstanceExtensionPropertiesError!Result {
    const result = base_dispatch.vkEnumerateInstanceExtensionProperties.?(
        p_layer_name,
        p_property_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_layer_not_present => return error.LayerNotPresent,
        else => return error.Unknown,
    }
    return result;
}
pub const EnumerateInstanceExtensionPropertiesAllocError =
    EnumerateInstanceExtensionPropertiesError || Allocator.Error;
pub fn enumerateInstanceExtensionPropertiesAlloc(
    p_layer_name: ?[*:0]const u8,
    allocator: Allocator,
) EnumerateInstanceExtensionPropertiesAllocError![]ExtensionProperties {
    var count: u32 = undefined;
    var data: []ExtensionProperties = &.{};
    errdefer allocator.free(data);
    var result = Result.incomplete;
    while (result == .incomplete) {
        _ = try enumerateInstanceExtensionProperties(p_layer_name, &count, null);
        data = try allocator.realloc(data, count);
        result = try enumerateInstanceExtensionProperties(p_layer_name, &count, data.ptr);
    }
    return if (count == data.len) data else allocator.realloc(data, count);
}
var instance_dispatch: InstanceDispatch = undefined;
var instance_wrapper: InstanceWrapper = .{};
const InstanceWrapper = InstanceWrapperWithCustomDispatch(InstanceDispatch);
fn InstanceWrapperWithCustomDispatch(DispatchType: type) type {
    return struct {
        const Self = @This();
        pub const Dispatch = DispatchType;

        dispatch: *InstanceDispatch = &instance_dispatch,
        pub fn load(self: *Self, instance: Instance, loader: anytype) void {
            inline for (std.meta.fields(Dispatch)) |field| {
                const cmd_ptr = loader(instance, field.name.ptr) orelse undefined;
                @field(self.dispatch, field.name) = @ptrCast(cmd_ptr);
            }
        }
    };
}
pub fn destroyInstance(
    instance: Instance,
    p_allocator: ?*const AllocationCallbacks,
) void {
    instance_dispatch.vkDestroyInstance.?(
        instance,
        p_allocator,
    );
}
pub const EnumeratePhysicalDevicesError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InitializationFailed,
    Unknown,
};
pub fn enumeratePhysicalDevices(
    instance: Instance,
    p_physical_device_count: *u32,
    p_physical_devices: ?[*]PhysicalDevice,
) EnumeratePhysicalDevicesError!Result {
    const result = instance_dispatch.vkEnumeratePhysicalDevices.?(
        instance,
        p_physical_device_count,
        p_physical_devices,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
    return result;
}
pub const EnumeratePhysicalDevicesAllocError =
    EnumeratePhysicalDevicesError || Allocator.Error;
pub fn enumeratePhysicalDevicesAlloc(
    instance: Instance,
    allocator: Allocator,
) EnumeratePhysicalDevicesAllocError![]PhysicalDevice {
    var count: u32 = undefined;
    var data: []PhysicalDevice = &.{};
    errdefer allocator.free(data);
    var result = Result.incomplete;
    while (result == .incomplete) {
        _ = try enumeratePhysicalDevices(instance, &count, null);
        data = try allocator.realloc(data, count);
        result = try enumeratePhysicalDevices(instance, &count, data.ptr);
    }
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub fn getDeviceProcAddr(
    device: Device,
    p_name: [*:0]const u8,
) PfnVoidFunction {
    return instance_dispatch.vkGetDeviceProcAddr.?(
        device,
        p_name,
    );
}
pub fn getPhysicalDeviceProperties(
    physical_device: PhysicalDevice,
) PhysicalDeviceProperties {
    var out_properties: PhysicalDeviceProperties = undefined;
    instance_dispatch.vkGetPhysicalDeviceProperties.?(
        physical_device,
        &out_properties,
    );
    return out_properties;
}
pub fn getPhysicalDeviceQueueFamilyProperties(
    physical_device: PhysicalDevice,
    p_queue_family_property_count: *u32,
    p_queue_family_properties: ?[*]QueueFamilyProperties,
) void {
    instance_dispatch.vkGetPhysicalDeviceQueueFamilyProperties.?(
        physical_device,
        p_queue_family_property_count,
        p_queue_family_properties,
    );
}
pub fn getPhysicalDeviceQueueFamilyPropertiesAlloc(
    physical_device: PhysicalDevice,
    allocator: Allocator,
) Allocator.Error![]QueueFamilyProperties {
    var count: u32 = undefined;
    getPhysicalDeviceQueueFamilyProperties(physical_device, &count, null);
    const data = try allocator.alloc(QueueFamilyProperties, count);
    errdefer allocator.free(data);
    getPhysicalDeviceQueueFamilyProperties(physical_device, &count, data.ptr);
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub fn getPhysicalDeviceMemoryProperties(
    physical_device: PhysicalDevice,
) PhysicalDeviceMemoryProperties {
    var out_memory_properties: PhysicalDeviceMemoryProperties = undefined;
    instance_dispatch.vkGetPhysicalDeviceMemoryProperties.?(
        physical_device,
        &out_memory_properties,
    );
    return out_memory_properties;
}
pub fn getPhysicalDeviceFeatures(
    physical_device: PhysicalDevice,
) PhysicalDeviceFeatures {
    var out_features: PhysicalDeviceFeatures = undefined;
    instance_dispatch.vkGetPhysicalDeviceFeatures.?(
        physical_device,
        &out_features,
    );
    return out_features;
}
pub fn getPhysicalDeviceFormatProperties(
    physical_device: PhysicalDevice,
    format: Format,
) FormatProperties {
    var out_format_properties: FormatProperties = undefined;
    instance_dispatch.vkGetPhysicalDeviceFormatProperties.?(
        physical_device,
        format,
        &out_format_properties,
    );
    return out_format_properties;
}
pub const GetPhysicalDeviceImageFormatPropertiesError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    FormatNotSupported,
    Unknown,
};
pub fn getPhysicalDeviceImageFormatProperties(
    physical_device: PhysicalDevice,
    format: Format,
    @"type": ImageType,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    flags: ImageCreateFlags,
) GetPhysicalDeviceImageFormatPropertiesError!ImageFormatProperties {
    var out_image_format_properties: ImageFormatProperties = undefined;
    const result = instance_dispatch.vkGetPhysicalDeviceImageFormatProperties.?(
        physical_device,
        format,
        @"type",
        tiling,
        usage,
        flags,
        &out_image_format_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_format_not_supported => return error.FormatNotSupported,
        else => return error.Unknown,
    }
    return out_image_format_properties;
}
pub const CreateDeviceError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InitializationFailed,
    ExtensionNotPresent,
    FeatureNotPresent,
    TooManyObjects,
    DeviceLost,
    Unknown,
};
pub fn createDevice(
    physical_device: PhysicalDevice,
    p_create_info: *const DeviceCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateDeviceError!Device {
    var out_device: Device = undefined;
    const result = instance_dispatch.vkCreateDevice.?(
        physical_device,
        p_create_info,
        p_allocator,
        &out_device,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_extension_not_present => return error.ExtensionNotPresent,
        Result.error_feature_not_present => return error.FeatureNotPresent,
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_device_lost => return error.DeviceLost,
        else => return error.Unknown,
    }
    device_wrapper.load(out_device, getDeviceProcAddr);
    return out_device;
}
pub const EnumerateDeviceLayerPropertiesError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn enumerateDeviceLayerProperties(
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]LayerProperties,
) EnumerateDeviceLayerPropertiesError!Result {
    const result = instance_dispatch.vkEnumerateDeviceLayerProperties.?(
        physical_device,
        p_property_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const EnumerateDeviceLayerPropertiesAllocError =
    EnumerateDeviceLayerPropertiesError || Allocator.Error;
pub fn enumerateDeviceLayerPropertiesAlloc(
    physical_device: PhysicalDevice,
    allocator: Allocator,
) EnumerateDeviceLayerPropertiesAllocError![]LayerProperties {
    var count: u32 = undefined;
    var data: []LayerProperties = &.{};
    errdefer allocator.free(data);
    var result = Result.incomplete;
    while (result == .incomplete) {
        _ = try enumerateDeviceLayerProperties(physical_device, &count, null);
        data = try allocator.realloc(data, count);
        result = try enumerateDeviceLayerProperties(physical_device, &count, data.ptr);
    }
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub const EnumerateDeviceExtensionPropertiesError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    LayerNotPresent,
    Unknown,
};
pub fn enumerateDeviceExtensionProperties(
    physical_device: PhysicalDevice,
    p_layer_name: ?[*:0]const u8,
    p_property_count: *u32,
    p_properties: ?[*]ExtensionProperties,
) EnumerateDeviceExtensionPropertiesError!Result {
    const result = instance_dispatch.vkEnumerateDeviceExtensionProperties.?(
        physical_device,
        p_layer_name,
        p_property_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_layer_not_present => return error.LayerNotPresent,
        else => return error.Unknown,
    }
    return result;
}
pub const EnumerateDeviceExtensionPropertiesAllocError =
    EnumerateDeviceExtensionPropertiesError || Allocator.Error;
pub fn enumerateDeviceExtensionPropertiesAlloc(
    physical_device: PhysicalDevice,
    p_layer_name: ?[*:0]const u8,
    allocator: Allocator,
) EnumerateDeviceExtensionPropertiesAllocError![]ExtensionProperties {
    var count: u32 = undefined;
    var data: []ExtensionProperties = &.{};
    errdefer allocator.free(data);
    var result = Result.incomplete;
    while (result == .incomplete) {
        _ = try enumerateDeviceExtensionProperties(physical_device, p_layer_name, &count, null);
        data = try allocator.realloc(data, count);
        result = try enumerateDeviceExtensionProperties(physical_device, p_layer_name, &count, data.ptr);
    }
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub fn getPhysicalDeviceSparseImageFormatProperties(
    physical_device: PhysicalDevice,
    format: Format,
    @"type": ImageType,
    samples: SampleCountFlags,
    usage: ImageUsageFlags,
    tiling: ImageTiling,
    p_property_count: *u32,
    p_properties: ?[*]SparseImageFormatProperties,
) void {
    instance_dispatch.vkGetPhysicalDeviceSparseImageFormatProperties.?(
        physical_device,
        format,
        @"type",
        samples,
        usage,
        tiling,
        p_property_count,
        p_properties,
    );
}
pub fn getPhysicalDeviceSparseImageFormatPropertiesAlloc(
    physical_device: PhysicalDevice,
    format: Format,
    @"type": ImageType,
    samples: SampleCountFlags,
    usage: ImageUsageFlags,
    tiling: ImageTiling,
    allocator: Allocator,
) Allocator.Error![]SparseImageFormatProperties {
    var count: u32 = undefined;
    getPhysicalDeviceSparseImageFormatProperties(physical_device, format, @"type", samples, usage, tiling, &count, null);
    const data = try allocator.alloc(SparseImageFormatProperties, count);
    errdefer allocator.free(data);
    getPhysicalDeviceSparseImageFormatProperties(physical_device, format, @"type", samples, usage, tiling, &count, data.ptr);
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub const CreateAndroidSurfaceKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    NativeWindowInUseKHR,
    Unknown,
};
pub fn createAndroidSurfaceKHR(
    instance: Instance,
    p_create_info: *const AndroidSurfaceCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
) CreateAndroidSurfaceKHRError!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = instance_dispatch.vkCreateAndroidSurfaceKHR.?(
        instance,
        p_create_info,
        p_allocator,
        &out_surface,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_native_window_in_use_khr => return error.NativeWindowInUseKHR,
        else => return error.Unknown,
    }
    return out_surface;
}
pub const CreateSurfaceOHOSError = error{
    OutOfHostMemory,
    SurfaceLostKHR,
    Unknown,
};
pub fn createSurfaceOHOS(
    instance: Instance,
    p_create_info: *const SurfaceCreateInfoOHOS,
    p_allocator: ?*const AllocationCallbacks,
) CreateSurfaceOHOSError!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = instance_dispatch.vkCreateSurfaceOHOS.?(
        instance,
        p_create_info,
        p_allocator,
        &out_surface,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
    return out_surface;
}
pub const GetPhysicalDeviceDisplayPropertiesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPhysicalDeviceDisplayPropertiesKHR(
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]DisplayPropertiesKHR,
) GetPhysicalDeviceDisplayPropertiesKHRError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceDisplayPropertiesKHR.?(
        physical_device,
        p_property_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDeviceDisplayPlanePropertiesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPhysicalDeviceDisplayPlanePropertiesKHR(
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]DisplayPlanePropertiesKHR,
) GetPhysicalDeviceDisplayPlanePropertiesKHRError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceDisplayPlanePropertiesKHR.?(
        physical_device,
        p_property_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetDisplayPlaneSupportedDisplaysKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getDisplayPlaneSupportedDisplaysKHR(
    physical_device: PhysicalDevice,
    plane_index: u32,
    p_display_count: *u32,
    p_displays: ?[*]DisplayKHR,
) GetDisplayPlaneSupportedDisplaysKHRError!Result {
    const result = instance_dispatch.vkGetDisplayPlaneSupportedDisplaysKHR.?(
        physical_device,
        plane_index,
        p_display_count,
        p_displays,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetDisplayModePropertiesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getDisplayModePropertiesKHR(
    physical_device: PhysicalDevice,
    display: DisplayKHR,
    p_property_count: *u32,
    p_properties: ?[*]DisplayModePropertiesKHR,
) GetDisplayModePropertiesKHRError!Result {
    const result = instance_dispatch.vkGetDisplayModePropertiesKHR.?(
        physical_device,
        display,
        p_property_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const CreateDisplayModeKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InitializationFailed,
    Unknown,
};
pub fn createDisplayModeKHR(
    physical_device: PhysicalDevice,
    display: DisplayKHR,
    p_create_info: *const DisplayModeCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
) CreateDisplayModeKHRError!DisplayModeKHR {
    var out_mode: DisplayModeKHR = undefined;
    const result = instance_dispatch.vkCreateDisplayModeKHR.?(
        physical_device,
        display,
        p_create_info,
        p_allocator,
        &out_mode,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
    return out_mode;
}
pub const GetDisplayPlaneCapabilitiesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getDisplayPlaneCapabilitiesKHR(
    physical_device: PhysicalDevice,
    mode: DisplayModeKHR,
    plane_index: u32,
) GetDisplayPlaneCapabilitiesKHRError!DisplayPlaneCapabilitiesKHR {
    var out_capabilities: DisplayPlaneCapabilitiesKHR = undefined;
    const result = instance_dispatch.vkGetDisplayPlaneCapabilitiesKHR.?(
        physical_device,
        mode,
        plane_index,
        &out_capabilities,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_capabilities;
}
pub const CreateDisplayPlaneSurfaceKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createDisplayPlaneSurfaceKHR(
    instance: Instance,
    p_create_info: *const DisplaySurfaceCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
) CreateDisplayPlaneSurfaceKHRError!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = instance_dispatch.vkCreateDisplayPlaneSurfaceKHR.?(
        instance,
        p_create_info,
        p_allocator,
        &out_surface,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_surface;
}
pub fn destroySurfaceKHR(
    instance: Instance,
    surface: SurfaceKHR,
    p_allocator: ?*const AllocationCallbacks,
) void {
    instance_dispatch.vkDestroySurfaceKHR.?(
        instance,
        surface,
        p_allocator,
    );
}
pub const GetPhysicalDeviceSurfaceSupportKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    SurfaceLostKHR,
    Unknown,
};
pub fn getPhysicalDeviceSurfaceSupportKHR(
    physical_device: PhysicalDevice,
    queue_family_index: u32,
    surface: SurfaceKHR,
) GetPhysicalDeviceSurfaceSupportKHRError!Bool32 {
    var out_supported: Bool32 = undefined;
    const result = instance_dispatch.vkGetPhysicalDeviceSurfaceSupportKHR.?(
        physical_device,
        queue_family_index,
        surface,
        &out_supported,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
    return out_supported;
}
pub const GetPhysicalDeviceSurfaceCapabilitiesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    SurfaceLostKHR,
    Unknown,
};
pub fn getPhysicalDeviceSurfaceCapabilitiesKHR(
    physical_device: PhysicalDevice,
    surface: SurfaceKHR,
) GetPhysicalDeviceSurfaceCapabilitiesKHRError!SurfaceCapabilitiesKHR {
    var out_surface_capabilities: SurfaceCapabilitiesKHR = undefined;
    const result = instance_dispatch.vkGetPhysicalDeviceSurfaceCapabilitiesKHR.?(
        physical_device,
        surface,
        &out_surface_capabilities,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
    return out_surface_capabilities;
}
pub const GetPhysicalDeviceSurfaceFormatsKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    SurfaceLostKHR,
    Unknown,
};
pub fn getPhysicalDeviceSurfaceFormatsKHR(
    physical_device: PhysicalDevice,
    surface: SurfaceKHR,
    p_surface_format_count: *u32,
    p_surface_formats: ?[*]SurfaceFormatKHR,
) GetPhysicalDeviceSurfaceFormatsKHRError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceSurfaceFormatsKHR.?(
        physical_device,
        surface,
        p_surface_format_count,
        p_surface_formats,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDeviceSurfaceFormatsAllocKHRError =
    GetPhysicalDeviceSurfaceFormatsKHRError || Allocator.Error;
pub fn getPhysicalDeviceSurfaceFormatsAllocKHR(
    physical_device: PhysicalDevice,
    surface: SurfaceKHR,
    allocator: Allocator,
) GetPhysicalDeviceSurfaceFormatsAllocKHRError![]SurfaceFormatKHR {
    var count: u32 = undefined;
    var data: []SurfaceFormatKHR = &.{};
    errdefer allocator.free(data);
    var result = Result.incomplete;
    while (result == .incomplete) {
        _ = try getPhysicalDeviceSurfaceFormatsKHR(physical_device, surface, &count, null);
        data = try allocator.realloc(data, count);
        result = try getPhysicalDeviceSurfaceFormatsKHR(physical_device, surface, &count, data.ptr);
    }
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub const GetPhysicalDeviceSurfacePresentModesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    SurfaceLostKHR,
    Unknown,
};
pub fn getPhysicalDeviceSurfacePresentModesKHR(
    physical_device: PhysicalDevice,
    surface: SurfaceKHR,
    p_present_mode_count: *u32,
    p_present_modes: ?[*]PresentModeKHR,
) GetPhysicalDeviceSurfacePresentModesKHRError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceSurfacePresentModesKHR.?(
        physical_device,
        surface,
        p_present_mode_count,
        p_present_modes,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDeviceSurfacePresentModesAllocKHRError =
    GetPhysicalDeviceSurfacePresentModesKHRError || Allocator.Error;
pub fn getPhysicalDeviceSurfacePresentModesAllocKHR(
    physical_device: PhysicalDevice,
    surface: SurfaceKHR,
    allocator: Allocator,
) GetPhysicalDeviceSurfacePresentModesAllocKHRError![]PresentModeKHR {
    var count: u32 = undefined;
    var data: []PresentModeKHR = &.{};
    errdefer allocator.free(data);
    var result = Result.incomplete;
    while (result == .incomplete) {
        _ = try getPhysicalDeviceSurfacePresentModesKHR(physical_device, surface, &count, null);
        data = try allocator.realloc(data, count);
        result = try getPhysicalDeviceSurfacePresentModesKHR(physical_device, surface, &count, data.ptr);
    }
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub const CreateViSurfaceNNError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    NativeWindowInUseKHR,
    Unknown,
};
pub fn createViSurfaceNN(
    instance: Instance,
    p_create_info: *const ViSurfaceCreateInfoNN,
    p_allocator: ?*const AllocationCallbacks,
) CreateViSurfaceNNError!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = instance_dispatch.vkCreateViSurfaceNN.?(
        instance,
        p_create_info,
        p_allocator,
        &out_surface,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_native_window_in_use_khr => return error.NativeWindowInUseKHR,
        else => return error.Unknown,
    }
    return out_surface;
}
pub const CreateWaylandSurfaceKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createWaylandSurfaceKHR(
    instance: Instance,
    p_create_info: *const WaylandSurfaceCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
) CreateWaylandSurfaceKHRError!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = instance_dispatch.vkCreateWaylandSurfaceKHR.?(
        instance,
        p_create_info,
        p_allocator,
        &out_surface,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_surface;
}
pub fn getPhysicalDeviceWaylandPresentationSupportKHR(
    physical_device: PhysicalDevice,
    queue_family_index: u32,
    display: *wl_display,
) Bool32 {
    return instance_dispatch.vkGetPhysicalDeviceWaylandPresentationSupportKHR.?(
        physical_device,
        queue_family_index,
        display,
    );
}
pub const CreateWin32SurfaceKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createWin32SurfaceKHR(
    instance: Instance,
    p_create_info: *const Win32SurfaceCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
) CreateWin32SurfaceKHRError!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = instance_dispatch.vkCreateWin32SurfaceKHR.?(
        instance,
        p_create_info,
        p_allocator,
        &out_surface,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_surface;
}
pub fn getPhysicalDeviceWin32PresentationSupportKHR(
    physical_device: PhysicalDevice,
    queue_family_index: u32,
) Bool32 {
    return instance_dispatch.vkGetPhysicalDeviceWin32PresentationSupportKHR.?(
        physical_device,
        queue_family_index,
    );
}
pub const CreateXlibSurfaceKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createXlibSurfaceKHR(
    instance: Instance,
    p_create_info: *const XlibSurfaceCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
) CreateXlibSurfaceKHRError!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = instance_dispatch.vkCreateXlibSurfaceKHR.?(
        instance,
        p_create_info,
        p_allocator,
        &out_surface,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_surface;
}
pub fn getPhysicalDeviceXlibPresentationSupportKHR(
    physical_device: PhysicalDevice,
    queue_family_index: u32,
    dpy: *Display,
    visual_id: VisualID,
) Bool32 {
    return instance_dispatch.vkGetPhysicalDeviceXlibPresentationSupportKHR.?(
        physical_device,
        queue_family_index,
        dpy,
        visual_id,
    );
}
pub const CreateXcbSurfaceKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createXcbSurfaceKHR(
    instance: Instance,
    p_create_info: *const XcbSurfaceCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
) CreateXcbSurfaceKHRError!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = instance_dispatch.vkCreateXcbSurfaceKHR.?(
        instance,
        p_create_info,
        p_allocator,
        &out_surface,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_surface;
}
pub fn getPhysicalDeviceXcbPresentationSupportKHR(
    physical_device: PhysicalDevice,
    queue_family_index: u32,
    connection: *xcb_connection_t,
    visual_id: xcb_visualid_t,
) Bool32 {
    return instance_dispatch.vkGetPhysicalDeviceXcbPresentationSupportKHR.?(
        physical_device,
        queue_family_index,
        connection,
        visual_id,
    );
}
pub const CreateDirectFbSurfaceEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createDirectFbSurfaceEXT(
    instance: Instance,
    p_create_info: *const DirectFBSurfaceCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
) CreateDirectFbSurfaceEXTError!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = instance_dispatch.vkCreateDirectFBSurfaceEXT.?(
        instance,
        p_create_info,
        p_allocator,
        &out_surface,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_surface;
}
pub fn getPhysicalDeviceDirectFbPresentationSupportEXT(
    physical_device: PhysicalDevice,
    queue_family_index: u32,
    dfb: *IDirectFB,
) Bool32 {
    return instance_dispatch.vkGetPhysicalDeviceDirectFBPresentationSupportEXT.?(
        physical_device,
        queue_family_index,
        dfb,
    );
}
pub const CreateImagePipeSurfaceFUCHSIAError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createImagePipeSurfaceFUCHSIA(
    instance: Instance,
    p_create_info: *const ImagePipeSurfaceCreateInfoFUCHSIA,
    p_allocator: ?*const AllocationCallbacks,
) CreateImagePipeSurfaceFUCHSIAError!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = instance_dispatch.vkCreateImagePipeSurfaceFUCHSIA.?(
        instance,
        p_create_info,
        p_allocator,
        &out_surface,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_surface;
}
pub const CreateStreamDescriptorSurfaceGGPError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    NativeWindowInUseKHR,
    Unknown,
};
pub fn createStreamDescriptorSurfaceGGP(
    instance: Instance,
    p_create_info: *const StreamDescriptorSurfaceCreateInfoGGP,
    p_allocator: ?*const AllocationCallbacks,
) CreateStreamDescriptorSurfaceGGPError!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = instance_dispatch.vkCreateStreamDescriptorSurfaceGGP.?(
        instance,
        p_create_info,
        p_allocator,
        &out_surface,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_native_window_in_use_khr => return error.NativeWindowInUseKHR,
        else => return error.Unknown,
    }
    return out_surface;
}
pub const CreateScreenSurfaceQNXError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createScreenSurfaceQNX(
    instance: Instance,
    p_create_info: *const ScreenSurfaceCreateInfoQNX,
    p_allocator: ?*const AllocationCallbacks,
) CreateScreenSurfaceQNXError!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = instance_dispatch.vkCreateScreenSurfaceQNX.?(
        instance,
        p_create_info,
        p_allocator,
        &out_surface,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_surface;
}
pub fn getPhysicalDeviceScreenPresentationSupportQNX(
    physical_device: PhysicalDevice,
    queue_family_index: u32,
    window: *_screen_window,
) Bool32 {
    return instance_dispatch.vkGetPhysicalDeviceScreenPresentationSupportQNX.?(
        physical_device,
        queue_family_index,
        window,
    );
}
pub const CreateDebugReportCallbackEXTError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn createDebugReportCallbackEXT(
    instance: Instance,
    p_create_info: *const DebugReportCallbackCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
) CreateDebugReportCallbackEXTError!DebugReportCallbackEXT {
    var out_callback: DebugReportCallbackEXT = undefined;
    const result = instance_dispatch.vkCreateDebugReportCallbackEXT.?(
        instance,
        p_create_info,
        p_allocator,
        &out_callback,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_callback;
}
pub fn destroyDebugReportCallbackEXT(
    instance: Instance,
    callback: DebugReportCallbackEXT,
    p_allocator: ?*const AllocationCallbacks,
) void {
    instance_dispatch.vkDestroyDebugReportCallbackEXT.?(
        instance,
        callback,
        p_allocator,
    );
}
pub fn debugReportMessageEXT(
    instance: Instance,
    flags: DebugReportFlagsEXT,
    object_type: DebugReportObjectTypeEXT,
    object: u64,
    location: usize,
    message_code: i32,
    p_layer_prefix: [*:0]const u8,
    p_message: [*:0]const u8,
) void {
    instance_dispatch.vkDebugReportMessageEXT.?(
        instance,
        flags,
        object_type,
        object,
        location,
        message_code,
        p_layer_prefix,
        p_message,
    );
}
pub const GetPhysicalDeviceExternalImageFormatPropertiesNVError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    FormatNotSupported,
    Unknown,
};
pub fn getPhysicalDeviceExternalImageFormatPropertiesNV(
    physical_device: PhysicalDevice,
    format: Format,
    @"type": ImageType,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    flags: ImageCreateFlags,
    external_handle_type: ExternalMemoryHandleTypeFlagsNV,
) GetPhysicalDeviceExternalImageFormatPropertiesNVError!ExternalImageFormatPropertiesNV {
    var out_external_image_format_properties: ExternalImageFormatPropertiesNV = undefined;
    const result = instance_dispatch.vkGetPhysicalDeviceExternalImageFormatPropertiesNV.?(
        physical_device,
        format,
        @"type",
        tiling,
        usage,
        flags,
        external_handle_type,
        &out_external_image_format_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_format_not_supported => return error.FormatNotSupported,
        else => return error.Unknown,
    }
    return out_external_image_format_properties;
}
pub fn getPhysicalDeviceFeatures2(
    physical_device: PhysicalDevice,
    p_features: *PhysicalDeviceFeatures2,
) void {
    instance_dispatch.vkGetPhysicalDeviceFeatures2.?(
        physical_device,
        p_features,
    );
}
pub fn getPhysicalDeviceFeatures2KHR(
    physical_device: PhysicalDevice,
    p_features: *PhysicalDeviceFeatures2,
) void {
    instance_dispatch.vkGetPhysicalDeviceFeatures2KHR.?(
        physical_device,
        p_features,
    );
}
pub fn getPhysicalDeviceProperties2(
    physical_device: PhysicalDevice,
    p_properties: *PhysicalDeviceProperties2,
) void {
    instance_dispatch.vkGetPhysicalDeviceProperties2.?(
        physical_device,
        p_properties,
    );
}
pub fn getPhysicalDeviceProperties2KHR(
    physical_device: PhysicalDevice,
    p_properties: *PhysicalDeviceProperties2,
) void {
    instance_dispatch.vkGetPhysicalDeviceProperties2KHR.?(
        physical_device,
        p_properties,
    );
}
pub fn getPhysicalDeviceFormatProperties2(
    physical_device: PhysicalDevice,
    format: Format,
    p_format_properties: *FormatProperties2,
) void {
    instance_dispatch.vkGetPhysicalDeviceFormatProperties2.?(
        physical_device,
        format,
        p_format_properties,
    );
}
pub fn getPhysicalDeviceFormatProperties2KHR(
    physical_device: PhysicalDevice,
    format: Format,
    p_format_properties: *FormatProperties2,
) void {
    instance_dispatch.vkGetPhysicalDeviceFormatProperties2KHR.?(
        physical_device,
        format,
        p_format_properties,
    );
}
pub const GetPhysicalDeviceImageFormatProperties2Error = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    FormatNotSupported,
    ImageUsageNotSupportedKHR,
    VideoProfileOperationNotSupportedKHR,
    VideoProfileFormatNotSupportedKHR,
    VideoPictureLayoutNotSupportedKHR,
    VideoProfileCodecNotSupportedKHR,
    Unknown,
};
pub fn getPhysicalDeviceImageFormatProperties2(
    physical_device: PhysicalDevice,
    p_image_format_info: *const PhysicalDeviceImageFormatInfo2,
    p_image_format_properties: *ImageFormatProperties2,
) GetPhysicalDeviceImageFormatProperties2Error!void {
    const result = instance_dispatch.vkGetPhysicalDeviceImageFormatProperties2.?(
        physical_device,
        p_image_format_info,
        p_image_format_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_format_not_supported => return error.FormatNotSupported,
        Result.error_image_usage_not_supported_khr => return error.ImageUsageNotSupportedKHR,
        Result.error_video_profile_operation_not_supported_khr => return error.VideoProfileOperationNotSupportedKHR,
        Result.error_video_profile_format_not_supported_khr => return error.VideoProfileFormatNotSupportedKHR,
        Result.error_video_picture_layout_not_supported_khr => return error.VideoPictureLayoutNotSupportedKHR,
        Result.error_video_profile_codec_not_supported_khr => return error.VideoProfileCodecNotSupportedKHR,
        else => return error.Unknown,
    }
}
pub const GetPhysicalDeviceImageFormatProperties2KHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    FormatNotSupported,
    ImageUsageNotSupportedKHR,
    VideoProfileOperationNotSupportedKHR,
    VideoProfileFormatNotSupportedKHR,
    VideoPictureLayoutNotSupportedKHR,
    VideoProfileCodecNotSupportedKHR,
    Unknown,
};
pub fn getPhysicalDeviceImageFormatProperties2KHR(
    physical_device: PhysicalDevice,
    p_image_format_info: *const PhysicalDeviceImageFormatInfo2,
    p_image_format_properties: *ImageFormatProperties2,
) GetPhysicalDeviceImageFormatProperties2KHRError!void {
    const result = instance_dispatch.vkGetPhysicalDeviceImageFormatProperties2KHR.?(
        physical_device,
        p_image_format_info,
        p_image_format_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_format_not_supported => return error.FormatNotSupported,
        Result.error_image_usage_not_supported_khr => return error.ImageUsageNotSupportedKHR,
        Result.error_video_profile_operation_not_supported_khr => return error.VideoProfileOperationNotSupportedKHR,
        Result.error_video_profile_format_not_supported_khr => return error.VideoProfileFormatNotSupportedKHR,
        Result.error_video_picture_layout_not_supported_khr => return error.VideoPictureLayoutNotSupportedKHR,
        Result.error_video_profile_codec_not_supported_khr => return error.VideoProfileCodecNotSupportedKHR,
        else => return error.Unknown,
    }
}
pub fn getPhysicalDeviceQueueFamilyProperties2(
    physical_device: PhysicalDevice,
    p_queue_family_property_count: *u32,
    p_queue_family_properties: ?[*]QueueFamilyProperties2,
) void {
    instance_dispatch.vkGetPhysicalDeviceQueueFamilyProperties2.?(
        physical_device,
        p_queue_family_property_count,
        p_queue_family_properties,
    );
}
pub fn getPhysicalDeviceQueueFamilyProperties2Alloc(
    physical_device: PhysicalDevice,
    allocator: Allocator,
) Allocator.Error![]QueueFamilyProperties2 {
    var count: u32 = undefined;
    getPhysicalDeviceQueueFamilyProperties2(physical_device, &count, null);
    const data = try allocator.alloc(QueueFamilyProperties2, count);
    errdefer allocator.free(data);
    getPhysicalDeviceQueueFamilyProperties2(physical_device, &count, data.ptr);
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub fn getPhysicalDeviceQueueFamilyProperties2KHR(
    physical_device: PhysicalDevice,
    p_queue_family_property_count: *u32,
    p_queue_family_properties: ?[*]QueueFamilyProperties2,
) void {
    instance_dispatch.vkGetPhysicalDeviceQueueFamilyProperties2KHR.?(
        physical_device,
        p_queue_family_property_count,
        p_queue_family_properties,
    );
}
pub fn getPhysicalDeviceMemoryProperties2(
    physical_device: PhysicalDevice,
    p_memory_properties: *PhysicalDeviceMemoryProperties2,
) void {
    instance_dispatch.vkGetPhysicalDeviceMemoryProperties2.?(
        physical_device,
        p_memory_properties,
    );
}
pub fn getPhysicalDeviceMemoryProperties2KHR(
    physical_device: PhysicalDevice,
    p_memory_properties: *PhysicalDeviceMemoryProperties2,
) void {
    instance_dispatch.vkGetPhysicalDeviceMemoryProperties2KHR.?(
        physical_device,
        p_memory_properties,
    );
}
pub fn getPhysicalDeviceSparseImageFormatProperties2(
    physical_device: PhysicalDevice,
    p_format_info: *const PhysicalDeviceSparseImageFormatInfo2,
    p_property_count: *u32,
    p_properties: ?[*]SparseImageFormatProperties2,
) void {
    instance_dispatch.vkGetPhysicalDeviceSparseImageFormatProperties2.?(
        physical_device,
        p_format_info,
        p_property_count,
        p_properties,
    );
}
pub fn getPhysicalDeviceSparseImageFormatProperties2Alloc(
    physical_device: PhysicalDevice,
    p_format_info: *const PhysicalDeviceSparseImageFormatInfo2,
    allocator: Allocator,
) Allocator.Error![]SparseImageFormatProperties2 {
    var count: u32 = undefined;
    getPhysicalDeviceSparseImageFormatProperties2(physical_device, p_format_info, &count, null);
    const data = try allocator.alloc(SparseImageFormatProperties2, count);
    errdefer allocator.free(data);
    getPhysicalDeviceSparseImageFormatProperties2(physical_device, p_format_info, &count, data.ptr);
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub fn getPhysicalDeviceSparseImageFormatProperties2KHR(
    physical_device: PhysicalDevice,
    p_format_info: *const PhysicalDeviceSparseImageFormatInfo2,
    p_property_count: *u32,
    p_properties: ?[*]SparseImageFormatProperties2,
) void {
    instance_dispatch.vkGetPhysicalDeviceSparseImageFormatProperties2KHR.?(
        physical_device,
        p_format_info,
        p_property_count,
        p_properties,
    );
}
pub fn getPhysicalDeviceExternalBufferProperties(
    physical_device: PhysicalDevice,
    p_external_buffer_info: *const PhysicalDeviceExternalBufferInfo,
    p_external_buffer_properties: *ExternalBufferProperties,
) void {
    instance_dispatch.vkGetPhysicalDeviceExternalBufferProperties.?(
        physical_device,
        p_external_buffer_info,
        p_external_buffer_properties,
    );
}
pub fn getPhysicalDeviceExternalBufferPropertiesKHR(
    physical_device: PhysicalDevice,
    p_external_buffer_info: *const PhysicalDeviceExternalBufferInfo,
    p_external_buffer_properties: *ExternalBufferProperties,
) void {
    instance_dispatch.vkGetPhysicalDeviceExternalBufferPropertiesKHR.?(
        physical_device,
        p_external_buffer_info,
        p_external_buffer_properties,
    );
}
pub const GetPhysicalDeviceExternalMemorySciBufPropertiesNVError = error{
    InitializationFailed,
    InvalidExternalHandle,
    Unknown,
};
pub fn getPhysicalDeviceExternalMemorySciBufPropertiesNV(
    physical_device: PhysicalDevice,
    handle_type: ExternalMemoryHandleTypeFlags,
    handle: NvSciBufObj,
    p_memory_sci_buf_properties: *MemorySciBufPropertiesNV,
) GetPhysicalDeviceExternalMemorySciBufPropertiesNVError!void {
    const result = instance_dispatch.vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV.?(
        physical_device,
        handle_type,
        handle,
        p_memory_sci_buf_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        else => return error.Unknown,
    }
}
pub const GetPhysicalDeviceSciBufAttributesNVError = error{
    OutOfHostMemory,
    InitializationFailed,
    Unknown,
};
pub fn getPhysicalDeviceSciBufAttributesNV(
    physical_device: PhysicalDevice,
    p_attributes: NvSciBufAttrList,
) GetPhysicalDeviceSciBufAttributesNVError!void {
    const result = instance_dispatch.vkGetPhysicalDeviceSciBufAttributesNV.?(
        physical_device,
        p_attributes,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
}
pub fn getPhysicalDeviceExternalSemaphoreProperties(
    physical_device: PhysicalDevice,
    p_external_semaphore_info: *const PhysicalDeviceExternalSemaphoreInfo,
    p_external_semaphore_properties: *ExternalSemaphoreProperties,
) void {
    instance_dispatch.vkGetPhysicalDeviceExternalSemaphoreProperties.?(
        physical_device,
        p_external_semaphore_info,
        p_external_semaphore_properties,
    );
}
pub fn getPhysicalDeviceExternalSemaphorePropertiesKHR(
    physical_device: PhysicalDevice,
    p_external_semaphore_info: *const PhysicalDeviceExternalSemaphoreInfo,
    p_external_semaphore_properties: *ExternalSemaphoreProperties,
) void {
    instance_dispatch.vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.?(
        physical_device,
        p_external_semaphore_info,
        p_external_semaphore_properties,
    );
}
pub fn getPhysicalDeviceExternalFenceProperties(
    physical_device: PhysicalDevice,
    p_external_fence_info: *const PhysicalDeviceExternalFenceInfo,
    p_external_fence_properties: *ExternalFenceProperties,
) void {
    instance_dispatch.vkGetPhysicalDeviceExternalFenceProperties.?(
        physical_device,
        p_external_fence_info,
        p_external_fence_properties,
    );
}
pub fn getPhysicalDeviceExternalFencePropertiesKHR(
    physical_device: PhysicalDevice,
    p_external_fence_info: *const PhysicalDeviceExternalFenceInfo,
    p_external_fence_properties: *ExternalFenceProperties,
) void {
    instance_dispatch.vkGetPhysicalDeviceExternalFencePropertiesKHR.?(
        physical_device,
        p_external_fence_info,
        p_external_fence_properties,
    );
}
pub const GetPhysicalDeviceSciSyncAttributesNVError = error{
    InitializationFailed,
    Unknown,
};
pub fn getPhysicalDeviceSciSyncAttributesNV(
    physical_device: PhysicalDevice,
    p_sci_sync_attributes_info: *const SciSyncAttributesInfoNV,
    p_attributes: NvSciSyncAttrList,
) GetPhysicalDeviceSciSyncAttributesNVError!void {
    const result = instance_dispatch.vkGetPhysicalDeviceSciSyncAttributesNV.?(
        physical_device,
        p_sci_sync_attributes_info,
        p_attributes,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
}
pub const ReleaseDisplayEXTError = error{
    Unknown,
};
pub fn releaseDisplayEXT(
    physical_device: PhysicalDevice,
    display: DisplayKHR,
) ReleaseDisplayEXTError!void {
    const result = instance_dispatch.vkReleaseDisplayEXT.?(
        physical_device,
        display,
    );
    switch (result) {
        Result.success => {},
        else => return error.Unknown,
    }
}
pub const AcquireXlibDisplayEXTError = error{
    OutOfHostMemory,
    InitializationFailed,
    Unknown,
};
pub fn acquireXlibDisplayEXT(
    physical_device: PhysicalDevice,
    dpy: *Display,
    display: DisplayKHR,
) AcquireXlibDisplayEXTError!void {
    const result = instance_dispatch.vkAcquireXlibDisplayEXT.?(
        physical_device,
        dpy,
        display,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
}
pub const GetRandROutputDisplayEXTError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn getRandROutputDisplayEXT(
    physical_device: PhysicalDevice,
    dpy: *Display,
    rr_output: RROutput,
) GetRandROutputDisplayEXTError!DisplayKHR {
    var out_display: DisplayKHR = undefined;
    const result = instance_dispatch.vkGetRandROutputDisplayEXT.?(
        physical_device,
        dpy,
        rr_output,
        &out_display,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_display;
}
pub const AcquireWinrtDisplayNVError = error{
    OutOfHostMemory,
    DeviceLost,
    InitializationFailed,
    Unknown,
};
pub fn acquireWinrtDisplayNV(
    physical_device: PhysicalDevice,
    display: DisplayKHR,
) AcquireWinrtDisplayNVError!void {
    const result = instance_dispatch.vkAcquireWinrtDisplayNV.?(
        physical_device,
        display,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_device_lost => return error.DeviceLost,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
}
pub const GetWinrtDisplayNVError = error{
    OutOfHostMemory,
    DeviceLost,
    InitializationFailed,
    Unknown,
};
pub fn getWinrtDisplayNV(
    physical_device: PhysicalDevice,
    device_relative_id: u32,
) GetWinrtDisplayNVError!DisplayKHR {
    var out_display: DisplayKHR = undefined;
    const result = instance_dispatch.vkGetWinrtDisplayNV.?(
        physical_device,
        device_relative_id,
        &out_display,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_device_lost => return error.DeviceLost,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
    return out_display;
}
pub const GetPhysicalDeviceSurfaceCapabilities2EXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    SurfaceLostKHR,
    Unknown,
};
pub fn getPhysicalDeviceSurfaceCapabilities2EXT(
    physical_device: PhysicalDevice,
    surface: SurfaceKHR,
    p_surface_capabilities: *SurfaceCapabilities2EXT,
) GetPhysicalDeviceSurfaceCapabilities2EXTError!void {
    const result = instance_dispatch.vkGetPhysicalDeviceSurfaceCapabilities2EXT.?(
        physical_device,
        surface,
        p_surface_capabilities,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
}
pub const EnumeratePhysicalDeviceGroupsError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InitializationFailed,
    Unknown,
};
pub fn enumeratePhysicalDeviceGroups(
    instance: Instance,
    p_physical_device_group_count: *u32,
    p_physical_device_group_properties: ?[*]PhysicalDeviceGroupProperties,
) EnumeratePhysicalDeviceGroupsError!Result {
    const result = instance_dispatch.vkEnumeratePhysicalDeviceGroups.?(
        instance,
        p_physical_device_group_count,
        p_physical_device_group_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
    return result;
}
pub const EnumeratePhysicalDeviceGroupsAllocError =
    EnumeratePhysicalDeviceGroupsError || Allocator.Error;
pub fn enumeratePhysicalDeviceGroupsAlloc(
    instance: Instance,
    allocator: Allocator,
) EnumeratePhysicalDeviceGroupsAllocError![]PhysicalDeviceGroupProperties {
    var count: u32 = undefined;
    var data: []PhysicalDeviceGroupProperties = &.{};
    errdefer allocator.free(data);
    var result = Result.incomplete;
    while (result == .incomplete) {
        _ = try enumeratePhysicalDeviceGroups(instance, &count, null);
        data = try allocator.realloc(data, count);
        result = try enumeratePhysicalDeviceGroups(instance, &count, data.ptr);
    }
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub const EnumeratePhysicalDeviceGroupsKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InitializationFailed,
    Unknown,
};
pub fn enumeratePhysicalDeviceGroupsKHR(
    instance: Instance,
    p_physical_device_group_count: *u32,
    p_physical_device_group_properties: ?[*]PhysicalDeviceGroupProperties,
) EnumeratePhysicalDeviceGroupsKHRError!Result {
    const result = instance_dispatch.vkEnumeratePhysicalDeviceGroupsKHR.?(
        instance,
        p_physical_device_group_count,
        p_physical_device_group_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDevicePresentRectanglesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPhysicalDevicePresentRectanglesKHR(
    physical_device: PhysicalDevice,
    surface: SurfaceKHR,
    p_rect_count: *u32,
    p_rects: ?[*]Rect2D,
) GetPhysicalDevicePresentRectanglesKHRError!Result {
    const result = instance_dispatch.vkGetPhysicalDevicePresentRectanglesKHR.?(
        physical_device,
        surface,
        p_rect_count,
        p_rects,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDevicePresentRectanglesAllocKHRError =
    GetPhysicalDevicePresentRectanglesKHRError || Allocator.Error;
pub fn getPhysicalDevicePresentRectanglesAllocKHR(
    physical_device: PhysicalDevice,
    surface: SurfaceKHR,
    allocator: Allocator,
) GetPhysicalDevicePresentRectanglesAllocKHRError![]Rect2D {
    var count: u32 = undefined;
    var data: []Rect2D = &.{};
    errdefer allocator.free(data);
    var result = Result.incomplete;
    while (result == .incomplete) {
        _ = try getPhysicalDevicePresentRectanglesKHR(physical_device, surface, &count, null);
        data = try allocator.realloc(data, count);
        result = try getPhysicalDevicePresentRectanglesKHR(physical_device, surface, &count, data.ptr);
    }
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub const CreateIosSurfaceMVKError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    NativeWindowInUseKHR,
    Unknown,
};
pub fn createIosSurfaceMVK(
    instance: Instance,
    p_create_info: *const IOSSurfaceCreateInfoMVK,
    p_allocator: ?*const AllocationCallbacks,
) CreateIosSurfaceMVKError!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = instance_dispatch.vkCreateIOSSurfaceMVK.?(
        instance,
        p_create_info,
        p_allocator,
        &out_surface,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_native_window_in_use_khr => return error.NativeWindowInUseKHR,
        else => return error.Unknown,
    }
    return out_surface;
}
pub const CreateMacOsSurfaceMVKError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    NativeWindowInUseKHR,
    Unknown,
};
pub fn createMacOsSurfaceMVK(
    instance: Instance,
    p_create_info: *const MacOSSurfaceCreateInfoMVK,
    p_allocator: ?*const AllocationCallbacks,
) CreateMacOsSurfaceMVKError!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = instance_dispatch.vkCreateMacOSSurfaceMVK.?(
        instance,
        p_create_info,
        p_allocator,
        &out_surface,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_native_window_in_use_khr => return error.NativeWindowInUseKHR,
        else => return error.Unknown,
    }
    return out_surface;
}
pub const CreateMetalSurfaceEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    NativeWindowInUseKHR,
    Unknown,
};
pub fn createMetalSurfaceEXT(
    instance: Instance,
    p_create_info: *const MetalSurfaceCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
) CreateMetalSurfaceEXTError!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = instance_dispatch.vkCreateMetalSurfaceEXT.?(
        instance,
        p_create_info,
        p_allocator,
        &out_surface,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_native_window_in_use_khr => return error.NativeWindowInUseKHR,
        else => return error.Unknown,
    }
    return out_surface;
}
pub fn getPhysicalDeviceMultisamplePropertiesEXT(
    physical_device: PhysicalDevice,
    samples: SampleCountFlags,
    p_multisample_properties: *MultisamplePropertiesEXT,
) void {
    instance_dispatch.vkGetPhysicalDeviceMultisamplePropertiesEXT.?(
        physical_device,
        samples,
        p_multisample_properties,
    );
}
pub const GetPhysicalDeviceSurfaceCapabilities2KHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    SurfaceLostKHR,
    Unknown,
};
pub fn getPhysicalDeviceSurfaceCapabilities2KHR(
    physical_device: PhysicalDevice,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    p_surface_capabilities: *SurfaceCapabilities2KHR,
) GetPhysicalDeviceSurfaceCapabilities2KHRError!void {
    const result = instance_dispatch.vkGetPhysicalDeviceSurfaceCapabilities2KHR.?(
        physical_device,
        p_surface_info,
        p_surface_capabilities,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
}
pub const GetPhysicalDeviceSurfaceFormats2KHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    SurfaceLostKHR,
    Unknown,
};
pub fn getPhysicalDeviceSurfaceFormats2KHR(
    physical_device: PhysicalDevice,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    p_surface_format_count: *u32,
    p_surface_formats: ?[*]SurfaceFormat2KHR,
) GetPhysicalDeviceSurfaceFormats2KHRError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceSurfaceFormats2KHR.?(
        physical_device,
        p_surface_info,
        p_surface_format_count,
        p_surface_formats,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDeviceSurfaceFormats2AllocKHRError =
    GetPhysicalDeviceSurfaceFormats2KHRError || Allocator.Error;
pub fn getPhysicalDeviceSurfaceFormats2AllocKHR(
    physical_device: PhysicalDevice,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    allocator: Allocator,
) GetPhysicalDeviceSurfaceFormats2AllocKHRError![]SurfaceFormat2KHR {
    var count: u32 = undefined;
    var data: []SurfaceFormat2KHR = &.{};
    errdefer allocator.free(data);
    var result = Result.incomplete;
    while (result == .incomplete) {
        _ = try getPhysicalDeviceSurfaceFormats2KHR(physical_device, p_surface_info, &count, null);
        data = try allocator.realloc(data, count);
        result = try getPhysicalDeviceSurfaceFormats2KHR(physical_device, p_surface_info, &count, data.ptr);
    }
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub const GetPhysicalDeviceDisplayProperties2KHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPhysicalDeviceDisplayProperties2KHR(
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]DisplayProperties2KHR,
) GetPhysicalDeviceDisplayProperties2KHRError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceDisplayProperties2KHR.?(
        physical_device,
        p_property_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDeviceDisplayPlaneProperties2KHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPhysicalDeviceDisplayPlaneProperties2KHR(
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]DisplayPlaneProperties2KHR,
) GetPhysicalDeviceDisplayPlaneProperties2KHRError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceDisplayPlaneProperties2KHR.?(
        physical_device,
        p_property_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetDisplayModeProperties2KHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getDisplayModeProperties2KHR(
    physical_device: PhysicalDevice,
    display: DisplayKHR,
    p_property_count: *u32,
    p_properties: ?[*]DisplayModeProperties2KHR,
) GetDisplayModeProperties2KHRError!Result {
    const result = instance_dispatch.vkGetDisplayModeProperties2KHR.?(
        physical_device,
        display,
        p_property_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetDisplayPlaneCapabilities2KHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getDisplayPlaneCapabilities2KHR(
    physical_device: PhysicalDevice,
    p_display_plane_info: *const DisplayPlaneInfo2KHR,
    p_capabilities: *DisplayPlaneCapabilities2KHR,
) GetDisplayPlaneCapabilities2KHRError!void {
    const result = instance_dispatch.vkGetDisplayPlaneCapabilities2KHR.?(
        physical_device,
        p_display_plane_info,
        p_capabilities,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const GetPhysicalDeviceCalibrateableTimeDomainsKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPhysicalDeviceCalibrateableTimeDomainsKHR(
    physical_device: PhysicalDevice,
    p_time_domain_count: *u32,
    p_time_domains: ?[*]TimeDomainKHR,
) GetPhysicalDeviceCalibrateableTimeDomainsKHRError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceCalibrateableTimeDomainsKHR.?(
        physical_device,
        p_time_domain_count,
        p_time_domains,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDeviceCalibrateableTimeDomainsAllocKHRError =
    GetPhysicalDeviceCalibrateableTimeDomainsKHRError || Allocator.Error;
pub fn getPhysicalDeviceCalibrateableTimeDomainsAllocKHR(
    physical_device: PhysicalDevice,
    allocator: Allocator,
) GetPhysicalDeviceCalibrateableTimeDomainsAllocKHRError![]TimeDomainKHR {
    var count: u32 = undefined;
    var data: []TimeDomainKHR = &.{};
    errdefer allocator.free(data);
    var result = Result.incomplete;
    while (result == .incomplete) {
        _ = try getPhysicalDeviceCalibrateableTimeDomainsKHR(physical_device, &count, null);
        data = try allocator.realloc(data, count);
        result = try getPhysicalDeviceCalibrateableTimeDomainsKHR(physical_device, &count, data.ptr);
    }
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub const GetPhysicalDeviceCalibrateableTimeDomainsEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPhysicalDeviceCalibrateableTimeDomainsEXT(
    physical_device: PhysicalDevice,
    p_time_domain_count: *u32,
    p_time_domains: ?[*]TimeDomainKHR,
) GetPhysicalDeviceCalibrateableTimeDomainsEXTError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.?(
        physical_device,
        p_time_domain_count,
        p_time_domains,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const CreateDebugUtilsMessengerEXTError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn createDebugUtilsMessengerEXT(
    instance: Instance,
    p_create_info: *const DebugUtilsMessengerCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
) CreateDebugUtilsMessengerEXTError!DebugUtilsMessengerEXT {
    var out_messenger: DebugUtilsMessengerEXT = undefined;
    const result = instance_dispatch.vkCreateDebugUtilsMessengerEXT.?(
        instance,
        p_create_info,
        p_allocator,
        &out_messenger,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_messenger;
}
pub fn destroyDebugUtilsMessengerEXT(
    instance: Instance,
    messenger: DebugUtilsMessengerEXT,
    p_allocator: ?*const AllocationCallbacks,
) void {
    instance_dispatch.vkDestroyDebugUtilsMessengerEXT.?(
        instance,
        messenger,
        p_allocator,
    );
}
pub fn submitDebugUtilsMessageEXT(
    instance: Instance,
    message_severity: DebugUtilsMessageSeverityFlagsEXT,
    message_types: DebugUtilsMessageTypeFlagsEXT,
    p_callback_data: *const DebugUtilsMessengerCallbackDataEXT,
) void {
    instance_dispatch.vkSubmitDebugUtilsMessageEXT.?(
        instance,
        message_severity,
        message_types,
        p_callback_data,
    );
}
pub const GetPhysicalDeviceCooperativeMatrixPropertiesNVError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPhysicalDeviceCooperativeMatrixPropertiesNV(
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]CooperativeMatrixPropertiesNV,
) GetPhysicalDeviceCooperativeMatrixPropertiesNVError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.?(
        physical_device,
        p_property_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDeviceSurfacePresentModes2EXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    SurfaceLostKHR,
    Unknown,
};
pub fn getPhysicalDeviceSurfacePresentModes2EXT(
    physical_device: PhysicalDevice,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    p_present_mode_count: *u32,
    p_present_modes: ?[*]PresentModeKHR,
) GetPhysicalDeviceSurfacePresentModes2EXTError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceSurfacePresentModes2EXT.?(
        physical_device,
        p_surface_info,
        p_present_mode_count,
        p_present_modes,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
    return result;
}
pub const EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InitializationFailed,
    Unknown,
};
pub fn enumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
    physical_device: PhysicalDevice,
    queue_family_index: u32,
    p_counter_count: *u32,
    p_counters: ?[*]PerformanceCounterKHR,
    p_counter_descriptions: ?[*]PerformanceCounterDescriptionKHR,
) EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHRError!Result {
    const result = instance_dispatch.vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.?(
        physical_device,
        queue_family_index,
        p_counter_count,
        p_counters,
        p_counter_descriptions,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
    return result;
}
pub fn getPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(
    physical_device: PhysicalDevice,
    p_performance_query_create_info: *const QueryPoolPerformanceCreateInfoKHR,
) u32 {
    var out_num_passes: u32 = undefined;
    instance_dispatch.vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR.?(
        physical_device,
        p_performance_query_create_info,
        &out_num_passes,
    );
    return out_num_passes;
}
pub const CreateHeadlessSurfaceEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createHeadlessSurfaceEXT(
    instance: Instance,
    p_create_info: *const HeadlessSurfaceCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
) CreateHeadlessSurfaceEXTError!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = instance_dispatch.vkCreateHeadlessSurfaceEXT.?(
        instance,
        p_create_info,
        p_allocator,
        &out_surface,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_surface;
}
pub const GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNVError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
    physical_device: PhysicalDevice,
    p_combination_count: *u32,
    p_combinations: ?[*]FramebufferMixedSamplesCombinationNV,
) GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNVError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.?(
        physical_device,
        p_combination_count,
        p_combinations,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDeviceToolPropertiesError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn getPhysicalDeviceToolProperties(
    physical_device: PhysicalDevice,
    p_tool_count: *u32,
    p_tool_properties: ?[*]PhysicalDeviceToolProperties,
) GetPhysicalDeviceToolPropertiesError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceToolProperties.?(
        physical_device,
        p_tool_count,
        p_tool_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDeviceToolPropertiesAllocError =
    GetPhysicalDeviceToolPropertiesError || Allocator.Error;
pub fn getPhysicalDeviceToolPropertiesAlloc(
    physical_device: PhysicalDevice,
    allocator: Allocator,
) GetPhysicalDeviceToolPropertiesAllocError![]PhysicalDeviceToolProperties {
    var count: u32 = undefined;
    var data: []PhysicalDeviceToolProperties = &.{};
    errdefer allocator.free(data);
    var result = Result.incomplete;
    while (result == .incomplete) {
        _ = try getPhysicalDeviceToolProperties(physical_device, &count, null);
        data = try allocator.realloc(data, count);
        result = try getPhysicalDeviceToolProperties(physical_device, &count, data.ptr);
    }
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub const GetPhysicalDeviceToolPropertiesEXTError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn getPhysicalDeviceToolPropertiesEXT(
    physical_device: PhysicalDevice,
    p_tool_count: *u32,
    p_tool_properties: ?[*]PhysicalDeviceToolProperties,
) GetPhysicalDeviceToolPropertiesEXTError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceToolPropertiesEXT.?(
        physical_device,
        p_tool_count,
        p_tool_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDeviceRefreshableObjectTypesKHRError = error{
    Unknown,
};
pub fn getPhysicalDeviceRefreshableObjectTypesKHR(
    physical_device: PhysicalDevice,
    p_refreshable_object_type_count: *u32,
    p_refreshable_object_types: ?[*]ObjectType,
) GetPhysicalDeviceRefreshableObjectTypesKHRError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceRefreshableObjectTypesKHR.?(
        physical_device,
        p_refreshable_object_type_count,
        p_refreshable_object_types,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDeviceFragmentShadingRatesKHRError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn getPhysicalDeviceFragmentShadingRatesKHR(
    physical_device: PhysicalDevice,
    p_fragment_shading_rate_count: *u32,
    p_fragment_shading_rates: ?[*]PhysicalDeviceFragmentShadingRateKHR,
) GetPhysicalDeviceFragmentShadingRatesKHRError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceFragmentShadingRatesKHR.?(
        physical_device,
        p_fragment_shading_rate_count,
        p_fragment_shading_rates,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDeviceVideoCapabilitiesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    VideoProfileOperationNotSupportedKHR,
    VideoProfileFormatNotSupportedKHR,
    VideoPictureLayoutNotSupportedKHR,
    VideoProfileCodecNotSupportedKHR,
    Unknown,
};
pub fn getPhysicalDeviceVideoCapabilitiesKHR(
    physical_device: PhysicalDevice,
    p_video_profile: *const VideoProfileInfoKHR,
    p_capabilities: *VideoCapabilitiesKHR,
) GetPhysicalDeviceVideoCapabilitiesKHRError!void {
    const result = instance_dispatch.vkGetPhysicalDeviceVideoCapabilitiesKHR.?(
        physical_device,
        p_video_profile,
        p_capabilities,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_video_profile_operation_not_supported_khr => return error.VideoProfileOperationNotSupportedKHR,
        Result.error_video_profile_format_not_supported_khr => return error.VideoProfileFormatNotSupportedKHR,
        Result.error_video_picture_layout_not_supported_khr => return error.VideoPictureLayoutNotSupportedKHR,
        Result.error_video_profile_codec_not_supported_khr => return error.VideoProfileCodecNotSupportedKHR,
        else => return error.Unknown,
    }
}
pub const GetPhysicalDeviceVideoFormatPropertiesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    ImageUsageNotSupportedKHR,
    VideoProfileOperationNotSupportedKHR,
    VideoProfileFormatNotSupportedKHR,
    VideoPictureLayoutNotSupportedKHR,
    VideoProfileCodecNotSupportedKHR,
    Unknown,
};
pub fn getPhysicalDeviceVideoFormatPropertiesKHR(
    physical_device: PhysicalDevice,
    p_video_format_info: *const PhysicalDeviceVideoFormatInfoKHR,
    p_video_format_property_count: *u32,
    p_video_format_properties: ?[*]VideoFormatPropertiesKHR,
) GetPhysicalDeviceVideoFormatPropertiesKHRError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceVideoFormatPropertiesKHR.?(
        physical_device,
        p_video_format_info,
        p_video_format_property_count,
        p_video_format_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_image_usage_not_supported_khr => return error.ImageUsageNotSupportedKHR,
        Result.error_video_profile_operation_not_supported_khr => return error.VideoProfileOperationNotSupportedKHR,
        Result.error_video_profile_format_not_supported_khr => return error.VideoProfileFormatNotSupportedKHR,
        Result.error_video_picture_layout_not_supported_khr => return error.VideoPictureLayoutNotSupportedKHR,
        Result.error_video_profile_codec_not_supported_khr => return error.VideoProfileCodecNotSupportedKHR,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    VideoProfileOperationNotSupportedKHR,
    VideoProfileFormatNotSupportedKHR,
    VideoPictureLayoutNotSupportedKHR,
    VideoProfileCodecNotSupportedKHR,
    Unknown,
};
pub fn getPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(
    physical_device: PhysicalDevice,
    p_quality_level_info: *const PhysicalDeviceVideoEncodeQualityLevelInfoKHR,
    p_quality_level_properties: *VideoEncodeQualityLevelPropertiesKHR,
) GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHRError!void {
    const result = instance_dispatch.vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR.?(
        physical_device,
        p_quality_level_info,
        p_quality_level_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_video_profile_operation_not_supported_khr => return error.VideoProfileOperationNotSupportedKHR,
        Result.error_video_profile_format_not_supported_khr => return error.VideoProfileFormatNotSupportedKHR,
        Result.error_video_picture_layout_not_supported_khr => return error.VideoPictureLayoutNotSupportedKHR,
        Result.error_video_profile_codec_not_supported_khr => return error.VideoProfileCodecNotSupportedKHR,
        else => return error.Unknown,
    }
}
pub const AcquireDrmDisplayEXTError = error{
    InitializationFailed,
    Unknown,
};
pub fn acquireDrmDisplayEXT(
    physical_device: PhysicalDevice,
    drm_fd: i32,
    display: DisplayKHR,
) AcquireDrmDisplayEXTError!void {
    const result = instance_dispatch.vkAcquireDrmDisplayEXT.?(
        physical_device,
        drm_fd,
        display,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
}
pub const GetDrmDisplayEXTError = error{
    InitializationFailed,
    OutOfHostMemory,
    Unknown,
};
pub fn getDrmDisplayEXT(
    physical_device: PhysicalDevice,
    drm_fd: i32,
    connector_id: u32,
) GetDrmDisplayEXTError!DisplayKHR {
    var out_display: DisplayKHR = undefined;
    const result = instance_dispatch.vkGetDrmDisplayEXT.?(
        physical_device,
        drm_fd,
        connector_id,
        &out_display,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_display;
}
pub const GetPhysicalDeviceOpticalFlowImageFormatsNVError = error{
    ExtensionNotPresent,
    InitializationFailed,
    FormatNotSupported,
    Unknown,
};
pub fn getPhysicalDeviceOpticalFlowImageFormatsNV(
    physical_device: PhysicalDevice,
    p_optical_flow_image_format_info: *const OpticalFlowImageFormatInfoNV,
    p_format_count: *u32,
    p_image_format_properties: ?[*]OpticalFlowImageFormatPropertiesNV,
) GetPhysicalDeviceOpticalFlowImageFormatsNVError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceOpticalFlowImageFormatsNV.?(
        physical_device,
        p_optical_flow_image_format_info,
        p_format_count,
        p_image_format_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_extension_not_present => return error.ExtensionNotPresent,
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_format_not_supported => return error.FormatNotSupported,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDeviceCooperativeMatrixPropertiesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPhysicalDeviceCooperativeMatrixPropertiesKHR(
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]CooperativeMatrixPropertiesKHR,
) GetPhysicalDeviceCooperativeMatrixPropertiesKHRError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR.?(
        physical_device,
        p_property_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNVError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]CooperativeMatrixFlexibleDimensionsPropertiesNV,
) GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNVError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV.?(
        physical_device,
        p_property_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPhysicalDeviceCooperativeVectorPropertiesNVError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPhysicalDeviceCooperativeVectorPropertiesNV(
    physical_device: PhysicalDevice,
    p_property_count: *u32,
    p_properties: ?[*]CooperativeVectorPropertiesNV,
) GetPhysicalDeviceCooperativeVectorPropertiesNVError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceCooperativeVectorPropertiesNV.?(
        physical_device,
        p_property_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn getExternalComputeQueueDataNV(
    external_queue: ExternalComputeQueueNV,
    params: *ExternalComputeQueueDataParamsNV,
    p_data: *anyopaque,
) void {
    instance_dispatch.vkGetExternalComputeQueueDataNV.?(
        external_queue,
        params,
        p_data,
    );
}
pub fn getPhysicalDeviceExternalTensorPropertiesARM(
    physical_device: PhysicalDevice,
    p_external_tensor_info: *const PhysicalDeviceExternalTensorInfoARM,
    p_external_tensor_properties: *ExternalTensorPropertiesARM,
) void {
    instance_dispatch.vkGetPhysicalDeviceExternalTensorPropertiesARM.?(
        physical_device,
        p_external_tensor_info,
        p_external_tensor_properties,
    );
}
pub const GetPhysicalDeviceQueueFamilyDataGraphPropertiesARMError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPhysicalDeviceQueueFamilyDataGraphPropertiesARM(
    physical_device: PhysicalDevice,
    queue_family_index: u32,
    p_queue_family_data_graph_property_count: *u32,
    p_queue_family_data_graph_properties: ?[*]QueueFamilyDataGraphPropertiesARM,
) GetPhysicalDeviceQueueFamilyDataGraphPropertiesARMError!Result {
    const result = instance_dispatch.vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM.?(
        physical_device,
        queue_family_index,
        p_queue_family_data_graph_property_count,
        p_queue_family_data_graph_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn getPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(
    physical_device: PhysicalDevice,
    p_queue_family_data_graph_processing_engine_info: *const PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM,
    p_queue_family_data_graph_processing_engine_properties: *QueueFamilyDataGraphProcessingEnginePropertiesARM,
) void {
    instance_dispatch.vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM.?(
        physical_device,
        p_queue_family_data_graph_processing_engine_info,
        p_queue_family_data_graph_processing_engine_properties,
    );
}
var device_dispatch: DeviceDispatch = undefined;
var device_wrapper: DeviceWrapper = .{};
const DeviceWrapper = DeviceWrapperWithCustomDispatch(DeviceDispatch);
fn DeviceWrapperWithCustomDispatch(DispatchType: type) type {
    return struct {
        const Self = @This();
        pub const Dispatch = DispatchType;

        dispatch: *DeviceDispatch = &device_dispatch,
        pub fn load(self: *Self, device: Device, loader: anytype) void {
            inline for (std.meta.fields(Dispatch)) |field| {
                const cmd_ptr = loader(device, field.name.ptr) orelse undefined;
                @field(self.dispatch, field.name) = @ptrCast(cmd_ptr);
            }
        }
    };
}
pub fn destroyDevice(
    device: Device,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyDevice.?(
        device,
        p_allocator,
    );
}
pub fn getDeviceQueue(
    device: Device,
    queue_family_index: u32,
    queue_index: u32,
) Queue {
    var out_queue: Queue = undefined;
    device_dispatch.vkGetDeviceQueue.?(
        device,
        queue_family_index,
        queue_index,
        &out_queue,
    );
    return out_queue;
}
pub const QueueSubmitError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    Unknown,
};
pub fn queueSubmit(
    queue: Queue,
    submit_count: u32,
    p_submits: ?[*]const SubmitInfo,
    fence: Fence,
) QueueSubmitError!void {
    const result = device_dispatch.vkQueueSubmit.?(
        queue,
        submit_count,
        p_submits,
        fence,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        else => return error.Unknown,
    }
}
pub const QueueWaitIdleError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    Unknown,
};
pub fn queueWaitIdle(
    queue: Queue,
) QueueWaitIdleError!void {
    const result = device_dispatch.vkQueueWaitIdle.?(
        queue,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        else => return error.Unknown,
    }
}
pub const DeviceWaitIdleError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    Unknown,
};
pub fn deviceWaitIdle(
    device: Device,
) DeviceWaitIdleError!void {
    const result = device_dispatch.vkDeviceWaitIdle.?(
        device,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        else => return error.Unknown,
    }
}
pub const AllocateMemoryError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InvalidExternalHandle,
    InvalidOpaqueCaptureAddressKHR,
    Unknown,
};
pub fn allocateMemory(
    device: Device,
    p_allocate_info: *const MemoryAllocateInfo,
    p_allocator: ?*const AllocationCallbacks,
) AllocateMemoryError!DeviceMemory {
    var out_memory: DeviceMemory = undefined;
    const result = device_dispatch.vkAllocateMemory.?(
        device,
        p_allocate_info,
        p_allocator,
        &out_memory,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        Result.error_invalid_opaque_capture_address_khr => return error.InvalidOpaqueCaptureAddressKHR,
        else => return error.Unknown,
    }
    return out_memory;
}
pub fn freeMemory(
    device: Device,
    memory: DeviceMemory,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkFreeMemory.?(
        device,
        memory,
        p_allocator,
    );
}
pub const MapMemoryError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    MemoryMapFailed,
    Unknown,
};
pub fn mapMemory(
    device: Device,
    memory: DeviceMemory,
    offset: DeviceSize,
    size: DeviceSize,
    flags: MemoryMapFlags,
) MapMemoryError!?*anyopaque {
    var out_pp_data: ?*anyopaque = undefined;
    const result = device_dispatch.vkMapMemory.?(
        device,
        memory,
        offset,
        size,
        flags,
        &out_pp_data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_memory_map_failed => return error.MemoryMapFailed,
        else => return error.Unknown,
    }
    return out_pp_data;
}
pub fn unmapMemory(
    device: Device,
    memory: DeviceMemory,
) void {
    device_dispatch.vkUnmapMemory.?(
        device,
        memory,
    );
}
pub const FlushMappedMemoryRangesError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn flushMappedMemoryRanges(
    device: Device,
    memory_range_count: u32,
    p_memory_ranges: [*]const MappedMemoryRange,
) FlushMappedMemoryRangesError!void {
    const result = device_dispatch.vkFlushMappedMemoryRanges.?(
        device,
        memory_range_count,
        p_memory_ranges,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const InvalidateMappedMemoryRangesError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn invalidateMappedMemoryRanges(
    device: Device,
    memory_range_count: u32,
    p_memory_ranges: [*]const MappedMemoryRange,
) InvalidateMappedMemoryRangesError!void {
    const result = device_dispatch.vkInvalidateMappedMemoryRanges.?(
        device,
        memory_range_count,
        p_memory_ranges,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub fn getDeviceMemoryCommitment(
    device: Device,
    memory: DeviceMemory,
) DeviceSize {
    var out_committed_memory_in_bytes: DeviceSize = undefined;
    device_dispatch.vkGetDeviceMemoryCommitment.?(
        device,
        memory,
        &out_committed_memory_in_bytes,
    );
    return out_committed_memory_in_bytes;
}
pub fn getBufferMemoryRequirements(
    device: Device,
    buffer: Buffer,
) MemoryRequirements {
    var out_memory_requirements: MemoryRequirements = undefined;
    device_dispatch.vkGetBufferMemoryRequirements.?(
        device,
        buffer,
        &out_memory_requirements,
    );
    return out_memory_requirements;
}
pub const BindBufferMemoryError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InvalidOpaqueCaptureAddressKHR,
    Unknown,
};
pub fn bindBufferMemory(
    device: Device,
    buffer: Buffer,
    memory: DeviceMemory,
    memory_offset: DeviceSize,
) BindBufferMemoryError!void {
    const result = device_dispatch.vkBindBufferMemory.?(
        device,
        buffer,
        memory,
        memory_offset,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_invalid_opaque_capture_address_khr => return error.InvalidOpaqueCaptureAddressKHR,
        else => return error.Unknown,
    }
}
pub fn getImageMemoryRequirements(
    device: Device,
    image: Image,
) MemoryRequirements {
    var out_memory_requirements: MemoryRequirements = undefined;
    device_dispatch.vkGetImageMemoryRequirements.?(
        device,
        image,
        &out_memory_requirements,
    );
    return out_memory_requirements;
}
pub const BindImageMemoryError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn bindImageMemory(
    device: Device,
    image: Image,
    memory: DeviceMemory,
    memory_offset: DeviceSize,
) BindImageMemoryError!void {
    const result = device_dispatch.vkBindImageMemory.?(
        device,
        image,
        memory,
        memory_offset,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub fn getImageSparseMemoryRequirements(
    device: Device,
    image: Image,
    p_sparse_memory_requirement_count: *u32,
    p_sparse_memory_requirements: ?[*]SparseImageMemoryRequirements,
) void {
    device_dispatch.vkGetImageSparseMemoryRequirements.?(
        device,
        image,
        p_sparse_memory_requirement_count,
        p_sparse_memory_requirements,
    );
}
pub fn getImageSparseMemoryRequirementsAlloc(
    device: Device,
    image: Image,
    allocator: Allocator,
) Allocator.Error![]SparseImageMemoryRequirements {
    var count: u32 = undefined;
    getImageSparseMemoryRequirements(device, image, &count, null);
    const data = try allocator.alloc(SparseImageMemoryRequirements, count);
    errdefer allocator.free(data);
    getImageSparseMemoryRequirements(device, image, &count, data.ptr);
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub const QueueBindSparseError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    Unknown,
};
pub fn queueBindSparse(
    queue: Queue,
    bind_info_count: u32,
    p_bind_info: ?[*]const BindSparseInfo,
    fence: Fence,
) QueueBindSparseError!void {
    const result = device_dispatch.vkQueueBindSparse.?(
        queue,
        bind_info_count,
        p_bind_info,
        fence,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        else => return error.Unknown,
    }
}
pub const CreateFenceError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createFence(
    device: Device,
    p_create_info: *const FenceCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateFenceError!Fence {
    var out_fence: Fence = undefined;
    const result = device_dispatch.vkCreateFence.?(
        device,
        p_create_info,
        p_allocator,
        &out_fence,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_fence;
}
pub fn destroyFence(
    device: Device,
    fence: Fence,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyFence.?(
        device,
        fence,
        p_allocator,
    );
}
pub const ResetFencesError = error{
    OutOfDeviceMemory,
    Unknown,
};
pub fn resetFences(
    device: Device,
    fence_count: u32,
    p_fences: [*]const Fence,
) ResetFencesError!void {
    const result = device_dispatch.vkResetFences.?(
        device,
        fence_count,
        p_fences,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const GetFenceStatusError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    Unknown,
};
pub fn getFenceStatus(
    device: Device,
    fence: Fence,
) GetFenceStatusError!Result {
    const result = device_dispatch.vkGetFenceStatus.?(
        device,
        fence,
    );
    switch (result) {
        Result.success => {},
        Result.not_ready => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        else => return error.Unknown,
    }
    return result;
}
pub const WaitForFencesError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    Unknown,
};
pub fn waitForFences(
    device: Device,
    fence_count: u32,
    p_fences: [*]const Fence,
    wait_all: Bool32,
    timeout: u64,
) WaitForFencesError!Result {
    const result = device_dispatch.vkWaitForFences.?(
        device,
        fence_count,
        p_fences,
        wait_all,
        timeout,
    );
    switch (result) {
        Result.success => {},
        Result.timeout => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        else => return error.Unknown,
    }
    return result;
}
pub const CreateSemaphoreError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createSemaphore(
    device: Device,
    p_create_info: *const SemaphoreCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateSemaphoreError!Semaphore {
    var out_semaphore: Semaphore = undefined;
    const result = device_dispatch.vkCreateSemaphore.?(
        device,
        p_create_info,
        p_allocator,
        &out_semaphore,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_semaphore;
}
pub fn destroySemaphore(
    device: Device,
    semaphore: Semaphore,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroySemaphore.?(
        device,
        semaphore,
        p_allocator,
    );
}
pub const CreateEventError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createEvent(
    device: Device,
    p_create_info: *const EventCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateEventError!Event {
    var out_event: Event = undefined;
    const result = device_dispatch.vkCreateEvent.?(
        device,
        p_create_info,
        p_allocator,
        &out_event,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_event;
}
pub fn destroyEvent(
    device: Device,
    event: Event,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyEvent.?(
        device,
        event,
        p_allocator,
    );
}
pub const GetEventStatusError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    Unknown,
};
pub fn getEventStatus(
    device: Device,
    event: Event,
) GetEventStatusError!Result {
    const result = device_dispatch.vkGetEventStatus.?(
        device,
        event,
    );
    switch (result) {
        Result.event_set => {},
        Result.event_reset => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        else => return error.Unknown,
    }
    return result;
}
pub const SetEventError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn setEvent(
    device: Device,
    event: Event,
) SetEventError!void {
    const result = device_dispatch.vkSetEvent.?(
        device,
        event,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const ResetEventError = error{
    OutOfDeviceMemory,
    Unknown,
};
pub fn resetEvent(
    device: Device,
    event: Event,
) ResetEventError!void {
    const result = device_dispatch.vkResetEvent.?(
        device,
        event,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const CreateQueryPoolError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createQueryPool(
    device: Device,
    p_create_info: *const QueryPoolCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateQueryPoolError!QueryPool {
    var out_query_pool: QueryPool = undefined;
    const result = device_dispatch.vkCreateQueryPool.?(
        device,
        p_create_info,
        p_allocator,
        &out_query_pool,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_query_pool;
}
pub fn destroyQueryPool(
    device: Device,
    query_pool: QueryPool,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyQueryPool.?(
        device,
        query_pool,
        p_allocator,
    );
}
pub const GetQueryPoolResultsError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    Unknown,
};
pub fn getQueryPoolResults(
    device: Device,
    query_pool: QueryPool,
    first_query: u32,
    query_count: u32,
    data_size: usize,
    p_data: *anyopaque,
    stride: DeviceSize,
    flags: QueryResultFlags,
) GetQueryPoolResultsError!Result {
    const result = device_dispatch.vkGetQueryPoolResults.?(
        device,
        query_pool,
        first_query,
        query_count,
        data_size,
        p_data,
        stride,
        flags,
    );
    switch (result) {
        Result.success => {},
        Result.not_ready => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        else => return error.Unknown,
    }
    return result;
}
pub fn resetQueryPool(
    device: Device,
    query_pool: QueryPool,
    first_query: u32,
    query_count: u32,
) void {
    device_dispatch.vkResetQueryPool.?(
        device,
        query_pool,
        first_query,
        query_count,
    );
}
pub fn resetQueryPoolEXT(
    device: Device,
    query_pool: QueryPool,
    first_query: u32,
    query_count: u32,
) void {
    device_dispatch.vkResetQueryPoolEXT.?(
        device,
        query_pool,
        first_query,
        query_count,
    );
}
pub const CreateBufferError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InvalidOpaqueCaptureAddressKHR,
    Unknown,
};
pub fn createBuffer(
    device: Device,
    p_create_info: *const BufferCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateBufferError!Buffer {
    var out_buffer: Buffer = undefined;
    const result = device_dispatch.vkCreateBuffer.?(
        device,
        p_create_info,
        p_allocator,
        &out_buffer,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_invalid_opaque_capture_address_khr => return error.InvalidOpaqueCaptureAddressKHR,
        else => return error.Unknown,
    }
    return out_buffer;
}
pub fn destroyBuffer(
    device: Device,
    buffer: Buffer,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyBuffer.?(
        device,
        buffer,
        p_allocator,
    );
}
pub const CreateBufferViewError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createBufferView(
    device: Device,
    p_create_info: *const BufferViewCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateBufferViewError!BufferView {
    var out_view: BufferView = undefined;
    const result = device_dispatch.vkCreateBufferView.?(
        device,
        p_create_info,
        p_allocator,
        &out_view,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_view;
}
pub fn destroyBufferView(
    device: Device,
    buffer_view: BufferView,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyBufferView.?(
        device,
        buffer_view,
        p_allocator,
    );
}
pub const CreateImageError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    CompressionExhaustedEXT,
    InvalidOpaqueCaptureAddressKHR,
    Unknown,
};
pub fn createImage(
    device: Device,
    p_create_info: *const ImageCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateImageError!Image {
    var out_image: Image = undefined;
    const result = device_dispatch.vkCreateImage.?(
        device,
        p_create_info,
        p_allocator,
        &out_image,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_compression_exhausted_ext => return error.CompressionExhaustedEXT,
        Result.error_invalid_opaque_capture_address_khr => return error.InvalidOpaqueCaptureAddressKHR,
        else => return error.Unknown,
    }
    return out_image;
}
pub fn destroyImage(
    device: Device,
    image: Image,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyImage.?(
        device,
        image,
        p_allocator,
    );
}
pub fn getImageSubresourceLayout(
    device: Device,
    image: Image,
    p_subresource: *const ImageSubresource,
) SubresourceLayout {
    var out_layout: SubresourceLayout = undefined;
    device_dispatch.vkGetImageSubresourceLayout.?(
        device,
        image,
        p_subresource,
        &out_layout,
    );
    return out_layout;
}
pub const CreateImageViewError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InvalidOpaqueCaptureAddressKHR,
    Unknown,
};
pub fn createImageView(
    device: Device,
    p_create_info: *const ImageViewCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateImageViewError!ImageView {
    var out_view: ImageView = undefined;
    const result = device_dispatch.vkCreateImageView.?(
        device,
        p_create_info,
        p_allocator,
        &out_view,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_invalid_opaque_capture_address_khr => return error.InvalidOpaqueCaptureAddressKHR,
        else => return error.Unknown,
    }
    return out_view;
}
pub fn destroyImageView(
    device: Device,
    image_view: ImageView,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyImageView.?(
        device,
        image_view,
        p_allocator,
    );
}
pub const CreateShaderModuleError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InvalidShaderNV,
    Unknown,
};
pub fn createShaderModule(
    device: Device,
    p_create_info: *const ShaderModuleCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateShaderModuleError!ShaderModule {
    var out_shader_module: ShaderModule = undefined;
    const result = device_dispatch.vkCreateShaderModule.?(
        device,
        p_create_info,
        p_allocator,
        &out_shader_module,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_invalid_shader_nv => return error.InvalidShaderNV,
        else => return error.Unknown,
    }
    return out_shader_module;
}
pub fn destroyShaderModule(
    device: Device,
    shader_module: ShaderModule,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyShaderModule.?(
        device,
        shader_module,
        p_allocator,
    );
}
pub const CreatePipelineCacheError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createPipelineCache(
    device: Device,
    p_create_info: *const PipelineCacheCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreatePipelineCacheError!PipelineCache {
    var out_pipeline_cache: PipelineCache = undefined;
    const result = device_dispatch.vkCreatePipelineCache.?(
        device,
        p_create_info,
        p_allocator,
        &out_pipeline_cache,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_pipeline_cache;
}
pub fn destroyPipelineCache(
    device: Device,
    pipeline_cache: PipelineCache,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyPipelineCache.?(
        device,
        pipeline_cache,
        p_allocator,
    );
}
pub const GetPipelineCacheDataError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPipelineCacheData(
    device: Device,
    pipeline_cache: PipelineCache,
    p_data_size: *usize,
    p_data: ?*anyopaque,
) GetPipelineCacheDataError!Result {
    const result = device_dispatch.vkGetPipelineCacheData.?(
        device,
        pipeline_cache,
        p_data_size,
        p_data,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPipelineCacheDataAllocError =
    GetPipelineCacheDataError || Allocator.Error;
pub fn getPipelineCacheDataAlloc(
    device: Device,
    pipeline_cache: PipelineCache,
    allocator: Allocator,
) GetPipelineCacheDataAllocError![]void {
    var count: u32 = undefined;
    var data: []void = &.{};
    errdefer allocator.free(data);
    var result = Result.incomplete;
    while (result == .incomplete) {
        _ = try getPipelineCacheData(device, pipeline_cache, &count, null);
        data = try allocator.realloc(data, count);
        result = try getPipelineCacheData(device, pipeline_cache, &count, data.ptr);
    }
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub const MergePipelineCachesError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn mergePipelineCaches(
    device: Device,
    dst_cache: PipelineCache,
    src_cache_count: u32,
    p_src_caches: [*]const PipelineCache,
) MergePipelineCachesError!void {
    const result = device_dispatch.vkMergePipelineCaches.?(
        device,
        dst_cache,
        src_cache_count,
        p_src_caches,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const CreatePipelineBinariesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InitializationFailed,
    Unknown,
};
pub fn createPipelineBinariesKHR(
    device: Device,
    p_create_info: *const PipelineBinaryCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_binaries: *PipelineBinaryHandlesInfoKHR,
) CreatePipelineBinariesKHRError!Result {
    const result = device_dispatch.vkCreatePipelineBinariesKHR.?(
        device,
        p_create_info,
        p_allocator,
        p_binaries,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.pipeline_binary_missing_khr => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
    return result;
}
pub fn destroyPipelineBinaryKHR(
    device: Device,
    pipeline_binary: PipelineBinaryKHR,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyPipelineBinaryKHR.?(
        device,
        pipeline_binary,
        p_allocator,
    );
}
pub const GetPipelineKeyKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPipelineKeyKHR(
    device: Device,
    p_pipeline_create_info: ?*const PipelineCreateInfoKHR,
    p_pipeline_key: *PipelineBinaryKeyKHR,
) GetPipelineKeyKHRError!void {
    const result = device_dispatch.vkGetPipelineKeyKHR.?(
        device,
        p_pipeline_create_info,
        p_pipeline_key,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const GetPipelineBinaryDataKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    NotEnoughSpaceKHR,
    Unknown,
};
pub fn getPipelineBinaryDataKHR(
    device: Device,
    p_info: *const PipelineBinaryDataInfoKHR,
    p_pipeline_binary_key: *PipelineBinaryKeyKHR,
    p_pipeline_binary_data_size: *usize,
    p_pipeline_binary_data: ?*anyopaque,
) GetPipelineBinaryDataKHRError!void {
    const result = device_dispatch.vkGetPipelineBinaryDataKHR.?(
        device,
        p_info,
        p_pipeline_binary_key,
        p_pipeline_binary_data_size,
        p_pipeline_binary_data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_not_enough_space_khr => return error.NotEnoughSpaceKHR,
        else => return error.Unknown,
    }
}
pub const ReleaseCapturedPipelineDataKHRError = error{
    Unknown,
};
pub fn releaseCapturedPipelineDataKHR(
    device: Device,
    p_info: *const ReleaseCapturedPipelineDataInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
) ReleaseCapturedPipelineDataKHRError!void {
    const result = device_dispatch.vkReleaseCapturedPipelineDataKHR.?(
        device,
        p_info,
        p_allocator,
    );
    switch (result) {
        Result.success => {},
        else => return error.Unknown,
    }
}
pub const CreateGraphicsPipelinesError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InvalidShaderNV,
    Unknown,
};
pub fn createGraphicsPipelines(
    device: Device,
    pipeline_cache: PipelineCache,
    create_info_count: u32,
    p_create_infos: [*]const GraphicsPipelineCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_pipelines: [*]Pipeline,
) CreateGraphicsPipelinesError!Result {
    const result = device_dispatch.vkCreateGraphicsPipelines.?(
        device,
        pipeline_cache,
        create_info_count,
        p_create_infos,
        p_allocator,
        p_pipelines,
    );
    switch (result) {
        Result.success => {},
        Result.pipeline_compile_required_ext => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_invalid_shader_nv => return error.InvalidShaderNV,
        else => return error.Unknown,
    }
    return result;
}
pub const CreateComputePipelinesError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InvalidShaderNV,
    Unknown,
};
pub fn createComputePipelines(
    device: Device,
    pipeline_cache: PipelineCache,
    create_info_count: u32,
    p_create_infos: [*]const ComputePipelineCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
    p_pipelines: [*]Pipeline,
) CreateComputePipelinesError!Result {
    const result = device_dispatch.vkCreateComputePipelines.?(
        device,
        pipeline_cache,
        create_info_count,
        p_create_infos,
        p_allocator,
        p_pipelines,
    );
    switch (result) {
        Result.success => {},
        Result.pipeline_compile_required_ext => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_invalid_shader_nv => return error.InvalidShaderNV,
        else => return error.Unknown,
    }
    return result;
}
pub const GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEIError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    SurfaceLostKHR,
    Unknown,
};
pub fn getDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(
    device: Device,
    renderpass: RenderPass,
    p_max_workgroup_size: [*]Extent2D,
) GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEIError!void {
    const result = device_dispatch.vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.?(
        device,
        renderpass,
        p_max_workgroup_size,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
}
pub fn destroyPipeline(
    device: Device,
    pipeline: Pipeline,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyPipeline.?(
        device,
        pipeline,
        p_allocator,
    );
}
pub const CreatePipelineLayoutError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createPipelineLayout(
    device: Device,
    p_create_info: *const PipelineLayoutCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreatePipelineLayoutError!PipelineLayout {
    var out_pipeline_layout: PipelineLayout = undefined;
    const result = device_dispatch.vkCreatePipelineLayout.?(
        device,
        p_create_info,
        p_allocator,
        &out_pipeline_layout,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_pipeline_layout;
}
pub fn destroyPipelineLayout(
    device: Device,
    pipeline_layout: PipelineLayout,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyPipelineLayout.?(
        device,
        pipeline_layout,
        p_allocator,
    );
}
pub const CreateSamplerError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InvalidOpaqueCaptureAddressKHR,
    Unknown,
};
pub fn createSampler(
    device: Device,
    p_create_info: *const SamplerCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateSamplerError!Sampler {
    var out_sampler: Sampler = undefined;
    const result = device_dispatch.vkCreateSampler.?(
        device,
        p_create_info,
        p_allocator,
        &out_sampler,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_invalid_opaque_capture_address_khr => return error.InvalidOpaqueCaptureAddressKHR,
        else => return error.Unknown,
    }
    return out_sampler;
}
pub fn destroySampler(
    device: Device,
    sampler: Sampler,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroySampler.?(
        device,
        sampler,
        p_allocator,
    );
}
pub const CreateDescriptorSetLayoutError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createDescriptorSetLayout(
    device: Device,
    p_create_info: *const DescriptorSetLayoutCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateDescriptorSetLayoutError!DescriptorSetLayout {
    var out_set_layout: DescriptorSetLayout = undefined;
    const result = device_dispatch.vkCreateDescriptorSetLayout.?(
        device,
        p_create_info,
        p_allocator,
        &out_set_layout,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_set_layout;
}
pub fn destroyDescriptorSetLayout(
    device: Device,
    descriptor_set_layout: DescriptorSetLayout,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyDescriptorSetLayout.?(
        device,
        descriptor_set_layout,
        p_allocator,
    );
}
pub const CreateDescriptorPoolError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    FragmentationEXT,
    Unknown,
};
pub fn createDescriptorPool(
    device: Device,
    p_create_info: *const DescriptorPoolCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateDescriptorPoolError!DescriptorPool {
    var out_descriptor_pool: DescriptorPool = undefined;
    const result = device_dispatch.vkCreateDescriptorPool.?(
        device,
        p_create_info,
        p_allocator,
        &out_descriptor_pool,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_fragmentation_ext => return error.FragmentationEXT,
        else => return error.Unknown,
    }
    return out_descriptor_pool;
}
pub fn destroyDescriptorPool(
    device: Device,
    descriptor_pool: DescriptorPool,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyDescriptorPool.?(
        device,
        descriptor_pool,
        p_allocator,
    );
}
pub const ResetDescriptorPoolError = error{
    Unknown,
};
pub fn resetDescriptorPool(
    device: Device,
    descriptor_pool: DescriptorPool,
    flags: DescriptorPoolResetFlags,
) ResetDescriptorPoolError!void {
    const result = device_dispatch.vkResetDescriptorPool.?(
        device,
        descriptor_pool,
        flags,
    );
    switch (result) {
        Result.success => {},
        else => return error.Unknown,
    }
}
pub const AllocateDescriptorSetsError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    FragmentedPool,
    OutOfPoolMemory,
    Unknown,
};
pub fn allocateDescriptorSets(
    device: Device,
    p_allocate_info: *const DescriptorSetAllocateInfo,
    p_descriptor_sets: [*]DescriptorSet,
) AllocateDescriptorSetsError!void {
    const result = device_dispatch.vkAllocateDescriptorSets.?(
        device,
        p_allocate_info,
        p_descriptor_sets,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_fragmented_pool => return error.FragmentedPool,
        Result.error_out_of_pool_memory => return error.OutOfPoolMemory,
        else => return error.Unknown,
    }
}
pub const FreeDescriptorSetsError = error{
    Unknown,
};
pub fn freeDescriptorSets(
    device: Device,
    descriptor_pool: DescriptorPool,
    descriptor_set_count: u32,
    p_descriptor_sets: [*]const DescriptorSet,
) FreeDescriptorSetsError!void {
    const result = device_dispatch.vkFreeDescriptorSets.?(
        device,
        descriptor_pool,
        descriptor_set_count,
        p_descriptor_sets,
    );
    switch (result) {
        Result.success => {},
        else => return error.Unknown,
    }
}
pub fn updateDescriptorSets(
    device: Device,
    descriptor_write_count: u32,
    p_descriptor_writes: ?[*]const WriteDescriptorSet,
    descriptor_copy_count: u32,
    p_descriptor_copies: ?[*]const CopyDescriptorSet,
) void {
    device_dispatch.vkUpdateDescriptorSets.?(
        device,
        descriptor_write_count,
        p_descriptor_writes,
        descriptor_copy_count,
        p_descriptor_copies,
    );
}
pub const CreateFramebufferError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createFramebuffer(
    device: Device,
    p_create_info: *const FramebufferCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateFramebufferError!Framebuffer {
    var out_framebuffer: Framebuffer = undefined;
    const result = device_dispatch.vkCreateFramebuffer.?(
        device,
        p_create_info,
        p_allocator,
        &out_framebuffer,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_framebuffer;
}
pub fn destroyFramebuffer(
    device: Device,
    framebuffer: Framebuffer,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyFramebuffer.?(
        device,
        framebuffer,
        p_allocator,
    );
}
pub const CreateRenderPassError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createRenderPass(
    device: Device,
    p_create_info: *const RenderPassCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateRenderPassError!RenderPass {
    var out_render_pass: RenderPass = undefined;
    const result = device_dispatch.vkCreateRenderPass.?(
        device,
        p_create_info,
        p_allocator,
        &out_render_pass,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_render_pass;
}
pub fn destroyRenderPass(
    device: Device,
    render_pass: RenderPass,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyRenderPass.?(
        device,
        render_pass,
        p_allocator,
    );
}
pub fn getRenderAreaGranularity(
    device: Device,
    render_pass: RenderPass,
) Extent2D {
    var out_granularity: Extent2D = undefined;
    device_dispatch.vkGetRenderAreaGranularity.?(
        device,
        render_pass,
        &out_granularity,
    );
    return out_granularity;
}
pub fn getRenderingAreaGranularity(
    device: Device,
    p_rendering_area_info: *const RenderingAreaInfo,
) Extent2D {
    var out_granularity: Extent2D = undefined;
    device_dispatch.vkGetRenderingAreaGranularity.?(
        device,
        p_rendering_area_info,
        &out_granularity,
    );
    return out_granularity;
}
pub fn getRenderingAreaGranularityKHR(
    device: Device,
    p_rendering_area_info: *const RenderingAreaInfo,
) Extent2D {
    var out_granularity: Extent2D = undefined;
    device_dispatch.vkGetRenderingAreaGranularityKHR.?(
        device,
        p_rendering_area_info,
        &out_granularity,
    );
    return out_granularity;
}
pub const CreateCommandPoolError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createCommandPool(
    device: Device,
    p_create_info: *const CommandPoolCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateCommandPoolError!CommandPool {
    var out_command_pool: CommandPool = undefined;
    const result = device_dispatch.vkCreateCommandPool.?(
        device,
        p_create_info,
        p_allocator,
        &out_command_pool,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_command_pool;
}
pub fn destroyCommandPool(
    device: Device,
    command_pool: CommandPool,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyCommandPool.?(
        device,
        command_pool,
        p_allocator,
    );
}
pub const ResetCommandPoolError = error{
    OutOfDeviceMemory,
    Unknown,
};
pub fn resetCommandPool(
    device: Device,
    command_pool: CommandPool,
    flags: CommandPoolResetFlags,
) ResetCommandPoolError!void {
    const result = device_dispatch.vkResetCommandPool.?(
        device,
        command_pool,
        flags,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const AllocateCommandBuffersError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn allocateCommandBuffers(
    device: Device,
    p_allocate_info: *const CommandBufferAllocateInfo,
    p_command_buffers: [*]CommandBuffer,
) AllocateCommandBuffersError!void {
    const result = device_dispatch.vkAllocateCommandBuffers.?(
        device,
        p_allocate_info,
        p_command_buffers,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub fn freeCommandBuffers(
    device: Device,
    command_pool: CommandPool,
    command_buffer_count: u32,
    p_command_buffers: [*]const CommandBuffer,
) void {
    device_dispatch.vkFreeCommandBuffers.?(
        device,
        command_pool,
        command_buffer_count,
        p_command_buffers,
    );
}
pub const BeginCommandBufferError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn beginCommandBuffer(
    command_buffer: CommandBuffer,
    p_begin_info: *const CommandBufferBeginInfo,
) BeginCommandBufferError!void {
    const result = device_dispatch.vkBeginCommandBuffer.?(
        command_buffer,
        p_begin_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const EndCommandBufferError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InvalidVideoStdParametersKHR,
    Unknown,
};
pub fn endCommandBuffer(
    command_buffer: CommandBuffer,
) EndCommandBufferError!void {
    const result = device_dispatch.vkEndCommandBuffer.?(
        command_buffer,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_invalid_video_std_parameters_khr => return error.InvalidVideoStdParametersKHR,
        else => return error.Unknown,
    }
}
pub const ResetCommandBufferError = error{
    OutOfDeviceMemory,
    Unknown,
};
pub fn resetCommandBuffer(
    command_buffer: CommandBuffer,
    flags: CommandBufferResetFlags,
) ResetCommandBufferError!void {
    const result = device_dispatch.vkResetCommandBuffer.?(
        command_buffer,
        flags,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub fn cmdBindPipeline(
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    pipeline: Pipeline,
) void {
    device_dispatch.vkCmdBindPipeline.?(
        command_buffer,
        pipeline_bind_point,
        pipeline,
    );
}
pub fn cmdSetAttachmentFeedbackLoopEnableEXT(
    command_buffer: CommandBuffer,
    aspect_mask: ImageAspectFlags,
) void {
    device_dispatch.vkCmdSetAttachmentFeedbackLoopEnableEXT.?(
        command_buffer,
        aspect_mask,
    );
}
pub fn cmdSetViewport(
    command_buffer: CommandBuffer,
    first_viewport: u32,
    viewport_count: u32,
    p_viewports: [*]const Viewport,
) void {
    device_dispatch.vkCmdSetViewport.?(
        command_buffer,
        first_viewport,
        viewport_count,
        p_viewports,
    );
}
pub fn cmdSetScissor(
    command_buffer: CommandBuffer,
    first_scissor: u32,
    scissor_count: u32,
    p_scissors: [*]const Rect2D,
) void {
    device_dispatch.vkCmdSetScissor.?(
        command_buffer,
        first_scissor,
        scissor_count,
        p_scissors,
    );
}
pub fn cmdSetLineWidth(
    command_buffer: CommandBuffer,
    line_width: f32,
) void {
    device_dispatch.vkCmdSetLineWidth.?(
        command_buffer,
        line_width,
    );
}
pub fn cmdSetDepthBias(
    command_buffer: CommandBuffer,
    depth_bias_constant_factor: f32,
    depth_bias_clamp: f32,
    depth_bias_slope_factor: f32,
) void {
    device_dispatch.vkCmdSetDepthBias.?(
        command_buffer,
        depth_bias_constant_factor,
        depth_bias_clamp,
        depth_bias_slope_factor,
    );
}
pub fn cmdSetBlendConstants(
    command_buffer: CommandBuffer,
    blend_constants: *const [4]f32,
) void {
    device_dispatch.vkCmdSetBlendConstants.?(
        command_buffer,
        blend_constants,
    );
}
pub fn cmdSetDepthBounds(
    command_buffer: CommandBuffer,
    min_depth_bounds: f32,
    max_depth_bounds: f32,
) void {
    device_dispatch.vkCmdSetDepthBounds.?(
        command_buffer,
        min_depth_bounds,
        max_depth_bounds,
    );
}
pub fn cmdSetStencilCompareMask(
    command_buffer: CommandBuffer,
    face_mask: StencilFaceFlags,
    compare_mask: u32,
) void {
    device_dispatch.vkCmdSetStencilCompareMask.?(
        command_buffer,
        face_mask,
        compare_mask,
    );
}
pub fn cmdSetStencilWriteMask(
    command_buffer: CommandBuffer,
    face_mask: StencilFaceFlags,
    write_mask: u32,
) void {
    device_dispatch.vkCmdSetStencilWriteMask.?(
        command_buffer,
        face_mask,
        write_mask,
    );
}
pub fn cmdSetStencilReference(
    command_buffer: CommandBuffer,
    face_mask: StencilFaceFlags,
    reference: u32,
) void {
    device_dispatch.vkCmdSetStencilReference.?(
        command_buffer,
        face_mask,
        reference,
    );
}
pub fn cmdBindDescriptorSets(
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    layout: PipelineLayout,
    first_set: u32,
    descriptor_set_count: u32,
    p_descriptor_sets: [*]const DescriptorSet,
    dynamic_offset_count: u32,
    p_dynamic_offsets: ?[*]const u32,
) void {
    device_dispatch.vkCmdBindDescriptorSets.?(
        command_buffer,
        pipeline_bind_point,
        layout,
        first_set,
        descriptor_set_count,
        p_descriptor_sets,
        dynamic_offset_count,
        p_dynamic_offsets,
    );
}
pub fn cmdBindIndexBuffer(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    index_type: IndexType,
) void {
    device_dispatch.vkCmdBindIndexBuffer.?(
        command_buffer,
        buffer,
        offset,
        index_type,
    );
}
pub fn cmdBindVertexBuffers(
    command_buffer: CommandBuffer,
    first_binding: u32,
    binding_count: u32,
    p_buffers: [*]const Buffer,
    p_offsets: [*]const DeviceSize,
) void {
    device_dispatch.vkCmdBindVertexBuffers.?(
        command_buffer,
        first_binding,
        binding_count,
        p_buffers,
        p_offsets,
    );
}
pub fn cmdDraw(
    command_buffer: CommandBuffer,
    vertex_count: u32,
    instance_count: u32,
    first_vertex: u32,
    first_instance: u32,
) void {
    device_dispatch.vkCmdDraw.?(
        command_buffer,
        vertex_count,
        instance_count,
        first_vertex,
        first_instance,
    );
}
pub fn cmdDrawIndexed(
    command_buffer: CommandBuffer,
    index_count: u32,
    instance_count: u32,
    first_index: u32,
    vertex_offset: i32,
    first_instance: u32,
) void {
    device_dispatch.vkCmdDrawIndexed.?(
        command_buffer,
        index_count,
        instance_count,
        first_index,
        vertex_offset,
        first_instance,
    );
}
pub fn cmdDrawMultiEXT(
    command_buffer: CommandBuffer,
    draw_count: u32,
    p_vertex_info: ?[*]const MultiDrawInfoEXT,
    instance_count: u32,
    first_instance: u32,
    stride: u32,
) void {
    device_dispatch.vkCmdDrawMultiEXT.?(
        command_buffer,
        draw_count,
        p_vertex_info,
        instance_count,
        first_instance,
        stride,
    );
}
pub fn cmdDrawMultiIndexedEXT(
    command_buffer: CommandBuffer,
    draw_count: u32,
    p_index_info: ?[*]const MultiDrawIndexedInfoEXT,
    instance_count: u32,
    first_instance: u32,
    stride: u32,
    p_vertex_offset: ?*const i32,
) void {
    device_dispatch.vkCmdDrawMultiIndexedEXT.?(
        command_buffer,
        draw_count,
        p_index_info,
        instance_count,
        first_instance,
        stride,
        p_vertex_offset,
    );
}
pub fn cmdDrawIndirect(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    draw_count: u32,
    stride: u32,
) void {
    device_dispatch.vkCmdDrawIndirect.?(
        command_buffer,
        buffer,
        offset,
        draw_count,
        stride,
    );
}
pub fn cmdDrawIndexedIndirect(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    draw_count: u32,
    stride: u32,
) void {
    device_dispatch.vkCmdDrawIndexedIndirect.?(
        command_buffer,
        buffer,
        offset,
        draw_count,
        stride,
    );
}
pub fn cmdDispatch(
    command_buffer: CommandBuffer,
    group_count_x: u32,
    group_count_y: u32,
    group_count_z: u32,
) void {
    device_dispatch.vkCmdDispatch.?(
        command_buffer,
        group_count_x,
        group_count_y,
        group_count_z,
    );
}
pub fn cmdDispatchIndirect(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
) void {
    device_dispatch.vkCmdDispatchIndirect.?(
        command_buffer,
        buffer,
        offset,
    );
}
pub fn cmdSubpassShadingHUAWEI(
    command_buffer: CommandBuffer,
) void {
    device_dispatch.vkCmdSubpassShadingHUAWEI.?(
        command_buffer,
    );
}
pub fn cmdDrawClusterHUAWEI(
    command_buffer: CommandBuffer,
    group_count_x: u32,
    group_count_y: u32,
    group_count_z: u32,
) void {
    device_dispatch.vkCmdDrawClusterHUAWEI.?(
        command_buffer,
        group_count_x,
        group_count_y,
        group_count_z,
    );
}
pub fn cmdDrawClusterIndirectHUAWEI(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
) void {
    device_dispatch.vkCmdDrawClusterIndirectHUAWEI.?(
        command_buffer,
        buffer,
        offset,
    );
}
pub fn cmdUpdatePipelineIndirectBufferNV(
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    pipeline: Pipeline,
) void {
    device_dispatch.vkCmdUpdatePipelineIndirectBufferNV.?(
        command_buffer,
        pipeline_bind_point,
        pipeline,
    );
}
pub fn cmdCopyBuffer(
    command_buffer: CommandBuffer,
    src_buffer: Buffer,
    dst_buffer: Buffer,
    region_count: u32,
    p_regions: [*]const BufferCopy,
) void {
    device_dispatch.vkCmdCopyBuffer.?(
        command_buffer,
        src_buffer,
        dst_buffer,
        region_count,
        p_regions,
    );
}
pub fn cmdCopyImage(
    command_buffer: CommandBuffer,
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: [*]const ImageCopy,
) void {
    device_dispatch.vkCmdCopyImage.?(
        command_buffer,
        src_image,
        src_image_layout,
        dst_image,
        dst_image_layout,
        region_count,
        p_regions,
    );
}
pub fn cmdBlitImage(
    command_buffer: CommandBuffer,
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: [*]const ImageBlit,
    filter: Filter,
) void {
    device_dispatch.vkCmdBlitImage.?(
        command_buffer,
        src_image,
        src_image_layout,
        dst_image,
        dst_image_layout,
        region_count,
        p_regions,
        filter,
    );
}
pub fn cmdCopyBufferToImage(
    command_buffer: CommandBuffer,
    src_buffer: Buffer,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: [*]const BufferImageCopy,
) void {
    device_dispatch.vkCmdCopyBufferToImage.?(
        command_buffer,
        src_buffer,
        dst_image,
        dst_image_layout,
        region_count,
        p_regions,
    );
}
pub fn cmdCopyImageToBuffer(
    command_buffer: CommandBuffer,
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_buffer: Buffer,
    region_count: u32,
    p_regions: [*]const BufferImageCopy,
) void {
    device_dispatch.vkCmdCopyImageToBuffer.?(
        command_buffer,
        src_image,
        src_image_layout,
        dst_buffer,
        region_count,
        p_regions,
    );
}
pub fn cmdCopyMemoryIndirectNV(
    command_buffer: CommandBuffer,
    copy_buffer_address: DeviceAddress,
    copy_count: u32,
    stride: u32,
) void {
    device_dispatch.vkCmdCopyMemoryIndirectNV.?(
        command_buffer,
        copy_buffer_address,
        copy_count,
        stride,
    );
}
pub fn cmdCopyMemoryToImageIndirectNV(
    command_buffer: CommandBuffer,
    copy_buffer_address: DeviceAddress,
    copy_count: u32,
    stride: u32,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    p_image_subresources: [*]const ImageSubresourceLayers,
) void {
    device_dispatch.vkCmdCopyMemoryToImageIndirectNV.?(
        command_buffer,
        copy_buffer_address,
        copy_count,
        stride,
        dst_image,
        dst_image_layout,
        p_image_subresources,
    );
}
pub fn cmdUpdateBuffer(
    command_buffer: CommandBuffer,
    dst_buffer: Buffer,
    dst_offset: DeviceSize,
    data_size: DeviceSize,
    p_data: *const anyopaque,
) void {
    device_dispatch.vkCmdUpdateBuffer.?(
        command_buffer,
        dst_buffer,
        dst_offset,
        data_size,
        p_data,
    );
}
pub fn cmdFillBuffer(
    command_buffer: CommandBuffer,
    dst_buffer: Buffer,
    dst_offset: DeviceSize,
    size: DeviceSize,
    data: u32,
) void {
    device_dispatch.vkCmdFillBuffer.?(
        command_buffer,
        dst_buffer,
        dst_offset,
        size,
        data,
    );
}
pub fn cmdClearColorImage(
    command_buffer: CommandBuffer,
    image: Image,
    image_layout: ImageLayout,
    p_color: *const ClearColorValue,
    range_count: u32,
    p_ranges: [*]const ImageSubresourceRange,
) void {
    device_dispatch.vkCmdClearColorImage.?(
        command_buffer,
        image,
        image_layout,
        p_color,
        range_count,
        p_ranges,
    );
}
pub fn cmdClearDepthStencilImage(
    command_buffer: CommandBuffer,
    image: Image,
    image_layout: ImageLayout,
    p_depth_stencil: *const ClearDepthStencilValue,
    range_count: u32,
    p_ranges: [*]const ImageSubresourceRange,
) void {
    device_dispatch.vkCmdClearDepthStencilImage.?(
        command_buffer,
        image,
        image_layout,
        p_depth_stencil,
        range_count,
        p_ranges,
    );
}
pub fn cmdClearAttachments(
    command_buffer: CommandBuffer,
    attachment_count: u32,
    p_attachments: [*]const ClearAttachment,
    rect_count: u32,
    p_rects: [*]const ClearRect,
) void {
    device_dispatch.vkCmdClearAttachments.?(
        command_buffer,
        attachment_count,
        p_attachments,
        rect_count,
        p_rects,
    );
}
pub fn cmdResolveImage(
    command_buffer: CommandBuffer,
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: [*]const ImageResolve,
) void {
    device_dispatch.vkCmdResolveImage.?(
        command_buffer,
        src_image,
        src_image_layout,
        dst_image,
        dst_image_layout,
        region_count,
        p_regions,
    );
}
pub fn cmdSetEvent(
    command_buffer: CommandBuffer,
    event: Event,
    stage_mask: PipelineStageFlags,
) void {
    device_dispatch.vkCmdSetEvent.?(
        command_buffer,
        event,
        stage_mask,
    );
}
pub fn cmdResetEvent(
    command_buffer: CommandBuffer,
    event: Event,
    stage_mask: PipelineStageFlags,
) void {
    device_dispatch.vkCmdResetEvent.?(
        command_buffer,
        event,
        stage_mask,
    );
}
pub fn cmdWaitEvents(
    command_buffer: CommandBuffer,
    event_count: u32,
    p_events: [*]const Event,
    src_stage_mask: PipelineStageFlags,
    dst_stage_mask: PipelineStageFlags,
    memory_barrier_count: u32,
    p_memory_barriers: ?[*]const MemoryBarrier,
    buffer_memory_barrier_count: u32,
    p_buffer_memory_barriers: ?[*]const BufferMemoryBarrier,
    image_memory_barrier_count: u32,
    p_image_memory_barriers: ?[*]const ImageMemoryBarrier,
) void {
    device_dispatch.vkCmdWaitEvents.?(
        command_buffer,
        event_count,
        p_events,
        src_stage_mask,
        dst_stage_mask,
        memory_barrier_count,
        p_memory_barriers,
        buffer_memory_barrier_count,
        p_buffer_memory_barriers,
        image_memory_barrier_count,
        p_image_memory_barriers,
    );
}
pub fn cmdPipelineBarrier(
    command_buffer: CommandBuffer,
    src_stage_mask: PipelineStageFlags,
    dst_stage_mask: PipelineStageFlags,
    dependency_flags: DependencyFlags,
    memory_barrier_count: u32,
    p_memory_barriers: ?[*]const MemoryBarrier,
    buffer_memory_barrier_count: u32,
    p_buffer_memory_barriers: ?[*]const BufferMemoryBarrier,
    image_memory_barrier_count: u32,
    p_image_memory_barriers: ?[*]const ImageMemoryBarrier,
) void {
    device_dispatch.vkCmdPipelineBarrier.?(
        command_buffer,
        src_stage_mask,
        dst_stage_mask,
        dependency_flags,
        memory_barrier_count,
        p_memory_barriers,
        buffer_memory_barrier_count,
        p_buffer_memory_barriers,
        image_memory_barrier_count,
        p_image_memory_barriers,
    );
}
pub fn cmdBeginQuery(
    command_buffer: CommandBuffer,
    query_pool: QueryPool,
    query: u32,
    flags: QueryControlFlags,
) void {
    device_dispatch.vkCmdBeginQuery.?(
        command_buffer,
        query_pool,
        query,
        flags,
    );
}
pub fn cmdEndQuery(
    command_buffer: CommandBuffer,
    query_pool: QueryPool,
    query: u32,
) void {
    device_dispatch.vkCmdEndQuery.?(
        command_buffer,
        query_pool,
        query,
    );
}
pub fn cmdBeginConditionalRenderingEXT(
    command_buffer: CommandBuffer,
    p_conditional_rendering_begin: *const ConditionalRenderingBeginInfoEXT,
) void {
    device_dispatch.vkCmdBeginConditionalRenderingEXT.?(
        command_buffer,
        p_conditional_rendering_begin,
    );
}
pub fn cmdEndConditionalRenderingEXT(
    command_buffer: CommandBuffer,
) void {
    device_dispatch.vkCmdEndConditionalRenderingEXT.?(
        command_buffer,
    );
}
pub fn cmdResetQueryPool(
    command_buffer: CommandBuffer,
    query_pool: QueryPool,
    first_query: u32,
    query_count: u32,
) void {
    device_dispatch.vkCmdResetQueryPool.?(
        command_buffer,
        query_pool,
        first_query,
        query_count,
    );
}
pub fn cmdWriteTimestamp(
    command_buffer: CommandBuffer,
    pipeline_stage: PipelineStageFlags,
    query_pool: QueryPool,
    query: u32,
) void {
    device_dispatch.vkCmdWriteTimestamp.?(
        command_buffer,
        pipeline_stage,
        query_pool,
        query,
    );
}
pub fn cmdCopyQueryPoolResults(
    command_buffer: CommandBuffer,
    query_pool: QueryPool,
    first_query: u32,
    query_count: u32,
    dst_buffer: Buffer,
    dst_offset: DeviceSize,
    stride: DeviceSize,
    flags: QueryResultFlags,
) void {
    device_dispatch.vkCmdCopyQueryPoolResults.?(
        command_buffer,
        query_pool,
        first_query,
        query_count,
        dst_buffer,
        dst_offset,
        stride,
        flags,
    );
}
pub fn cmdPushConstants(
    command_buffer: CommandBuffer,
    layout: PipelineLayout,
    stage_flags: ShaderStageFlags,
    offset: u32,
    size: u32,
    p_values: *const anyopaque,
) void {
    device_dispatch.vkCmdPushConstants.?(
        command_buffer,
        layout,
        stage_flags,
        offset,
        size,
        p_values,
    );
}
pub fn cmdBeginRenderPass(
    command_buffer: CommandBuffer,
    p_render_pass_begin: *const RenderPassBeginInfo,
    contents: SubpassContents,
) void {
    device_dispatch.vkCmdBeginRenderPass.?(
        command_buffer,
        p_render_pass_begin,
        contents,
    );
}
pub fn cmdNextSubpass(
    command_buffer: CommandBuffer,
    contents: SubpassContents,
) void {
    device_dispatch.vkCmdNextSubpass.?(
        command_buffer,
        contents,
    );
}
pub fn cmdEndRenderPass(
    command_buffer: CommandBuffer,
) void {
    device_dispatch.vkCmdEndRenderPass.?(
        command_buffer,
    );
}
pub fn cmdExecuteCommands(
    command_buffer: CommandBuffer,
    command_buffer_count: u32,
    p_command_buffers: [*]const CommandBuffer,
) void {
    device_dispatch.vkCmdExecuteCommands.?(
        command_buffer,
        command_buffer_count,
        p_command_buffers,
    );
}
pub const CreateSharedSwapchainsKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    IncompatibleDisplayKHR,
    DeviceLost,
    SurfaceLostKHR,
    Unknown,
};
pub fn createSharedSwapchainsKHR(
    device: Device,
    swapchain_count: u32,
    p_create_infos: [*]const SwapchainCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_swapchains: [*]SwapchainKHR,
) CreateSharedSwapchainsKHRError!void {
    const result = device_dispatch.vkCreateSharedSwapchainsKHR.?(
        device,
        swapchain_count,
        p_create_infos,
        p_allocator,
        p_swapchains,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_incompatible_display_khr => return error.IncompatibleDisplayKHR,
        Result.error_device_lost => return error.DeviceLost,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
}
pub const CreateSwapchainKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    SurfaceLostKHR,
    NativeWindowInUseKHR,
    InitializationFailed,
    CompressionExhaustedEXT,
    Unknown,
};
pub fn createSwapchainKHR(
    device: Device,
    p_create_info: *const SwapchainCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
) CreateSwapchainKHRError!SwapchainKHR {
    var out_swapchain: SwapchainKHR = undefined;
    const result = device_dispatch.vkCreateSwapchainKHR.?(
        device,
        p_create_info,
        p_allocator,
        &out_swapchain,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        Result.error_native_window_in_use_khr => return error.NativeWindowInUseKHR,
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_compression_exhausted_ext => return error.CompressionExhaustedEXT,
        else => return error.Unknown,
    }
    return out_swapchain;
}
pub fn destroySwapchainKHR(
    device: Device,
    swapchain: SwapchainKHR,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroySwapchainKHR.?(
        device,
        swapchain,
        p_allocator,
    );
}
pub const GetSwapchainImagesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getSwapchainImagesKHR(
    device: Device,
    swapchain: SwapchainKHR,
    p_swapchain_image_count: *u32,
    p_swapchain_images: ?[*]Image,
) GetSwapchainImagesKHRError!Result {
    const result = device_dispatch.vkGetSwapchainImagesKHR.?(
        device,
        swapchain,
        p_swapchain_image_count,
        p_swapchain_images,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetSwapchainImagesAllocKHRError =
    GetSwapchainImagesKHRError || Allocator.Error;
pub fn getSwapchainImagesAllocKHR(
    device: Device,
    swapchain: SwapchainKHR,
    allocator: Allocator,
) GetSwapchainImagesAllocKHRError![]Image {
    var count: u32 = undefined;
    var data: []Image = &.{};
    errdefer allocator.free(data);
    var result = Result.incomplete;
    while (result == .incomplete) {
        _ = try getSwapchainImagesKHR(device, swapchain, &count, null);
        data = try allocator.realloc(data, count);
        result = try getSwapchainImagesKHR(device, swapchain, &count, data.ptr);
    }
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub const AcquireNextImageKHRResult = struct {
    result: Result,
    image_index: u32,
};
pub const AcquireNextImageKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    OutOfDateKHR,
    SurfaceLostKHR,
    FullScreenExclusiveModeLostEXT,
    Unknown,
};
pub fn acquireNextImageKHR(
    device: Device,
    swapchain: SwapchainKHR,
    timeout: u64,
    semaphore: Semaphore,
    fence: Fence,
) AcquireNextImageKHRError!AcquireNextImageKHRResult {
    var return_values: AcquireNextImageKHRResult = undefined;
    const result = device_dispatch.vkAcquireNextImageKHR.?(
        device,
        swapchain,
        timeout,
        semaphore,
        fence,
        &return_values.image_index,
    );
    switch (result) {
        Result.success => {},
        Result.timeout => {},
        Result.not_ready => {},
        Result.suboptimal_khr => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        Result.error_out_of_date_khr => return error.OutOfDateKHR,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        Result.error_full_screen_exclusive_mode_lost_ext => return error.FullScreenExclusiveModeLostEXT,
        else => return error.Unknown,
    }
    return_values.result = result;
    return return_values;
}
pub const QueuePresentKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    OutOfDateKHR,
    SurfaceLostKHR,
    FullScreenExclusiveModeLostEXT,
    Unknown,
};
pub fn queuePresentKHR(
    queue: Queue,
    p_present_info: *const PresentInfoKHR,
) QueuePresentKHRError!Result {
    const result = device_dispatch.vkQueuePresentKHR.?(
        queue,
        p_present_info,
    );
    switch (result) {
        Result.success => {},
        Result.suboptimal_khr => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        Result.error_out_of_date_khr => return error.OutOfDateKHR,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        Result.error_full_screen_exclusive_mode_lost_ext => return error.FullScreenExclusiveModeLostEXT,
        else => return error.Unknown,
    }
    return result;
}
pub const DebugMarkerSetObjectNameEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn debugMarkerSetObjectNameEXT(
    device: Device,
    p_name_info: *const DebugMarkerObjectNameInfoEXT,
) DebugMarkerSetObjectNameEXTError!void {
    const result = device_dispatch.vkDebugMarkerSetObjectNameEXT.?(
        device,
        p_name_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const DebugMarkerSetObjectTagEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn debugMarkerSetObjectTagEXT(
    device: Device,
    p_tag_info: *const DebugMarkerObjectTagInfoEXT,
) DebugMarkerSetObjectTagEXTError!void {
    const result = device_dispatch.vkDebugMarkerSetObjectTagEXT.?(
        device,
        p_tag_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub fn cmdDebugMarkerBeginEXT(
    command_buffer: CommandBuffer,
    p_marker_info: *const DebugMarkerMarkerInfoEXT,
) void {
    device_dispatch.vkCmdDebugMarkerBeginEXT.?(
        command_buffer,
        p_marker_info,
    );
}
pub fn cmdDebugMarkerEndEXT(
    command_buffer: CommandBuffer,
) void {
    device_dispatch.vkCmdDebugMarkerEndEXT.?(
        command_buffer,
    );
}
pub fn cmdDebugMarkerInsertEXT(
    command_buffer: CommandBuffer,
    p_marker_info: *const DebugMarkerMarkerInfoEXT,
) void {
    device_dispatch.vkCmdDebugMarkerInsertEXT.?(
        command_buffer,
        p_marker_info,
    );
}
pub const GetMemoryWin32HandleNVError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn getMemoryWin32HandleNV(
    device: Device,
    memory: DeviceMemory,
    handle_type: ExternalMemoryHandleTypeFlagsNV,
    p_handle: *HANDLE,
) GetMemoryWin32HandleNVError!void {
    const result = device_dispatch.vkGetMemoryWin32HandleNV.?(
        device,
        memory,
        handle_type,
        p_handle,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub fn cmdExecuteGeneratedCommandsNV(
    command_buffer: CommandBuffer,
    is_preprocessed: Bool32,
    p_generated_commands_info: *const GeneratedCommandsInfoNV,
) void {
    device_dispatch.vkCmdExecuteGeneratedCommandsNV.?(
        command_buffer,
        is_preprocessed,
        p_generated_commands_info,
    );
}
pub fn cmdPreprocessGeneratedCommandsNV(
    command_buffer: CommandBuffer,
    p_generated_commands_info: *const GeneratedCommandsInfoNV,
) void {
    device_dispatch.vkCmdPreprocessGeneratedCommandsNV.?(
        command_buffer,
        p_generated_commands_info,
    );
}
pub fn cmdBindPipelineShaderGroupNV(
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    pipeline: Pipeline,
    group_index: u32,
) void {
    device_dispatch.vkCmdBindPipelineShaderGroupNV.?(
        command_buffer,
        pipeline_bind_point,
        pipeline,
        group_index,
    );
}
pub fn getGeneratedCommandsMemoryRequirementsNV(
    device: Device,
    p_info: *const GeneratedCommandsMemoryRequirementsInfoNV,
    p_memory_requirements: *MemoryRequirements2,
) void {
    device_dispatch.vkGetGeneratedCommandsMemoryRequirementsNV.?(
        device,
        p_info,
        p_memory_requirements,
    );
}
pub const CreateIndirectCommandsLayoutNVError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createIndirectCommandsLayoutNV(
    device: Device,
    p_create_info: *const IndirectCommandsLayoutCreateInfoNV,
    p_allocator: ?*const AllocationCallbacks,
) CreateIndirectCommandsLayoutNVError!IndirectCommandsLayoutNV {
    var out_indirect_commands_layout: IndirectCommandsLayoutNV = undefined;
    const result = device_dispatch.vkCreateIndirectCommandsLayoutNV.?(
        device,
        p_create_info,
        p_allocator,
        &out_indirect_commands_layout,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_indirect_commands_layout;
}
pub fn destroyIndirectCommandsLayoutNV(
    device: Device,
    indirect_commands_layout: IndirectCommandsLayoutNV,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyIndirectCommandsLayoutNV.?(
        device,
        indirect_commands_layout,
        p_allocator,
    );
}
pub fn cmdExecuteGeneratedCommandsEXT(
    command_buffer: CommandBuffer,
    is_preprocessed: Bool32,
    p_generated_commands_info: *const GeneratedCommandsInfoEXT,
) void {
    device_dispatch.vkCmdExecuteGeneratedCommandsEXT.?(
        command_buffer,
        is_preprocessed,
        p_generated_commands_info,
    );
}
pub fn cmdPreprocessGeneratedCommandsEXT(
    command_buffer: CommandBuffer,
    p_generated_commands_info: *const GeneratedCommandsInfoEXT,
    state_command_buffer: CommandBuffer,
) void {
    device_dispatch.vkCmdPreprocessGeneratedCommandsEXT.?(
        command_buffer,
        p_generated_commands_info,
        state_command_buffer,
    );
}
pub fn getGeneratedCommandsMemoryRequirementsEXT(
    device: Device,
    p_info: *const GeneratedCommandsMemoryRequirementsInfoEXT,
    p_memory_requirements: *MemoryRequirements2,
) void {
    device_dispatch.vkGetGeneratedCommandsMemoryRequirementsEXT.?(
        device,
        p_info,
        p_memory_requirements,
    );
}
pub const CreateIndirectCommandsLayoutEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createIndirectCommandsLayoutEXT(
    device: Device,
    p_create_info: *const IndirectCommandsLayoutCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
) CreateIndirectCommandsLayoutEXTError!IndirectCommandsLayoutEXT {
    var out_indirect_commands_layout: IndirectCommandsLayoutEXT = undefined;
    const result = device_dispatch.vkCreateIndirectCommandsLayoutEXT.?(
        device,
        p_create_info,
        p_allocator,
        &out_indirect_commands_layout,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_indirect_commands_layout;
}
pub fn destroyIndirectCommandsLayoutEXT(
    device: Device,
    indirect_commands_layout: IndirectCommandsLayoutEXT,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyIndirectCommandsLayoutEXT.?(
        device,
        indirect_commands_layout,
        p_allocator,
    );
}
pub const CreateIndirectExecutionSetEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createIndirectExecutionSetEXT(
    device: Device,
    p_create_info: *const IndirectExecutionSetCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
) CreateIndirectExecutionSetEXTError!IndirectExecutionSetEXT {
    var out_indirect_execution_set: IndirectExecutionSetEXT = undefined;
    const result = device_dispatch.vkCreateIndirectExecutionSetEXT.?(
        device,
        p_create_info,
        p_allocator,
        &out_indirect_execution_set,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_indirect_execution_set;
}
pub fn destroyIndirectExecutionSetEXT(
    device: Device,
    indirect_execution_set: IndirectExecutionSetEXT,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyIndirectExecutionSetEXT.?(
        device,
        indirect_execution_set,
        p_allocator,
    );
}
pub fn updateIndirectExecutionSetPipelineEXT(
    device: Device,
    indirect_execution_set: IndirectExecutionSetEXT,
    execution_set_write_count: u32,
    p_execution_set_writes: [*]const WriteIndirectExecutionSetPipelineEXT,
) void {
    device_dispatch.vkUpdateIndirectExecutionSetPipelineEXT.?(
        device,
        indirect_execution_set,
        execution_set_write_count,
        p_execution_set_writes,
    );
}
pub fn updateIndirectExecutionSetShaderEXT(
    device: Device,
    indirect_execution_set: IndirectExecutionSetEXT,
    execution_set_write_count: u32,
    p_execution_set_writes: [*]const WriteIndirectExecutionSetShaderEXT,
) void {
    device_dispatch.vkUpdateIndirectExecutionSetShaderEXT.?(
        device,
        indirect_execution_set,
        execution_set_write_count,
        p_execution_set_writes,
    );
}
pub fn cmdPushDescriptorSet(
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    layout: PipelineLayout,
    set: u32,
    descriptor_write_count: u32,
    p_descriptor_writes: [*]const WriteDescriptorSet,
) void {
    device_dispatch.vkCmdPushDescriptorSet.?(
        command_buffer,
        pipeline_bind_point,
        layout,
        set,
        descriptor_write_count,
        p_descriptor_writes,
    );
}
pub fn cmdPushDescriptorSetKHR(
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    layout: PipelineLayout,
    set: u32,
    descriptor_write_count: u32,
    p_descriptor_writes: [*]const WriteDescriptorSet,
) void {
    device_dispatch.vkCmdPushDescriptorSetKHR.?(
        command_buffer,
        pipeline_bind_point,
        layout,
        set,
        descriptor_write_count,
        p_descriptor_writes,
    );
}
pub fn trimCommandPool(
    device: Device,
    command_pool: CommandPool,
    flags: CommandPoolTrimFlags,
) void {
    device_dispatch.vkTrimCommandPool.?(
        device,
        command_pool,
        flags,
    );
}
pub fn trimCommandPoolKHR(
    device: Device,
    command_pool: CommandPool,
    flags: CommandPoolTrimFlags,
) void {
    device_dispatch.vkTrimCommandPoolKHR.?(
        device,
        command_pool,
        flags,
    );
}
pub const GetMemoryWin32HandleKHRError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn getMemoryWin32HandleKHR(
    device: Device,
    p_get_win_32_handle_info: *const MemoryGetWin32HandleInfoKHR,
    p_handle: *HANDLE,
) GetMemoryWin32HandleKHRError!void {
    const result = device_dispatch.vkGetMemoryWin32HandleKHR.?(
        device,
        p_get_win_32_handle_info,
        p_handle,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub const GetMemoryWin32HandlePropertiesKHRError = error{
    OutOfHostMemory,
    InvalidExternalHandle,
    Unknown,
};
pub fn getMemoryWin32HandlePropertiesKHR(
    device: Device,
    handle_type: ExternalMemoryHandleTypeFlags,
    handle: HANDLE,
    p_memory_win_32_handle_properties: *MemoryWin32HandlePropertiesKHR,
) GetMemoryWin32HandlePropertiesKHRError!void {
    const result = device_dispatch.vkGetMemoryWin32HandlePropertiesKHR.?(
        device,
        handle_type,
        handle,
        p_memory_win_32_handle_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        else => return error.Unknown,
    }
}
pub const GetMemoryFdKHRError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn getMemoryFdKHR(
    device: Device,
    p_get_fd_info: *const MemoryGetFdInfoKHR,
) GetMemoryFdKHRError!c_int {
    var out_fd: c_int = undefined;
    const result = device_dispatch.vkGetMemoryFdKHR.?(
        device,
        p_get_fd_info,
        &out_fd,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_fd;
}
pub const GetMemoryFdPropertiesKHRError = error{
    OutOfHostMemory,
    InvalidExternalHandle,
    Unknown,
};
pub fn getMemoryFdPropertiesKHR(
    device: Device,
    handle_type: ExternalMemoryHandleTypeFlags,
    fd: c_int,
    p_memory_fd_properties: *MemoryFdPropertiesKHR,
) GetMemoryFdPropertiesKHRError!void {
    const result = device_dispatch.vkGetMemoryFdPropertiesKHR.?(
        device,
        handle_type,
        fd,
        p_memory_fd_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        else => return error.Unknown,
    }
}
pub const GetMemoryZirconHandleFUCHSIAError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn getMemoryZirconHandleFUCHSIA(
    device: Device,
    p_get_zircon_handle_info: *const MemoryGetZirconHandleInfoFUCHSIA,
    p_zircon_handle: *zx_handle_t,
) GetMemoryZirconHandleFUCHSIAError!void {
    const result = device_dispatch.vkGetMemoryZirconHandleFUCHSIA.?(
        device,
        p_get_zircon_handle_info,
        p_zircon_handle,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub const GetMemoryZirconHandlePropertiesFUCHSIAError = error{
    InvalidExternalHandle,
    Unknown,
};
pub fn getMemoryZirconHandlePropertiesFUCHSIA(
    device: Device,
    handle_type: ExternalMemoryHandleTypeFlags,
    zircon_handle: zx_handle_t,
    p_memory_zircon_handle_properties: *MemoryZirconHandlePropertiesFUCHSIA,
) GetMemoryZirconHandlePropertiesFUCHSIAError!void {
    const result = device_dispatch.vkGetMemoryZirconHandlePropertiesFUCHSIA.?(
        device,
        handle_type,
        zircon_handle,
        p_memory_zircon_handle_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        else => return error.Unknown,
    }
}
pub const GetMemoryRemoteAddressNVError = error{
    InvalidExternalHandle,
    Unknown,
};
pub fn getMemoryRemoteAddressNV(
    device: Device,
    p_memory_get_remote_address_info: *const MemoryGetRemoteAddressInfoNV,
) GetMemoryRemoteAddressNVError!RemoteAddressNV {
    var out_address: RemoteAddressNV = undefined;
    const result = device_dispatch.vkGetMemoryRemoteAddressNV.?(
        device,
        p_memory_get_remote_address_info,
        &out_address,
    );
    switch (result) {
        Result.success => {},
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        else => return error.Unknown,
    }
    return out_address;
}
pub const GetMemorySciBufNVError = error{
    InitializationFailed,
    Unknown,
};
pub fn getMemorySciBufNV(
    device: Device,
    p_get_sci_buf_info: *const MemoryGetSciBufInfoNV,
    p_handle: *NvSciBufObj,
) GetMemorySciBufNVError!void {
    const result = device_dispatch.vkGetMemorySciBufNV.?(
        device,
        p_get_sci_buf_info,
        p_handle,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
}
pub const GetSemaphoreWin32HandleKHRError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn getSemaphoreWin32HandleKHR(
    device: Device,
    p_get_win_32_handle_info: *const SemaphoreGetWin32HandleInfoKHR,
    p_handle: *HANDLE,
) GetSemaphoreWin32HandleKHRError!void {
    const result = device_dispatch.vkGetSemaphoreWin32HandleKHR.?(
        device,
        p_get_win_32_handle_info,
        p_handle,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub const ImportSemaphoreWin32HandleKHRError = error{
    OutOfHostMemory,
    InvalidExternalHandle,
    Unknown,
};
pub fn importSemaphoreWin32HandleKHR(
    device: Device,
    p_import_semaphore_win_32_handle_info: *const ImportSemaphoreWin32HandleInfoKHR,
) ImportSemaphoreWin32HandleKHRError!void {
    const result = device_dispatch.vkImportSemaphoreWin32HandleKHR.?(
        device,
        p_import_semaphore_win_32_handle_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        else => return error.Unknown,
    }
}
pub const GetSemaphoreFdKHRError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn getSemaphoreFdKHR(
    device: Device,
    p_get_fd_info: *const SemaphoreGetFdInfoKHR,
) GetSemaphoreFdKHRError!c_int {
    var out_fd: c_int = undefined;
    const result = device_dispatch.vkGetSemaphoreFdKHR.?(
        device,
        p_get_fd_info,
        &out_fd,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_fd;
}
pub const ImportSemaphoreFdKHRError = error{
    OutOfHostMemory,
    InvalidExternalHandle,
    Unknown,
};
pub fn importSemaphoreFdKHR(
    device: Device,
    p_import_semaphore_fd_info: *const ImportSemaphoreFdInfoKHR,
) ImportSemaphoreFdKHRError!void {
    const result = device_dispatch.vkImportSemaphoreFdKHR.?(
        device,
        p_import_semaphore_fd_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        else => return error.Unknown,
    }
}
pub const GetSemaphoreZirconHandleFUCHSIAError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn getSemaphoreZirconHandleFUCHSIA(
    device: Device,
    p_get_zircon_handle_info: *const SemaphoreGetZirconHandleInfoFUCHSIA,
    p_zircon_handle: *zx_handle_t,
) GetSemaphoreZirconHandleFUCHSIAError!void {
    const result = device_dispatch.vkGetSemaphoreZirconHandleFUCHSIA.?(
        device,
        p_get_zircon_handle_info,
        p_zircon_handle,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub const ImportSemaphoreZirconHandleFUCHSIAError = error{
    OutOfHostMemory,
    InvalidExternalHandle,
    Unknown,
};
pub fn importSemaphoreZirconHandleFUCHSIA(
    device: Device,
    p_import_semaphore_zircon_handle_info: *const ImportSemaphoreZirconHandleInfoFUCHSIA,
) ImportSemaphoreZirconHandleFUCHSIAError!void {
    const result = device_dispatch.vkImportSemaphoreZirconHandleFUCHSIA.?(
        device,
        p_import_semaphore_zircon_handle_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        else => return error.Unknown,
    }
}
pub const GetFenceWin32HandleKHRError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn getFenceWin32HandleKHR(
    device: Device,
    p_get_win_32_handle_info: *const FenceGetWin32HandleInfoKHR,
    p_handle: *HANDLE,
) GetFenceWin32HandleKHRError!void {
    const result = device_dispatch.vkGetFenceWin32HandleKHR.?(
        device,
        p_get_win_32_handle_info,
        p_handle,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub const ImportFenceWin32HandleKHRError = error{
    OutOfHostMemory,
    InvalidExternalHandle,
    Unknown,
};
pub fn importFenceWin32HandleKHR(
    device: Device,
    p_import_fence_win_32_handle_info: *const ImportFenceWin32HandleInfoKHR,
) ImportFenceWin32HandleKHRError!void {
    const result = device_dispatch.vkImportFenceWin32HandleKHR.?(
        device,
        p_import_fence_win_32_handle_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        else => return error.Unknown,
    }
}
pub const GetFenceFdKHRError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn getFenceFdKHR(
    device: Device,
    p_get_fd_info: *const FenceGetFdInfoKHR,
) GetFenceFdKHRError!c_int {
    var out_fd: c_int = undefined;
    const result = device_dispatch.vkGetFenceFdKHR.?(
        device,
        p_get_fd_info,
        &out_fd,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_fd;
}
pub const ImportFenceFdKHRError = error{
    OutOfHostMemory,
    InvalidExternalHandle,
    Unknown,
};
pub fn importFenceFdKHR(
    device: Device,
    p_import_fence_fd_info: *const ImportFenceFdInfoKHR,
) ImportFenceFdKHRError!void {
    const result = device_dispatch.vkImportFenceFdKHR.?(
        device,
        p_import_fence_fd_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        else => return error.Unknown,
    }
}
pub const GetFenceSciSyncFenceNVError = error{
    InvalidExternalHandle,
    NotPermitted,
    Unknown,
};
pub fn getFenceSciSyncFenceNV(
    device: Device,
    p_get_sci_sync_handle_info: *const FenceGetSciSyncInfoNV,
    p_handle: *anyopaque,
) GetFenceSciSyncFenceNVError!void {
    const result = device_dispatch.vkGetFenceSciSyncFenceNV.?(
        device,
        p_get_sci_sync_handle_info,
        p_handle,
    );
    switch (result) {
        Result.success => {},
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        Result.error_not_permitted => return error.NotPermitted,
        else => return error.Unknown,
    }
}
pub const GetFenceSciSyncObjNVError = error{
    InvalidExternalHandle,
    NotPermitted,
    Unknown,
};
pub fn getFenceSciSyncObjNV(
    device: Device,
    p_get_sci_sync_handle_info: *const FenceGetSciSyncInfoNV,
    p_handle: *anyopaque,
) GetFenceSciSyncObjNVError!void {
    const result = device_dispatch.vkGetFenceSciSyncObjNV.?(
        device,
        p_get_sci_sync_handle_info,
        p_handle,
    );
    switch (result) {
        Result.success => {},
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        Result.error_not_permitted => return error.NotPermitted,
        else => return error.Unknown,
    }
}
pub const ImportFenceSciSyncFenceNVError = error{
    InvalidExternalHandle,
    NotPermitted,
    Unknown,
};
pub fn importFenceSciSyncFenceNV(
    device: Device,
    p_import_fence_sci_sync_info: *const ImportFenceSciSyncInfoNV,
) ImportFenceSciSyncFenceNVError!void {
    const result = device_dispatch.vkImportFenceSciSyncFenceNV.?(
        device,
        p_import_fence_sci_sync_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        Result.error_not_permitted => return error.NotPermitted,
        else => return error.Unknown,
    }
}
pub const ImportFenceSciSyncObjNVError = error{
    InvalidExternalHandle,
    NotPermitted,
    Unknown,
};
pub fn importFenceSciSyncObjNV(
    device: Device,
    p_import_fence_sci_sync_info: *const ImportFenceSciSyncInfoNV,
) ImportFenceSciSyncObjNVError!void {
    const result = device_dispatch.vkImportFenceSciSyncObjNV.?(
        device,
        p_import_fence_sci_sync_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        Result.error_not_permitted => return error.NotPermitted,
        else => return error.Unknown,
    }
}
pub const GetSemaphoreSciSyncObjNVError = error{
    InvalidExternalHandle,
    NotPermitted,
    Unknown,
};
pub fn getSemaphoreSciSyncObjNV(
    device: Device,
    p_get_sci_sync_info: *const SemaphoreGetSciSyncInfoNV,
    p_handle: *anyopaque,
) GetSemaphoreSciSyncObjNVError!void {
    const result = device_dispatch.vkGetSemaphoreSciSyncObjNV.?(
        device,
        p_get_sci_sync_info,
        p_handle,
    );
    switch (result) {
        Result.success => {},
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        Result.error_not_permitted => return error.NotPermitted,
        else => return error.Unknown,
    }
}
pub const ImportSemaphoreSciSyncObjNVError = error{
    InvalidExternalHandle,
    NotPermitted,
    OutOfHostMemory,
    Unknown,
};
pub fn importSemaphoreSciSyncObjNV(
    device: Device,
    p_import_semaphore_sci_sync_info: *const ImportSemaphoreSciSyncInfoNV,
) ImportSemaphoreSciSyncObjNVError!void {
    const result = device_dispatch.vkImportSemaphoreSciSyncObjNV.?(
        device,
        p_import_semaphore_sci_sync_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        Result.error_not_permitted => return error.NotPermitted,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub const CreateSemaphoreSciSyncPoolNVError = error{
    InitializationFailed,
    OutOfHostMemory,
    Unknown,
};
pub fn createSemaphoreSciSyncPoolNV(
    device: Device,
    p_create_info: *const SemaphoreSciSyncPoolCreateInfoNV,
    p_allocator: ?*const AllocationCallbacks,
) CreateSemaphoreSciSyncPoolNVError!SemaphoreSciSyncPoolNV {
    var out_semaphore_pool: SemaphoreSciSyncPoolNV = undefined;
    const result = device_dispatch.vkCreateSemaphoreSciSyncPoolNV.?(
        device,
        p_create_info,
        p_allocator,
        &out_semaphore_pool,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_semaphore_pool;
}
pub fn destroySemaphoreSciSyncPoolNV(
    device: Device,
    semaphore_pool: SemaphoreSciSyncPoolNV,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroySemaphoreSciSyncPoolNV.?(
        device,
        semaphore_pool,
        p_allocator,
    );
}
pub const DisplayPowerControlEXTError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn displayPowerControlEXT(
    device: Device,
    display: DisplayKHR,
    p_display_power_info: *const DisplayPowerInfoEXT,
) DisplayPowerControlEXTError!void {
    const result = device_dispatch.vkDisplayPowerControlEXT.?(
        device,
        display,
        p_display_power_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub const RegisterDeviceEventEXTError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn registerDeviceEventEXT(
    device: Device,
    p_device_event_info: *const DeviceEventInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
) RegisterDeviceEventEXTError!Fence {
    var out_fence: Fence = undefined;
    const result = device_dispatch.vkRegisterDeviceEventEXT.?(
        device,
        p_device_event_info,
        p_allocator,
        &out_fence,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_fence;
}
pub const RegisterDisplayEventEXTError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn registerDisplayEventEXT(
    device: Device,
    display: DisplayKHR,
    p_display_event_info: *const DisplayEventInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
) RegisterDisplayEventEXTError!Fence {
    var out_fence: Fence = undefined;
    const result = device_dispatch.vkRegisterDisplayEventEXT.?(
        device,
        display,
        p_display_event_info,
        p_allocator,
        &out_fence,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_fence;
}
pub const GetSwapchainCounterEXTError = error{
    OutOfHostMemory,
    DeviceLost,
    OutOfDateKHR,
    Unknown,
};
pub fn getSwapchainCounterEXT(
    device: Device,
    swapchain: SwapchainKHR,
    counter: SurfaceCounterFlagsEXT,
) GetSwapchainCounterEXTError!u64 {
    var out_counter_value: u64 = undefined;
    const result = device_dispatch.vkGetSwapchainCounterEXT.?(
        device,
        swapchain,
        counter,
        &out_counter_value,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_device_lost => return error.DeviceLost,
        Result.error_out_of_date_khr => return error.OutOfDateKHR,
        else => return error.Unknown,
    }
    return out_counter_value;
}
pub fn getDeviceGroupPeerMemoryFeatures(
    device: Device,
    heap_index: u32,
    local_device_index: u32,
    remote_device_index: u32,
) PeerMemoryFeatureFlags {
    var out_peer_memory_features: PeerMemoryFeatureFlags = undefined;
    device_dispatch.vkGetDeviceGroupPeerMemoryFeatures.?(
        device,
        heap_index,
        local_device_index,
        remote_device_index,
        &out_peer_memory_features,
    );
    return out_peer_memory_features;
}
pub fn getDeviceGroupPeerMemoryFeaturesKHR(
    device: Device,
    heap_index: u32,
    local_device_index: u32,
    remote_device_index: u32,
) PeerMemoryFeatureFlags {
    var out_peer_memory_features: PeerMemoryFeatureFlags = undefined;
    device_dispatch.vkGetDeviceGroupPeerMemoryFeaturesKHR.?(
        device,
        heap_index,
        local_device_index,
        remote_device_index,
        &out_peer_memory_features,
    );
    return out_peer_memory_features;
}
pub const BindBufferMemory2Error = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InvalidOpaqueCaptureAddressKHR,
    Unknown,
};
pub fn bindBufferMemory2(
    device: Device,
    bind_info_count: u32,
    p_bind_infos: [*]const BindBufferMemoryInfo,
) BindBufferMemory2Error!void {
    const result = device_dispatch.vkBindBufferMemory2.?(
        device,
        bind_info_count,
        p_bind_infos,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_invalid_opaque_capture_address_khr => return error.InvalidOpaqueCaptureAddressKHR,
        else => return error.Unknown,
    }
}
pub const BindBufferMemory2KHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InvalidOpaqueCaptureAddressKHR,
    Unknown,
};
pub fn bindBufferMemory2KHR(
    device: Device,
    bind_info_count: u32,
    p_bind_infos: [*]const BindBufferMemoryInfo,
) BindBufferMemory2KHRError!void {
    const result = device_dispatch.vkBindBufferMemory2KHR.?(
        device,
        bind_info_count,
        p_bind_infos,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_invalid_opaque_capture_address_khr => return error.InvalidOpaqueCaptureAddressKHR,
        else => return error.Unknown,
    }
}
pub const BindImageMemory2Error = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn bindImageMemory2(
    device: Device,
    bind_info_count: u32,
    p_bind_infos: [*]const BindImageMemoryInfo,
) BindImageMemory2Error!void {
    const result = device_dispatch.vkBindImageMemory2.?(
        device,
        bind_info_count,
        p_bind_infos,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const BindImageMemory2KHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn bindImageMemory2KHR(
    device: Device,
    bind_info_count: u32,
    p_bind_infos: [*]const BindImageMemoryInfo,
) BindImageMemory2KHRError!void {
    const result = device_dispatch.vkBindImageMemory2KHR.?(
        device,
        bind_info_count,
        p_bind_infos,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub fn cmdSetDeviceMask(
    command_buffer: CommandBuffer,
    device_mask: u32,
) void {
    device_dispatch.vkCmdSetDeviceMask.?(
        command_buffer,
        device_mask,
    );
}
pub fn cmdSetDeviceMaskKHR(
    command_buffer: CommandBuffer,
    device_mask: u32,
) void {
    device_dispatch.vkCmdSetDeviceMaskKHR.?(
        command_buffer,
        device_mask,
    );
}
pub const GetDeviceGroupPresentCapabilitiesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getDeviceGroupPresentCapabilitiesKHR(
    device: Device,
    p_device_group_present_capabilities: *DeviceGroupPresentCapabilitiesKHR,
) GetDeviceGroupPresentCapabilitiesKHRError!void {
    const result = device_dispatch.vkGetDeviceGroupPresentCapabilitiesKHR.?(
        device,
        p_device_group_present_capabilities,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const GetDeviceGroupSurfacePresentModesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    SurfaceLostKHR,
    Unknown,
};
pub fn getDeviceGroupSurfacePresentModesKHR(
    device: Device,
    surface: SurfaceKHR,
) GetDeviceGroupSurfacePresentModesKHRError!DeviceGroupPresentModeFlagsKHR {
    var out_modes: DeviceGroupPresentModeFlagsKHR = undefined;
    const result = device_dispatch.vkGetDeviceGroupSurfacePresentModesKHR.?(
        device,
        surface,
        &out_modes,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
    return out_modes;
}
pub const AcquireNextImage2KHRResult = struct {
    result: Result,
    image_index: u32,
};
pub const AcquireNextImage2KHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    OutOfDateKHR,
    SurfaceLostKHR,
    FullScreenExclusiveModeLostEXT,
    Unknown,
};
pub fn acquireNextImage2KHR(
    device: Device,
    p_acquire_info: *const AcquireNextImageInfoKHR,
) AcquireNextImage2KHRError!AcquireNextImage2KHRResult {
    var return_values: AcquireNextImage2KHRResult = undefined;
    const result = device_dispatch.vkAcquireNextImage2KHR.?(
        device,
        p_acquire_info,
        &return_values.image_index,
    );
    switch (result) {
        Result.success => {},
        Result.timeout => {},
        Result.not_ready => {},
        Result.suboptimal_khr => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        Result.error_out_of_date_khr => return error.OutOfDateKHR,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        Result.error_full_screen_exclusive_mode_lost_ext => return error.FullScreenExclusiveModeLostEXT,
        else => return error.Unknown,
    }
    return_values.result = result;
    return return_values;
}
pub fn cmdDispatchBase(
    command_buffer: CommandBuffer,
    base_group_x: u32,
    base_group_y: u32,
    base_group_z: u32,
    group_count_x: u32,
    group_count_y: u32,
    group_count_z: u32,
) void {
    device_dispatch.vkCmdDispatchBase.?(
        command_buffer,
        base_group_x,
        base_group_y,
        base_group_z,
        group_count_x,
        group_count_y,
        group_count_z,
    );
}
pub fn cmdDispatchBaseKHR(
    command_buffer: CommandBuffer,
    base_group_x: u32,
    base_group_y: u32,
    base_group_z: u32,
    group_count_x: u32,
    group_count_y: u32,
    group_count_z: u32,
) void {
    device_dispatch.vkCmdDispatchBaseKHR.?(
        command_buffer,
        base_group_x,
        base_group_y,
        base_group_z,
        group_count_x,
        group_count_y,
        group_count_z,
    );
}
pub const CreateDescriptorUpdateTemplateError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createDescriptorUpdateTemplate(
    device: Device,
    p_create_info: *const DescriptorUpdateTemplateCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateDescriptorUpdateTemplateError!DescriptorUpdateTemplate {
    var out_descriptor_update_template: DescriptorUpdateTemplate = undefined;
    const result = device_dispatch.vkCreateDescriptorUpdateTemplate.?(
        device,
        p_create_info,
        p_allocator,
        &out_descriptor_update_template,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_descriptor_update_template;
}
pub const CreateDescriptorUpdateTemplateKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createDescriptorUpdateTemplateKHR(
    device: Device,
    p_create_info: *const DescriptorUpdateTemplateCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateDescriptorUpdateTemplateKHRError!DescriptorUpdateTemplate {
    var out_descriptor_update_template: DescriptorUpdateTemplate = undefined;
    const result = device_dispatch.vkCreateDescriptorUpdateTemplateKHR.?(
        device,
        p_create_info,
        p_allocator,
        &out_descriptor_update_template,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_descriptor_update_template;
}
pub fn destroyDescriptorUpdateTemplate(
    device: Device,
    descriptor_update_template: DescriptorUpdateTemplate,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyDescriptorUpdateTemplate.?(
        device,
        descriptor_update_template,
        p_allocator,
    );
}
pub fn destroyDescriptorUpdateTemplateKHR(
    device: Device,
    descriptor_update_template: DescriptorUpdateTemplate,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyDescriptorUpdateTemplateKHR.?(
        device,
        descriptor_update_template,
        p_allocator,
    );
}
pub fn updateDescriptorSetWithTemplate(
    device: Device,
    descriptor_set: DescriptorSet,
    descriptor_update_template: DescriptorUpdateTemplate,
    p_data: *const anyopaque,
) void {
    device_dispatch.vkUpdateDescriptorSetWithTemplate.?(
        device,
        descriptor_set,
        descriptor_update_template,
        p_data,
    );
}
pub fn updateDescriptorSetWithTemplateKHR(
    device: Device,
    descriptor_set: DescriptorSet,
    descriptor_update_template: DescriptorUpdateTemplate,
    p_data: *const anyopaque,
) void {
    device_dispatch.vkUpdateDescriptorSetWithTemplateKHR.?(
        device,
        descriptor_set,
        descriptor_update_template,
        p_data,
    );
}
pub fn cmdPushDescriptorSetWithTemplate(
    command_buffer: CommandBuffer,
    descriptor_update_template: DescriptorUpdateTemplate,
    layout: PipelineLayout,
    set: u32,
    p_data: *const anyopaque,
) void {
    device_dispatch.vkCmdPushDescriptorSetWithTemplate.?(
        command_buffer,
        descriptor_update_template,
        layout,
        set,
        p_data,
    );
}
pub fn cmdPushDescriptorSetWithTemplateKHR(
    command_buffer: CommandBuffer,
    descriptor_update_template: DescriptorUpdateTemplate,
    layout: PipelineLayout,
    set: u32,
    p_data: *const anyopaque,
) void {
    device_dispatch.vkCmdPushDescriptorSetWithTemplateKHR.?(
        command_buffer,
        descriptor_update_template,
        layout,
        set,
        p_data,
    );
}
pub fn setHdrMetadataEXT(
    device: Device,
    swapchain_count: u32,
    p_swapchains: [*]const SwapchainKHR,
    p_metadata: [*]const HdrMetadataEXT,
) void {
    device_dispatch.vkSetHdrMetadataEXT.?(
        device,
        swapchain_count,
        p_swapchains,
        p_metadata,
    );
}
pub const GetSwapchainStatusKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    OutOfDateKHR,
    SurfaceLostKHR,
    FullScreenExclusiveModeLostEXT,
    Unknown,
};
pub fn getSwapchainStatusKHR(
    device: Device,
    swapchain: SwapchainKHR,
) GetSwapchainStatusKHRError!Result {
    const result = device_dispatch.vkGetSwapchainStatusKHR.?(
        device,
        swapchain,
    );
    switch (result) {
        Result.success => {},
        Result.suboptimal_khr => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        Result.error_out_of_date_khr => return error.OutOfDateKHR,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        Result.error_full_screen_exclusive_mode_lost_ext => return error.FullScreenExclusiveModeLostEXT,
        else => return error.Unknown,
    }
    return result;
}
pub const GetRefreshCycleDurationGOOGLEError = error{
    OutOfHostMemory,
    DeviceLost,
    SurfaceLostKHR,
    Unknown,
};
pub fn getRefreshCycleDurationGOOGLE(
    device: Device,
    swapchain: SwapchainKHR,
) GetRefreshCycleDurationGOOGLEError!RefreshCycleDurationGOOGLE {
    var out_display_timing_properties: RefreshCycleDurationGOOGLE = undefined;
    const result = device_dispatch.vkGetRefreshCycleDurationGOOGLE.?(
        device,
        swapchain,
        &out_display_timing_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_device_lost => return error.DeviceLost,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
    return out_display_timing_properties;
}
pub const GetPastPresentationTimingGOOGLEError = error{
    OutOfHostMemory,
    DeviceLost,
    OutOfDateKHR,
    SurfaceLostKHR,
    Unknown,
};
pub fn getPastPresentationTimingGOOGLE(
    device: Device,
    swapchain: SwapchainKHR,
    p_presentation_timing_count: *u32,
    p_presentation_timings: ?[*]PastPresentationTimingGOOGLE,
) GetPastPresentationTimingGOOGLEError!Result {
    const result = device_dispatch.vkGetPastPresentationTimingGOOGLE.?(
        device,
        swapchain,
        p_presentation_timing_count,
        p_presentation_timings,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_device_lost => return error.DeviceLost,
        Result.error_out_of_date_khr => return error.OutOfDateKHR,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
    return result;
}
pub fn cmdSetViewportWScalingNV(
    command_buffer: CommandBuffer,
    first_viewport: u32,
    viewport_count: u32,
    p_viewport_w_scalings: [*]const ViewportWScalingNV,
) void {
    device_dispatch.vkCmdSetViewportWScalingNV.?(
        command_buffer,
        first_viewport,
        viewport_count,
        p_viewport_w_scalings,
    );
}
pub fn cmdSetDiscardRectangleEXT(
    command_buffer: CommandBuffer,
    first_discard_rectangle: u32,
    discard_rectangle_count: u32,
    p_discard_rectangles: [*]const Rect2D,
) void {
    device_dispatch.vkCmdSetDiscardRectangleEXT.?(
        command_buffer,
        first_discard_rectangle,
        discard_rectangle_count,
        p_discard_rectangles,
    );
}
pub fn cmdSetDiscardRectangleEnableEXT(
    command_buffer: CommandBuffer,
    discard_rectangle_enable: Bool32,
) void {
    device_dispatch.vkCmdSetDiscardRectangleEnableEXT.?(
        command_buffer,
        discard_rectangle_enable,
    );
}
pub fn cmdSetDiscardRectangleModeEXT(
    command_buffer: CommandBuffer,
    discard_rectangle_mode: DiscardRectangleModeEXT,
) void {
    device_dispatch.vkCmdSetDiscardRectangleModeEXT.?(
        command_buffer,
        discard_rectangle_mode,
    );
}
pub fn cmdSetSampleLocationsEXT(
    command_buffer: CommandBuffer,
    p_sample_locations_info: *const SampleLocationsInfoEXT,
) void {
    device_dispatch.vkCmdSetSampleLocationsEXT.?(
        command_buffer,
        p_sample_locations_info,
    );
}
pub fn getBufferMemoryRequirements2(
    device: Device,
    p_info: *const BufferMemoryRequirementsInfo2,
    p_memory_requirements: *MemoryRequirements2,
) void {
    device_dispatch.vkGetBufferMemoryRequirements2.?(
        device,
        p_info,
        p_memory_requirements,
    );
}
pub fn getBufferMemoryRequirements2KHR(
    device: Device,
    p_info: *const BufferMemoryRequirementsInfo2,
    p_memory_requirements: *MemoryRequirements2,
) void {
    device_dispatch.vkGetBufferMemoryRequirements2KHR.?(
        device,
        p_info,
        p_memory_requirements,
    );
}
pub fn getImageMemoryRequirements2(
    device: Device,
    p_info: *const ImageMemoryRequirementsInfo2,
    p_memory_requirements: *MemoryRequirements2,
) void {
    device_dispatch.vkGetImageMemoryRequirements2.?(
        device,
        p_info,
        p_memory_requirements,
    );
}
pub fn getImageMemoryRequirements2KHR(
    device: Device,
    p_info: *const ImageMemoryRequirementsInfo2,
    p_memory_requirements: *MemoryRequirements2,
) void {
    device_dispatch.vkGetImageMemoryRequirements2KHR.?(
        device,
        p_info,
        p_memory_requirements,
    );
}
pub fn getImageSparseMemoryRequirements2(
    device: Device,
    p_info: *const ImageSparseMemoryRequirementsInfo2,
    p_sparse_memory_requirement_count: *u32,
    p_sparse_memory_requirements: ?[*]SparseImageMemoryRequirements2,
) void {
    device_dispatch.vkGetImageSparseMemoryRequirements2.?(
        device,
        p_info,
        p_sparse_memory_requirement_count,
        p_sparse_memory_requirements,
    );
}
pub fn getImageSparseMemoryRequirements2Alloc(
    device: Device,
    p_info: *const ImageSparseMemoryRequirementsInfo2,
    allocator: Allocator,
) Allocator.Error![]SparseImageMemoryRequirements2 {
    var count: u32 = undefined;
    getImageSparseMemoryRequirements2(device, p_info, &count, null);
    const data = try allocator.alloc(SparseImageMemoryRequirements2, count);
    errdefer allocator.free(data);
    getImageSparseMemoryRequirements2(device, p_info, &count, data.ptr);
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub fn getImageSparseMemoryRequirements2KHR(
    device: Device,
    p_info: *const ImageSparseMemoryRequirementsInfo2,
    p_sparse_memory_requirement_count: *u32,
    p_sparse_memory_requirements: ?[*]SparseImageMemoryRequirements2,
) void {
    device_dispatch.vkGetImageSparseMemoryRequirements2KHR.?(
        device,
        p_info,
        p_sparse_memory_requirement_count,
        p_sparse_memory_requirements,
    );
}
pub fn getDeviceBufferMemoryRequirements(
    device: Device,
    p_info: *const DeviceBufferMemoryRequirements,
    p_memory_requirements: *MemoryRequirements2,
) void {
    device_dispatch.vkGetDeviceBufferMemoryRequirements.?(
        device,
        p_info,
        p_memory_requirements,
    );
}
pub fn getDeviceBufferMemoryRequirementsKHR(
    device: Device,
    p_info: *const DeviceBufferMemoryRequirements,
    p_memory_requirements: *MemoryRequirements2,
) void {
    device_dispatch.vkGetDeviceBufferMemoryRequirementsKHR.?(
        device,
        p_info,
        p_memory_requirements,
    );
}
pub fn getDeviceImageMemoryRequirements(
    device: Device,
    p_info: *const DeviceImageMemoryRequirements,
    p_memory_requirements: *MemoryRequirements2,
) void {
    device_dispatch.vkGetDeviceImageMemoryRequirements.?(
        device,
        p_info,
        p_memory_requirements,
    );
}
pub fn getDeviceImageMemoryRequirementsKHR(
    device: Device,
    p_info: *const DeviceImageMemoryRequirements,
    p_memory_requirements: *MemoryRequirements2,
) void {
    device_dispatch.vkGetDeviceImageMemoryRequirementsKHR.?(
        device,
        p_info,
        p_memory_requirements,
    );
}
pub fn getDeviceImageSparseMemoryRequirements(
    device: Device,
    p_info: *const DeviceImageMemoryRequirements,
    p_sparse_memory_requirement_count: *u32,
    p_sparse_memory_requirements: ?[*]SparseImageMemoryRequirements2,
) void {
    device_dispatch.vkGetDeviceImageSparseMemoryRequirements.?(
        device,
        p_info,
        p_sparse_memory_requirement_count,
        p_sparse_memory_requirements,
    );
}
pub fn getDeviceImageSparseMemoryRequirementsAlloc(
    device: Device,
    p_info: *const DeviceImageMemoryRequirements,
    allocator: Allocator,
) Allocator.Error![]SparseImageMemoryRequirements2 {
    var count: u32 = undefined;
    getDeviceImageSparseMemoryRequirements(device, p_info, &count, null);
    const data = try allocator.alloc(SparseImageMemoryRequirements2, count);
    errdefer allocator.free(data);
    getDeviceImageSparseMemoryRequirements(device, p_info, &count, data.ptr);
    return if (count == data.len) data else allocator.realloc(data, count);
}
pub fn getDeviceImageSparseMemoryRequirementsKHR(
    device: Device,
    p_info: *const DeviceImageMemoryRequirements,
    p_sparse_memory_requirement_count: *u32,
    p_sparse_memory_requirements: ?[*]SparseImageMemoryRequirements2,
) void {
    device_dispatch.vkGetDeviceImageSparseMemoryRequirementsKHR.?(
        device,
        p_info,
        p_sparse_memory_requirement_count,
        p_sparse_memory_requirements,
    );
}
pub const CreateSamplerYcbcrConversionError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createSamplerYcbcrConversion(
    device: Device,
    p_create_info: *const SamplerYcbcrConversionCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateSamplerYcbcrConversionError!SamplerYcbcrConversion {
    var out_ycbcr_conversion: SamplerYcbcrConversion = undefined;
    const result = device_dispatch.vkCreateSamplerYcbcrConversion.?(
        device,
        p_create_info,
        p_allocator,
        &out_ycbcr_conversion,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_ycbcr_conversion;
}
pub const CreateSamplerYcbcrConversionKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createSamplerYcbcrConversionKHR(
    device: Device,
    p_create_info: *const SamplerYcbcrConversionCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreateSamplerYcbcrConversionKHRError!SamplerYcbcrConversion {
    var out_ycbcr_conversion: SamplerYcbcrConversion = undefined;
    const result = device_dispatch.vkCreateSamplerYcbcrConversionKHR.?(
        device,
        p_create_info,
        p_allocator,
        &out_ycbcr_conversion,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_ycbcr_conversion;
}
pub fn destroySamplerYcbcrConversion(
    device: Device,
    ycbcr_conversion: SamplerYcbcrConversion,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroySamplerYcbcrConversion.?(
        device,
        ycbcr_conversion,
        p_allocator,
    );
}
pub fn destroySamplerYcbcrConversionKHR(
    device: Device,
    ycbcr_conversion: SamplerYcbcrConversion,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroySamplerYcbcrConversionKHR.?(
        device,
        ycbcr_conversion,
        p_allocator,
    );
}
pub fn getDeviceQueue2(
    device: Device,
    p_queue_info: *const DeviceQueueInfo2,
) Queue {
    var out_queue: Queue = undefined;
    device_dispatch.vkGetDeviceQueue2.?(
        device,
        p_queue_info,
        &out_queue,
    );
    return out_queue;
}
pub const CreateValidationCacheEXTError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn createValidationCacheEXT(
    device: Device,
    p_create_info: *const ValidationCacheCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
) CreateValidationCacheEXTError!ValidationCacheEXT {
    var out_validation_cache: ValidationCacheEXT = undefined;
    const result = device_dispatch.vkCreateValidationCacheEXT.?(
        device,
        p_create_info,
        p_allocator,
        &out_validation_cache,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_validation_cache;
}
pub fn destroyValidationCacheEXT(
    device: Device,
    validation_cache: ValidationCacheEXT,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyValidationCacheEXT.?(
        device,
        validation_cache,
        p_allocator,
    );
}
pub const GetValidationCacheDataEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getValidationCacheDataEXT(
    device: Device,
    validation_cache: ValidationCacheEXT,
    p_data_size: *usize,
    p_data: ?*anyopaque,
) GetValidationCacheDataEXTError!Result {
    const result = device_dispatch.vkGetValidationCacheDataEXT.?(
        device,
        validation_cache,
        p_data_size,
        p_data,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const MergeValidationCachesEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn mergeValidationCachesEXT(
    device: Device,
    dst_cache: ValidationCacheEXT,
    src_cache_count: u32,
    p_src_caches: [*]const ValidationCacheEXT,
) MergeValidationCachesEXTError!void {
    const result = device_dispatch.vkMergeValidationCachesEXT.?(
        device,
        dst_cache,
        src_cache_count,
        p_src_caches,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub fn getDescriptorSetLayoutSupport(
    device: Device,
    p_create_info: *const DescriptorSetLayoutCreateInfo,
    p_support: *DescriptorSetLayoutSupport,
) void {
    device_dispatch.vkGetDescriptorSetLayoutSupport.?(
        device,
        p_create_info,
        p_support,
    );
}
pub fn getDescriptorSetLayoutSupportKHR(
    device: Device,
    p_create_info: *const DescriptorSetLayoutCreateInfo,
    p_support: *DescriptorSetLayoutSupport,
) void {
    device_dispatch.vkGetDescriptorSetLayoutSupportKHR.?(
        device,
        p_create_info,
        p_support,
    );
}
pub const GetSwapchainGrallocUsageANDROIDError = error{
    Unknown,
};
pub fn getSwapchainGrallocUsageANDROID(
    device: Device,
    format: Format,
    image_usage: ImageUsageFlags,
) GetSwapchainGrallocUsageANDROIDError!c_int {
    var out_gralloc_usage: c_int = undefined;
    const result = device_dispatch.vkGetSwapchainGrallocUsageANDROID.?(
        device,
        format,
        image_usage,
        &out_gralloc_usage,
    );
    switch (result) {
        else => return error.Unknown,
    }
    return out_gralloc_usage;
}
pub const GetSwapchainGrallocUsage2ANDROIDResult = struct {
    gralloc_consumer_usage: u64,
    gralloc_producer_usage: u64,
};
pub const GetSwapchainGrallocUsage2ANDROIDError = error{
    Unknown,
};
pub fn getSwapchainGrallocUsage2ANDROID(
    device: Device,
    format: Format,
    image_usage: ImageUsageFlags,
    swapchain_image_usage: SwapchainImageUsageFlagsANDROID,
) GetSwapchainGrallocUsage2ANDROIDError!GetSwapchainGrallocUsage2ANDROIDResult {
    var return_values: GetSwapchainGrallocUsage2ANDROIDResult = undefined;
    const result = device_dispatch.vkGetSwapchainGrallocUsage2ANDROID.?(
        device,
        format,
        image_usage,
        swapchain_image_usage,
        &return_values.gralloc_consumer_usage,
        &return_values.gralloc_producer_usage,
    );
    switch (result) {
        else => return error.Unknown,
    }
    return return_values;
}
pub const AcquireImageANDROIDError = error{
    Unknown,
};
pub fn acquireImageANDROID(
    device: Device,
    image: Image,
    native_fence_fd: c_int,
    semaphore: Semaphore,
    fence: Fence,
) AcquireImageANDROIDError!void {
    const result = device_dispatch.vkAcquireImageANDROID.?(
        device,
        image,
        native_fence_fd,
        semaphore,
        fence,
    );
    switch (result) {
        else => return error.Unknown,
    }
}
pub const QueueSignalReleaseImageANDROIDError = error{
    Unknown,
};
pub fn queueSignalReleaseImageANDROID(
    queue: Queue,
    wait_semaphore_count: u32,
    p_wait_semaphores: [*]const Semaphore,
    image: Image,
) QueueSignalReleaseImageANDROIDError!c_int {
    var out_native_fence_fd: c_int = undefined;
    const result = device_dispatch.vkQueueSignalReleaseImageANDROID.?(
        queue,
        wait_semaphore_count,
        p_wait_semaphores,
        image,
        &out_native_fence_fd,
    );
    switch (result) {
        else => return error.Unknown,
    }
    return out_native_fence_fd;
}
pub const GetShaderInfoAMDError = error{
    FeatureNotPresent,
    OutOfHostMemory,
    Unknown,
};
pub fn getShaderInfoAMD(
    device: Device,
    pipeline: Pipeline,
    shader_stage: ShaderStageFlags,
    info_type: ShaderInfoTypeAMD,
    p_info_size: *usize,
    p_info: ?*anyopaque,
) GetShaderInfoAMDError!Result {
    const result = device_dispatch.vkGetShaderInfoAMD.?(
        device,
        pipeline,
        shader_stage,
        info_type,
        p_info_size,
        p_info,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_feature_not_present => return error.FeatureNotPresent,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn setLocalDimmingAMD(
    device: Device,
    swap_chain: SwapchainKHR,
    local_dimming_enable: Bool32,
) void {
    device_dispatch.vkSetLocalDimmingAMD.?(
        device,
        swap_chain,
        local_dimming_enable,
    );
}
pub const GetCalibratedTimestampsKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getCalibratedTimestampsKHR(
    device: Device,
    timestamp_count: u32,
    p_timestamp_infos: [*]const CalibratedTimestampInfoKHR,
    p_timestamps: [*]u64,
) GetCalibratedTimestampsKHRError!u64 {
    var out_max_deviation: u64 = undefined;
    const result = device_dispatch.vkGetCalibratedTimestampsKHR.?(
        device,
        timestamp_count,
        p_timestamp_infos,
        p_timestamps,
        &out_max_deviation,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_max_deviation;
}
pub const GetCalibratedTimestampsEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getCalibratedTimestampsEXT(
    device: Device,
    timestamp_count: u32,
    p_timestamp_infos: [*]const CalibratedTimestampInfoKHR,
    p_timestamps: [*]u64,
) GetCalibratedTimestampsEXTError!u64 {
    var out_max_deviation: u64 = undefined;
    const result = device_dispatch.vkGetCalibratedTimestampsEXT.?(
        device,
        timestamp_count,
        p_timestamp_infos,
        p_timestamps,
        &out_max_deviation,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_max_deviation;
}
pub const SetDebugUtilsObjectNameEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn setDebugUtilsObjectNameEXT(
    device: Device,
    p_name_info: *const DebugUtilsObjectNameInfoEXT,
) SetDebugUtilsObjectNameEXTError!void {
    const result = device_dispatch.vkSetDebugUtilsObjectNameEXT.?(
        device,
        p_name_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const SetDebugUtilsObjectTagEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn setDebugUtilsObjectTagEXT(
    device: Device,
    p_tag_info: *const DebugUtilsObjectTagInfoEXT,
) SetDebugUtilsObjectTagEXTError!void {
    const result = device_dispatch.vkSetDebugUtilsObjectTagEXT.?(
        device,
        p_tag_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub fn queueBeginDebugUtilsLabelEXT(
    queue: Queue,
    p_label_info: *const DebugUtilsLabelEXT,
) void {
    device_dispatch.vkQueueBeginDebugUtilsLabelEXT.?(
        queue,
        p_label_info,
    );
}
pub fn queueEndDebugUtilsLabelEXT(
    queue: Queue,
) void {
    device_dispatch.vkQueueEndDebugUtilsLabelEXT.?(
        queue,
    );
}
pub fn queueInsertDebugUtilsLabelEXT(
    queue: Queue,
    p_label_info: *const DebugUtilsLabelEXT,
) void {
    device_dispatch.vkQueueInsertDebugUtilsLabelEXT.?(
        queue,
        p_label_info,
    );
}
pub fn cmdBeginDebugUtilsLabelEXT(
    command_buffer: CommandBuffer,
    p_label_info: *const DebugUtilsLabelEXT,
) void {
    device_dispatch.vkCmdBeginDebugUtilsLabelEXT.?(
        command_buffer,
        p_label_info,
    );
}
pub fn cmdEndDebugUtilsLabelEXT(
    command_buffer: CommandBuffer,
) void {
    device_dispatch.vkCmdEndDebugUtilsLabelEXT.?(
        command_buffer,
    );
}
pub fn cmdInsertDebugUtilsLabelEXT(
    command_buffer: CommandBuffer,
    p_label_info: *const DebugUtilsLabelEXT,
) void {
    device_dispatch.vkCmdInsertDebugUtilsLabelEXT.?(
        command_buffer,
        p_label_info,
    );
}
pub const GetMemoryHostPointerPropertiesEXTError = error{
    OutOfHostMemory,
    InvalidExternalHandle,
    Unknown,
};
pub fn getMemoryHostPointerPropertiesEXT(
    device: Device,
    handle_type: ExternalMemoryHandleTypeFlags,
    p_host_pointer: *const anyopaque,
    p_memory_host_pointer_properties: *MemoryHostPointerPropertiesEXT,
) GetMemoryHostPointerPropertiesEXTError!void {
    const result = device_dispatch.vkGetMemoryHostPointerPropertiesEXT.?(
        device,
        handle_type,
        p_host_pointer,
        p_memory_host_pointer_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        else => return error.Unknown,
    }
}
pub fn cmdWriteBufferMarkerAMD(
    command_buffer: CommandBuffer,
    pipeline_stage: PipelineStageFlags,
    dst_buffer: Buffer,
    dst_offset: DeviceSize,
    marker: u32,
) void {
    device_dispatch.vkCmdWriteBufferMarkerAMD.?(
        command_buffer,
        pipeline_stage,
        dst_buffer,
        dst_offset,
        marker,
    );
}
pub const CreateRenderPass2Error = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createRenderPass2(
    device: Device,
    p_create_info: *const RenderPassCreateInfo2,
    p_allocator: ?*const AllocationCallbacks,
) CreateRenderPass2Error!RenderPass {
    var out_render_pass: RenderPass = undefined;
    const result = device_dispatch.vkCreateRenderPass2.?(
        device,
        p_create_info,
        p_allocator,
        &out_render_pass,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_render_pass;
}
pub const CreateRenderPass2KHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createRenderPass2KHR(
    device: Device,
    p_create_info: *const RenderPassCreateInfo2,
    p_allocator: ?*const AllocationCallbacks,
) CreateRenderPass2KHRError!RenderPass {
    var out_render_pass: RenderPass = undefined;
    const result = device_dispatch.vkCreateRenderPass2KHR.?(
        device,
        p_create_info,
        p_allocator,
        &out_render_pass,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_render_pass;
}
pub fn cmdBeginRenderPass2(
    command_buffer: CommandBuffer,
    p_render_pass_begin: *const RenderPassBeginInfo,
    p_subpass_begin_info: *const SubpassBeginInfo,
) void {
    device_dispatch.vkCmdBeginRenderPass2.?(
        command_buffer,
        p_render_pass_begin,
        p_subpass_begin_info,
    );
}
pub fn cmdBeginRenderPass2KHR(
    command_buffer: CommandBuffer,
    p_render_pass_begin: *const RenderPassBeginInfo,
    p_subpass_begin_info: *const SubpassBeginInfo,
) void {
    device_dispatch.vkCmdBeginRenderPass2KHR.?(
        command_buffer,
        p_render_pass_begin,
        p_subpass_begin_info,
    );
}
pub fn cmdNextSubpass2(
    command_buffer: CommandBuffer,
    p_subpass_begin_info: *const SubpassBeginInfo,
    p_subpass_end_info: *const SubpassEndInfo,
) void {
    device_dispatch.vkCmdNextSubpass2.?(
        command_buffer,
        p_subpass_begin_info,
        p_subpass_end_info,
    );
}
pub fn cmdNextSubpass2KHR(
    command_buffer: CommandBuffer,
    p_subpass_begin_info: *const SubpassBeginInfo,
    p_subpass_end_info: *const SubpassEndInfo,
) void {
    device_dispatch.vkCmdNextSubpass2KHR.?(
        command_buffer,
        p_subpass_begin_info,
        p_subpass_end_info,
    );
}
pub fn cmdEndRenderPass2(
    command_buffer: CommandBuffer,
    p_subpass_end_info: *const SubpassEndInfo,
) void {
    device_dispatch.vkCmdEndRenderPass2.?(
        command_buffer,
        p_subpass_end_info,
    );
}
pub fn cmdEndRenderPass2KHR(
    command_buffer: CommandBuffer,
    p_subpass_end_info: *const SubpassEndInfo,
) void {
    device_dispatch.vkCmdEndRenderPass2KHR.?(
        command_buffer,
        p_subpass_end_info,
    );
}
pub const GetSemaphoreCounterValueError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    Unknown,
};
pub fn getSemaphoreCounterValue(
    device: Device,
    semaphore: Semaphore,
) GetSemaphoreCounterValueError!u64 {
    var out_value: u64 = undefined;
    const result = device_dispatch.vkGetSemaphoreCounterValue.?(
        device,
        semaphore,
        &out_value,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        else => return error.Unknown,
    }
    return out_value;
}
pub const GetSemaphoreCounterValueKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    Unknown,
};
pub fn getSemaphoreCounterValueKHR(
    device: Device,
    semaphore: Semaphore,
) GetSemaphoreCounterValueKHRError!u64 {
    var out_value: u64 = undefined;
    const result = device_dispatch.vkGetSemaphoreCounterValueKHR.?(
        device,
        semaphore,
        &out_value,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        else => return error.Unknown,
    }
    return out_value;
}
pub const WaitSemaphoresError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    Unknown,
};
pub fn waitSemaphores(
    device: Device,
    p_wait_info: *const SemaphoreWaitInfo,
    timeout: u64,
) WaitSemaphoresError!Result {
    const result = device_dispatch.vkWaitSemaphores.?(
        device,
        p_wait_info,
        timeout,
    );
    switch (result) {
        Result.success => {},
        Result.timeout => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        else => return error.Unknown,
    }
    return result;
}
pub const WaitSemaphoresKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    Unknown,
};
pub fn waitSemaphoresKHR(
    device: Device,
    p_wait_info: *const SemaphoreWaitInfo,
    timeout: u64,
) WaitSemaphoresKHRError!Result {
    const result = device_dispatch.vkWaitSemaphoresKHR.?(
        device,
        p_wait_info,
        timeout,
    );
    switch (result) {
        Result.success => {},
        Result.timeout => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        else => return error.Unknown,
    }
    return result;
}
pub const SignalSemaphoreError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn signalSemaphore(
    device: Device,
    p_signal_info: *const SemaphoreSignalInfo,
) SignalSemaphoreError!void {
    const result = device_dispatch.vkSignalSemaphore.?(
        device,
        p_signal_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const SignalSemaphoreKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn signalSemaphoreKHR(
    device: Device,
    p_signal_info: *const SemaphoreSignalInfo,
) SignalSemaphoreKHRError!void {
    const result = device_dispatch.vkSignalSemaphoreKHR.?(
        device,
        p_signal_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const GetAndroidHardwareBufferPropertiesANDROIDError = error{
    OutOfHostMemory,
    InvalidExternalHandleKHR,
    Unknown,
};
pub fn getAndroidHardwareBufferPropertiesANDROID(
    device: Device,
    buffer: *const AHardwareBuffer,
    p_properties: *AndroidHardwareBufferPropertiesANDROID,
) GetAndroidHardwareBufferPropertiesANDROIDError!void {
    const result = device_dispatch.vkGetAndroidHardwareBufferPropertiesANDROID.?(
        device,
        buffer,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_invalid_external_handle_khr => return error.InvalidExternalHandleKHR,
        else => return error.Unknown,
    }
}
pub const GetMemoryAndroidHardwareBufferANDROIDError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn getMemoryAndroidHardwareBufferANDROID(
    device: Device,
    p_info: *const MemoryGetAndroidHardwareBufferInfoANDROID,
) GetMemoryAndroidHardwareBufferANDROIDError!*AHardwareBuffer {
    var out_buffer: *AHardwareBuffer = undefined;
    const result = device_dispatch.vkGetMemoryAndroidHardwareBufferANDROID.?(
        device,
        p_info,
        &out_buffer,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_buffer;
}
pub fn cmdDrawIndirectCount(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    count_buffer: Buffer,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
) void {
    device_dispatch.vkCmdDrawIndirectCount.?(
        command_buffer,
        buffer,
        offset,
        count_buffer,
        count_buffer_offset,
        max_draw_count,
        stride,
    );
}
pub fn cmdDrawIndirectCountKHR(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    count_buffer: Buffer,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
) void {
    device_dispatch.vkCmdDrawIndirectCountKHR.?(
        command_buffer,
        buffer,
        offset,
        count_buffer,
        count_buffer_offset,
        max_draw_count,
        stride,
    );
}
pub fn cmdDrawIndirectCountAMD(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    count_buffer: Buffer,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
) void {
    device_dispatch.vkCmdDrawIndirectCountAMD.?(
        command_buffer,
        buffer,
        offset,
        count_buffer,
        count_buffer_offset,
        max_draw_count,
        stride,
    );
}
pub fn cmdDrawIndexedIndirectCount(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    count_buffer: Buffer,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
) void {
    device_dispatch.vkCmdDrawIndexedIndirectCount.?(
        command_buffer,
        buffer,
        offset,
        count_buffer,
        count_buffer_offset,
        max_draw_count,
        stride,
    );
}
pub fn cmdDrawIndexedIndirectCountKHR(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    count_buffer: Buffer,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
) void {
    device_dispatch.vkCmdDrawIndexedIndirectCountKHR.?(
        command_buffer,
        buffer,
        offset,
        count_buffer,
        count_buffer_offset,
        max_draw_count,
        stride,
    );
}
pub fn cmdDrawIndexedIndirectCountAMD(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    count_buffer: Buffer,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
) void {
    device_dispatch.vkCmdDrawIndexedIndirectCountAMD.?(
        command_buffer,
        buffer,
        offset,
        count_buffer,
        count_buffer_offset,
        max_draw_count,
        stride,
    );
}
pub fn cmdSetCheckpointNV(
    command_buffer: CommandBuffer,
    p_checkpoint_marker: *const anyopaque,
) void {
    device_dispatch.vkCmdSetCheckpointNV.?(
        command_buffer,
        p_checkpoint_marker,
    );
}
pub fn getQueueCheckpointDataNV(
    queue: Queue,
    p_checkpoint_data_count: *u32,
    p_checkpoint_data: ?[*]CheckpointDataNV,
) void {
    device_dispatch.vkGetQueueCheckpointDataNV.?(
        queue,
        p_checkpoint_data_count,
        p_checkpoint_data,
    );
}
pub fn cmdBindTransformFeedbackBuffersEXT(
    command_buffer: CommandBuffer,
    first_binding: u32,
    binding_count: u32,
    p_buffers: [*]const Buffer,
    p_offsets: [*]const DeviceSize,
    p_sizes: ?[*]const DeviceSize,
) void {
    device_dispatch.vkCmdBindTransformFeedbackBuffersEXT.?(
        command_buffer,
        first_binding,
        binding_count,
        p_buffers,
        p_offsets,
        p_sizes,
    );
}
pub fn cmdBeginTransformFeedbackEXT(
    command_buffer: CommandBuffer,
    first_counter_buffer: u32,
    counter_buffer_count: u32,
    p_counter_buffers: ?[*]const Buffer,
    p_counter_buffer_offsets: ?[*]const DeviceSize,
) void {
    device_dispatch.vkCmdBeginTransformFeedbackEXT.?(
        command_buffer,
        first_counter_buffer,
        counter_buffer_count,
        p_counter_buffers,
        p_counter_buffer_offsets,
    );
}
pub fn cmdEndTransformFeedbackEXT(
    command_buffer: CommandBuffer,
    first_counter_buffer: u32,
    counter_buffer_count: u32,
    p_counter_buffers: ?[*]const Buffer,
    p_counter_buffer_offsets: ?[*]const DeviceSize,
) void {
    device_dispatch.vkCmdEndTransformFeedbackEXT.?(
        command_buffer,
        first_counter_buffer,
        counter_buffer_count,
        p_counter_buffers,
        p_counter_buffer_offsets,
    );
}
pub fn cmdBeginQueryIndexedEXT(
    command_buffer: CommandBuffer,
    query_pool: QueryPool,
    query: u32,
    flags: QueryControlFlags,
    index: u32,
) void {
    device_dispatch.vkCmdBeginQueryIndexedEXT.?(
        command_buffer,
        query_pool,
        query,
        flags,
        index,
    );
}
pub fn cmdEndQueryIndexedEXT(
    command_buffer: CommandBuffer,
    query_pool: QueryPool,
    query: u32,
    index: u32,
) void {
    device_dispatch.vkCmdEndQueryIndexedEXT.?(
        command_buffer,
        query_pool,
        query,
        index,
    );
}
pub fn cmdDrawIndirectByteCountEXT(
    command_buffer: CommandBuffer,
    instance_count: u32,
    first_instance: u32,
    counter_buffer: Buffer,
    counter_buffer_offset: DeviceSize,
    counter_offset: u32,
    vertex_stride: u32,
) void {
    device_dispatch.vkCmdDrawIndirectByteCountEXT.?(
        command_buffer,
        instance_count,
        first_instance,
        counter_buffer,
        counter_buffer_offset,
        counter_offset,
        vertex_stride,
    );
}
pub fn cmdSetExclusiveScissorNV(
    command_buffer: CommandBuffer,
    first_exclusive_scissor: u32,
    exclusive_scissor_count: u32,
    p_exclusive_scissors: [*]const Rect2D,
) void {
    device_dispatch.vkCmdSetExclusiveScissorNV.?(
        command_buffer,
        first_exclusive_scissor,
        exclusive_scissor_count,
        p_exclusive_scissors,
    );
}
pub fn cmdSetExclusiveScissorEnableNV(
    command_buffer: CommandBuffer,
    first_exclusive_scissor: u32,
    exclusive_scissor_count: u32,
    p_exclusive_scissor_enables: [*]const Bool32,
) void {
    device_dispatch.vkCmdSetExclusiveScissorEnableNV.?(
        command_buffer,
        first_exclusive_scissor,
        exclusive_scissor_count,
        p_exclusive_scissor_enables,
    );
}
pub fn cmdBindShadingRateImageNV(
    command_buffer: CommandBuffer,
    image_view: ImageView,
    image_layout: ImageLayout,
) void {
    device_dispatch.vkCmdBindShadingRateImageNV.?(
        command_buffer,
        image_view,
        image_layout,
    );
}
pub fn cmdSetViewportShadingRatePaletteNV(
    command_buffer: CommandBuffer,
    first_viewport: u32,
    viewport_count: u32,
    p_shading_rate_palettes: [*]const ShadingRatePaletteNV,
) void {
    device_dispatch.vkCmdSetViewportShadingRatePaletteNV.?(
        command_buffer,
        first_viewport,
        viewport_count,
        p_shading_rate_palettes,
    );
}
pub fn cmdSetCoarseSampleOrderNV(
    command_buffer: CommandBuffer,
    sample_order_type: CoarseSampleOrderTypeNV,
    custom_sample_order_count: u32,
    p_custom_sample_orders: ?[*]const CoarseSampleOrderCustomNV,
) void {
    device_dispatch.vkCmdSetCoarseSampleOrderNV.?(
        command_buffer,
        sample_order_type,
        custom_sample_order_count,
        p_custom_sample_orders,
    );
}
pub fn cmdDrawMeshTasksNV(
    command_buffer: CommandBuffer,
    task_count: u32,
    first_task: u32,
) void {
    device_dispatch.vkCmdDrawMeshTasksNV.?(
        command_buffer,
        task_count,
        first_task,
    );
}
pub fn cmdDrawMeshTasksIndirectNV(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    draw_count: u32,
    stride: u32,
) void {
    device_dispatch.vkCmdDrawMeshTasksIndirectNV.?(
        command_buffer,
        buffer,
        offset,
        draw_count,
        stride,
    );
}
pub fn cmdDrawMeshTasksIndirectCountNV(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    count_buffer: Buffer,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
) void {
    device_dispatch.vkCmdDrawMeshTasksIndirectCountNV.?(
        command_buffer,
        buffer,
        offset,
        count_buffer,
        count_buffer_offset,
        max_draw_count,
        stride,
    );
}
pub fn cmdDrawMeshTasksEXT(
    command_buffer: CommandBuffer,
    group_count_x: u32,
    group_count_y: u32,
    group_count_z: u32,
) void {
    device_dispatch.vkCmdDrawMeshTasksEXT.?(
        command_buffer,
        group_count_x,
        group_count_y,
        group_count_z,
    );
}
pub fn cmdDrawMeshTasksIndirectEXT(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    draw_count: u32,
    stride: u32,
) void {
    device_dispatch.vkCmdDrawMeshTasksIndirectEXT.?(
        command_buffer,
        buffer,
        offset,
        draw_count,
        stride,
    );
}
pub fn cmdDrawMeshTasksIndirectCountEXT(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    count_buffer: Buffer,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
) void {
    device_dispatch.vkCmdDrawMeshTasksIndirectCountEXT.?(
        command_buffer,
        buffer,
        offset,
        count_buffer,
        count_buffer_offset,
        max_draw_count,
        stride,
    );
}
pub const CompileDeferredNVError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn compileDeferredNV(
    device: Device,
    pipeline: Pipeline,
    shader: u32,
) CompileDeferredNVError!void {
    const result = device_dispatch.vkCompileDeferredNV.?(
        device,
        pipeline,
        shader,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const CreateAccelerationStructureNVError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn createAccelerationStructureNV(
    device: Device,
    p_create_info: *const AccelerationStructureCreateInfoNV,
    p_allocator: ?*const AllocationCallbacks,
) CreateAccelerationStructureNVError!AccelerationStructureNV {
    var out_acceleration_structure: AccelerationStructureNV = undefined;
    const result = device_dispatch.vkCreateAccelerationStructureNV.?(
        device,
        p_create_info,
        p_allocator,
        &out_acceleration_structure,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_acceleration_structure;
}
pub fn cmdBindInvocationMaskHUAWEI(
    command_buffer: CommandBuffer,
    image_view: ImageView,
    image_layout: ImageLayout,
) void {
    device_dispatch.vkCmdBindInvocationMaskHUAWEI.?(
        command_buffer,
        image_view,
        image_layout,
    );
}
pub fn destroyAccelerationStructureKHR(
    device: Device,
    acceleration_structure: AccelerationStructureKHR,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyAccelerationStructureKHR.?(
        device,
        acceleration_structure,
        p_allocator,
    );
}
pub fn destroyAccelerationStructureNV(
    device: Device,
    acceleration_structure: AccelerationStructureNV,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyAccelerationStructureNV.?(
        device,
        acceleration_structure,
        p_allocator,
    );
}
pub fn getAccelerationStructureMemoryRequirementsNV(
    device: Device,
    p_info: *const AccelerationStructureMemoryRequirementsInfoNV,
    p_memory_requirements: *MemoryRequirements2KHR,
) void {
    device_dispatch.vkGetAccelerationStructureMemoryRequirementsNV.?(
        device,
        p_info,
        p_memory_requirements,
    );
}
pub const BindAccelerationStructureMemoryNVError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn bindAccelerationStructureMemoryNV(
    device: Device,
    bind_info_count: u32,
    p_bind_infos: [*]const BindAccelerationStructureMemoryInfoNV,
) BindAccelerationStructureMemoryNVError!void {
    const result = device_dispatch.vkBindAccelerationStructureMemoryNV.?(
        device,
        bind_info_count,
        p_bind_infos,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub fn cmdCopyAccelerationStructureNV(
    command_buffer: CommandBuffer,
    dst: AccelerationStructureNV,
    src: AccelerationStructureNV,
    mode: CopyAccelerationStructureModeKHR,
) void {
    device_dispatch.vkCmdCopyAccelerationStructureNV.?(
        command_buffer,
        dst,
        src,
        mode,
    );
}
pub fn cmdCopyAccelerationStructureKHR(
    command_buffer: CommandBuffer,
    p_info: *const CopyAccelerationStructureInfoKHR,
) void {
    device_dispatch.vkCmdCopyAccelerationStructureKHR.?(
        command_buffer,
        p_info,
    );
}
pub const CopyAccelerationStructureKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn copyAccelerationStructureKHR(
    device: Device,
    deferred_operation: DeferredOperationKHR,
    p_info: *const CopyAccelerationStructureInfoKHR,
) CopyAccelerationStructureKHRError!Result {
    const result = device_dispatch.vkCopyAccelerationStructureKHR.?(
        device,
        deferred_operation,
        p_info,
    );
    switch (result) {
        Result.success => {},
        Result.operation_deferred_khr => {},
        Result.operation_not_deferred_khr => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn cmdCopyAccelerationStructureToMemoryKHR(
    command_buffer: CommandBuffer,
    p_info: *const CopyAccelerationStructureToMemoryInfoKHR,
) void {
    device_dispatch.vkCmdCopyAccelerationStructureToMemoryKHR.?(
        command_buffer,
        p_info,
    );
}
pub const CopyAccelerationStructureToMemoryKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn copyAccelerationStructureToMemoryKHR(
    device: Device,
    deferred_operation: DeferredOperationKHR,
    p_info: *const CopyAccelerationStructureToMemoryInfoKHR,
) CopyAccelerationStructureToMemoryKHRError!Result {
    const result = device_dispatch.vkCopyAccelerationStructureToMemoryKHR.?(
        device,
        deferred_operation,
        p_info,
    );
    switch (result) {
        Result.success => {},
        Result.operation_deferred_khr => {},
        Result.operation_not_deferred_khr => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn cmdCopyMemoryToAccelerationStructureKHR(
    command_buffer: CommandBuffer,
    p_info: *const CopyMemoryToAccelerationStructureInfoKHR,
) void {
    device_dispatch.vkCmdCopyMemoryToAccelerationStructureKHR.?(
        command_buffer,
        p_info,
    );
}
pub const CopyMemoryToAccelerationStructureKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn copyMemoryToAccelerationStructureKHR(
    device: Device,
    deferred_operation: DeferredOperationKHR,
    p_info: *const CopyMemoryToAccelerationStructureInfoKHR,
) CopyMemoryToAccelerationStructureKHRError!Result {
    const result = device_dispatch.vkCopyMemoryToAccelerationStructureKHR.?(
        device,
        deferred_operation,
        p_info,
    );
    switch (result) {
        Result.success => {},
        Result.operation_deferred_khr => {},
        Result.operation_not_deferred_khr => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn cmdWriteAccelerationStructuresPropertiesKHR(
    command_buffer: CommandBuffer,
    acceleration_structure_count: u32,
    p_acceleration_structures: [*]const AccelerationStructureKHR,
    query_type: QueryType,
    query_pool: QueryPool,
    first_query: u32,
) void {
    device_dispatch.vkCmdWriteAccelerationStructuresPropertiesKHR.?(
        command_buffer,
        acceleration_structure_count,
        p_acceleration_structures,
        query_type,
        query_pool,
        first_query,
    );
}
pub fn cmdWriteAccelerationStructuresPropertiesNV(
    command_buffer: CommandBuffer,
    acceleration_structure_count: u32,
    p_acceleration_structures: [*]const AccelerationStructureNV,
    query_type: QueryType,
    query_pool: QueryPool,
    first_query: u32,
) void {
    device_dispatch.vkCmdWriteAccelerationStructuresPropertiesNV.?(
        command_buffer,
        acceleration_structure_count,
        p_acceleration_structures,
        query_type,
        query_pool,
        first_query,
    );
}
pub fn cmdBuildAccelerationStructureNV(
    command_buffer: CommandBuffer,
    p_info: *const AccelerationStructureInfoNV,
    instance_data: Buffer,
    instance_offset: DeviceSize,
    update: Bool32,
    dst: AccelerationStructureNV,
    src: AccelerationStructureNV,
    scratch: Buffer,
    scratch_offset: DeviceSize,
) void {
    device_dispatch.vkCmdBuildAccelerationStructureNV.?(
        command_buffer,
        p_info,
        instance_data,
        instance_offset,
        update,
        dst,
        src,
        scratch,
        scratch_offset,
    );
}
pub const WriteAccelerationStructuresPropertiesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn writeAccelerationStructuresPropertiesKHR(
    device: Device,
    acceleration_structure_count: u32,
    p_acceleration_structures: [*]const AccelerationStructureKHR,
    query_type: QueryType,
    data_size: usize,
    p_data: *anyopaque,
    stride: usize,
) WriteAccelerationStructuresPropertiesKHRError!void {
    const result = device_dispatch.vkWriteAccelerationStructuresPropertiesKHR.?(
        device,
        acceleration_structure_count,
        p_acceleration_structures,
        query_type,
        data_size,
        p_data,
        stride,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub fn cmdTraceRaysKHR(
    command_buffer: CommandBuffer,
    p_raygen_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_miss_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_hit_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_callable_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    width: u32,
    height: u32,
    depth: u32,
) void {
    device_dispatch.vkCmdTraceRaysKHR.?(
        command_buffer,
        p_raygen_shader_binding_table,
        p_miss_shader_binding_table,
        p_hit_shader_binding_table,
        p_callable_shader_binding_table,
        width,
        height,
        depth,
    );
}
pub fn cmdTraceRaysNV(
    command_buffer: CommandBuffer,
    raygen_shader_binding_table_buffer: Buffer,
    raygen_shader_binding_offset: DeviceSize,
    miss_shader_binding_table_buffer: Buffer,
    miss_shader_binding_offset: DeviceSize,
    miss_shader_binding_stride: DeviceSize,
    hit_shader_binding_table_buffer: Buffer,
    hit_shader_binding_offset: DeviceSize,
    hit_shader_binding_stride: DeviceSize,
    callable_shader_binding_table_buffer: Buffer,
    callable_shader_binding_offset: DeviceSize,
    callable_shader_binding_stride: DeviceSize,
    width: u32,
    height: u32,
    depth: u32,
) void {
    device_dispatch.vkCmdTraceRaysNV.?(
        command_buffer,
        raygen_shader_binding_table_buffer,
        raygen_shader_binding_offset,
        miss_shader_binding_table_buffer,
        miss_shader_binding_offset,
        miss_shader_binding_stride,
        hit_shader_binding_table_buffer,
        hit_shader_binding_offset,
        hit_shader_binding_stride,
        callable_shader_binding_table_buffer,
        callable_shader_binding_offset,
        callable_shader_binding_stride,
        width,
        height,
        depth,
    );
}
pub const GetRayTracingShaderGroupHandlesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getRayTracingShaderGroupHandlesKHR(
    device: Device,
    pipeline: Pipeline,
    first_group: u32,
    group_count: u32,
    data_size: usize,
    p_data: *anyopaque,
) GetRayTracingShaderGroupHandlesKHRError!void {
    const result = device_dispatch.vkGetRayTracingShaderGroupHandlesKHR.?(
        device,
        pipeline,
        first_group,
        group_count,
        data_size,
        p_data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const GetRayTracingShaderGroupHandlesNVError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getRayTracingShaderGroupHandlesNV(
    device: Device,
    pipeline: Pipeline,
    first_group: u32,
    group_count: u32,
    data_size: usize,
    p_data: *anyopaque,
) GetRayTracingShaderGroupHandlesNVError!void {
    const result = device_dispatch.vkGetRayTracingShaderGroupHandlesNV.?(
        device,
        pipeline,
        first_group,
        group_count,
        data_size,
        p_data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const GetRayTracingCaptureReplayShaderGroupHandlesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getRayTracingCaptureReplayShaderGroupHandlesKHR(
    device: Device,
    pipeline: Pipeline,
    first_group: u32,
    group_count: u32,
    data_size: usize,
    p_data: *anyopaque,
) GetRayTracingCaptureReplayShaderGroupHandlesKHRError!void {
    const result = device_dispatch.vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.?(
        device,
        pipeline,
        first_group,
        group_count,
        data_size,
        p_data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const GetAccelerationStructureHandleNVError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getAccelerationStructureHandleNV(
    device: Device,
    acceleration_structure: AccelerationStructureNV,
    data_size: usize,
    p_data: *anyopaque,
) GetAccelerationStructureHandleNVError!void {
    const result = device_dispatch.vkGetAccelerationStructureHandleNV.?(
        device,
        acceleration_structure,
        data_size,
        p_data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const CreateRayTracingPipelinesNVError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InvalidShaderNV,
    Unknown,
};
pub fn createRayTracingPipelinesNV(
    device: Device,
    pipeline_cache: PipelineCache,
    create_info_count: u32,
    p_create_infos: [*]const RayTracingPipelineCreateInfoNV,
    p_allocator: ?*const AllocationCallbacks,
    p_pipelines: [*]Pipeline,
) CreateRayTracingPipelinesNVError!Result {
    const result = device_dispatch.vkCreateRayTracingPipelinesNV.?(
        device,
        pipeline_cache,
        create_info_count,
        p_create_infos,
        p_allocator,
        p_pipelines,
    );
    switch (result) {
        Result.success => {},
        Result.pipeline_compile_required_ext => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_invalid_shader_nv => return error.InvalidShaderNV,
        else => return error.Unknown,
    }
    return result;
}
pub const CreateRayTracingPipelinesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InvalidOpaqueCaptureAddress,
    Unknown,
};
pub fn createRayTracingPipelinesKHR(
    device: Device,
    deferred_operation: DeferredOperationKHR,
    pipeline_cache: PipelineCache,
    create_info_count: u32,
    p_create_infos: [*]const RayTracingPipelineCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
    p_pipelines: [*]Pipeline,
) CreateRayTracingPipelinesKHRError!Result {
    const result = device_dispatch.vkCreateRayTracingPipelinesKHR.?(
        device,
        deferred_operation,
        pipeline_cache,
        create_info_count,
        p_create_infos,
        p_allocator,
        p_pipelines,
    );
    switch (result) {
        Result.success => {},
        Result.operation_deferred_khr => {},
        Result.operation_not_deferred_khr => {},
        Result.pipeline_compile_required_ext => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_invalid_opaque_capture_address => return error.InvalidOpaqueCaptureAddress,
        else => return error.Unknown,
    }
    return result;
}
pub fn cmdTraceRaysIndirectKHR(
    command_buffer: CommandBuffer,
    p_raygen_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_miss_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_hit_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_callable_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    indirect_device_address: DeviceAddress,
) void {
    device_dispatch.vkCmdTraceRaysIndirectKHR.?(
        command_buffer,
        p_raygen_shader_binding_table,
        p_miss_shader_binding_table,
        p_hit_shader_binding_table,
        p_callable_shader_binding_table,
        indirect_device_address,
    );
}
pub fn cmdTraceRaysIndirect2KHR(
    command_buffer: CommandBuffer,
    indirect_device_address: DeviceAddress,
) void {
    device_dispatch.vkCmdTraceRaysIndirect2KHR.?(
        command_buffer,
        indirect_device_address,
    );
}
pub fn getClusterAccelerationStructureBuildSizesNV(
    device: Device,
    p_info: *const ClusterAccelerationStructureInputInfoNV,
    p_size_info: *AccelerationStructureBuildSizesInfoKHR,
) void {
    device_dispatch.vkGetClusterAccelerationStructureBuildSizesNV.?(
        device,
        p_info,
        p_size_info,
    );
}
pub fn cmdBuildClusterAccelerationStructureIndirectNV(
    command_buffer: CommandBuffer,
    p_command_infos: *const ClusterAccelerationStructureCommandsInfoNV,
) void {
    device_dispatch.vkCmdBuildClusterAccelerationStructureIndirectNV.?(
        command_buffer,
        p_command_infos,
    );
}
pub fn getDeviceAccelerationStructureCompatibilityKHR(
    device: Device,
    p_version_info: *const AccelerationStructureVersionInfoKHR,
) AccelerationStructureCompatibilityKHR {
    var out_compatibility: AccelerationStructureCompatibilityKHR = undefined;
    device_dispatch.vkGetDeviceAccelerationStructureCompatibilityKHR.?(
        device,
        p_version_info,
        &out_compatibility,
    );
    return out_compatibility;
}
pub fn getRayTracingShaderGroupStackSizeKHR(
    device: Device,
    pipeline: Pipeline,
    group: u32,
    group_shader: ShaderGroupShaderKHR,
) DeviceSize {
    return device_dispatch.vkGetRayTracingShaderGroupStackSizeKHR.?(
        device,
        pipeline,
        group,
        group_shader,
    );
}
pub fn cmdSetRayTracingPipelineStackSizeKHR(
    command_buffer: CommandBuffer,
    pipeline_stack_size: u32,
) void {
    device_dispatch.vkCmdSetRayTracingPipelineStackSizeKHR.?(
        command_buffer,
        pipeline_stack_size,
    );
}
pub fn getImageViewHandleNVX(
    device: Device,
    p_info: *const ImageViewHandleInfoNVX,
) u32 {
    return device_dispatch.vkGetImageViewHandleNVX.?(
        device,
        p_info,
    );
}
pub fn getImageViewHandle64NVX(
    device: Device,
    p_info: *const ImageViewHandleInfoNVX,
) u64 {
    return device_dispatch.vkGetImageViewHandle64NVX.?(
        device,
        p_info,
    );
}
pub const GetImageViewAddressNVXError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn getImageViewAddressNVX(
    device: Device,
    image_view: ImageView,
    p_properties: *ImageViewAddressPropertiesNVX,
) GetImageViewAddressNVXError!void {
    const result = device_dispatch.vkGetImageViewAddressNVX.?(
        device,
        image_view,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub const GetDeviceGroupSurfacePresentModes2EXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    SurfaceLostKHR,
    Unknown,
};
pub fn getDeviceGroupSurfacePresentModes2EXT(
    device: Device,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
) GetDeviceGroupSurfacePresentModes2EXTError!DeviceGroupPresentModeFlagsKHR {
    var out_modes: DeviceGroupPresentModeFlagsKHR = undefined;
    const result = device_dispatch.vkGetDeviceGroupSurfacePresentModes2EXT.?(
        device,
        p_surface_info,
        &out_modes,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
    return out_modes;
}
pub const AcquireFullScreenExclusiveModeEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InitializationFailed,
    SurfaceLostKHR,
    Unknown,
};
pub fn acquireFullScreenExclusiveModeEXT(
    device: Device,
    swapchain: SwapchainKHR,
) AcquireFullScreenExclusiveModeEXTError!void {
    const result = device_dispatch.vkAcquireFullScreenExclusiveModeEXT.?(
        device,
        swapchain,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
}
pub const ReleaseFullScreenExclusiveModeEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    SurfaceLostKHR,
    Unknown,
};
pub fn releaseFullScreenExclusiveModeEXT(
    device: Device,
    swapchain: SwapchainKHR,
) ReleaseFullScreenExclusiveModeEXTError!void {
    const result = device_dispatch.vkReleaseFullScreenExclusiveModeEXT.?(
        device,
        swapchain,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
}
pub const AcquireProfilingLockKHRError = error{
    OutOfHostMemory,
    Timeout,
    Unknown,
};
pub fn acquireProfilingLockKHR(
    device: Device,
    p_info: *const AcquireProfilingLockInfoKHR,
) AcquireProfilingLockKHRError!void {
    const result = device_dispatch.vkAcquireProfilingLockKHR.?(
        device,
        p_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.timeout => return error.Timeout,
        else => return error.Unknown,
    }
}
pub fn releaseProfilingLockKHR(
    device: Device,
) void {
    device_dispatch.vkReleaseProfilingLockKHR.?(
        device,
    );
}
pub const GetImageDrmFormatModifierPropertiesEXTError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn getImageDrmFormatModifierPropertiesEXT(
    device: Device,
    image: Image,
    p_properties: *ImageDrmFormatModifierPropertiesEXT,
) GetImageDrmFormatModifierPropertiesEXTError!void {
    const result = device_dispatch.vkGetImageDrmFormatModifierPropertiesEXT.?(
        device,
        image,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub fn getBufferOpaqueCaptureAddress(
    device: Device,
    p_info: *const BufferDeviceAddressInfo,
) u64 {
    return device_dispatch.vkGetBufferOpaqueCaptureAddress.?(
        device,
        p_info,
    );
}
pub fn getBufferOpaqueCaptureAddressKHR(
    device: Device,
    p_info: *const BufferDeviceAddressInfo,
) u64 {
    return device_dispatch.vkGetBufferOpaqueCaptureAddressKHR.?(
        device,
        p_info,
    );
}
pub fn getBufferDeviceAddress(
    device: Device,
    p_info: *const BufferDeviceAddressInfo,
) DeviceAddress {
    return device_dispatch.vkGetBufferDeviceAddress.?(
        device,
        p_info,
    );
}
pub fn getBufferDeviceAddressKHR(
    device: Device,
    p_info: *const BufferDeviceAddressInfo,
) DeviceAddress {
    return device_dispatch.vkGetBufferDeviceAddressKHR.?(
        device,
        p_info,
    );
}
pub fn getBufferDeviceAddressEXT(
    device: Device,
    p_info: *const BufferDeviceAddressInfo,
) DeviceAddress {
    return device_dispatch.vkGetBufferDeviceAddressEXT.?(
        device,
        p_info,
    );
}
pub const InitializePerformanceApiINTELError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn initializePerformanceApiINTEL(
    device: Device,
    p_initialize_info: *const InitializePerformanceApiInfoINTEL,
) InitializePerformanceApiINTELError!void {
    const result = device_dispatch.vkInitializePerformanceApiINTEL.?(
        device,
        p_initialize_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub fn uninitializePerformanceApiINTEL(
    device: Device,
) void {
    device_dispatch.vkUninitializePerformanceApiINTEL.?(
        device,
    );
}
pub const CmdSetPerformanceMarkerINTELError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn cmdSetPerformanceMarkerINTEL(
    command_buffer: CommandBuffer,
    p_marker_info: *const PerformanceMarkerInfoINTEL,
) CmdSetPerformanceMarkerINTELError!void {
    const result = device_dispatch.vkCmdSetPerformanceMarkerINTEL.?(
        command_buffer,
        p_marker_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub const CmdSetPerformanceStreamMarkerINTELError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn cmdSetPerformanceStreamMarkerINTEL(
    command_buffer: CommandBuffer,
    p_marker_info: *const PerformanceStreamMarkerInfoINTEL,
) CmdSetPerformanceStreamMarkerINTELError!void {
    const result = device_dispatch.vkCmdSetPerformanceStreamMarkerINTEL.?(
        command_buffer,
        p_marker_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub const CmdSetPerformanceOverrideINTELError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn cmdSetPerformanceOverrideINTEL(
    command_buffer: CommandBuffer,
    p_override_info: *const PerformanceOverrideInfoINTEL,
) CmdSetPerformanceOverrideINTELError!void {
    const result = device_dispatch.vkCmdSetPerformanceOverrideINTEL.?(
        command_buffer,
        p_override_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub const AcquirePerformanceConfigurationINTELError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn acquirePerformanceConfigurationINTEL(
    device: Device,
    p_acquire_info: *const PerformanceConfigurationAcquireInfoINTEL,
) AcquirePerformanceConfigurationINTELError!PerformanceConfigurationINTEL {
    var out_configuration: PerformanceConfigurationINTEL = undefined;
    const result = device_dispatch.vkAcquirePerformanceConfigurationINTEL.?(
        device,
        p_acquire_info,
        &out_configuration,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_configuration;
}
pub const ReleasePerformanceConfigurationINTELError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn releasePerformanceConfigurationINTEL(
    device: Device,
    configuration: PerformanceConfigurationINTEL,
) ReleasePerformanceConfigurationINTELError!void {
    const result = device_dispatch.vkReleasePerformanceConfigurationINTEL.?(
        device,
        configuration,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub const QueueSetPerformanceConfigurationINTELError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn queueSetPerformanceConfigurationINTEL(
    queue: Queue,
    configuration: PerformanceConfigurationINTEL,
) QueueSetPerformanceConfigurationINTELError!void {
    const result = device_dispatch.vkQueueSetPerformanceConfigurationINTEL.?(
        queue,
        configuration,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub const GetPerformanceParameterINTELError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn getPerformanceParameterINTEL(
    device: Device,
    parameter: PerformanceParameterTypeINTEL,
) GetPerformanceParameterINTELError!PerformanceValueINTEL {
    var out_value: PerformanceValueINTEL = undefined;
    const result = device_dispatch.vkGetPerformanceParameterINTEL.?(
        device,
        parameter,
        &out_value,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_value;
}
pub fn getDeviceMemoryOpaqueCaptureAddress(
    device: Device,
    p_info: *const DeviceMemoryOpaqueCaptureAddressInfo,
) u64 {
    return device_dispatch.vkGetDeviceMemoryOpaqueCaptureAddress.?(
        device,
        p_info,
    );
}
pub fn getDeviceMemoryOpaqueCaptureAddressKHR(
    device: Device,
    p_info: *const DeviceMemoryOpaqueCaptureAddressInfo,
) u64 {
    return device_dispatch.vkGetDeviceMemoryOpaqueCaptureAddressKHR.?(
        device,
        p_info,
    );
}
pub const GetPipelineExecutablePropertiesKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPipelineExecutablePropertiesKHR(
    device: Device,
    p_pipeline_info: *const PipelineInfoKHR,
    p_executable_count: *u32,
    p_properties: ?[*]PipelineExecutablePropertiesKHR,
) GetPipelineExecutablePropertiesKHRError!Result {
    const result = device_dispatch.vkGetPipelineExecutablePropertiesKHR.?(
        device,
        p_pipeline_info,
        p_executable_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPipelineExecutableStatisticsKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPipelineExecutableStatisticsKHR(
    device: Device,
    p_executable_info: *const PipelineExecutableInfoKHR,
    p_statistic_count: *u32,
    p_statistics: ?[*]PipelineExecutableStatisticKHR,
) GetPipelineExecutableStatisticsKHRError!Result {
    const result = device_dispatch.vkGetPipelineExecutableStatisticsKHR.?(
        device,
        p_executable_info,
        p_statistic_count,
        p_statistics,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetPipelineExecutableInternalRepresentationsKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getPipelineExecutableInternalRepresentationsKHR(
    device: Device,
    p_executable_info: *const PipelineExecutableInfoKHR,
    p_internal_representation_count: *u32,
    p_internal_representations: ?[*]PipelineExecutableInternalRepresentationKHR,
) GetPipelineExecutableInternalRepresentationsKHRError!Result {
    const result = device_dispatch.vkGetPipelineExecutableInternalRepresentationsKHR.?(
        device,
        p_executable_info,
        p_internal_representation_count,
        p_internal_representations,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn cmdSetLineStipple(
    command_buffer: CommandBuffer,
    line_stipple_factor: u32,
    line_stipple_pattern: u16,
) void {
    device_dispatch.vkCmdSetLineStipple.?(
        command_buffer,
        line_stipple_factor,
        line_stipple_pattern,
    );
}
pub fn cmdSetLineStippleKHR(
    command_buffer: CommandBuffer,
    line_stipple_factor: u32,
    line_stipple_pattern: u16,
) void {
    device_dispatch.vkCmdSetLineStippleKHR.?(
        command_buffer,
        line_stipple_factor,
        line_stipple_pattern,
    );
}
pub fn cmdSetLineStippleEXT(
    command_buffer: CommandBuffer,
    line_stipple_factor: u32,
    line_stipple_pattern: u16,
) void {
    device_dispatch.vkCmdSetLineStippleEXT.?(
        command_buffer,
        line_stipple_factor,
        line_stipple_pattern,
    );
}
pub const GetFaultDataResult = struct {
    result: Result,
    unrecorded_faults: Bool32,
};
pub const GetFaultDataError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getFaultData(
    device: Device,
    fault_query_behavior: FaultQueryBehavior,
    p_fault_count: *u32,
    p_faults: ?[*]FaultData,
) GetFaultDataError!GetFaultDataResult {
    var return_values: GetFaultDataResult = undefined;
    const result = device_dispatch.vkGetFaultData.?(
        device,
        fault_query_behavior,
        &return_values.unrecorded_faults,
        p_fault_count,
        p_faults,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return_values.result = result;
    return return_values;
}
pub const CreateAccelerationStructureKHRError = error{
    OutOfHostMemory,
    InvalidOpaqueCaptureAddressKHR,
    Unknown,
};
pub fn createAccelerationStructureKHR(
    device: Device,
    p_create_info: *const AccelerationStructureCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
) CreateAccelerationStructureKHRError!AccelerationStructureKHR {
    var out_acceleration_structure: AccelerationStructureKHR = undefined;
    const result = device_dispatch.vkCreateAccelerationStructureKHR.?(
        device,
        p_create_info,
        p_allocator,
        &out_acceleration_structure,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_invalid_opaque_capture_address_khr => return error.InvalidOpaqueCaptureAddressKHR,
        else => return error.Unknown,
    }
    return out_acceleration_structure;
}
pub fn cmdBuildAccelerationStructuresKHR(
    command_buffer: CommandBuffer,
    info_count: u32,
    p_infos: [*]const AccelerationStructureBuildGeometryInfoKHR,
    pp_build_range_infos: [*]const [*]const AccelerationStructureBuildRangeInfoKHR,
) void {
    device_dispatch.vkCmdBuildAccelerationStructuresKHR.?(
        command_buffer,
        info_count,
        p_infos,
        pp_build_range_infos,
    );
}
pub fn cmdBuildAccelerationStructuresIndirectKHR(
    command_buffer: CommandBuffer,
    info_count: u32,
    p_infos: [*]const AccelerationStructureBuildGeometryInfoKHR,
    p_indirect_device_addresses: [*]const DeviceAddress,
    p_indirect_strides: [*]const u32,
    pp_max_primitive_counts: [*]const [*]const u32,
) void {
    device_dispatch.vkCmdBuildAccelerationStructuresIndirectKHR.?(
        command_buffer,
        info_count,
        p_infos,
        p_indirect_device_addresses,
        p_indirect_strides,
        pp_max_primitive_counts,
    );
}
pub const BuildAccelerationStructuresKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn buildAccelerationStructuresKHR(
    device: Device,
    deferred_operation: DeferredOperationKHR,
    info_count: u32,
    p_infos: [*]const AccelerationStructureBuildGeometryInfoKHR,
    pp_build_range_infos: [*]const [*]const AccelerationStructureBuildRangeInfoKHR,
) BuildAccelerationStructuresKHRError!Result {
    const result = device_dispatch.vkBuildAccelerationStructuresKHR.?(
        device,
        deferred_operation,
        info_count,
        p_infos,
        pp_build_range_infos,
    );
    switch (result) {
        Result.success => {},
        Result.operation_deferred_khr => {},
        Result.operation_not_deferred_khr => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn getAccelerationStructureDeviceAddressKHR(
    device: Device,
    p_info: *const AccelerationStructureDeviceAddressInfoKHR,
) DeviceAddress {
    return device_dispatch.vkGetAccelerationStructureDeviceAddressKHR.?(
        device,
        p_info,
    );
}
pub const CreateDeferredOperationKHRError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn createDeferredOperationKHR(
    device: Device,
    p_allocator: ?*const AllocationCallbacks,
) CreateDeferredOperationKHRError!DeferredOperationKHR {
    var out_deferred_operation: DeferredOperationKHR = undefined;
    const result = device_dispatch.vkCreateDeferredOperationKHR.?(
        device,
        p_allocator,
        &out_deferred_operation,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_deferred_operation;
}
pub fn destroyDeferredOperationKHR(
    device: Device,
    operation: DeferredOperationKHR,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyDeferredOperationKHR.?(
        device,
        operation,
        p_allocator,
    );
}
pub fn getDeferredOperationMaxConcurrencyKHR(
    device: Device,
    operation: DeferredOperationKHR,
) u32 {
    return device_dispatch.vkGetDeferredOperationMaxConcurrencyKHR.?(
        device,
        operation,
    );
}
pub const GetDeferredOperationResultKHRError = error{
    Unknown,
};
pub fn getDeferredOperationResultKHR(
    device: Device,
    operation: DeferredOperationKHR,
) GetDeferredOperationResultKHRError!Result {
    const result = device_dispatch.vkGetDeferredOperationResultKHR.?(
        device,
        operation,
    );
    switch (result) {
        Result.success => {},
        Result.not_ready => {},
        else => return error.Unknown,
    }
    return result;
}
pub const DeferredOperationJoinKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn deferredOperationJoinKHR(
    device: Device,
    operation: DeferredOperationKHR,
) DeferredOperationJoinKHRError!Result {
    const result = device_dispatch.vkDeferredOperationJoinKHR.?(
        device,
        operation,
    );
    switch (result) {
        Result.success => {},
        Result.thread_done_khr => {},
        Result.thread_idle_khr => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn getPipelineIndirectMemoryRequirementsNV(
    device: Device,
    p_create_info: *const ComputePipelineCreateInfo,
    p_memory_requirements: *MemoryRequirements2,
) void {
    device_dispatch.vkGetPipelineIndirectMemoryRequirementsNV.?(
        device,
        p_create_info,
        p_memory_requirements,
    );
}
pub fn getPipelineIndirectDeviceAddressNV(
    device: Device,
    p_info: *const PipelineIndirectDeviceAddressInfoNV,
) DeviceAddress {
    return device_dispatch.vkGetPipelineIndirectDeviceAddressNV.?(
        device,
        p_info,
    );
}
pub fn antiLagUpdateAMD(
    device: Device,
    p_data: *const AntiLagDataAMD,
) void {
    device_dispatch.vkAntiLagUpdateAMD.?(
        device,
        p_data,
    );
}
pub fn cmdSetCullMode(
    command_buffer: CommandBuffer,
    cull_mode: CullModeFlags,
) void {
    device_dispatch.vkCmdSetCullMode.?(
        command_buffer,
        cull_mode,
    );
}
pub fn cmdSetCullModeEXT(
    command_buffer: CommandBuffer,
    cull_mode: CullModeFlags,
) void {
    device_dispatch.vkCmdSetCullModeEXT.?(
        command_buffer,
        cull_mode,
    );
}
pub fn cmdSetFrontFace(
    command_buffer: CommandBuffer,
    front_face: FrontFace,
) void {
    device_dispatch.vkCmdSetFrontFace.?(
        command_buffer,
        front_face,
    );
}
pub fn cmdSetFrontFaceEXT(
    command_buffer: CommandBuffer,
    front_face: FrontFace,
) void {
    device_dispatch.vkCmdSetFrontFaceEXT.?(
        command_buffer,
        front_face,
    );
}
pub fn cmdSetPrimitiveTopology(
    command_buffer: CommandBuffer,
    primitive_topology: PrimitiveTopology,
) void {
    device_dispatch.vkCmdSetPrimitiveTopology.?(
        command_buffer,
        primitive_topology,
    );
}
pub fn cmdSetPrimitiveTopologyEXT(
    command_buffer: CommandBuffer,
    primitive_topology: PrimitiveTopology,
) void {
    device_dispatch.vkCmdSetPrimitiveTopologyEXT.?(
        command_buffer,
        primitive_topology,
    );
}
pub fn cmdSetViewportWithCount(
    command_buffer: CommandBuffer,
    viewport_count: u32,
    p_viewports: [*]const Viewport,
) void {
    device_dispatch.vkCmdSetViewportWithCount.?(
        command_buffer,
        viewport_count,
        p_viewports,
    );
}
pub fn cmdSetViewportWithCountEXT(
    command_buffer: CommandBuffer,
    viewport_count: u32,
    p_viewports: [*]const Viewport,
) void {
    device_dispatch.vkCmdSetViewportWithCountEXT.?(
        command_buffer,
        viewport_count,
        p_viewports,
    );
}
pub fn cmdSetScissorWithCount(
    command_buffer: CommandBuffer,
    scissor_count: u32,
    p_scissors: [*]const Rect2D,
) void {
    device_dispatch.vkCmdSetScissorWithCount.?(
        command_buffer,
        scissor_count,
        p_scissors,
    );
}
pub fn cmdSetScissorWithCountEXT(
    command_buffer: CommandBuffer,
    scissor_count: u32,
    p_scissors: [*]const Rect2D,
) void {
    device_dispatch.vkCmdSetScissorWithCountEXT.?(
        command_buffer,
        scissor_count,
        p_scissors,
    );
}
pub fn cmdBindIndexBuffer2(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    size: DeviceSize,
    index_type: IndexType,
) void {
    device_dispatch.vkCmdBindIndexBuffer2.?(
        command_buffer,
        buffer,
        offset,
        size,
        index_type,
    );
}
pub fn cmdBindIndexBuffer2KHR(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    size: DeviceSize,
    index_type: IndexType,
) void {
    device_dispatch.vkCmdBindIndexBuffer2KHR.?(
        command_buffer,
        buffer,
        offset,
        size,
        index_type,
    );
}
pub fn cmdBindVertexBuffers2(
    command_buffer: CommandBuffer,
    first_binding: u32,
    binding_count: u32,
    p_buffers: [*]const Buffer,
    p_offsets: [*]const DeviceSize,
    p_sizes: ?[*]const DeviceSize,
    p_strides: ?[*]const DeviceSize,
) void {
    device_dispatch.vkCmdBindVertexBuffers2.?(
        command_buffer,
        first_binding,
        binding_count,
        p_buffers,
        p_offsets,
        p_sizes,
        p_strides,
    );
}
pub fn cmdBindVertexBuffers2EXT(
    command_buffer: CommandBuffer,
    first_binding: u32,
    binding_count: u32,
    p_buffers: [*]const Buffer,
    p_offsets: [*]const DeviceSize,
    p_sizes: ?[*]const DeviceSize,
    p_strides: ?[*]const DeviceSize,
) void {
    device_dispatch.vkCmdBindVertexBuffers2EXT.?(
        command_buffer,
        first_binding,
        binding_count,
        p_buffers,
        p_offsets,
        p_sizes,
        p_strides,
    );
}
pub fn cmdSetDepthTestEnable(
    command_buffer: CommandBuffer,
    depth_test_enable: Bool32,
) void {
    device_dispatch.vkCmdSetDepthTestEnable.?(
        command_buffer,
        depth_test_enable,
    );
}
pub fn cmdSetDepthTestEnableEXT(
    command_buffer: CommandBuffer,
    depth_test_enable: Bool32,
) void {
    device_dispatch.vkCmdSetDepthTestEnableEXT.?(
        command_buffer,
        depth_test_enable,
    );
}
pub fn cmdSetDepthWriteEnable(
    command_buffer: CommandBuffer,
    depth_write_enable: Bool32,
) void {
    device_dispatch.vkCmdSetDepthWriteEnable.?(
        command_buffer,
        depth_write_enable,
    );
}
pub fn cmdSetDepthWriteEnableEXT(
    command_buffer: CommandBuffer,
    depth_write_enable: Bool32,
) void {
    device_dispatch.vkCmdSetDepthWriteEnableEXT.?(
        command_buffer,
        depth_write_enable,
    );
}
pub fn cmdSetDepthCompareOp(
    command_buffer: CommandBuffer,
    depth_compare_op: CompareOp,
) void {
    device_dispatch.vkCmdSetDepthCompareOp.?(
        command_buffer,
        depth_compare_op,
    );
}
pub fn cmdSetDepthCompareOpEXT(
    command_buffer: CommandBuffer,
    depth_compare_op: CompareOp,
) void {
    device_dispatch.vkCmdSetDepthCompareOpEXT.?(
        command_buffer,
        depth_compare_op,
    );
}
pub fn cmdSetDepthBoundsTestEnable(
    command_buffer: CommandBuffer,
    depth_bounds_test_enable: Bool32,
) void {
    device_dispatch.vkCmdSetDepthBoundsTestEnable.?(
        command_buffer,
        depth_bounds_test_enable,
    );
}
pub fn cmdSetDepthBoundsTestEnableEXT(
    command_buffer: CommandBuffer,
    depth_bounds_test_enable: Bool32,
) void {
    device_dispatch.vkCmdSetDepthBoundsTestEnableEXT.?(
        command_buffer,
        depth_bounds_test_enable,
    );
}
pub fn cmdSetStencilTestEnable(
    command_buffer: CommandBuffer,
    stencil_test_enable: Bool32,
) void {
    device_dispatch.vkCmdSetStencilTestEnable.?(
        command_buffer,
        stencil_test_enable,
    );
}
pub fn cmdSetStencilTestEnableEXT(
    command_buffer: CommandBuffer,
    stencil_test_enable: Bool32,
) void {
    device_dispatch.vkCmdSetStencilTestEnableEXT.?(
        command_buffer,
        stencil_test_enable,
    );
}
pub fn cmdSetStencilOp(
    command_buffer: CommandBuffer,
    face_mask: StencilFaceFlags,
    fail_op: StencilOp,
    pass_op: StencilOp,
    depth_fail_op: StencilOp,
    compare_op: CompareOp,
) void {
    device_dispatch.vkCmdSetStencilOp.?(
        command_buffer,
        face_mask,
        fail_op,
        pass_op,
        depth_fail_op,
        compare_op,
    );
}
pub fn cmdSetStencilOpEXT(
    command_buffer: CommandBuffer,
    face_mask: StencilFaceFlags,
    fail_op: StencilOp,
    pass_op: StencilOp,
    depth_fail_op: StencilOp,
    compare_op: CompareOp,
) void {
    device_dispatch.vkCmdSetStencilOpEXT.?(
        command_buffer,
        face_mask,
        fail_op,
        pass_op,
        depth_fail_op,
        compare_op,
    );
}
pub fn cmdSetPatchControlPointsEXT(
    command_buffer: CommandBuffer,
    patch_control_points: u32,
) void {
    device_dispatch.vkCmdSetPatchControlPointsEXT.?(
        command_buffer,
        patch_control_points,
    );
}
pub fn cmdSetRasterizerDiscardEnable(
    command_buffer: CommandBuffer,
    rasterizer_discard_enable: Bool32,
) void {
    device_dispatch.vkCmdSetRasterizerDiscardEnable.?(
        command_buffer,
        rasterizer_discard_enable,
    );
}
pub fn cmdSetRasterizerDiscardEnableEXT(
    command_buffer: CommandBuffer,
    rasterizer_discard_enable: Bool32,
) void {
    device_dispatch.vkCmdSetRasterizerDiscardEnableEXT.?(
        command_buffer,
        rasterizer_discard_enable,
    );
}
pub fn cmdSetDepthBiasEnable(
    command_buffer: CommandBuffer,
    depth_bias_enable: Bool32,
) void {
    device_dispatch.vkCmdSetDepthBiasEnable.?(
        command_buffer,
        depth_bias_enable,
    );
}
pub fn cmdSetDepthBiasEnableEXT(
    command_buffer: CommandBuffer,
    depth_bias_enable: Bool32,
) void {
    device_dispatch.vkCmdSetDepthBiasEnableEXT.?(
        command_buffer,
        depth_bias_enable,
    );
}
pub fn cmdSetLogicOpEXT(
    command_buffer: CommandBuffer,
    logic_op: LogicOp,
) void {
    device_dispatch.vkCmdSetLogicOpEXT.?(
        command_buffer,
        logic_op,
    );
}
pub fn cmdSetPrimitiveRestartEnable(
    command_buffer: CommandBuffer,
    primitive_restart_enable: Bool32,
) void {
    device_dispatch.vkCmdSetPrimitiveRestartEnable.?(
        command_buffer,
        primitive_restart_enable,
    );
}
pub fn cmdSetPrimitiveRestartEnableEXT(
    command_buffer: CommandBuffer,
    primitive_restart_enable: Bool32,
) void {
    device_dispatch.vkCmdSetPrimitiveRestartEnableEXT.?(
        command_buffer,
        primitive_restart_enable,
    );
}
pub fn cmdSetTessellationDomainOriginEXT(
    command_buffer: CommandBuffer,
    domain_origin: TessellationDomainOrigin,
) void {
    device_dispatch.vkCmdSetTessellationDomainOriginEXT.?(
        command_buffer,
        domain_origin,
    );
}
pub fn cmdSetDepthClampEnableEXT(
    command_buffer: CommandBuffer,
    depth_clamp_enable: Bool32,
) void {
    device_dispatch.vkCmdSetDepthClampEnableEXT.?(
        command_buffer,
        depth_clamp_enable,
    );
}
pub fn cmdSetPolygonModeEXT(
    command_buffer: CommandBuffer,
    polygon_mode: PolygonMode,
) void {
    device_dispatch.vkCmdSetPolygonModeEXT.?(
        command_buffer,
        polygon_mode,
    );
}
pub fn cmdSetRasterizationSamplesEXT(
    command_buffer: CommandBuffer,
    rasterization_samples: SampleCountFlags,
) void {
    device_dispatch.vkCmdSetRasterizationSamplesEXT.?(
        command_buffer,
        rasterization_samples,
    );
}
pub fn cmdSetSampleMaskEXT(
    command_buffer: CommandBuffer,
    samples: SampleCountFlags,
    p_sample_mask: [*]const SampleMask,
) void {
    device_dispatch.vkCmdSetSampleMaskEXT.?(
        command_buffer,
        samples,
        p_sample_mask,
    );
}
pub fn cmdSetAlphaToCoverageEnableEXT(
    command_buffer: CommandBuffer,
    alpha_to_coverage_enable: Bool32,
) void {
    device_dispatch.vkCmdSetAlphaToCoverageEnableEXT.?(
        command_buffer,
        alpha_to_coverage_enable,
    );
}
pub fn cmdSetAlphaToOneEnableEXT(
    command_buffer: CommandBuffer,
    alpha_to_one_enable: Bool32,
) void {
    device_dispatch.vkCmdSetAlphaToOneEnableEXT.?(
        command_buffer,
        alpha_to_one_enable,
    );
}
pub fn cmdSetLogicOpEnableEXT(
    command_buffer: CommandBuffer,
    logic_op_enable: Bool32,
) void {
    device_dispatch.vkCmdSetLogicOpEnableEXT.?(
        command_buffer,
        logic_op_enable,
    );
}
pub fn cmdSetColorBlendEnableEXT(
    command_buffer: CommandBuffer,
    first_attachment: u32,
    attachment_count: u32,
    p_color_blend_enables: [*]const Bool32,
) void {
    device_dispatch.vkCmdSetColorBlendEnableEXT.?(
        command_buffer,
        first_attachment,
        attachment_count,
        p_color_blend_enables,
    );
}
pub fn cmdSetColorBlendEquationEXT(
    command_buffer: CommandBuffer,
    first_attachment: u32,
    attachment_count: u32,
    p_color_blend_equations: [*]const ColorBlendEquationEXT,
) void {
    device_dispatch.vkCmdSetColorBlendEquationEXT.?(
        command_buffer,
        first_attachment,
        attachment_count,
        p_color_blend_equations,
    );
}
pub fn cmdSetColorWriteMaskEXT(
    command_buffer: CommandBuffer,
    first_attachment: u32,
    attachment_count: u32,
    p_color_write_masks: [*]const ColorComponentFlags,
) void {
    device_dispatch.vkCmdSetColorWriteMaskEXT.?(
        command_buffer,
        first_attachment,
        attachment_count,
        p_color_write_masks,
    );
}
pub fn cmdSetRasterizationStreamEXT(
    command_buffer: CommandBuffer,
    rasterization_stream: u32,
) void {
    device_dispatch.vkCmdSetRasterizationStreamEXT.?(
        command_buffer,
        rasterization_stream,
    );
}
pub fn cmdSetConservativeRasterizationModeEXT(
    command_buffer: CommandBuffer,
    conservative_rasterization_mode: ConservativeRasterizationModeEXT,
) void {
    device_dispatch.vkCmdSetConservativeRasterizationModeEXT.?(
        command_buffer,
        conservative_rasterization_mode,
    );
}
pub fn cmdSetExtraPrimitiveOverestimationSizeEXT(
    command_buffer: CommandBuffer,
    extra_primitive_overestimation_size: f32,
) void {
    device_dispatch.vkCmdSetExtraPrimitiveOverestimationSizeEXT.?(
        command_buffer,
        extra_primitive_overestimation_size,
    );
}
pub fn cmdSetDepthClipEnableEXT(
    command_buffer: CommandBuffer,
    depth_clip_enable: Bool32,
) void {
    device_dispatch.vkCmdSetDepthClipEnableEXT.?(
        command_buffer,
        depth_clip_enable,
    );
}
pub fn cmdSetSampleLocationsEnableEXT(
    command_buffer: CommandBuffer,
    sample_locations_enable: Bool32,
) void {
    device_dispatch.vkCmdSetSampleLocationsEnableEXT.?(
        command_buffer,
        sample_locations_enable,
    );
}
pub fn cmdSetColorBlendAdvancedEXT(
    command_buffer: CommandBuffer,
    first_attachment: u32,
    attachment_count: u32,
    p_color_blend_advanced: [*]const ColorBlendAdvancedEXT,
) void {
    device_dispatch.vkCmdSetColorBlendAdvancedEXT.?(
        command_buffer,
        first_attachment,
        attachment_count,
        p_color_blend_advanced,
    );
}
pub fn cmdSetProvokingVertexModeEXT(
    command_buffer: CommandBuffer,
    provoking_vertex_mode: ProvokingVertexModeEXT,
) void {
    device_dispatch.vkCmdSetProvokingVertexModeEXT.?(
        command_buffer,
        provoking_vertex_mode,
    );
}
pub fn cmdSetLineRasterizationModeEXT(
    command_buffer: CommandBuffer,
    line_rasterization_mode: LineRasterizationModeEXT,
) void {
    device_dispatch.vkCmdSetLineRasterizationModeEXT.?(
        command_buffer,
        line_rasterization_mode,
    );
}
pub fn cmdSetLineStippleEnableEXT(
    command_buffer: CommandBuffer,
    stippled_line_enable: Bool32,
) void {
    device_dispatch.vkCmdSetLineStippleEnableEXT.?(
        command_buffer,
        stippled_line_enable,
    );
}
pub fn cmdSetDepthClipNegativeOneToOneEXT(
    command_buffer: CommandBuffer,
    negative_one_to_one: Bool32,
) void {
    device_dispatch.vkCmdSetDepthClipNegativeOneToOneEXT.?(
        command_buffer,
        negative_one_to_one,
    );
}
pub fn cmdSetViewportWScalingEnableNV(
    command_buffer: CommandBuffer,
    viewport_w_scaling_enable: Bool32,
) void {
    device_dispatch.vkCmdSetViewportWScalingEnableNV.?(
        command_buffer,
        viewport_w_scaling_enable,
    );
}
pub fn cmdSetViewportSwizzleNV(
    command_buffer: CommandBuffer,
    first_viewport: u32,
    viewport_count: u32,
    p_viewport_swizzles: [*]const ViewportSwizzleNV,
) void {
    device_dispatch.vkCmdSetViewportSwizzleNV.?(
        command_buffer,
        first_viewport,
        viewport_count,
        p_viewport_swizzles,
    );
}
pub fn cmdSetCoverageToColorEnableNV(
    command_buffer: CommandBuffer,
    coverage_to_color_enable: Bool32,
) void {
    device_dispatch.vkCmdSetCoverageToColorEnableNV.?(
        command_buffer,
        coverage_to_color_enable,
    );
}
pub fn cmdSetCoverageToColorLocationNV(
    command_buffer: CommandBuffer,
    coverage_to_color_location: u32,
) void {
    device_dispatch.vkCmdSetCoverageToColorLocationNV.?(
        command_buffer,
        coverage_to_color_location,
    );
}
pub fn cmdSetCoverageModulationModeNV(
    command_buffer: CommandBuffer,
    coverage_modulation_mode: CoverageModulationModeNV,
) void {
    device_dispatch.vkCmdSetCoverageModulationModeNV.?(
        command_buffer,
        coverage_modulation_mode,
    );
}
pub fn cmdSetCoverageModulationTableEnableNV(
    command_buffer: CommandBuffer,
    coverage_modulation_table_enable: Bool32,
) void {
    device_dispatch.vkCmdSetCoverageModulationTableEnableNV.?(
        command_buffer,
        coverage_modulation_table_enable,
    );
}
pub fn cmdSetCoverageModulationTableNV(
    command_buffer: CommandBuffer,
    coverage_modulation_table_count: u32,
    p_coverage_modulation_table: [*]const f32,
) void {
    device_dispatch.vkCmdSetCoverageModulationTableNV.?(
        command_buffer,
        coverage_modulation_table_count,
        p_coverage_modulation_table,
    );
}
pub fn cmdSetShadingRateImageEnableNV(
    command_buffer: CommandBuffer,
    shading_rate_image_enable: Bool32,
) void {
    device_dispatch.vkCmdSetShadingRateImageEnableNV.?(
        command_buffer,
        shading_rate_image_enable,
    );
}
pub fn cmdSetCoverageReductionModeNV(
    command_buffer: CommandBuffer,
    coverage_reduction_mode: CoverageReductionModeNV,
) void {
    device_dispatch.vkCmdSetCoverageReductionModeNV.?(
        command_buffer,
        coverage_reduction_mode,
    );
}
pub fn cmdSetRepresentativeFragmentTestEnableNV(
    command_buffer: CommandBuffer,
    representative_fragment_test_enable: Bool32,
) void {
    device_dispatch.vkCmdSetRepresentativeFragmentTestEnableNV.?(
        command_buffer,
        representative_fragment_test_enable,
    );
}
pub const CreatePrivateDataSlotError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn createPrivateDataSlot(
    device: Device,
    p_create_info: *const PrivateDataSlotCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreatePrivateDataSlotError!PrivateDataSlot {
    var out_private_data_slot: PrivateDataSlot = undefined;
    const result = device_dispatch.vkCreatePrivateDataSlot.?(
        device,
        p_create_info,
        p_allocator,
        &out_private_data_slot,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_private_data_slot;
}
pub const CreatePrivateDataSlotEXTError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn createPrivateDataSlotEXT(
    device: Device,
    p_create_info: *const PrivateDataSlotCreateInfo,
    p_allocator: ?*const AllocationCallbacks,
) CreatePrivateDataSlotEXTError!PrivateDataSlot {
    var out_private_data_slot: PrivateDataSlot = undefined;
    const result = device_dispatch.vkCreatePrivateDataSlotEXT.?(
        device,
        p_create_info,
        p_allocator,
        &out_private_data_slot,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_private_data_slot;
}
pub fn destroyPrivateDataSlot(
    device: Device,
    private_data_slot: PrivateDataSlot,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyPrivateDataSlot.?(
        device,
        private_data_slot,
        p_allocator,
    );
}
pub fn destroyPrivateDataSlotEXT(
    device: Device,
    private_data_slot: PrivateDataSlot,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyPrivateDataSlotEXT.?(
        device,
        private_data_slot,
        p_allocator,
    );
}
pub const SetPrivateDataError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn setPrivateData(
    device: Device,
    object_type: ObjectType,
    object_handle: u64,
    private_data_slot: PrivateDataSlot,
    data: u64,
) SetPrivateDataError!void {
    const result = device_dispatch.vkSetPrivateData.?(
        device,
        object_type,
        object_handle,
        private_data_slot,
        data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub const SetPrivateDataEXTError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn setPrivateDataEXT(
    device: Device,
    object_type: ObjectType,
    object_handle: u64,
    private_data_slot: PrivateDataSlot,
    data: u64,
) SetPrivateDataEXTError!void {
    const result = device_dispatch.vkSetPrivateDataEXT.?(
        device,
        object_type,
        object_handle,
        private_data_slot,
        data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub fn getPrivateData(
    device: Device,
    object_type: ObjectType,
    object_handle: u64,
    private_data_slot: PrivateDataSlot,
) u64 {
    var out_data: u64 = undefined;
    device_dispatch.vkGetPrivateData.?(
        device,
        object_type,
        object_handle,
        private_data_slot,
        &out_data,
    );
    return out_data;
}
pub fn getPrivateDataEXT(
    device: Device,
    object_type: ObjectType,
    object_handle: u64,
    private_data_slot: PrivateDataSlot,
) u64 {
    var out_data: u64 = undefined;
    device_dispatch.vkGetPrivateDataEXT.?(
        device,
        object_type,
        object_handle,
        private_data_slot,
        &out_data,
    );
    return out_data;
}
pub fn cmdCopyBuffer2(
    command_buffer: CommandBuffer,
    p_copy_buffer_info: *const CopyBufferInfo2,
) void {
    device_dispatch.vkCmdCopyBuffer2.?(
        command_buffer,
        p_copy_buffer_info,
    );
}
pub fn cmdCopyBuffer2KHR(
    command_buffer: CommandBuffer,
    p_copy_buffer_info: *const CopyBufferInfo2,
) void {
    device_dispatch.vkCmdCopyBuffer2KHR.?(
        command_buffer,
        p_copy_buffer_info,
    );
}
pub fn cmdCopyImage2(
    command_buffer: CommandBuffer,
    p_copy_image_info: *const CopyImageInfo2,
) void {
    device_dispatch.vkCmdCopyImage2.?(
        command_buffer,
        p_copy_image_info,
    );
}
pub fn cmdCopyImage2KHR(
    command_buffer: CommandBuffer,
    p_copy_image_info: *const CopyImageInfo2,
) void {
    device_dispatch.vkCmdCopyImage2KHR.?(
        command_buffer,
        p_copy_image_info,
    );
}
pub fn cmdBlitImage2(
    command_buffer: CommandBuffer,
    p_blit_image_info: *const BlitImageInfo2,
) void {
    device_dispatch.vkCmdBlitImage2.?(
        command_buffer,
        p_blit_image_info,
    );
}
pub fn cmdBlitImage2KHR(
    command_buffer: CommandBuffer,
    p_blit_image_info: *const BlitImageInfo2,
) void {
    device_dispatch.vkCmdBlitImage2KHR.?(
        command_buffer,
        p_blit_image_info,
    );
}
pub fn cmdCopyBufferToImage2(
    command_buffer: CommandBuffer,
    p_copy_buffer_to_image_info: *const CopyBufferToImageInfo2,
) void {
    device_dispatch.vkCmdCopyBufferToImage2.?(
        command_buffer,
        p_copy_buffer_to_image_info,
    );
}
pub fn cmdCopyBufferToImage2KHR(
    command_buffer: CommandBuffer,
    p_copy_buffer_to_image_info: *const CopyBufferToImageInfo2,
) void {
    device_dispatch.vkCmdCopyBufferToImage2KHR.?(
        command_buffer,
        p_copy_buffer_to_image_info,
    );
}
pub fn cmdCopyImageToBuffer2(
    command_buffer: CommandBuffer,
    p_copy_image_to_buffer_info: *const CopyImageToBufferInfo2,
) void {
    device_dispatch.vkCmdCopyImageToBuffer2.?(
        command_buffer,
        p_copy_image_to_buffer_info,
    );
}
pub fn cmdCopyImageToBuffer2KHR(
    command_buffer: CommandBuffer,
    p_copy_image_to_buffer_info: *const CopyImageToBufferInfo2,
) void {
    device_dispatch.vkCmdCopyImageToBuffer2KHR.?(
        command_buffer,
        p_copy_image_to_buffer_info,
    );
}
pub fn cmdResolveImage2(
    command_buffer: CommandBuffer,
    p_resolve_image_info: *const ResolveImageInfo2,
) void {
    device_dispatch.vkCmdResolveImage2.?(
        command_buffer,
        p_resolve_image_info,
    );
}
pub fn cmdResolveImage2KHR(
    command_buffer: CommandBuffer,
    p_resolve_image_info: *const ResolveImageInfo2,
) void {
    device_dispatch.vkCmdResolveImage2KHR.?(
        command_buffer,
        p_resolve_image_info,
    );
}
pub fn cmdRefreshObjectsKHR(
    command_buffer: CommandBuffer,
    p_refresh_objects: *const RefreshObjectListKHR,
) void {
    device_dispatch.vkCmdRefreshObjectsKHR.?(
        command_buffer,
        p_refresh_objects,
    );
}
pub fn cmdSetFragmentShadingRateKHR(
    command_buffer: CommandBuffer,
    p_fragment_size: *const Extent2D,
    combiner_ops: *const [2]FragmentShadingRateCombinerOpKHR,
) void {
    device_dispatch.vkCmdSetFragmentShadingRateKHR.?(
        command_buffer,
        p_fragment_size,
        combiner_ops,
    );
}
pub fn cmdSetFragmentShadingRateEnumNV(
    command_buffer: CommandBuffer,
    shading_rate: FragmentShadingRateNV,
    combiner_ops: *const [2]FragmentShadingRateCombinerOpKHR,
) void {
    device_dispatch.vkCmdSetFragmentShadingRateEnumNV.?(
        command_buffer,
        shading_rate,
        combiner_ops,
    );
}
pub fn getAccelerationStructureBuildSizesKHR(
    device: Device,
    build_type: AccelerationStructureBuildTypeKHR,
    p_build_info: *const AccelerationStructureBuildGeometryInfoKHR,
    p_max_primitive_counts: ?[*]const u32,
    p_size_info: *AccelerationStructureBuildSizesInfoKHR,
) void {
    device_dispatch.vkGetAccelerationStructureBuildSizesKHR.?(
        device,
        build_type,
        p_build_info,
        p_max_primitive_counts,
        p_size_info,
    );
}
pub fn cmdSetVertexInputEXT(
    command_buffer: CommandBuffer,
    vertex_binding_description_count: u32,
    p_vertex_binding_descriptions: ?[*]const VertexInputBindingDescription2EXT,
    vertex_attribute_description_count: u32,
    p_vertex_attribute_descriptions: ?[*]const VertexInputAttributeDescription2EXT,
) void {
    device_dispatch.vkCmdSetVertexInputEXT.?(
        command_buffer,
        vertex_binding_description_count,
        p_vertex_binding_descriptions,
        vertex_attribute_description_count,
        p_vertex_attribute_descriptions,
    );
}
pub fn cmdSetColorWriteEnableEXT(
    command_buffer: CommandBuffer,
    attachment_count: u32,
    p_color_write_enables: [*]const Bool32,
) void {
    device_dispatch.vkCmdSetColorWriteEnableEXT.?(
        command_buffer,
        attachment_count,
        p_color_write_enables,
    );
}
pub fn cmdSetEvent2(
    command_buffer: CommandBuffer,
    event: Event,
    p_dependency_info: *const DependencyInfo,
) void {
    device_dispatch.vkCmdSetEvent2.?(
        command_buffer,
        event,
        p_dependency_info,
    );
}
pub fn cmdSetEvent2KHR(
    command_buffer: CommandBuffer,
    event: Event,
    p_dependency_info: *const DependencyInfo,
) void {
    device_dispatch.vkCmdSetEvent2KHR.?(
        command_buffer,
        event,
        p_dependency_info,
    );
}
pub fn cmdResetEvent2(
    command_buffer: CommandBuffer,
    event: Event,
    stage_mask: PipelineStageFlags2,
) void {
    device_dispatch.vkCmdResetEvent2.?(
        command_buffer,
        event,
        stage_mask,
    );
}
pub fn cmdResetEvent2KHR(
    command_buffer: CommandBuffer,
    event: Event,
    stage_mask: PipelineStageFlags2,
) void {
    device_dispatch.vkCmdResetEvent2KHR.?(
        command_buffer,
        event,
        stage_mask,
    );
}
pub fn cmdWaitEvents2(
    command_buffer: CommandBuffer,
    event_count: u32,
    p_events: [*]const Event,
    p_dependency_infos: [*]const DependencyInfo,
) void {
    device_dispatch.vkCmdWaitEvents2.?(
        command_buffer,
        event_count,
        p_events,
        p_dependency_infos,
    );
}
pub fn cmdWaitEvents2KHR(
    command_buffer: CommandBuffer,
    event_count: u32,
    p_events: [*]const Event,
    p_dependency_infos: [*]const DependencyInfo,
) void {
    device_dispatch.vkCmdWaitEvents2KHR.?(
        command_buffer,
        event_count,
        p_events,
        p_dependency_infos,
    );
}
pub fn cmdPipelineBarrier2(
    command_buffer: CommandBuffer,
    p_dependency_info: *const DependencyInfo,
) void {
    device_dispatch.vkCmdPipelineBarrier2.?(
        command_buffer,
        p_dependency_info,
    );
}
pub fn cmdPipelineBarrier2KHR(
    command_buffer: CommandBuffer,
    p_dependency_info: *const DependencyInfo,
) void {
    device_dispatch.vkCmdPipelineBarrier2KHR.?(
        command_buffer,
        p_dependency_info,
    );
}
pub const QueueSubmit2Error = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    Unknown,
};
pub fn queueSubmit2(
    queue: Queue,
    submit_count: u32,
    p_submits: ?[*]const SubmitInfo2,
    fence: Fence,
) QueueSubmit2Error!void {
    const result = device_dispatch.vkQueueSubmit2.?(
        queue,
        submit_count,
        p_submits,
        fence,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        else => return error.Unknown,
    }
}
pub const QueueSubmit2KHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    Unknown,
};
pub fn queueSubmit2KHR(
    queue: Queue,
    submit_count: u32,
    p_submits: ?[*]const SubmitInfo2,
    fence: Fence,
) QueueSubmit2KHRError!void {
    const result = device_dispatch.vkQueueSubmit2KHR.?(
        queue,
        submit_count,
        p_submits,
        fence,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        else => return error.Unknown,
    }
}
pub fn cmdWriteTimestamp2(
    command_buffer: CommandBuffer,
    stage: PipelineStageFlags2,
    query_pool: QueryPool,
    query: u32,
) void {
    device_dispatch.vkCmdWriteTimestamp2.?(
        command_buffer,
        stage,
        query_pool,
        query,
    );
}
pub fn cmdWriteTimestamp2KHR(
    command_buffer: CommandBuffer,
    stage: PipelineStageFlags2,
    query_pool: QueryPool,
    query: u32,
) void {
    device_dispatch.vkCmdWriteTimestamp2KHR.?(
        command_buffer,
        stage,
        query_pool,
        query,
    );
}
pub fn cmdWriteBufferMarker2AMD(
    command_buffer: CommandBuffer,
    stage: PipelineStageFlags2,
    dst_buffer: Buffer,
    dst_offset: DeviceSize,
    marker: u32,
) void {
    device_dispatch.vkCmdWriteBufferMarker2AMD.?(
        command_buffer,
        stage,
        dst_buffer,
        dst_offset,
        marker,
    );
}
pub fn getQueueCheckpointData2NV(
    queue: Queue,
    p_checkpoint_data_count: *u32,
    p_checkpoint_data: ?[*]CheckpointData2NV,
) void {
    device_dispatch.vkGetQueueCheckpointData2NV.?(
        queue,
        p_checkpoint_data_count,
        p_checkpoint_data,
    );
}
pub const CopyMemoryToImageError = error{
    InitializationFailed,
    OutOfHostMemory,
    OutOfDeviceMemory,
    MemoryMapFailed,
    Unknown,
};
pub fn copyMemoryToImage(
    device: Device,
    p_copy_memory_to_image_info: *const CopyMemoryToImageInfo,
) CopyMemoryToImageError!void {
    const result = device_dispatch.vkCopyMemoryToImage.?(
        device,
        p_copy_memory_to_image_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_memory_map_failed => return error.MemoryMapFailed,
        else => return error.Unknown,
    }
}
pub const CopyMemoryToImageEXTError = error{
    InitializationFailed,
    OutOfHostMemory,
    OutOfDeviceMemory,
    MemoryMapFailed,
    Unknown,
};
pub fn copyMemoryToImageEXT(
    device: Device,
    p_copy_memory_to_image_info: *const CopyMemoryToImageInfo,
) CopyMemoryToImageEXTError!void {
    const result = device_dispatch.vkCopyMemoryToImageEXT.?(
        device,
        p_copy_memory_to_image_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_memory_map_failed => return error.MemoryMapFailed,
        else => return error.Unknown,
    }
}
pub const CopyImageToMemoryError = error{
    InitializationFailed,
    OutOfHostMemory,
    OutOfDeviceMemory,
    MemoryMapFailed,
    Unknown,
};
pub fn copyImageToMemory(
    device: Device,
    p_copy_image_to_memory_info: *const CopyImageToMemoryInfo,
) CopyImageToMemoryError!void {
    const result = device_dispatch.vkCopyImageToMemory.?(
        device,
        p_copy_image_to_memory_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_memory_map_failed => return error.MemoryMapFailed,
        else => return error.Unknown,
    }
}
pub const CopyImageToMemoryEXTError = error{
    InitializationFailed,
    OutOfHostMemory,
    OutOfDeviceMemory,
    MemoryMapFailed,
    Unknown,
};
pub fn copyImageToMemoryEXT(
    device: Device,
    p_copy_image_to_memory_info: *const CopyImageToMemoryInfo,
) CopyImageToMemoryEXTError!void {
    const result = device_dispatch.vkCopyImageToMemoryEXT.?(
        device,
        p_copy_image_to_memory_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_memory_map_failed => return error.MemoryMapFailed,
        else => return error.Unknown,
    }
}
pub const CopyImageToImageError = error{
    InitializationFailed,
    OutOfHostMemory,
    OutOfDeviceMemory,
    MemoryMapFailed,
    Unknown,
};
pub fn copyImageToImage(
    device: Device,
    p_copy_image_to_image_info: *const CopyImageToImageInfo,
) CopyImageToImageError!void {
    const result = device_dispatch.vkCopyImageToImage.?(
        device,
        p_copy_image_to_image_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_memory_map_failed => return error.MemoryMapFailed,
        else => return error.Unknown,
    }
}
pub const CopyImageToImageEXTError = error{
    InitializationFailed,
    OutOfHostMemory,
    OutOfDeviceMemory,
    MemoryMapFailed,
    Unknown,
};
pub fn copyImageToImageEXT(
    device: Device,
    p_copy_image_to_image_info: *const CopyImageToImageInfo,
) CopyImageToImageEXTError!void {
    const result = device_dispatch.vkCopyImageToImageEXT.?(
        device,
        p_copy_image_to_image_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_memory_map_failed => return error.MemoryMapFailed,
        else => return error.Unknown,
    }
}
pub const TransitionImageLayoutError = error{
    InitializationFailed,
    OutOfHostMemory,
    OutOfDeviceMemory,
    MemoryMapFailed,
    Unknown,
};
pub fn transitionImageLayout(
    device: Device,
    transition_count: u32,
    p_transitions: [*]const HostImageLayoutTransitionInfo,
) TransitionImageLayoutError!void {
    const result = device_dispatch.vkTransitionImageLayout.?(
        device,
        transition_count,
        p_transitions,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_memory_map_failed => return error.MemoryMapFailed,
        else => return error.Unknown,
    }
}
pub const TransitionImageLayoutEXTError = error{
    InitializationFailed,
    OutOfHostMemory,
    OutOfDeviceMemory,
    MemoryMapFailed,
    Unknown,
};
pub fn transitionImageLayoutEXT(
    device: Device,
    transition_count: u32,
    p_transitions: [*]const HostImageLayoutTransitionInfo,
) TransitionImageLayoutEXTError!void {
    const result = device_dispatch.vkTransitionImageLayoutEXT.?(
        device,
        transition_count,
        p_transitions,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_memory_map_failed => return error.MemoryMapFailed,
        else => return error.Unknown,
    }
}
pub fn getCommandPoolMemoryConsumption(
    device: Device,
    command_pool: CommandPool,
    command_buffer: CommandBuffer,
    p_consumption: *CommandPoolMemoryConsumption,
) void {
    device_dispatch.vkGetCommandPoolMemoryConsumption.?(
        device,
        command_pool,
        command_buffer,
        p_consumption,
    );
}
pub const CreateVideoSessionKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InitializationFailed,
    VideoStdVersionNotSupportedKHR,
    InvalidVideoStdParametersKHR,
    Unknown,
};
pub fn createVideoSessionKHR(
    device: Device,
    p_create_info: *const VideoSessionCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
) CreateVideoSessionKHRError!VideoSessionKHR {
    var out_video_session: VideoSessionKHR = undefined;
    const result = device_dispatch.vkCreateVideoSessionKHR.?(
        device,
        p_create_info,
        p_allocator,
        &out_video_session,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_video_std_version_not_supported_khr => return error.VideoStdVersionNotSupportedKHR,
        Result.error_invalid_video_std_parameters_khr => return error.InvalidVideoStdParametersKHR,
        else => return error.Unknown,
    }
    return out_video_session;
}
pub fn destroyVideoSessionKHR(
    device: Device,
    video_session: VideoSessionKHR,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyVideoSessionKHR.?(
        device,
        video_session,
        p_allocator,
    );
}
pub const CreateVideoSessionParametersKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InitializationFailed,
    InvalidVideoStdParametersKHR,
    Unknown,
};
pub fn createVideoSessionParametersKHR(
    device: Device,
    p_create_info: *const VideoSessionParametersCreateInfoKHR,
    p_allocator: ?*const AllocationCallbacks,
) CreateVideoSessionParametersKHRError!VideoSessionParametersKHR {
    var out_video_session_parameters: VideoSessionParametersKHR = undefined;
    const result = device_dispatch.vkCreateVideoSessionParametersKHR.?(
        device,
        p_create_info,
        p_allocator,
        &out_video_session_parameters,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_invalid_video_std_parameters_khr => return error.InvalidVideoStdParametersKHR,
        else => return error.Unknown,
    }
    return out_video_session_parameters;
}
pub const UpdateVideoSessionParametersKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InvalidVideoStdParametersKHR,
    Unknown,
};
pub fn updateVideoSessionParametersKHR(
    device: Device,
    video_session_parameters: VideoSessionParametersKHR,
    p_update_info: *const VideoSessionParametersUpdateInfoKHR,
) UpdateVideoSessionParametersKHRError!void {
    const result = device_dispatch.vkUpdateVideoSessionParametersKHR.?(
        device,
        video_session_parameters,
        p_update_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_invalid_video_std_parameters_khr => return error.InvalidVideoStdParametersKHR,
        else => return error.Unknown,
    }
}
pub const GetEncodedVideoSessionParametersKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getEncodedVideoSessionParametersKHR(
    device: Device,
    p_video_session_parameters_info: *const VideoEncodeSessionParametersGetInfoKHR,
    p_feedback_info: ?*VideoEncodeSessionParametersFeedbackInfoKHR,
    p_data_size: *usize,
    p_data: ?*anyopaque,
) GetEncodedVideoSessionParametersKHRError!Result {
    const result = device_dispatch.vkGetEncodedVideoSessionParametersKHR.?(
        device,
        p_video_session_parameters_info,
        p_feedback_info,
        p_data_size,
        p_data,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn destroyVideoSessionParametersKHR(
    device: Device,
    video_session_parameters: VideoSessionParametersKHR,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyVideoSessionParametersKHR.?(
        device,
        video_session_parameters,
        p_allocator,
    );
}
pub const GetVideoSessionMemoryRequirementsKHRError = error{
    Unknown,
};
pub fn getVideoSessionMemoryRequirementsKHR(
    device: Device,
    video_session: VideoSessionKHR,
    p_memory_requirements_count: *u32,
    p_memory_requirements: ?[*]VideoSessionMemoryRequirementsKHR,
) GetVideoSessionMemoryRequirementsKHRError!Result {
    const result = device_dispatch.vkGetVideoSessionMemoryRequirementsKHR.?(
        device,
        video_session,
        p_memory_requirements_count,
        p_memory_requirements,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        else => return error.Unknown,
    }
    return result;
}
pub const BindVideoSessionMemoryKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn bindVideoSessionMemoryKHR(
    device: Device,
    video_session: VideoSessionKHR,
    bind_session_memory_info_count: u32,
    p_bind_session_memory_infos: [*]const BindVideoSessionMemoryInfoKHR,
) BindVideoSessionMemoryKHRError!void {
    const result = device_dispatch.vkBindVideoSessionMemoryKHR.?(
        device,
        video_session,
        bind_session_memory_info_count,
        p_bind_session_memory_infos,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub fn cmdDecodeVideoKHR(
    command_buffer: CommandBuffer,
    p_decode_info: *const VideoDecodeInfoKHR,
) void {
    device_dispatch.vkCmdDecodeVideoKHR.?(
        command_buffer,
        p_decode_info,
    );
}
pub fn cmdBeginVideoCodingKHR(
    command_buffer: CommandBuffer,
    p_begin_info: *const VideoBeginCodingInfoKHR,
) void {
    device_dispatch.vkCmdBeginVideoCodingKHR.?(
        command_buffer,
        p_begin_info,
    );
}
pub fn cmdControlVideoCodingKHR(
    command_buffer: CommandBuffer,
    p_coding_control_info: *const VideoCodingControlInfoKHR,
) void {
    device_dispatch.vkCmdControlVideoCodingKHR.?(
        command_buffer,
        p_coding_control_info,
    );
}
pub fn cmdEndVideoCodingKHR(
    command_buffer: CommandBuffer,
    p_end_coding_info: *const VideoEndCodingInfoKHR,
) void {
    device_dispatch.vkCmdEndVideoCodingKHR.?(
        command_buffer,
        p_end_coding_info,
    );
}
pub fn cmdEncodeVideoKHR(
    command_buffer: CommandBuffer,
    p_encode_info: *const VideoEncodeInfoKHR,
) void {
    device_dispatch.vkCmdEncodeVideoKHR.?(
        command_buffer,
        p_encode_info,
    );
}
pub fn cmdDecompressMemoryNV(
    command_buffer: CommandBuffer,
    decompress_region_count: u32,
    p_decompress_memory_regions: [*]const DecompressMemoryRegionNV,
) void {
    device_dispatch.vkCmdDecompressMemoryNV.?(
        command_buffer,
        decompress_region_count,
        p_decompress_memory_regions,
    );
}
pub fn cmdDecompressMemoryIndirectCountNV(
    command_buffer: CommandBuffer,
    indirect_commands_address: DeviceAddress,
    indirect_commands_count_address: DeviceAddress,
    stride: u32,
) void {
    device_dispatch.vkCmdDecompressMemoryIndirectCountNV.?(
        command_buffer,
        indirect_commands_address,
        indirect_commands_count_address,
        stride,
    );
}
pub fn getPartitionedAccelerationStructuresBuildSizesNV(
    device: Device,
    p_info: *const PartitionedAccelerationStructureInstancesInputNV,
    p_size_info: *AccelerationStructureBuildSizesInfoKHR,
) void {
    device_dispatch.vkGetPartitionedAccelerationStructuresBuildSizesNV.?(
        device,
        p_info,
        p_size_info,
    );
}
pub fn cmdBuildPartitionedAccelerationStructuresNV(
    command_buffer: CommandBuffer,
    p_build_info: *const BuildPartitionedAccelerationStructureInfoNV,
) void {
    device_dispatch.vkCmdBuildPartitionedAccelerationStructuresNV.?(
        command_buffer,
        p_build_info,
    );
}
pub const CreateCuModuleNVXError = error{
    OutOfHostMemory,
    InitializationFailed,
    Unknown,
};
pub fn createCuModuleNVX(
    device: Device,
    p_create_info: *const CuModuleCreateInfoNVX,
    p_allocator: ?*const AllocationCallbacks,
) CreateCuModuleNVXError!CuModuleNVX {
    var out_module: CuModuleNVX = undefined;
    const result = device_dispatch.vkCreateCuModuleNVX.?(
        device,
        p_create_info,
        p_allocator,
        &out_module,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
    return out_module;
}
pub const CreateCuFunctionNVXError = error{
    OutOfHostMemory,
    InitializationFailed,
    Unknown,
};
pub fn createCuFunctionNVX(
    device: Device,
    p_create_info: *const CuFunctionCreateInfoNVX,
    p_allocator: ?*const AllocationCallbacks,
) CreateCuFunctionNVXError!CuFunctionNVX {
    var out_function: CuFunctionNVX = undefined;
    const result = device_dispatch.vkCreateCuFunctionNVX.?(
        device,
        p_create_info,
        p_allocator,
        &out_function,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
    return out_function;
}
pub fn destroyCuModuleNVX(
    device: Device,
    module: CuModuleNVX,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyCuModuleNVX.?(
        device,
        module,
        p_allocator,
    );
}
pub fn destroyCuFunctionNVX(
    device: Device,
    function: CuFunctionNVX,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyCuFunctionNVX.?(
        device,
        function,
        p_allocator,
    );
}
pub fn cmdCuLaunchKernelNVX(
    command_buffer: CommandBuffer,
    p_launch_info: *const CuLaunchInfoNVX,
) void {
    device_dispatch.vkCmdCuLaunchKernelNVX.?(
        command_buffer,
        p_launch_info,
    );
}
pub fn getDescriptorSetLayoutSizeEXT(
    device: Device,
    layout: DescriptorSetLayout,
) DeviceSize {
    var out_layout_size_in_bytes: DeviceSize = undefined;
    device_dispatch.vkGetDescriptorSetLayoutSizeEXT.?(
        device,
        layout,
        &out_layout_size_in_bytes,
    );
    return out_layout_size_in_bytes;
}
pub fn getDescriptorSetLayoutBindingOffsetEXT(
    device: Device,
    layout: DescriptorSetLayout,
    binding: u32,
) DeviceSize {
    var out_offset: DeviceSize = undefined;
    device_dispatch.vkGetDescriptorSetLayoutBindingOffsetEXT.?(
        device,
        layout,
        binding,
        &out_offset,
    );
    return out_offset;
}
pub fn getDescriptorEXT(
    device: Device,
    p_descriptor_info: *const DescriptorGetInfoEXT,
    data_size: usize,
    p_descriptor: *anyopaque,
) void {
    device_dispatch.vkGetDescriptorEXT.?(
        device,
        p_descriptor_info,
        data_size,
        p_descriptor,
    );
}
pub fn cmdBindDescriptorBuffersEXT(
    command_buffer: CommandBuffer,
    buffer_count: u32,
    p_binding_infos: [*]const DescriptorBufferBindingInfoEXT,
) void {
    device_dispatch.vkCmdBindDescriptorBuffersEXT.?(
        command_buffer,
        buffer_count,
        p_binding_infos,
    );
}
pub fn cmdSetDescriptorBufferOffsetsEXT(
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    layout: PipelineLayout,
    first_set: u32,
    set_count: u32,
    p_buffer_indices: [*]const u32,
    p_offsets: [*]const DeviceSize,
) void {
    device_dispatch.vkCmdSetDescriptorBufferOffsetsEXT.?(
        command_buffer,
        pipeline_bind_point,
        layout,
        first_set,
        set_count,
        p_buffer_indices,
        p_offsets,
    );
}
pub fn cmdBindDescriptorBufferEmbeddedSamplersEXT(
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    layout: PipelineLayout,
    set: u32,
) void {
    device_dispatch.vkCmdBindDescriptorBufferEmbeddedSamplersEXT.?(
        command_buffer,
        pipeline_bind_point,
        layout,
        set,
    );
}
pub const GetBufferOpaqueCaptureDescriptorDataEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getBufferOpaqueCaptureDescriptorDataEXT(
    device: Device,
    p_info: *const BufferCaptureDescriptorDataInfoEXT,
    p_data: *anyopaque,
) GetBufferOpaqueCaptureDescriptorDataEXTError!void {
    const result = device_dispatch.vkGetBufferOpaqueCaptureDescriptorDataEXT.?(
        device,
        p_info,
        p_data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const GetImageOpaqueCaptureDescriptorDataEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getImageOpaqueCaptureDescriptorDataEXT(
    device: Device,
    p_info: *const ImageCaptureDescriptorDataInfoEXT,
    p_data: *anyopaque,
) GetImageOpaqueCaptureDescriptorDataEXTError!void {
    const result = device_dispatch.vkGetImageOpaqueCaptureDescriptorDataEXT.?(
        device,
        p_info,
        p_data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const GetImageViewOpaqueCaptureDescriptorDataEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getImageViewOpaqueCaptureDescriptorDataEXT(
    device: Device,
    p_info: *const ImageViewCaptureDescriptorDataInfoEXT,
    p_data: *anyopaque,
) GetImageViewOpaqueCaptureDescriptorDataEXTError!void {
    const result = device_dispatch.vkGetImageViewOpaqueCaptureDescriptorDataEXT.?(
        device,
        p_info,
        p_data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const GetSamplerOpaqueCaptureDescriptorDataEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getSamplerOpaqueCaptureDescriptorDataEXT(
    device: Device,
    p_info: *const SamplerCaptureDescriptorDataInfoEXT,
    p_data: *anyopaque,
) GetSamplerOpaqueCaptureDescriptorDataEXTError!void {
    const result = device_dispatch.vkGetSamplerOpaqueCaptureDescriptorDataEXT.?(
        device,
        p_info,
        p_data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const GetAccelerationStructureOpaqueCaptureDescriptorDataEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getAccelerationStructureOpaqueCaptureDescriptorDataEXT(
    device: Device,
    p_info: *const AccelerationStructureCaptureDescriptorDataInfoEXT,
    p_data: *anyopaque,
) GetAccelerationStructureOpaqueCaptureDescriptorDataEXTError!void {
    const result = device_dispatch.vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT.?(
        device,
        p_info,
        p_data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub fn setDeviceMemoryPriorityEXT(
    device: Device,
    memory: DeviceMemory,
    priority: f32,
) void {
    device_dispatch.vkSetDeviceMemoryPriorityEXT.?(
        device,
        memory,
        priority,
    );
}
pub const WaitForPresent2KHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    OutOfDateKHR,
    SurfaceLostKHR,
    FullScreenExclusiveModeLostEXT,
    Unknown,
};
pub fn waitForPresent2KHR(
    device: Device,
    swapchain: SwapchainKHR,
    p_present_wait_2_info: *const PresentWait2InfoKHR,
) WaitForPresent2KHRError!Result {
    const result = device_dispatch.vkWaitForPresent2KHR.?(
        device,
        swapchain,
        p_present_wait_2_info,
    );
    switch (result) {
        Result.success => {},
        Result.timeout => {},
        Result.suboptimal_khr => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        Result.error_out_of_date_khr => return error.OutOfDateKHR,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        Result.error_full_screen_exclusive_mode_lost_ext => return error.FullScreenExclusiveModeLostEXT,
        else => return error.Unknown,
    }
    return result;
}
pub const WaitForPresentKHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    DeviceLost,
    OutOfDateKHR,
    SurfaceLostKHR,
    FullScreenExclusiveModeLostEXT,
    Unknown,
};
pub fn waitForPresentKHR(
    device: Device,
    swapchain: SwapchainKHR,
    present_id: u64,
    timeout: u64,
) WaitForPresentKHRError!Result {
    const result = device_dispatch.vkWaitForPresentKHR.?(
        device,
        swapchain,
        present_id,
        timeout,
    );
    switch (result) {
        Result.success => {},
        Result.timeout => {},
        Result.suboptimal_khr => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_device_lost => return error.DeviceLost,
        Result.error_out_of_date_khr => return error.OutOfDateKHR,
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        Result.error_full_screen_exclusive_mode_lost_ext => return error.FullScreenExclusiveModeLostEXT,
        else => return error.Unknown,
    }
    return result;
}
pub const CreateBufferCollectionFUCHSIAError = error{
    OutOfHostMemory,
    InvalidExternalHandle,
    InitializationFailed,
    Unknown,
};
pub fn createBufferCollectionFUCHSIA(
    device: Device,
    p_create_info: *const BufferCollectionCreateInfoFUCHSIA,
    p_allocator: ?*const AllocationCallbacks,
) CreateBufferCollectionFUCHSIAError!BufferCollectionFUCHSIA {
    var out_collection: BufferCollectionFUCHSIA = undefined;
    const result = device_dispatch.vkCreateBufferCollectionFUCHSIA.?(
        device,
        p_create_info,
        p_allocator,
        &out_collection,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
    return out_collection;
}
pub const SetBufferCollectionBufferConstraintsFUCHSIAError = error{
    InitializationFailed,
    OutOfHostMemory,
    FormatNotSupported,
    Unknown,
};
pub fn setBufferCollectionBufferConstraintsFUCHSIA(
    device: Device,
    collection: BufferCollectionFUCHSIA,
    p_buffer_constraints_info: *const BufferConstraintsInfoFUCHSIA,
) SetBufferCollectionBufferConstraintsFUCHSIAError!void {
    const result = device_dispatch.vkSetBufferCollectionBufferConstraintsFUCHSIA.?(
        device,
        collection,
        p_buffer_constraints_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_format_not_supported => return error.FormatNotSupported,
        else => return error.Unknown,
    }
}
pub const SetBufferCollectionImageConstraintsFUCHSIAError = error{
    InitializationFailed,
    OutOfHostMemory,
    FormatNotSupported,
    Unknown,
};
pub fn setBufferCollectionImageConstraintsFUCHSIA(
    device: Device,
    collection: BufferCollectionFUCHSIA,
    p_image_constraints_info: *const ImageConstraintsInfoFUCHSIA,
) SetBufferCollectionImageConstraintsFUCHSIAError!void {
    const result = device_dispatch.vkSetBufferCollectionImageConstraintsFUCHSIA.?(
        device,
        collection,
        p_image_constraints_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_format_not_supported => return error.FormatNotSupported,
        else => return error.Unknown,
    }
}
pub fn destroyBufferCollectionFUCHSIA(
    device: Device,
    collection: BufferCollectionFUCHSIA,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyBufferCollectionFUCHSIA.?(
        device,
        collection,
        p_allocator,
    );
}
pub const GetBufferCollectionPropertiesFUCHSIAError = error{
    OutOfHostMemory,
    InitializationFailed,
    Unknown,
};
pub fn getBufferCollectionPropertiesFUCHSIA(
    device: Device,
    collection: BufferCollectionFUCHSIA,
    p_properties: *BufferCollectionPropertiesFUCHSIA,
) GetBufferCollectionPropertiesFUCHSIAError!void {
    const result = device_dispatch.vkGetBufferCollectionPropertiesFUCHSIA.?(
        device,
        collection,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
}
pub const CreateCudaModuleNVError = error{
    InitializationFailed,
    OutOfHostMemory,
    Unknown,
};
pub fn createCudaModuleNV(
    device: Device,
    p_create_info: *const CudaModuleCreateInfoNV,
    p_allocator: ?*const AllocationCallbacks,
) CreateCudaModuleNVError!CudaModuleNV {
    var out_module: CudaModuleNV = undefined;
    const result = device_dispatch.vkCreateCudaModuleNV.?(
        device,
        p_create_info,
        p_allocator,
        &out_module,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_module;
}
pub const GetCudaModuleCacheNVError = error{
    InitializationFailed,
    Unknown,
};
pub fn getCudaModuleCacheNV(
    device: Device,
    module: CudaModuleNV,
    p_cache_size: *usize,
    p_cache_data: ?*anyopaque,
) GetCudaModuleCacheNVError!Result {
    const result = device_dispatch.vkGetCudaModuleCacheNV.?(
        device,
        module,
        p_cache_size,
        p_cache_data,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
    return result;
}
pub const CreateCudaFunctionNVError = error{
    InitializationFailed,
    OutOfHostMemory,
    Unknown,
};
pub fn createCudaFunctionNV(
    device: Device,
    p_create_info: *const CudaFunctionCreateInfoNV,
    p_allocator: ?*const AllocationCallbacks,
) CreateCudaFunctionNVError!CudaFunctionNV {
    var out_function: CudaFunctionNV = undefined;
    const result = device_dispatch.vkCreateCudaFunctionNV.?(
        device,
        p_create_info,
        p_allocator,
        &out_function,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_function;
}
pub fn destroyCudaModuleNV(
    device: Device,
    module: CudaModuleNV,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyCudaModuleNV.?(
        device,
        module,
        p_allocator,
    );
}
pub fn destroyCudaFunctionNV(
    device: Device,
    function: CudaFunctionNV,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyCudaFunctionNV.?(
        device,
        function,
        p_allocator,
    );
}
pub fn cmdCudaLaunchKernelNV(
    command_buffer: CommandBuffer,
    p_launch_info: *const CudaLaunchInfoNV,
) void {
    device_dispatch.vkCmdCudaLaunchKernelNV.?(
        command_buffer,
        p_launch_info,
    );
}
pub fn cmdBeginRendering(
    command_buffer: CommandBuffer,
    p_rendering_info: *const RenderingInfo,
) void {
    device_dispatch.vkCmdBeginRendering.?(
        command_buffer,
        p_rendering_info,
    );
}
pub fn cmdBeginRenderingKHR(
    command_buffer: CommandBuffer,
    p_rendering_info: *const RenderingInfo,
) void {
    device_dispatch.vkCmdBeginRenderingKHR.?(
        command_buffer,
        p_rendering_info,
    );
}
pub fn cmdEndRendering(
    command_buffer: CommandBuffer,
) void {
    device_dispatch.vkCmdEndRendering.?(
        command_buffer,
    );
}
pub fn cmdEndRendering2EXT(
    command_buffer: CommandBuffer,
    p_rendering_end_info: ?*const RenderingEndInfoEXT,
) void {
    device_dispatch.vkCmdEndRendering2EXT.?(
        command_buffer,
        p_rendering_end_info,
    );
}
pub fn cmdEndRenderingKHR(
    command_buffer: CommandBuffer,
) void {
    device_dispatch.vkCmdEndRenderingKHR.?(
        command_buffer,
    );
}
pub fn getDescriptorSetLayoutHostMappingInfoVALVE(
    device: Device,
    p_binding_reference: *const DescriptorSetBindingReferenceVALVE,
    p_host_mapping: *DescriptorSetLayoutHostMappingInfoVALVE,
) void {
    device_dispatch.vkGetDescriptorSetLayoutHostMappingInfoVALVE.?(
        device,
        p_binding_reference,
        p_host_mapping,
    );
}
pub fn getDescriptorSetHostMappingVALVE(
    device: Device,
    descriptor_set: DescriptorSet,
) *anyopaque {
    var out_pp_data: *anyopaque = undefined;
    device_dispatch.vkGetDescriptorSetHostMappingVALVE.?(
        device,
        descriptor_set,
        &out_pp_data,
    );
    return out_pp_data;
}
pub const CreateMicromapEXTError = error{
    OutOfHostMemory,
    InvalidOpaqueCaptureAddressKHR,
    Unknown,
};
pub fn createMicromapEXT(
    device: Device,
    p_create_info: *const MicromapCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
) CreateMicromapEXTError!MicromapEXT {
    var out_micromap: MicromapEXT = undefined;
    const result = device_dispatch.vkCreateMicromapEXT.?(
        device,
        p_create_info,
        p_allocator,
        &out_micromap,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_invalid_opaque_capture_address_khr => return error.InvalidOpaqueCaptureAddressKHR,
        else => return error.Unknown,
    }
    return out_micromap;
}
pub fn cmdBuildMicromapsEXT(
    command_buffer: CommandBuffer,
    info_count: u32,
    p_infos: [*]const MicromapBuildInfoEXT,
) void {
    device_dispatch.vkCmdBuildMicromapsEXT.?(
        command_buffer,
        info_count,
        p_infos,
    );
}
pub const BuildMicromapsEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn buildMicromapsEXT(
    device: Device,
    deferred_operation: DeferredOperationKHR,
    info_count: u32,
    p_infos: [*]const MicromapBuildInfoEXT,
) BuildMicromapsEXTError!Result {
    const result = device_dispatch.vkBuildMicromapsEXT.?(
        device,
        deferred_operation,
        info_count,
        p_infos,
    );
    switch (result) {
        Result.success => {},
        Result.operation_deferred_khr => {},
        Result.operation_not_deferred_khr => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn destroyMicromapEXT(
    device: Device,
    micromap: MicromapEXT,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyMicromapEXT.?(
        device,
        micromap,
        p_allocator,
    );
}
pub fn cmdCopyMicromapEXT(
    command_buffer: CommandBuffer,
    p_info: *const CopyMicromapInfoEXT,
) void {
    device_dispatch.vkCmdCopyMicromapEXT.?(
        command_buffer,
        p_info,
    );
}
pub const CopyMicromapEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn copyMicromapEXT(
    device: Device,
    deferred_operation: DeferredOperationKHR,
    p_info: *const CopyMicromapInfoEXT,
) CopyMicromapEXTError!Result {
    const result = device_dispatch.vkCopyMicromapEXT.?(
        device,
        deferred_operation,
        p_info,
    );
    switch (result) {
        Result.success => {},
        Result.operation_deferred_khr => {},
        Result.operation_not_deferred_khr => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn cmdCopyMicromapToMemoryEXT(
    command_buffer: CommandBuffer,
    p_info: *const CopyMicromapToMemoryInfoEXT,
) void {
    device_dispatch.vkCmdCopyMicromapToMemoryEXT.?(
        command_buffer,
        p_info,
    );
}
pub const CopyMicromapToMemoryEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn copyMicromapToMemoryEXT(
    device: Device,
    deferred_operation: DeferredOperationKHR,
    p_info: *const CopyMicromapToMemoryInfoEXT,
) CopyMicromapToMemoryEXTError!Result {
    const result = device_dispatch.vkCopyMicromapToMemoryEXT.?(
        device,
        deferred_operation,
        p_info,
    );
    switch (result) {
        Result.success => {},
        Result.operation_deferred_khr => {},
        Result.operation_not_deferred_khr => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn cmdCopyMemoryToMicromapEXT(
    command_buffer: CommandBuffer,
    p_info: *const CopyMemoryToMicromapInfoEXT,
) void {
    device_dispatch.vkCmdCopyMemoryToMicromapEXT.?(
        command_buffer,
        p_info,
    );
}
pub const CopyMemoryToMicromapEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn copyMemoryToMicromapEXT(
    device: Device,
    deferred_operation: DeferredOperationKHR,
    p_info: *const CopyMemoryToMicromapInfoEXT,
) CopyMemoryToMicromapEXTError!Result {
    const result = device_dispatch.vkCopyMemoryToMicromapEXT.?(
        device,
        deferred_operation,
        p_info,
    );
    switch (result) {
        Result.success => {},
        Result.operation_deferred_khr => {},
        Result.operation_not_deferred_khr => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn cmdWriteMicromapsPropertiesEXT(
    command_buffer: CommandBuffer,
    micromap_count: u32,
    p_micromaps: [*]const MicromapEXT,
    query_type: QueryType,
    query_pool: QueryPool,
    first_query: u32,
) void {
    device_dispatch.vkCmdWriteMicromapsPropertiesEXT.?(
        command_buffer,
        micromap_count,
        p_micromaps,
        query_type,
        query_pool,
        first_query,
    );
}
pub const WriteMicromapsPropertiesEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn writeMicromapsPropertiesEXT(
    device: Device,
    micromap_count: u32,
    p_micromaps: [*]const MicromapEXT,
    query_type: QueryType,
    data_size: usize,
    p_data: *anyopaque,
    stride: usize,
) WriteMicromapsPropertiesEXTError!void {
    const result = device_dispatch.vkWriteMicromapsPropertiesEXT.?(
        device,
        micromap_count,
        p_micromaps,
        query_type,
        data_size,
        p_data,
        stride,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub fn getDeviceMicromapCompatibilityEXT(
    device: Device,
    p_version_info: *const MicromapVersionInfoEXT,
) AccelerationStructureCompatibilityKHR {
    var out_compatibility: AccelerationStructureCompatibilityKHR = undefined;
    device_dispatch.vkGetDeviceMicromapCompatibilityEXT.?(
        device,
        p_version_info,
        &out_compatibility,
    );
    return out_compatibility;
}
pub fn getMicromapBuildSizesEXT(
    device: Device,
    build_type: AccelerationStructureBuildTypeKHR,
    p_build_info: *const MicromapBuildInfoEXT,
    p_size_info: *MicromapBuildSizesInfoEXT,
) void {
    device_dispatch.vkGetMicromapBuildSizesEXT.?(
        device,
        build_type,
        p_build_info,
        p_size_info,
    );
}
pub fn getShaderModuleIdentifierEXT(
    device: Device,
    shader_module: ShaderModule,
    p_identifier: *ShaderModuleIdentifierEXT,
) void {
    device_dispatch.vkGetShaderModuleIdentifierEXT.?(
        device,
        shader_module,
        p_identifier,
    );
}
pub fn getShaderModuleCreateInfoIdentifierEXT(
    device: Device,
    p_create_info: *const ShaderModuleCreateInfo,
    p_identifier: *ShaderModuleIdentifierEXT,
) void {
    device_dispatch.vkGetShaderModuleCreateInfoIdentifierEXT.?(
        device,
        p_create_info,
        p_identifier,
    );
}
pub fn getImageSubresourceLayout2(
    device: Device,
    image: Image,
    p_subresource: *const ImageSubresource2,
    p_layout: *SubresourceLayout2,
) void {
    device_dispatch.vkGetImageSubresourceLayout2.?(
        device,
        image,
        p_subresource,
        p_layout,
    );
}
pub fn getImageSubresourceLayout2KHR(
    device: Device,
    image: Image,
    p_subresource: *const ImageSubresource2,
    p_layout: *SubresourceLayout2,
) void {
    device_dispatch.vkGetImageSubresourceLayout2KHR.?(
        device,
        image,
        p_subresource,
        p_layout,
    );
}
pub fn getImageSubresourceLayout2EXT(
    device: Device,
    image: Image,
    p_subresource: *const ImageSubresource2,
    p_layout: *SubresourceLayout2,
) void {
    device_dispatch.vkGetImageSubresourceLayout2EXT.?(
        device,
        image,
        p_subresource,
        p_layout,
    );
}
pub const GetPipelinePropertiesEXTError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn getPipelinePropertiesEXT(
    device: Device,
    p_pipeline_info: *const PipelineInfoEXT,
    p_pipeline_properties: *BaseOutStructure,
) GetPipelinePropertiesEXTError!void {
    const result = device_dispatch.vkGetPipelinePropertiesEXT.?(
        device,
        p_pipeline_info,
        p_pipeline_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub fn exportMetalObjectsEXT(
    device: Device,
    p_metal_objects_info: *ExportMetalObjectsInfoEXT,
) void {
    device_dispatch.vkExportMetalObjectsEXT.?(
        device,
        p_metal_objects_info,
    );
}
pub fn cmdBindTileMemoryQCOM(
    command_buffer: CommandBuffer,
    p_tile_memory_bind_info: ?*const TileMemoryBindInfoQCOM,
) void {
    device_dispatch.vkCmdBindTileMemoryQCOM.?(
        command_buffer,
        p_tile_memory_bind_info,
    );
}
pub const GetFramebufferTilePropertiesQCOMError = error{
    Unknown,
};
pub fn getFramebufferTilePropertiesQCOM(
    device: Device,
    framebuffer: Framebuffer,
    p_properties_count: *u32,
    p_properties: ?[*]TilePropertiesQCOM,
) GetFramebufferTilePropertiesQCOMError!Result {
    const result = device_dispatch.vkGetFramebufferTilePropertiesQCOM.?(
        device,
        framebuffer,
        p_properties_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        else => return error.Unknown,
    }
    return result;
}
pub const GetDynamicRenderingTilePropertiesQCOMError = error{
    Unknown,
};
pub fn getDynamicRenderingTilePropertiesQCOM(
    device: Device,
    p_rendering_info: *const RenderingInfo,
    p_properties: *TilePropertiesQCOM,
) GetDynamicRenderingTilePropertiesQCOMError!void {
    const result = device_dispatch.vkGetDynamicRenderingTilePropertiesQCOM.?(
        device,
        p_rendering_info,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        else => return error.Unknown,
    }
}
pub const CreateOpticalFlowSessionNVError = error{
    OutOfHostMemory,
    InitializationFailed,
    Unknown,
};
pub fn createOpticalFlowSessionNV(
    device: Device,
    p_create_info: *const OpticalFlowSessionCreateInfoNV,
    p_allocator: ?*const AllocationCallbacks,
) CreateOpticalFlowSessionNVError!OpticalFlowSessionNV {
    var out_session: OpticalFlowSessionNV = undefined;
    const result = device_dispatch.vkCreateOpticalFlowSessionNV.?(
        device,
        p_create_info,
        p_allocator,
        &out_session,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
    return out_session;
}
pub fn destroyOpticalFlowSessionNV(
    device: Device,
    session: OpticalFlowSessionNV,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyOpticalFlowSessionNV.?(
        device,
        session,
        p_allocator,
    );
}
pub const BindOpticalFlowSessionImageNVError = error{
    OutOfHostMemory,
    InitializationFailed,
    Unknown,
};
pub fn bindOpticalFlowSessionImageNV(
    device: Device,
    session: OpticalFlowSessionNV,
    binding_point: OpticalFlowSessionBindingPointNV,
    view: ImageView,
    layout: ImageLayout,
) BindOpticalFlowSessionImageNVError!void {
    const result = device_dispatch.vkBindOpticalFlowSessionImageNV.?(
        device,
        session,
        binding_point,
        view,
        layout,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
}
pub fn cmdOpticalFlowExecuteNV(
    command_buffer: CommandBuffer,
    session: OpticalFlowSessionNV,
    p_execute_info: *const OpticalFlowExecuteInfoNV,
) void {
    device_dispatch.vkCmdOpticalFlowExecuteNV.?(
        command_buffer,
        session,
        p_execute_info,
    );
}
pub const GetDeviceFaultInfoEXTError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn getDeviceFaultInfoEXT(
    device: Device,
    p_fault_counts: *DeviceFaultCountsEXT,
    p_fault_info: ?*DeviceFaultInfoEXT,
) GetDeviceFaultInfoEXTError!Result {
    const result = device_dispatch.vkGetDeviceFaultInfoEXT.?(
        device,
        p_fault_counts,
        p_fault_info,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn cmdSetDepthBias2EXT(
    command_buffer: CommandBuffer,
    p_depth_bias_info: *const DepthBiasInfoEXT,
) void {
    device_dispatch.vkCmdSetDepthBias2EXT.?(
        command_buffer,
        p_depth_bias_info,
    );
}
pub const ReleaseSwapchainImagesKHRError = error{
    SurfaceLostKHR,
    Unknown,
};
pub fn releaseSwapchainImagesKHR(
    device: Device,
    p_release_info: *const ReleaseSwapchainImagesInfoKHR,
) ReleaseSwapchainImagesKHRError!void {
    const result = device_dispatch.vkReleaseSwapchainImagesKHR.?(
        device,
        p_release_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
}
pub const ReleaseSwapchainImagesEXTError = error{
    SurfaceLostKHR,
    Unknown,
};
pub fn releaseSwapchainImagesEXT(
    device: Device,
    p_release_info: *const ReleaseSwapchainImagesInfoKHR,
) ReleaseSwapchainImagesEXTError!void {
    const result = device_dispatch.vkReleaseSwapchainImagesEXT.?(
        device,
        p_release_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_surface_lost_khr => return error.SurfaceLostKHR,
        else => return error.Unknown,
    }
}
pub fn getDeviceImageSubresourceLayout(
    device: Device,
    p_info: *const DeviceImageSubresourceInfo,
    p_layout: *SubresourceLayout2,
) void {
    device_dispatch.vkGetDeviceImageSubresourceLayout.?(
        device,
        p_info,
        p_layout,
    );
}
pub fn getDeviceImageSubresourceLayoutKHR(
    device: Device,
    p_info: *const DeviceImageSubresourceInfo,
    p_layout: *SubresourceLayout2,
) void {
    device_dispatch.vkGetDeviceImageSubresourceLayoutKHR.?(
        device,
        p_info,
        p_layout,
    );
}
pub const MapMemory2Error = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    MemoryMapFailed,
    Unknown,
};
pub fn mapMemory2(
    device: Device,
    p_memory_map_info: *const MemoryMapInfo,
) MapMemory2Error!?*anyopaque {
    var out_pp_data: ?*anyopaque = undefined;
    const result = device_dispatch.vkMapMemory2.?(
        device,
        p_memory_map_info,
        &out_pp_data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_memory_map_failed => return error.MemoryMapFailed,
        else => return error.Unknown,
    }
    return out_pp_data;
}
pub const MapMemory2KHRError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    MemoryMapFailed,
    Unknown,
};
pub fn mapMemory2KHR(
    device: Device,
    p_memory_map_info: *const MemoryMapInfo,
) MapMemory2KHRError!?*anyopaque {
    var out_pp_data: ?*anyopaque = undefined;
    const result = device_dispatch.vkMapMemory2KHR.?(
        device,
        p_memory_map_info,
        &out_pp_data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_memory_map_failed => return error.MemoryMapFailed,
        else => return error.Unknown,
    }
    return out_pp_data;
}
pub const UnmapMemory2Error = error{
    MemoryMapFailed,
    Unknown,
};
pub fn unmapMemory2(
    device: Device,
    p_memory_unmap_info: *const MemoryUnmapInfo,
) UnmapMemory2Error!void {
    const result = device_dispatch.vkUnmapMemory2.?(
        device,
        p_memory_unmap_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_memory_map_failed => return error.MemoryMapFailed,
        else => return error.Unknown,
    }
}
pub const UnmapMemory2KHRError = error{
    MemoryMapFailed,
    Unknown,
};
pub fn unmapMemory2KHR(
    device: Device,
    p_memory_unmap_info: *const MemoryUnmapInfo,
) UnmapMemory2KHRError!void {
    const result = device_dispatch.vkUnmapMemory2KHR.?(
        device,
        p_memory_unmap_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_memory_map_failed => return error.MemoryMapFailed,
        else => return error.Unknown,
    }
}
pub const CreateShadersEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    InitializationFailed,
    Unknown,
};
pub fn createShadersEXT(
    device: Device,
    create_info_count: u32,
    p_create_infos: [*]const ShaderCreateInfoEXT,
    p_allocator: ?*const AllocationCallbacks,
    p_shaders: [*]ShaderEXT,
) CreateShadersEXTError!Result {
    const result = device_dispatch.vkCreateShadersEXT.?(
        device,
        create_info_count,
        p_create_infos,
        p_allocator,
        p_shaders,
    );
    switch (result) {
        Result.success => {},
        Result.incompatible_shader_binary_ext => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
    return result;
}
pub fn destroyShaderEXT(
    device: Device,
    shader: ShaderEXT,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyShaderEXT.?(
        device,
        shader,
        p_allocator,
    );
}
pub const GetShaderBinaryDataEXTError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getShaderBinaryDataEXT(
    device: Device,
    shader: ShaderEXT,
    p_data_size: *usize,
    p_data: ?*anyopaque,
) GetShaderBinaryDataEXTError!Result {
    const result = device_dispatch.vkGetShaderBinaryDataEXT.?(
        device,
        shader,
        p_data_size,
        p_data,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn cmdBindShadersEXT(
    command_buffer: CommandBuffer,
    stage_count: u32,
    p_stages: [*]const ShaderStageFlags,
    p_shaders: ?[*]const ShaderEXT,
) void {
    device_dispatch.vkCmdBindShadersEXT.?(
        command_buffer,
        stage_count,
        p_stages,
        p_shaders,
    );
}
pub const GetScreenBufferPropertiesQNXError = error{
    OutOfHostMemory,
    InvalidExternalHandleKHR,
    Unknown,
};
pub fn getScreenBufferPropertiesQNX(
    device: Device,
    buffer: *const _screen_buffer,
    p_properties: *ScreenBufferPropertiesQNX,
) GetScreenBufferPropertiesQNXError!void {
    const result = device_dispatch.vkGetScreenBufferPropertiesQNX.?(
        device,
        buffer,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_invalid_external_handle_khr => return error.InvalidExternalHandleKHR,
        else => return error.Unknown,
    }
}
pub const GetExecutionGraphPipelineScratchSizeAMDXError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn getExecutionGraphPipelineScratchSizeAMDX(
    device: Device,
    execution_graph: Pipeline,
    p_size_info: *ExecutionGraphPipelineScratchSizeAMDX,
) GetExecutionGraphPipelineScratchSizeAMDXError!void {
    const result = device_dispatch.vkGetExecutionGraphPipelineScratchSizeAMDX.?(
        device,
        execution_graph,
        p_size_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
}
pub const GetExecutionGraphPipelineNodeIndexAMDXError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn getExecutionGraphPipelineNodeIndexAMDX(
    device: Device,
    execution_graph: Pipeline,
    p_node_info: *const PipelineShaderStageNodeCreateInfoAMDX,
) GetExecutionGraphPipelineNodeIndexAMDXError!u32 {
    var out_node_index: u32 = undefined;
    const result = device_dispatch.vkGetExecutionGraphPipelineNodeIndexAMDX.?(
        device,
        execution_graph,
        p_node_info,
        &out_node_index,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_node_index;
}
pub const CreateExecutionGraphPipelinesAMDXError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createExecutionGraphPipelinesAMDX(
    device: Device,
    pipeline_cache: PipelineCache,
    create_info_count: u32,
    p_create_infos: [*]const ExecutionGraphPipelineCreateInfoAMDX,
    p_allocator: ?*const AllocationCallbacks,
    p_pipelines: [*]Pipeline,
) CreateExecutionGraphPipelinesAMDXError!Result {
    const result = device_dispatch.vkCreateExecutionGraphPipelinesAMDX.?(
        device,
        pipeline_cache,
        create_info_count,
        p_create_infos,
        p_allocator,
        p_pipelines,
    );
    switch (result) {
        Result.success => {},
        Result.pipeline_compile_required_ext => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn cmdInitializeGraphScratchMemoryAMDX(
    command_buffer: CommandBuffer,
    execution_graph: Pipeline,
    scratch: DeviceAddress,
    scratch_size: DeviceSize,
) void {
    device_dispatch.vkCmdInitializeGraphScratchMemoryAMDX.?(
        command_buffer,
        execution_graph,
        scratch,
        scratch_size,
    );
}
pub fn cmdDispatchGraphAMDX(
    command_buffer: CommandBuffer,
    scratch: DeviceAddress,
    scratch_size: DeviceSize,
    p_count_info: *const DispatchGraphCountInfoAMDX,
) void {
    device_dispatch.vkCmdDispatchGraphAMDX.?(
        command_buffer,
        scratch,
        scratch_size,
        p_count_info,
    );
}
pub fn cmdDispatchGraphIndirectAMDX(
    command_buffer: CommandBuffer,
    scratch: DeviceAddress,
    scratch_size: DeviceSize,
    p_count_info: *const DispatchGraphCountInfoAMDX,
) void {
    device_dispatch.vkCmdDispatchGraphIndirectAMDX.?(
        command_buffer,
        scratch,
        scratch_size,
        p_count_info,
    );
}
pub fn cmdDispatchGraphIndirectCountAMDX(
    command_buffer: CommandBuffer,
    scratch: DeviceAddress,
    scratch_size: DeviceSize,
    count_info: DeviceAddress,
) void {
    device_dispatch.vkCmdDispatchGraphIndirectCountAMDX.?(
        command_buffer,
        scratch,
        scratch_size,
        count_info,
    );
}
pub fn cmdBindDescriptorSets2(
    command_buffer: CommandBuffer,
    p_bind_descriptor_sets_info: *const BindDescriptorSetsInfo,
) void {
    device_dispatch.vkCmdBindDescriptorSets2.?(
        command_buffer,
        p_bind_descriptor_sets_info,
    );
}
pub fn cmdBindDescriptorSets2KHR(
    command_buffer: CommandBuffer,
    p_bind_descriptor_sets_info: *const BindDescriptorSetsInfo,
) void {
    device_dispatch.vkCmdBindDescriptorSets2KHR.?(
        command_buffer,
        p_bind_descriptor_sets_info,
    );
}
pub fn cmdPushConstants2(
    command_buffer: CommandBuffer,
    p_push_constants_info: *const PushConstantsInfo,
) void {
    device_dispatch.vkCmdPushConstants2.?(
        command_buffer,
        p_push_constants_info,
    );
}
pub fn cmdPushConstants2KHR(
    command_buffer: CommandBuffer,
    p_push_constants_info: *const PushConstantsInfo,
) void {
    device_dispatch.vkCmdPushConstants2KHR.?(
        command_buffer,
        p_push_constants_info,
    );
}
pub fn cmdPushDescriptorSet2(
    command_buffer: CommandBuffer,
    p_push_descriptor_set_info: *const PushDescriptorSetInfo,
) void {
    device_dispatch.vkCmdPushDescriptorSet2.?(
        command_buffer,
        p_push_descriptor_set_info,
    );
}
pub fn cmdPushDescriptorSet2KHR(
    command_buffer: CommandBuffer,
    p_push_descriptor_set_info: *const PushDescriptorSetInfo,
) void {
    device_dispatch.vkCmdPushDescriptorSet2KHR.?(
        command_buffer,
        p_push_descriptor_set_info,
    );
}
pub fn cmdPushDescriptorSetWithTemplate2(
    command_buffer: CommandBuffer,
    p_push_descriptor_set_with_template_info: *const PushDescriptorSetWithTemplateInfo,
) void {
    device_dispatch.vkCmdPushDescriptorSetWithTemplate2.?(
        command_buffer,
        p_push_descriptor_set_with_template_info,
    );
}
pub fn cmdPushDescriptorSetWithTemplate2KHR(
    command_buffer: CommandBuffer,
    p_push_descriptor_set_with_template_info: *const PushDescriptorSetWithTemplateInfo,
) void {
    device_dispatch.vkCmdPushDescriptorSetWithTemplate2KHR.?(
        command_buffer,
        p_push_descriptor_set_with_template_info,
    );
}
pub fn cmdSetDescriptorBufferOffsets2EXT(
    command_buffer: CommandBuffer,
    p_set_descriptor_buffer_offsets_info: *const SetDescriptorBufferOffsetsInfoEXT,
) void {
    device_dispatch.vkCmdSetDescriptorBufferOffsets2EXT.?(
        command_buffer,
        p_set_descriptor_buffer_offsets_info,
    );
}
pub fn cmdBindDescriptorBufferEmbeddedSamplers2EXT(
    command_buffer: CommandBuffer,
    p_bind_descriptor_buffer_embedded_samplers_info: *const BindDescriptorBufferEmbeddedSamplersInfoEXT,
) void {
    device_dispatch.vkCmdBindDescriptorBufferEmbeddedSamplers2EXT.?(
        command_buffer,
        p_bind_descriptor_buffer_embedded_samplers_info,
    );
}
pub const SetLatencySleepModeNVError = error{
    InitializationFailed,
    Unknown,
};
pub fn setLatencySleepModeNV(
    device: Device,
    swapchain: SwapchainKHR,
    p_sleep_mode_info: *const LatencySleepModeInfoNV,
) SetLatencySleepModeNVError!void {
    const result = device_dispatch.vkSetLatencySleepModeNV.?(
        device,
        swapchain,
        p_sleep_mode_info,
    );
    switch (result) {
        Result.success => {},
        Result.error_initialization_failed => return error.InitializationFailed,
        else => return error.Unknown,
    }
}
pub const LatencySleepNVError = error{
    Unknown,
};
pub fn latencySleepNV(
    device: Device,
    swapchain: SwapchainKHR,
    p_sleep_info: *const LatencySleepInfoNV,
) LatencySleepNVError!void {
    const result = device_dispatch.vkLatencySleepNV.?(
        device,
        swapchain,
        p_sleep_info,
    );
    switch (result) {
        Result.success => {},
        else => return error.Unknown,
    }
}
pub fn setLatencyMarkerNV(
    device: Device,
    swapchain: SwapchainKHR,
    p_latency_marker_info: *const SetLatencyMarkerInfoNV,
) void {
    device_dispatch.vkSetLatencyMarkerNV.?(
        device,
        swapchain,
        p_latency_marker_info,
    );
}
pub fn getLatencyTimingsNV(
    device: Device,
    swapchain: SwapchainKHR,
    p_latency_marker_info: *GetLatencyMarkerInfoNV,
) void {
    device_dispatch.vkGetLatencyTimingsNV.?(
        device,
        swapchain,
        p_latency_marker_info,
    );
}
pub fn queueNotifyOutOfBandNV(
    queue: Queue,
    p_queue_type_info: *const OutOfBandQueueTypeInfoNV,
) void {
    device_dispatch.vkQueueNotifyOutOfBandNV.?(
        queue,
        p_queue_type_info,
    );
}
pub fn cmdSetRenderingAttachmentLocations(
    command_buffer: CommandBuffer,
    p_location_info: *const RenderingAttachmentLocationInfo,
) void {
    device_dispatch.vkCmdSetRenderingAttachmentLocations.?(
        command_buffer,
        p_location_info,
    );
}
pub fn cmdSetRenderingAttachmentLocationsKHR(
    command_buffer: CommandBuffer,
    p_location_info: *const RenderingAttachmentLocationInfo,
) void {
    device_dispatch.vkCmdSetRenderingAttachmentLocationsKHR.?(
        command_buffer,
        p_location_info,
    );
}
pub fn cmdSetRenderingInputAttachmentIndices(
    command_buffer: CommandBuffer,
    p_input_attachment_index_info: *const RenderingInputAttachmentIndexInfo,
) void {
    device_dispatch.vkCmdSetRenderingInputAttachmentIndices.?(
        command_buffer,
        p_input_attachment_index_info,
    );
}
pub fn cmdSetRenderingInputAttachmentIndicesKHR(
    command_buffer: CommandBuffer,
    p_input_attachment_index_info: *const RenderingInputAttachmentIndexInfo,
) void {
    device_dispatch.vkCmdSetRenderingInputAttachmentIndicesKHR.?(
        command_buffer,
        p_input_attachment_index_info,
    );
}
pub fn cmdSetDepthClampRangeEXT(
    command_buffer: CommandBuffer,
    depth_clamp_mode: DepthClampModeEXT,
    p_depth_clamp_range: ?*const DepthClampRangeEXT,
) void {
    device_dispatch.vkCmdSetDepthClampRangeEXT.?(
        command_buffer,
        depth_clamp_mode,
        p_depth_clamp_range,
    );
}
pub const GetMemoryMetalHandleEXTError = error{
    TooManyObjects,
    OutOfHostMemory,
    Unknown,
};
pub fn getMemoryMetalHandleEXT(
    device: Device,
    p_get_metal_handle_info: *const MemoryGetMetalHandleInfoEXT,
) GetMemoryMetalHandleEXTError!*anyopaque {
    var out_handle: *anyopaque = undefined;
    const result = device_dispatch.vkGetMemoryMetalHandleEXT.?(
        device,
        p_get_metal_handle_info,
        &out_handle,
    );
    switch (result) {
        Result.success => {},
        Result.error_too_many_objects => return error.TooManyObjects,
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return out_handle;
}
pub const GetMemoryMetalHandlePropertiesEXTError = error{
    OutOfHostMemory,
    InvalidExternalHandle,
    Unknown,
};
pub fn getMemoryMetalHandlePropertiesEXT(
    device: Device,
    handle_type: ExternalMemoryHandleTypeFlags,
    p_handle: *const anyopaque,
    p_memory_metal_handle_properties: *MemoryMetalHandlePropertiesEXT,
) GetMemoryMetalHandlePropertiesEXTError!void {
    const result = device_dispatch.vkGetMemoryMetalHandlePropertiesEXT.?(
        device,
        handle_type,
        p_handle,
        p_memory_metal_handle_properties,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_invalid_external_handle => return error.InvalidExternalHandle,
        else => return error.Unknown,
    }
}
pub const ConvertCooperativeVectorMatrixNVError = error{
    OutOfHostMemory,
    Unknown,
};
pub fn convertCooperativeVectorMatrixNV(
    device: Device,
    p_info: *const ConvertCooperativeVectorMatrixInfoNV,
) ConvertCooperativeVectorMatrixNVError!Result {
    const result = device_dispatch.vkConvertCooperativeVectorMatrixNV.?(
        device,
        p_info,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn cmdConvertCooperativeVectorMatrixNV(
    command_buffer: CommandBuffer,
    info_count: u32,
    p_infos: [*]const ConvertCooperativeVectorMatrixInfoNV,
) void {
    device_dispatch.vkCmdConvertCooperativeVectorMatrixNV.?(
        command_buffer,
        info_count,
        p_infos,
    );
}
pub fn cmdDispatchTileQCOM(
    command_buffer: CommandBuffer,
    p_dispatch_tile_info: *const DispatchTileInfoQCOM,
) void {
    device_dispatch.vkCmdDispatchTileQCOM.?(
        command_buffer,
        p_dispatch_tile_info,
    );
}
pub fn cmdBeginPerTileExecutionQCOM(
    command_buffer: CommandBuffer,
    p_per_tile_begin_info: *const PerTileBeginInfoQCOM,
) void {
    device_dispatch.vkCmdBeginPerTileExecutionQCOM.?(
        command_buffer,
        p_per_tile_begin_info,
    );
}
pub fn cmdEndPerTileExecutionQCOM(
    command_buffer: CommandBuffer,
    p_per_tile_end_info: *const PerTileEndInfoQCOM,
) void {
    device_dispatch.vkCmdEndPerTileExecutionQCOM.?(
        command_buffer,
        p_per_tile_end_info,
    );
}
pub const CreateExternalComputeQueueNVError = error{
    OutOfHostMemory,
    TooManyObjects,
    Unknown,
};
pub fn createExternalComputeQueueNV(
    device: Device,
    p_create_info: *const ExternalComputeQueueCreateInfoNV,
    p_allocator: ?*const AllocationCallbacks,
) CreateExternalComputeQueueNVError!ExternalComputeQueueNV {
    var out_external_queue: ExternalComputeQueueNV = undefined;
    const result = device_dispatch.vkCreateExternalComputeQueueNV.?(
        device,
        p_create_info,
        p_allocator,
        &out_external_queue,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_too_many_objects => return error.TooManyObjects,
        else => return error.Unknown,
    }
    return out_external_queue;
}
pub fn destroyExternalComputeQueueNV(
    device: Device,
    external_queue: ExternalComputeQueueNV,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyExternalComputeQueueNV.?(
        device,
        external_queue,
        p_allocator,
    );
}
pub const CreateTensorARMError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createTensorARM(
    device: Device,
    p_create_info: *const TensorCreateInfoARM,
    p_allocator: ?*const AllocationCallbacks,
) CreateTensorARMError!TensorARM {
    var out_tensor: TensorARM = undefined;
    const result = device_dispatch.vkCreateTensorARM.?(
        device,
        p_create_info,
        p_allocator,
        &out_tensor,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_tensor;
}
pub fn destroyTensorARM(
    device: Device,
    tensor: TensorARM,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyTensorARM.?(
        device,
        tensor,
        p_allocator,
    );
}
pub const CreateTensorViewARMError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createTensorViewARM(
    device: Device,
    p_create_info: *const TensorViewCreateInfoARM,
    p_allocator: ?*const AllocationCallbacks,
) CreateTensorViewARMError!TensorViewARM {
    var out_view: TensorViewARM = undefined;
    const result = device_dispatch.vkCreateTensorViewARM.?(
        device,
        p_create_info,
        p_allocator,
        &out_view,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_view;
}
pub fn destroyTensorViewARM(
    device: Device,
    tensor_view: TensorViewARM,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyTensorViewARM.?(
        device,
        tensor_view,
        p_allocator,
    );
}
pub fn getTensorMemoryRequirementsARM(
    device: Device,
    p_info: *const TensorMemoryRequirementsInfoARM,
    p_memory_requirements: *MemoryRequirements2,
) void {
    device_dispatch.vkGetTensorMemoryRequirementsARM.?(
        device,
        p_info,
        p_memory_requirements,
    );
}
pub const BindTensorMemoryARMError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn bindTensorMemoryARM(
    device: Device,
    bind_info_count: u32,
    p_bind_infos: [*]const BindTensorMemoryInfoARM,
) BindTensorMemoryARMError!void {
    const result = device_dispatch.vkBindTensorMemoryARM.?(
        device,
        bind_info_count,
        p_bind_infos,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub fn getDeviceTensorMemoryRequirementsARM(
    device: Device,
    p_info: *const DeviceTensorMemoryRequirementsARM,
    p_memory_requirements: *MemoryRequirements2,
) void {
    device_dispatch.vkGetDeviceTensorMemoryRequirementsARM.?(
        device,
        p_info,
        p_memory_requirements,
    );
}
pub fn cmdCopyTensorARM(
    command_buffer: CommandBuffer,
    p_copy_tensor_info: *const CopyTensorInfoARM,
) void {
    device_dispatch.vkCmdCopyTensorARM.?(
        command_buffer,
        p_copy_tensor_info,
    );
}
pub const GetTensorOpaqueCaptureDescriptorDataARMError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getTensorOpaqueCaptureDescriptorDataARM(
    device: Device,
    p_info: *const TensorCaptureDescriptorDataInfoARM,
    p_data: *anyopaque,
) GetTensorOpaqueCaptureDescriptorDataARMError!void {
    const result = device_dispatch.vkGetTensorOpaqueCaptureDescriptorDataARM.?(
        device,
        p_info,
        p_data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const GetTensorViewOpaqueCaptureDescriptorDataARMError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getTensorViewOpaqueCaptureDescriptorDataARM(
    device: Device,
    p_info: *const TensorViewCaptureDescriptorDataInfoARM,
    p_data: *anyopaque,
) GetTensorViewOpaqueCaptureDescriptorDataARMError!void {
    const result = device_dispatch.vkGetTensorViewOpaqueCaptureDescriptorDataARM.?(
        device,
        p_info,
        p_data,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub const CreateDataGraphPipelinesARMError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createDataGraphPipelinesARM(
    device: Device,
    deferred_operation: DeferredOperationKHR,
    pipeline_cache: PipelineCache,
    create_info_count: u32,
    p_create_infos: [*]const DataGraphPipelineCreateInfoARM,
    p_allocator: ?*const AllocationCallbacks,
    p_pipelines: [*]Pipeline,
) CreateDataGraphPipelinesARMError!Result {
    const result = device_dispatch.vkCreateDataGraphPipelinesARM.?(
        device,
        deferred_operation,
        pipeline_cache,
        create_info_count,
        p_create_infos,
        p_allocator,
        p_pipelines,
    );
    switch (result) {
        Result.success => {},
        Result.pipeline_compile_required_ext => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const CreateDataGraphPipelineSessionARMError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn createDataGraphPipelineSessionARM(
    device: Device,
    p_create_info: *const DataGraphPipelineSessionCreateInfoARM,
    p_allocator: ?*const AllocationCallbacks,
) CreateDataGraphPipelineSessionARMError!DataGraphPipelineSessionARM {
    var out_session: DataGraphPipelineSessionARM = undefined;
    const result = device_dispatch.vkCreateDataGraphPipelineSessionARM.?(
        device,
        p_create_info,
        p_allocator,
        &out_session,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return out_session;
}
pub const GetDataGraphPipelineSessionBindPointRequirementsARMError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getDataGraphPipelineSessionBindPointRequirementsARM(
    device: Device,
    p_info: *const DataGraphPipelineSessionBindPointRequirementsInfoARM,
    p_bind_point_requirement_count: *u32,
    p_bind_point_requirements: ?[*]DataGraphPipelineSessionBindPointRequirementARM,
) GetDataGraphPipelineSessionBindPointRequirementsARMError!Result {
    const result = device_dispatch.vkGetDataGraphPipelineSessionBindPointRequirementsARM.?(
        device,
        p_info,
        p_bind_point_requirement_count,
        p_bind_point_requirements,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn getDataGraphPipelineSessionMemoryRequirementsARM(
    device: Device,
    p_info: *const DataGraphPipelineSessionMemoryRequirementsInfoARM,
    p_memory_requirements: *MemoryRequirements2,
) void {
    device_dispatch.vkGetDataGraphPipelineSessionMemoryRequirementsARM.?(
        device,
        p_info,
        p_memory_requirements,
    );
}
pub const BindDataGraphPipelineSessionMemoryARMError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn bindDataGraphPipelineSessionMemoryARM(
    device: Device,
    bind_info_count: u32,
    p_bind_infos: [*]const BindDataGraphPipelineSessionMemoryInfoARM,
) BindDataGraphPipelineSessionMemoryARMError!void {
    const result = device_dispatch.vkBindDataGraphPipelineSessionMemoryARM.?(
        device,
        bind_info_count,
        p_bind_infos,
    );
    switch (result) {
        Result.success => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
}
pub fn destroyDataGraphPipelineSessionARM(
    device: Device,
    session: DataGraphPipelineSessionARM,
    p_allocator: ?*const AllocationCallbacks,
) void {
    device_dispatch.vkDestroyDataGraphPipelineSessionARM.?(
        device,
        session,
        p_allocator,
    );
}
pub fn cmdDispatchDataGraphARM(
    command_buffer: CommandBuffer,
    session: DataGraphPipelineSessionARM,
    p_info: ?*const DataGraphPipelineDispatchInfoARM,
) void {
    device_dispatch.vkCmdDispatchDataGraphARM.?(
        command_buffer,
        session,
        p_info,
    );
}
pub const GetDataGraphPipelineAvailablePropertiesARMError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getDataGraphPipelineAvailablePropertiesARM(
    device: Device,
    p_pipeline_info: *const DataGraphPipelineInfoARM,
    p_properties_count: *u32,
    p_properties: ?[*]DataGraphPipelinePropertyARM,
) GetDataGraphPipelineAvailablePropertiesARMError!Result {
    const result = device_dispatch.vkGetDataGraphPipelineAvailablePropertiesARM.?(
        device,
        p_pipeline_info,
        p_properties_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub const GetDataGraphPipelinePropertiesARMError = error{
    OutOfHostMemory,
    OutOfDeviceMemory,
    Unknown,
};
pub fn getDataGraphPipelinePropertiesARM(
    device: Device,
    p_pipeline_info: *const DataGraphPipelineInfoARM,
    properties_count: u32,
    p_properties: [*]DataGraphPipelinePropertyQueryResultARM,
) GetDataGraphPipelinePropertiesARMError!Result {
    const result = device_dispatch.vkGetDataGraphPipelinePropertiesARM.?(
        device,
        p_pipeline_info,
        properties_count,
        p_properties,
    );
    switch (result) {
        Result.success => {},
        Result.incomplete => {},
        Result.error_out_of_host_memory => return error.OutOfHostMemory,
        Result.error_out_of_device_memory => return error.OutOfDeviceMemory,
        else => return error.Unknown,
    }
    return result;
}
pub fn init(loader: anytype) void {
    base_wrapper.load(loader);
}
